<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hedonism Island</title>
  
  <!-- Perchance Bridge Script - Exposes Perchance functions to our bundled module -->
  <script>
    // When loaded in Perchance, these functions are available in the global scope
    // We expose them on window so our ES module can access them
    (function() {
      // Wait for Perchance plugins to be available
      const waitForPerchance = setInterval(() => {
        // Check if Perchance functions exist in global scope
        if (typeof generateImage === 'function') {
          window.generateImage = generateImage;
          console.log('‚úÖ Perchance generateImage exposed to window');
        }
        if (typeof generateText === 'function') {
          window.generateText = generateText;
          console.log('‚úÖ Perchance generateText exposed to window');
        }
        if (typeof kv !== 'undefined') {
          window.kv = kv;
          console.log('‚úÖ Perchance kv exposed to window');
        }
        
        // Stop checking once all are found
        if (window.generateImage && window.generateText && window.kv) {
          clearInterval(waitForPerchance);
          console.log('üéâ All Perchance plugins ready!');
        }
      }, 100);
      
      // Stop checking after 5 seconds if not found
      setTimeout(() => {
        clearInterval(waitForPerchance);
        if (!window.generateImage) {
          console.warn('‚ö†Ô∏è Perchance plugins not detected - running in standalone mode');
        }
      }, 5000);
    })();
  </script>
  <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
class PerchanceAI {
  constructor() {
    this.isReady = true;
    console.log("‚úÖ Perchance AI Ready");
    this.debugPerchanceAvailability();
  }
  /**
   * Debug helper to check what Perchance functions are available
   */
  debugPerchanceAvailability() {
    const checks = {
      "window.generateImage": typeof window.generateImage,
      "window.generateText": typeof window.generateText,
      "window.kv": typeof window.kv,
      "globalThis.generateImage": typeof globalThis.generateImage,
      "globalThis.generateText": typeof globalThis.generateText
    };
    console.group("üîç Perchance Availability Check");
    for (const [key, type] of Object.entries(checks)) {
      const icon = type === "function" || type === "object" ? "‚úÖ" : "‚ùå";
      console.log(`${icon} ${key}: ${type}`);
    }
    const generateProps = Object.keys(window).filter((k) => k.toLowerCase().includes("generate"));
    if (generateProps.length > 0) {
      console.log('üìã Window properties containing "generate":', generateProps);
    }
    console.groupEnd();
  }
  /**
   * Generate text using ai-text-plugin
   * @param {string} prompt - The instruction for text generation
   * @param {object} options - Optional parameters (temperature, max_tokens, etc.)
   * @returns {Promise<string>} Generated text
   */
  async generateText(prompt, options = {}) {
    try {
      const result = await window.generateText(prompt, options);
      return result;
    } catch (error) {
      console.error("Text generation failed:", error);
      throw new Error(`Failed to generate text: ${error.message}`);
    }
  }
  /**
   * Extract text from Perchance AI response
   * Removes metadata, formatting tokens, and unwanted wrappers
   * @param {*} response - Raw response from generateText
   * @returns {string} Clean text content
   */
  extractText(response) {
    if (!response) return "";
    if (typeof response === "object") {
      return response.text || response.content || String(response);
    }
    let text = String(response);
    text = text.replace(/\[output\d*\]/gi, "");
    text = text.replace(/\[\/output\]/gi, "");
    text = text.replace(/\[comment\].*?\[\/comment\]/gi, "");
    text = text.replace(/^(Assistant:|AI:|Response:)\s*/i, "");
    return text.trim();
  }
  /**
   * Sanitize NPC dialogue response
   * Based on proven patterns from Office Clicker
   * @param {string} rawResponse - Raw AI output
   * @param {object} npc - NPC object for context
   * @returns {string} Sanitized dialogue
   */
  sanitizeNpcResponse(rawResponse, npc = null) {
    let text = this.extractText(rawResponse);
    const unwantedPatterns = [
      // Meta-commentary
      /\(.*?thinks.*?\)/gi,
      /\(.*?feels.*?\)/gi,
      /\*.*?internally.*?\*/gi,
      // Narration
      /^(He|She|They)\s+(said|says|replies|responds|asks|whispers|shouts)/gi,
      /\*\*[^*]+\*\*/g,
      // Remove **bold** narration
      /\*[^*]+\*/g,
      // Remove *italic* actions
      // Meta instructions that leaked through
      /\[.*?INST.*?\]/gi,
      /\[.*?SYS.*?\]/gi,
      /<\|.*?\|>/gi
    ];
    for (const pattern of unwantedPatterns) {
      text = text.replace(pattern, "");
    }
    const cringePhrases = [
      /\bheh\b\.?/gi,
      /\.{4,}/g
      // Only remove REALLY excessive ellipses (4+), allow normal "..." or ".."
    ];
    for (const phrase of cringePhrases) {
      text = text.replace(phrase, "...");
    }
    const trimmed = text.trim();
    if (trimmed.startsWith('"') && trimmed.endsWith('"') && trimmed.indexOf('"', 1) === trimmed.length - 1) {
      text = trimmed.slice(1, -1);
    } else if (trimmed.startsWith("'") && trimmed.endsWith("'") && trimmed.indexOf("'", 1) === trimmed.length - 1) {
      text = trimmed.slice(1, -1);
    }
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    const maxSentences = 3;
    if (sentences.length > maxSentences) {
      text = sentences.slice(0, maxSentences).join(" ");
    }
    text = text.replace(/\s+/g, " ").trim();
    if (text.length > 0) {
      text = text.charAt(0).toUpperCase() + text.slice(1);
    }
    if (text && !/[.!?]$/.test(text)) {
      text += ".";
    }
    return text;
  }
  /**
   * Build conversation history for context
   * @param {Array} history - Array of {speaker, message, timestamp} objects
   * @param {number} maxMessages - Maximum messages to include
   * @returns {string} Formatted history
   */
  buildConversationHistory(history, maxMessages = 5) {
    if (!history || history.length === 0) return "";
    const recent = history.slice(-maxMessages);
    const formatted = recent.map((entry) => {
      const speaker = entry.speaker === "player" ? "Player" : entry.npcName || "NPC";
      return `${speaker}: "${entry.message}"`;
    }).join("\n");
    return formatted;
  }
  /**
   * Analyze response for repetition issues
   * @param {string} response - AI response
   * @param {Array} recentResponses - Recent NPC responses
   * @returns {boolean} True if response seems repetitive
   */
  analyzeResponseForRepetition(response, recentResponses = []) {
    if (!response || recentResponses.length === 0) return false;
    const normalized = response.toLowerCase().replace(/[^a-z0-9\s]/g, "");
    for (const recent of recentResponses) {
      const recentNormalized = recent.toLowerCase().replace(/[^a-z0-9\s]/g, "");
      if (normalized === recentNormalized) return true;
      const words1 = new Set(normalized.split(/\s+/));
      const words2 = new Set(recentNormalized.split(/\s+/));
      const intersection = new Set([...words1].filter((w) => words2.has(w)));
      const similarity = intersection.size / Math.max(words1.size, words2.size);
      if (similarity > 0.7) return true;
    }
    return false;
  }
  /**
   * Get variation strategy based on conversation state
   * @param {object} npc - NPC object
   * @param {string} context - Current context
   * @returns {string} Strategy instruction
   */
  getVariationStrategy(npc, context = "") {
    const strategies = [
      "Try a different emotional tone",
      "Reference a different aspect of your personality",
      "Use a different conversational style (formal/casual)",
      "Focus on a different topic",
      "Express a contrasting opinion or mood"
    ];
    const index = (npc.relationships?.player?.interactionCount || 0) % strategies.length;
    return strategies[index];
  }
  /**
   * Calculate temperature for regeneration attempts
   * @param {number} attemptNumber - Current regeneration attempt
   * @returns {number} Temperature value
   */
  getRegenerationTemperature(attemptNumber = 0) {
    return Math.min(0.7 + attemptNumber * 0.1, 1);
  }
  /**
   * Generate image using text-to-image-plugin
   * @param {string|object} promptInput - The image description (string) or prompt object
   * @returns {Promise<string>} Image URL or data URI
   */
  async generateImage(promptInput) {
    try {
      const generateImageFn = window.generateImage;
      if (typeof generateImageFn !== "function") {
        console.warn("‚ùå Perchance generateImage not found on window");
        console.warn(
          'üìã Available window properties with "generate":',
          Object.keys(window).filter((k) => k.toLowerCase().includes("generate"))
        );
        return this.getPlaceholderImage();
      }
      console.log(
        "‚úÖ Calling window.generateImage with:",
        typeof promptInput === "object" ? promptInput.prompt?.slice(0, 60) : String(promptInput).slice(0, 60)
      );
      const result = await generateImageFn(promptInput);
      const imageUrl = result?.dataUrl || result?.toString() || result;
      console.log("‚úÖ Image generated:", imageUrl ? String(imageUrl).slice(0, 60) + "..." : "null");
      return imageUrl;
    } catch (error) {
      console.error("‚ùå Image generation error:", error);
      console.warn("Falling back to placeholder");
      return this.getPlaceholderImage();
    }
  }
  /**
   * Generate placeholder image when Perchance is unavailable
   * @returns {string} Data URI for placeholder SVG
   */
  getPlaceholderImage() {
    const svg = `<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
          <stop offset="100%" style="stop-color:#2196F3;stop-opacity:1" />
        </linearGradient>
      </defs>
      <circle cx="200" cy="200" r="180" fill="url(#grad)" opacity="0.3"/>
      <text x="200" y="180" font-family="Arial, sans-serif" font-size="120" fill="#4CAF50" text-anchor="middle" font-weight="bold">?</text>
      <text x="200" y="250" font-family="Arial, sans-serif" font-size="24" fill="#fff" text-anchor="middle">Portrait Coming Soon</text>
    </svg>`;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  /**
   * Save data persistently using kv-plugin
   * @param {string} key - Storage key
   * @param {any} value - Value to store
   */
  async saveData(key, value) {
    try {
      await window.kv.set(key, value);
      return true;
    } catch (error) {
      console.error("Save failed:", error);
      return false;
    }
  }
  /**
   * Load data from kv-plugin
   * @param {string} key - Storage key
   * @returns {Promise<any>} Stored value
   */
  async loadData(key) {
    try {
      return await window.kv.get(key);
    } catch (error) {
      console.error("Load failed:", error);
      return null;
    }
  }
  /**
   * Generate character profile with AI
   * @param {string} faction - castaway, islander, mercenary, tourist
   * @param {string} gender - Gender from settings
   * @returns {Promise<object>} Character profile
   */
  async generateCharacter(faction, gender) {
    const genderLabel = {
      female: "woman",
      male: "man",
      futanari: "futanari",
      transWoman: "trans woman",
      transMale: "trans man"
    }[gender] || "person";
    const factionDesc = {
      castaway: "a fellow castaway who washed up on the island",
      islander: "a native islander, initially cautious of outsiders",
      mercenary: "a Blacksteel mercenary, hostile and dangerous",
      tourist: "a tourist visiting the island resort"
    }[faction] || "a person";
    const prompt = `Generate a detailed character profile for ${genderLabel} who is ${factionDesc}. Include:
- Name (first and last)
- Age (18-45)
- Physical description (2-3 sentences, be explicit and detailed)
- Personality traits (3-4 traits)
- Background story (2-3 sentences)
- Sexual preferences/kinks (2-3, be explicit)
- Skills (2-3 relevant skills)

Format as JSON with keys: name, age, description, personality, background, kinks, skills (array).`;
    try {
      const response = await this.generateText(prompt, {
        temperature: 0.9,
        max_tokens: 500
      });
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("Failed to parse character data");
      }
    } catch (error) {
      console.error("Character generation failed:", error);
      return {
        name: `${gender} ${faction}`,
        age: 25,
        description: "A mysterious person.",
        personality: ["friendly", "adventurous"],
        background: "Their past is unknown.",
        kinks: ["vanilla"],
        skills: ["survival"]
      };
    }
  }
  /**
   * Apply consistent art style to image prompts
   * Based on user's settings preference
   * @param {string} basePrompt - Base image description
   * @returns {object} Prompt object for generateImage
   */
  applyImageStyle(basePrompt) {
    const selectedStyle = window.gameState?.settings?.imageStyle || "photorealistic";
    const styleDirectives = {
      photorealistic: "photorealistic, highly detailed, 8k quality, professional photography, natural lighting, sharp focus, realistic textures",
      anime: "anime style, manga aesthetic, cel shaded, vibrant colors, clean lines, Japanese animation style, expressive features",
      artistic: "artistic style, painterly aesthetic, impressionist, brush strokes, artistic interpretation, creative composition, gallery quality",
      cartoon: "cartoon style, comic book aesthetic, bold outlines, simplified shapes, bright colors, animated style, character illustration",
      cinematic: "cinematic lighting, movie scene, dramatic composition, film quality, depth of field, atmospheric, professional cinematography"
    };
    const directive = styleDirectives[selectedStyle] || styleDirectives.photorealistic;
    const hasStyle = basePrompt.toLowerCase().includes(selectedStyle.toLowerCase());
    const styledPrompt = hasStyle ? basePrompt : `${basePrompt}, ${directive}`;
    console.log(`[Image Style] Selected: ${selectedStyle}`);
    return { prompt: styledPrompt };
  }
  /**
   * Generate character portrait image
   * @param {object} character - Character object
   * @param {string} styleOverride - Optional style override
   * @returns {Promise<string>} Portrait URL
   */
  async generatePortrait(character, styleOverride = null) {
    const appearance = character.appearance || {};
    const body = appearance.body || {};
    const face = appearance.face || {};
    const hair = appearance.hair || {};
    const genderDesc = {
      female: "woman",
      male: "man",
      futanari: "futanari",
      Cuntboy: "Cuntboy",
      other: "person"
    }[character.gender] || "person";
    const buildDesc = {
      petite: "petite, slender build",
      slim: "slim, athletic build",
      average: "average build",
      athletic: "athletic, toned build",
      curvy: "curvy, voluptuous build",
      muscular: "muscular, powerful build",
      heavyset: "heavyset, robust build"
    }[body.build] || "average build";
    const skinDesc = body.skinTone || "fair skin";
    const hairDesc = `${hair.length || "medium"} ${hair.color || "brown"} hair${hair.style ? ", " + hair.style : ""}`;
    const eyeDesc = `${face.eyeColor || "brown"} eyes`;
    const ageDesc = character.age ? `${character.age} years old` : "young adult";
    const heightDesc = body.height ? `, ${body.height}cm tall` : "";
    const basePrompt = `Portrait of a ${genderDesc}, ${ageDesc}, ${buildDesc}, ${skinDesc}, ${hairDesc}, ${eyeDesc}${heightDesc}, attractive face, confident expression, tropical island vacation attire, isolated on transparent background, profile portrait, studio lighting`;
    const styledPrompt = this.applyImageStyle(basePrompt);
    console.log("[Portrait] Generating with prompt:", styledPrompt.prompt.slice(0, 100) + "...");
    return await this.generateImage(styledPrompt);
  }
  // Generate image from custom prompt (used by character creator)
  async generateImageFromPrompt(prompt, styleOverride = null) {
    const styledPrompt = this.applyImageStyle(prompt);
    console.log("[Custom Portrait] Generating with prompt:", styledPrompt.prompt.slice(0, 150) + "...");
    return await this.generateImage(styledPrompt);
  }
}
class SceneEngine {
  constructor(scenes2, aiProvider) {
    this.scenes = scenes2;
    this.ai = aiProvider;
    this.currentScene = "start";
    this.state = {
      variables: {},
      inventory: [],
      characters: {}
    };
  }
  start() {
    this.renderScene(this.currentScene);
  }
  renderScene(sceneId) {
    const scene = this.scenes[sceneId];
    if (!scene) {
      console.error(`Scene "${sceneId}" not found`);
      return;
    }
    const sceneContainer = document.getElementById("scene-container");
    const choicesContainer = document.getElementById("choices-container");
    sceneContainer.innerHTML = "";
    choicesContainer.innerHTML = "";
    const textEl = document.createElement("div");
    textEl.innerHTML = this.processText(scene.text);
    sceneContainer.appendChild(textEl);
    if (scene.image) {
      this.renderImage(sceneContainer, scene.image);
    }
    if (scene.choices) {
      scene.choices.forEach((choice, index) => {
        const button = document.createElement("button");
        button.className = "choice-button";
        button.textContent = choice.text;
        button.onclick = () => this.makeChoice(choice);
        choicesContainer.appendChild(button);
      });
    }
    if (scene.aiGenerate) {
      this.addAIButtons(choicesContainer, scene.aiGenerate);
    }
  }
  processText(text) {
    return text.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return this.state.variables[varName] || match;
    });
  }
  renderImage(container, imageConfig) {
    const imgEl = document.createElement("img");
    imgEl.src = imageConfig.url || imageConfig;
    imgEl.alt = imageConfig.alt || "Scene image";
    imgEl.style.maxWidth = "100%";
    imgEl.style.borderRadius = "8px";
    imgEl.style.marginTop = "20px";
    container.appendChild(imgEl);
  }
  addAIButtons(container, config) {
    if (config.text) {
      const btn = document.createElement("button");
      btn.className = "choice-button";
      btn.textContent = "‚ú® Generate Text";
      btn.onclick = async () => {
        btn.textContent = "‚è≥ Generating...";
        btn.disabled = true;
        try {
          const result = await this.ai.generateText(config.text.prompt, config.text.options);
          alert(result);
        } catch (e) {
          alert("Error: " + e);
        }
        btn.disabled = false;
        btn.textContent = "‚ú® Generate Text";
      };
      container.appendChild(btn);
    }
    if (config.image) {
      const btn = document.createElement("button");
      btn.className = "choice-button";
      btn.textContent = "üé® Generate Image";
      btn.onclick = async () => {
        btn.textContent = "‚è≥ Generating...";
        btn.disabled = true;
        try {
          const imageUrl = await this.ai.generateImage(config.image.prompt);
          const img = document.createElement("img");
          img.src = imageUrl;
          img.style.maxWidth = "100%";
          img.style.borderRadius = "8px";
          img.style.marginTop = "20px";
          document.getElementById("scene-container").appendChild(img);
        } catch (e) {
          alert("Error: " + e);
        }
        btn.disabled = false;
        btn.textContent = "üé® Generate Image";
      };
      container.appendChild(btn);
    }
  }
  makeChoice(choice) {
    if (choice.action) {
      this.executeAction(choice.action);
    }
    if (choice.next) {
      this.currentScene = choice.next;
      this.renderScene(choice.next);
    }
  }
  executeAction(action) {
    if (action.setVariable) {
      Object.assign(this.state.variables, action.setVariable);
    }
    if (action.addItem) {
      this.state.inventory.push(action.addItem);
    }
  }
}
class InventorySlot {
  constructor() {
    this.item = null;
    this.quantity = 0;
  }
  /**
   * Add items to this slot
   * @returns {number} Number of items that couldn't be added
   */
  add(item, quantity = 1) {
    if (!this.item) {
      this.item = item;
      this.quantity = quantity;
      return 0;
    }
    if (this.item.canStack(item)) {
      const space = this.item.maxStack - this.quantity;
      const toAdd = Math.min(space, quantity);
      this.quantity += toAdd;
      return quantity - toAdd;
    }
    return quantity;
  }
  /**
   * Remove items from this slot
   * @returns {number} Number of items actually removed
   */
  remove(quantity = 1) {
    const removed = Math.min(this.quantity, quantity);
    this.quantity -= removed;
    if (this.quantity <= 0) {
      this.item = null;
      this.quantity = 0;
    }
    return removed;
  }
  /**
   * Check if slot is empty
   */
  isEmpty() {
    return this.item === null || this.quantity <= 0;
  }
  /**
   * Check if slot is full
   */
  isFull() {
    if (!this.item) return false;
    return this.quantity >= this.item.maxStack;
  }
  /**
   * Get available space in slot
   */
  getAvailableSpace() {
    if (!this.item) return Infinity;
    return this.item.maxStack - this.quantity;
  }
  /**
   * Clear the slot
   */
  clear() {
    this.item = null;
    this.quantity = 0;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    if (this.isEmpty()) return null;
    return {
      itemId: this.item.id,
      quantity: this.quantity,
      durability: this.item.durability
    };
  }
}
class Inventory {
  constructor(capacity = 20, maxWeight = 100) {
    this.capacity = capacity;
    this.maxWeight = maxWeight;
    this.slots = [];
    for (let i = 0; i < capacity; i++) {
      this.slots.push(new InventorySlot());
    }
    this.equipment = {
      weapon: null,
      tool: null,
      clothing: null,
      backpack: null
    };
  }
  /**
   * Add item to inventory
   */
  addItem(item, quantity = 1) {
    if (quantity <= 0) return false;
    let remaining = quantity;
    if (item.stackable) {
      for (let slot of this.slots) {
        if (slot.item && slot.item.canStack(item) && !slot.isFull()) {
          remaining = slot.add(item, remaining);
          if (remaining === 0) return true;
        }
      }
    }
    while (remaining > 0) {
      const emptySlot = this.slots.find((s) => s.isEmpty());
      if (!emptySlot) {
        console.warn("Inventory full! Could not add all items.");
        return false;
      }
      const toAdd = item.stackable ? Math.min(remaining, item.maxStack) : 1;
      emptySlot.add(item.clone(), toAdd);
      remaining -= toAdd;
    }
    return true;
  }
  /**
   * Remove item from inventory
   */
  removeItem(itemId, quantity = 1) {
    let remaining = quantity;
    for (let slot of this.slots) {
      if (slot.item && slot.item.id === itemId) {
        const removed = slot.remove(remaining);
        remaining -= removed;
        if (remaining === 0) return true;
      }
    }
    return remaining < quantity;
  }
  /**
   * Check if inventory has item
   */
  hasItem(itemId, quantity = 1) {
    return this.getItemCount(itemId) >= quantity;
  }
  /**
   * Get total count of an item
   */
  getItemCount(itemId) {
    return this.slots.filter((s) => s.item && s.item.id === itemId).reduce((sum, s) => sum + s.quantity, 0);
  }
  /**
   * Get first slot containing item
   */
  findItem(itemId) {
    return this.slots.findIndex((s) => s.item && s.item.id === itemId);
  }
  /**
   * Get all slots containing item
   */
  findAllItems(itemId) {
    return this.slots.map((slot, index) => ({ slot, index })).filter(({ slot }) => slot.item && slot.item.id === itemId);
  }
  /**
   * Calculate total weight
   */
  getTotalWeight() {
    let weight = this.slots.filter((s) => !s.isEmpty()).reduce((sum, s) => sum + s.item.weight * s.quantity, 0);
    Object.values(this.equipment).forEach((item) => {
      if (item) weight += item.weight;
    });
    return weight;
  }
  /**
   * Check if inventory is full
   */
  isFull() {
    return this.slots.every((s) => !s.isEmpty());
  }
  /**
   * Check if inventory has space for item
   */
  hasSpaceFor(item, quantity = 1) {
    if (this.isFull() && !item.stackable) return false;
    if (item.stackable) {
      let availableSpace = 0;
      for (let slot of this.slots) {
        if (slot.isEmpty()) {
          availableSpace += item.maxStack;
        } else if (slot.item && slot.item.canStack(item)) {
          availableSpace += slot.getAvailableSpace();
        }
      }
      return availableSpace >= quantity;
    }
    const emptySlots = this.slots.filter((s) => s.isEmpty()).length;
    return emptySlots >= quantity;
  }
  /**
   * Equip an item
   */
  equip(item, slotType) {
    if (!item.equippable) {
      console.warn(`${item.name} cannot be equipped`);
      return false;
    }
    if (this.equipment[slotType]) {
      const unequipped = this.equipment[slotType];
      if (!this.addItem(unequipped)) {
        console.warn("Inventory full, cannot unequip item");
        return false;
      }
    }
    this.equipment[slotType] = item;
    this.removeItem(item.id, 1);
    console.log(`Equipped ${item.name} in ${slotType} slot`);
    return true;
  }
  /**
   * Unequip an item
   */
  unequip(slotType) {
    const item = this.equipment[slotType];
    if (!item) return false;
    if (!this.addItem(item)) {
      console.warn("Inventory full, cannot unequip item");
      return false;
    }
    this.equipment[slotType] = null;
    console.log(`Unequipped ${item.name} from ${slotType} slot`);
    return true;
  }
  /**
   * Get equipped item in slot
   */
  getEquipped(slotType) {
    return this.equipment[slotType];
  }
  /**
   * Use item from inventory
   */
  useItem(slotIndex, player2) {
    const slot = this.slots[slotIndex];
    if (slot.isEmpty()) return false;
    const item = slot.item;
    const wasUsed = item.use(player2);
    if (wasUsed && item.consumable) {
      slot.remove(1);
    }
    return wasUsed;
  }
  /**
   * Drop item from inventory
   */
  dropItem(slotIndex, quantity = 1) {
    const slot = this.slots[slotIndex];
    if (slot.isEmpty()) return null;
    const item = slot.item.clone();
    const dropped = slot.remove(quantity);
    return { item, quantity: dropped };
  }
  /**
   * Swap two inventory slots
   */
  swapSlots(index1, index2) {
    const temp = this.slots[index1];
    this.slots[index1] = this.slots[index2];
    this.slots[index2] = temp;
  }
  /**
   * Sort inventory by type/name
   */
  sortInventory(sortBy = "type") {
    const nonEmptySlots = this.slots.filter((s) => !s.isEmpty());
    const emptySlots = this.slots.filter((s) => s.isEmpty());
    if (sortBy === "type") {
      nonEmptySlots.sort((a, b) => {
        if (a.item.type !== b.item.type) {
          return a.item.type.localeCompare(b.item.type);
        }
        return a.item.name.localeCompare(b.item.name);
      });
    } else if (sortBy === "name") {
      nonEmptySlots.sort((a, b) => a.item.name.localeCompare(b.item.name));
    } else if (sortBy === "value") {
      nonEmptySlots.sort((a, b) => b.item.value - a.item.value);
    }
    this.slots = [...nonEmptySlots, ...emptySlots];
  }
  /**
   * Stack all stackable items
   */
  stackAll() {
    const itemMap = /* @__PURE__ */ new Map();
    this.slots.forEach((slot) => {
      if (slot.isEmpty()) return;
      const id = slot.item.id;
      if (!itemMap.has(id)) {
        itemMap.set(id, []);
      }
      itemMap.get(id).push(slot);
    });
    itemMap.forEach((slots) => {
      if (slots.length <= 1) return;
      const item = slots[0].item;
      if (!item.stackable) return;
      let totalQuantity = slots.reduce((sum, s) => sum + s.quantity, 0);
      slots.forEach((s) => s.clear());
      let slotIndex = 0;
      while (totalQuantity > 0 && slotIndex < slots.length) {
        const toAdd = Math.min(totalQuantity, item.maxStack);
        slots[slotIndex].add(item.clone(), toAdd);
        totalQuantity -= toAdd;
        slotIndex++;
      }
    });
  }
  /**
   * Get number of empty slots
   */
  getEmptySlotCount() {
    return this.slots.filter((s) => s.isEmpty()).length;
  }
  /**
   * Clear entire inventory
   */
  clear() {
    this.slots.forEach((s) => s.clear());
    Object.keys(this.equipment).forEach((key) => {
      this.equipment[key] = null;
    });
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      capacity: this.capacity,
      maxWeight: this.maxWeight,
      slots: this.slots.map((s) => s.toJSON()),
      equipment: {
        weapon: this.equipment.weapon?.toJSON() || null,
        tool: this.equipment.tool?.toJSON() || null,
        clothing: this.equipment.clothing?.toJSON() || null,
        backpack: this.equipment.backpack?.toJSON() || null
      }
    };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data, itemDatabase) {
    if (!data) {
      console.warn("‚ö†Ô∏è No inventory data provided, creating default inventory");
      return new Inventory(20, 50);
    }
    const capacity = data.capacity || 20;
    const maxWeight = data.maxWeight || 50;
    const inventory2 = new Inventory(capacity, maxWeight);
    if (data.slots && Array.isArray(data.slots)) {
      data.slots.forEach((slotData, index) => {
        if (slotData && index < inventory2.slots.length) {
          const item = itemDatabase.get(slotData.itemId);
          if (item) {
            item.durability = slotData.durability ?? item.durability;
            inventory2.slots[index].add(item, slotData.quantity);
          }
        }
      });
    }
    if (data.equipment && typeof data.equipment === "object") {
      Object.entries(data.equipment).forEach(([slot, itemData]) => {
        if (itemData && inventory2.equipment.hasOwnProperty(slot)) {
          const item = itemDatabase.get(itemData.id);
          if (item) {
            item.durability = itemData.durability ?? item.durability;
            inventory2.equipment[slot] = item;
          }
        }
      });
    }
    return inventory2;
  }
}
class Item {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description || "";
    this.type = data.type;
    this.category = data.category;
    this.icon = data.icon || "items/default.png";
    this.sprite = data.sprite || null;
    this.stackable = data.stackable ?? false;
    this.maxStack = data.maxStack || 1;
    this.weight = data.weight || 1;
    this.consumable = data.consumable ?? false;
    this.equippable = data.equippable ?? false;
    this.usable = data.usable ?? false;
    this.effects = data.effects || {};
    this.durability = data.durability ?? null;
    this.maxDurability = data.maxDurability ?? null;
    this.value = data.value || 0;
    this.rarity = data.rarity || "common";
    this.requirements = data.requirements || {};
  }
  /**
   * Use the item (consume, activate, etc.)
   */
  use(player2) {
    if (!this.usable && !this.consumable) {
      console.warn(`${this.name} cannot be used`);
      return false;
    }
    if (this.consumable) {
      return this.consume(player2);
    }
    if (this.usable) {
      return this.activate(player2);
    }
    return false;
  }
  /**
   * Consume the item (food, water, medicine)
   */
  consume(player2) {
    Object.entries(this.effects).forEach(([stat, value]) => {
      player2.modifyStat(stat, value);
    });
    console.log(`${player2.name} consumed ${this.name}`);
    return true;
  }
  /**
   * Activate special item behavior
   */
  activate(player2) {
    console.log(`${this.name} was activated`);
    return false;
  }
  /**
   * Check if this item can stack with another
   */
  canStack(otherItem) {
    if (!this.stackable || !otherItem.stackable) return false;
    if (this.id !== otherItem.id) return false;
    if (this.durability !== null && this.durability !== otherItem.durability) {
      return false;
    }
    return true;
  }
  /**
   * Create a copy of this item
   */
  clone() {
    return new Item({
      id: this.id,
      name: this.name,
      description: this.description,
      type: this.type,
      category: this.category,
      icon: this.icon,
      sprite: this.sprite,
      stackable: this.stackable,
      maxStack: this.maxStack,
      weight: this.weight,
      consumable: this.consumable,
      equippable: this.equippable,
      usable: this.usable,
      effects: { ...this.effects },
      durability: this.durability,
      maxDurability: this.maxDurability,
      value: this.value,
      rarity: this.rarity,
      requirements: { ...this.requirements }
    });
  }
  /**
   * Get rarity color for UI
   */
  getRarityColor() {
    const colors = {
      common: "#ffffff",
      uncommon: "#00ff00",
      rare: "#0099ff",
      legendary: "#ff9900"
    };
    return colors[this.rarity] || colors.common;
  }
  /**
   * Get durability percentage
   */
  getDurabilityPercent() {
    if (this.durability === null) return 100;
    return this.durability / this.maxDurability * 100;
  }
  /**
   * Damage the item (tools/weapons)
   */
  damage(amount = 1) {
    if (this.durability === null) return false;
    this.durability = Math.max(0, this.durability - amount);
    return this.durability <= 0;
  }
  /**
   * Repair the item
   */
  repair(amount) {
    if (this.durability === null) return;
    this.durability = Math.min(this.maxDurability, this.durability + amount);
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      durability: this.durability
      // Other dynamic properties only
    };
  }
  /**
   * Get display name with quantity/durability
   */
  getDisplayName(quantity = 1) {
    let name = this.name;
    if (quantity > 1) {
      name += ` (${quantity})`;
    }
    if (this.durability !== null) {
      const percent = this.getDurabilityPercent();
      if (percent < 25) name += " [!]";
      else if (percent < 50) name += " [*]";
    }
    return name;
  }
}
class ItemDatabase {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.loadItems();
  }
  /**
   * Load all item definitions
   */
  loadItems() {
    const itemDefinitions = this.getItemDefinitions();
    itemDefinitions.forEach((def) => {
      this.items.set(def.id, def);
    });
    console.log(`Loaded ${this.items.size} items`);
  }
  /**
   * Get item by ID (returns a new instance)
   */
  get(itemId) {
    const def = this.items.get(itemId);
    if (!def) {
      console.error(`Item not found: ${itemId}`);
      return null;
    }
    return new Item(def);
  }
  /**
   * Check if item exists
   */
  has(itemId) {
    return this.items.has(itemId);
  }
  /**
   * Get all items of a type
   */
  getByType(type) {
    return Array.from(this.items.values()).filter((item) => item.type === type).map((def) => new Item(def));
  }
  /**
   * Get all items of a category
   */
  getByCategory(category) {
    return Array.from(this.items.values()).filter((item) => item.category === category).map((def) => new Item(def));
  }
  /**
   * Item definitions (will move to JSON file later)
   */
  getItemDefinitions() {
    return [
      // ===== CONSUMABLES - FOOD =====
      {
        id: "coconut",
        name: "Coconut",
        description: "A fresh coconut. Sweet meat and refreshing water.",
        type: "consumable",
        category: "food",
        icon: "items/coconut.png",
        stackable: true,
        maxStack: 10,
        weight: 2,
        consumable: true,
        effects: { hunger: 15, thirst: 10 },
        value: 2,
        rarity: "common"
      },
      {
        id: "berries",
        name: "Berries",
        description: "Sweet wild berries. A quick snack.",
        type: "consumable",
        category: "food",
        icon: "items/berries.png",
        stackable: true,
        maxStack: 20,
        weight: 0.1,
        consumable: true,
        effects: { hunger: 5 },
        value: 1,
        rarity: "common"
      },
      {
        id: "cooked_fish",
        name: "Cooked Fish",
        description: "Freshly cooked fish. Delicious and nutritious.",
        type: "consumable",
        category: "food",
        icon: "items/cooked_fish.png",
        stackable: true,
        maxStack: 10,
        weight: 1,
        consumable: true,
        effects: { hunger: 35, health: 5 },
        value: 5,
        rarity: "common"
      },
      {
        id: "raw_fish",
        name: "Raw Fish",
        description: "Uncooked fish. Should be cooked before eating.",
        type: "consumable",
        category: "food",
        icon: "items/raw_fish.png",
        stackable: true,
        maxStack: 10,
        weight: 1,
        consumable: true,
        effects: { hunger: 10, health: -5 },
        value: 2,
        rarity: "common"
      },
      {
        id: "cooked_meat",
        name: "Cooked Meat",
        description: "Properly cooked meat. Very filling.",
        type: "consumable",
        category: "food",
        icon: "items/cooked_meat.png",
        stackable: true,
        maxStack: 10,
        weight: 1.5,
        consumable: true,
        effects: { hunger: 45, health: 10 },
        value: 8,
        rarity: "common"
      },
      // ===== CONSUMABLES - WATER =====
      {
        id: "water_bottle",
        name: "Water Bottle",
        description: "Clean drinking water.",
        type: "consumable",
        category: "water",
        icon: "items/water.png",
        stackable: true,
        maxStack: 5,
        weight: 1,
        consumable: true,
        effects: { thirst: 30 },
        value: 3,
        rarity: "common"
      },
      {
        id: "dirty_water",
        name: "Dirty Water",
        description: "Unfiltered water. Might make you sick.",
        type: "consumable",
        category: "water",
        icon: "items/dirty_water.png",
        stackable: true,
        maxStack: 5,
        weight: 1,
        consumable: true,
        effects: { thirst: 15, health: -10 },
        value: 1,
        rarity: "common"
      },
      // ===== CONSUMABLES - MEDICINE =====
      {
        id: "bandage",
        name: "Bandage",
        description: "Stops bleeding and speeds healing.",
        type: "consumable",
        category: "medicine",
        icon: "items/bandage.png",
        stackable: true,
        maxStack: 10,
        weight: 0.1,
        consumable: true,
        effects: { health: 20 },
        value: 10,
        rarity: "common"
      },
      {
        id: "herbal_remedy",
        name: "Herbal Remedy",
        description: "Native medicine made from island plants.",
        type: "consumable",
        category: "medicine",
        icon: "items/herbs.png",
        stackable: true,
        maxStack: 5,
        weight: 0.2,
        consumable: true,
        effects: { health: 40, energy: 10 },
        value: 20,
        rarity: "uncommon"
      },
      // ===== MATERIALS =====
      {
        id: "wood",
        name: "Wood",
        description: "Sturdy wood for building and crafting.",
        type: "material",
        category: "wood",
        icon: "items/wood.png",
        stackable: true,
        maxStack: 50,
        weight: 0.5,
        value: 1,
        rarity: "common"
      },
      {
        id: "stone",
        name: "Stone",
        description: "Hard stone for tools and construction.",
        type: "material",
        category: "stone",
        icon: "items/stone.png",
        stackable: true,
        maxStack: 50,
        weight: 1,
        value: 1,
        rarity: "common"
      },
      {
        id: "fiber",
        name: "Plant Fiber",
        description: "Strong plant fibers for rope and cloth.",
        type: "material",
        category: "fiber",
        icon: "items/fiber.png",
        stackable: true,
        maxStack: 50,
        weight: 0.2,
        value: 1,
        rarity: "common"
      },
      {
        id: "leather",
        name: "Leather",
        description: "Tanned animal hide. Useful for crafting.",
        type: "material",
        category: "leather",
        icon: "items/leather.png",
        stackable: true,
        maxStack: 20,
        weight: 0.8,
        value: 5,
        rarity: "uncommon"
      },
      {
        id: "metal_scrap",
        name: "Metal Scrap",
        description: "Salvaged metal. Can be worked into tools.",
        type: "material",
        category: "metal",
        icon: "items/metal.png",
        stackable: true,
        maxStack: 20,
        weight: 2,
        value: 10,
        rarity: "uncommon"
      },
      {
        id: "rope",
        name: "Rope",
        description: "Strong rope made from plant fibers.",
        type: "material",
        category: "rope",
        icon: "items/rope.png",
        stackable: true,
        maxStack: 20,
        weight: 0.5,
        value: 3,
        rarity: "common"
      },
      {
        id: "cloth",
        name: "Cloth",
        description: "Woven plant fiber cloth.",
        type: "material",
        category: "cloth",
        icon: "items/cloth.png",
        stackable: true,
        maxStack: 20,
        weight: 0.3,
        value: 4,
        rarity: "common"
      },
      {
        id: "raw_meat",
        name: "Raw Meat",
        description: "Uncooked meat. Should be cooked before eating.",
        type: "consumable",
        category: "food",
        icon: "items/raw_meat.png",
        stackable: true,
        maxStack: 10,
        weight: 1.5,
        consumable: true,
        effects: { hunger: 15, health: -8 },
        value: 3,
        rarity: "common"
      },
      // ===== TOOLS =====
      {
        id: "stone_axe",
        name: "Stone Axe",
        description: "A crude but effective axe for chopping wood.",
        type: "tool",
        category: "axe",
        icon: "items/stone_axe.png",
        stackable: false,
        weight: 3,
        equippable: true,
        durability: 100,
        maxDurability: 100,
        effects: { woodcutting: 2, damage: 5 },
        value: 10,
        rarity: "common"
      },
      {
        id: "stone_pickaxe",
        name: "Stone Pickaxe",
        description: "Break rocks and mine stone.",
        type: "tool",
        category: "pickaxe",
        icon: "items/stone_pickaxe.png",
        stackable: false,
        weight: 4,
        equippable: true,
        durability: 80,
        maxDurability: 80,
        effects: { mining: 2, damage: 4 },
        value: 12,
        rarity: "common"
      },
      {
        id: "knife",
        name: "Knife",
        description: "A sharp knife for cutting and crafting.",
        type: "tool",
        category: "knife",
        icon: "items/knife.png",
        stackable: false,
        weight: 0.5,
        equippable: true,
        durability: 150,
        maxDurability: 150,
        effects: { crafting: 1, damage: 6 },
        value: 15,
        rarity: "common"
      },
      {
        id: "fishing_rod",
        name: "Fishing Rod",
        description: "Catch fish more easily.",
        type: "tool",
        category: "fishing",
        icon: "items/fishing_rod.png",
        stackable: false,
        weight: 1,
        equippable: true,
        durability: 50,
        maxDurability: 50,
        effects: { fishing: 3 },
        value: 20,
        rarity: "common"
      },
      // ===== WEAPONS =====
      {
        id: "stone_spear",
        name: "Stone Spear",
        description: "A sharp spear for hunting and combat.",
        type: "weapon",
        category: "spear",
        icon: "items/stone_spear.png",
        stackable: false,
        weight: 2,
        equippable: true,
        durability: 50,
        maxDurability: 50,
        effects: { damage: 10 },
        value: 15,
        rarity: "common"
      },
      {
        id: "wooden_club",
        name: "Wooden Club",
        description: "A heavy club for bashing.",
        type: "weapon",
        category: "club",
        icon: "items/club.png",
        stackable: false,
        weight: 3,
        equippable: true,
        durability: 60,
        maxDurability: 60,
        effects: { damage: 8 },
        value: 8,
        rarity: "common"
      },
      {
        id: "bow",
        name: "Hunting Bow",
        description: "A ranged weapon for hunting.",
        type: "weapon",
        category: "bow",
        icon: "items/bow.png",
        stackable: false,
        weight: 1.5,
        equippable: true,
        durability: 100,
        maxDurability: 100,
        effects: { damage: 12, range: 10 },
        value: 30,
        rarity: "uncommon"
      },
      // ===== EQUIPMENT =====
      {
        id: "cloth_shirt",
        name: "Cloth Shirt",
        description: "Basic clothing. Provides minimal protection.",
        type: "equipment",
        category: "clothing",
        icon: "items/cloth_shirt.png",
        stackable: false,
        weight: 0.5,
        equippable: true,
        effects: { defense: 1 },
        value: 5,
        rarity: "common"
      },
      {
        id: "leather_vest",
        name: "Leather Vest",
        description: "Sturdy leather protection.",
        type: "equipment",
        category: "clothing",
        icon: "items/leather_vest.png",
        stackable: false,
        weight: 2,
        equippable: true,
        effects: { defense: 5 },
        value: 25,
        rarity: "uncommon"
      },
      {
        id: "leather_backpack",
        name: "Leather Backpack",
        description: "Increases carrying capacity by 10 slots.",
        type: "equipment",
        category: "backpack",
        icon: "items/backpack.png",
        stackable: false,
        weight: 2,
        equippable: true,
        effects: { capacity: 10 },
        value: 50,
        rarity: "uncommon"
      },
      {
        id: "waterskin",
        name: "Waterskin",
        description: "Carry water with you.",
        type: "equipment",
        category: "container",
        icon: "items/waterskin.png",
        stackable: false,
        weight: 0.5,
        equippable: false,
        usable: true,
        value: 15,
        rarity: "common"
      },
      // ===== NEW BIOME RESOURCES =====
      {
        id: "bamboo",
        name: "Bamboo",
        description: "Fast-growing bamboo pole. Lightweight and strong.",
        type: "material",
        category: "wood",
        icon: "items/bamboo.png",
        stackable: true,
        maxStack: 50,
        weight: 0.3,
        value: 2,
        rarity: "common"
      },
      {
        id: "bamboo_shoot",
        name: "Bamboo Shoot",
        description: "Edible bamboo shoot. Crunchy and nutritious.",
        type: "consumable",
        category: "food",
        icon: "items/bamboo_shoot.png",
        stackable: true,
        maxStack: 20,
        weight: 0.2,
        consumable: true,
        effects: { hunger: 8 },
        value: 2,
        rarity: "common"
      },
      {
        id: "palm_frond",
        name: "Palm Frond",
        description: "Large palm leaf. Good for roofing and weaving.",
        type: "material",
        category: "fiber",
        icon: "items/palm_frond.png",
        stackable: true,
        maxStack: 30,
        weight: 0.2,
        value: 1,
        rarity: "common"
      },
      {
        id: "dates",
        name: "Dates",
        description: "Sweet dried dates. Very filling.",
        type: "consumable",
        category: "food",
        icon: "items/dates.png",
        stackable: true,
        maxStack: 20,
        weight: 0.1,
        consumable: true,
        effects: { hunger: 12, energy: 5 },
        value: 3,
        rarity: "common"
      },
      {
        id: "mangrove_wood",
        name: "Mangrove Wood",
        description: "Dense, water-resistant wood from mangrove trees.",
        type: "material",
        category: "wood",
        icon: "items/mangrove_wood.png",
        stackable: true,
        maxStack: 40,
        weight: 0.7,
        value: 3,
        rarity: "uncommon"
      },
      {
        id: "oyster",
        name: "Oyster",
        description: "Fresh oyster. Can be eaten raw or cooked.",
        type: "consumable",
        category: "food",
        icon: "items/oyster.png",
        stackable: true,
        maxStack: 15,
        weight: 0.3,
        consumable: true,
        effects: { hunger: 6, thirst: -2 },
        value: 4,
        rarity: "common"
      },
      {
        id: "medicinal_plant",
        name: "Medicinal Plant",
        description: "A rare plant with healing properties.",
        type: "material",
        category: "herb",
        icon: "items/medicinal_plant.png",
        stackable: true,
        maxStack: 10,
        weight: 0.1,
        value: 15,
        rarity: "uncommon"
      },
      {
        id: "cactus_fruit",
        name: "Cactus Fruit",
        description: "Sweet fruit from a cactus. Hydrating.",
        type: "consumable",
        category: "food",
        icon: "items/cactus_fruit.png",
        stackable: true,
        maxStack: 15,
        weight: 0.2,
        consumable: true,
        effects: { hunger: 7, thirst: 10 },
        value: 3,
        rarity: "common"
      },
      {
        id: "desert_herb",
        name: "Desert Herb",
        description: "Hardy herb that survives in arid climates.",
        type: "material",
        category: "herb",
        icon: "items/desert_herb.png",
        stackable: true,
        maxStack: 20,
        weight: 0.05,
        value: 2,
        rarity: "common"
      },
      // ===== SHIPWRECK / RUINS LOOT =====
      {
        id: "ancient_coin",
        name: "Ancient Coin",
        description: "A mysterious coin from a lost civilization.",
        type: "treasure",
        category: "artifact",
        icon: "items/coin.png",
        stackable: true,
        maxStack: 99,
        weight: 0.01,
        value: 25,
        rarity: "rare"
      },
      {
        id: "ship_log",
        name: "Ship's Log",
        description: "A weathered logbook. Contains navigation notes.",
        type: "quest",
        category: "document",
        icon: "items/book.png",
        stackable: false,
        weight: 0.5,
        value: 10,
        rarity: "uncommon"
      },
      {
        id: "rusted_compass",
        name: "Rusted Compass",
        description: "An old compass. Still works, mostly.",
        type: "tool",
        category: "navigation",
        icon: "items/compass.png",
        stackable: false,
        weight: 0.3,
        equippable: true,
        effects: { navigation: 2 },
        value: 30,
        rarity: "uncommon"
      },
      {
        id: "ancient_tablet",
        name: "Ancient Tablet",
        description: "Stone tablet with mysterious inscriptions.",
        type: "treasure",
        category: "artifact",
        icon: "items/tablet.png",
        stackable: false,
        weight: 3,
        value: 100,
        rarity: "rare"
      },
      {
        id: "crystal_shard",
        name: "Crystal Shard",
        description: "A glowing crystal shard. Pulses with energy.",
        type: "treasure",
        category: "artifact",
        icon: "items/crystal.png",
        stackable: true,
        maxStack: 20,
        weight: 0.2,
        value: 50,
        rarity: "epic"
      },
      {
        id: "gold_nugget",
        name: "Gold Nugget",
        description: "Pure gold. Valuable for trade.",
        type: "treasure",
        category: "metal",
        icon: "items/gold.png",
        stackable: true,
        maxStack: 50,
        weight: 0.5,
        value: 40,
        rarity: "rare"
      }
    ];
  }
}
const itemDB = new ItemDatabase();
class Player {
  constructor(config = {}) {
    this.name = config.name || "Survivor";
    this.gender = config.gender || "male";
    this.stats = {
      health: 100,
      maxHealth: 100,
      hunger: 100,
      // 100 = full, 0 = starving
      thirst: 100,
      // 100 = hydrated, 0 = dehydrated
      sanity: 100,
      // 100 = stable, 0 = broken
      happiness: 75
      // 100 = joyful, 0 = miserable (starts moderate)
    };
    this.statusEffects = [];
    this.skills = {
      woodcutting: 0,
      mining: 0,
      fishing: 0,
      crafting: 0,
      combat: 0,
      diplomacy: 0,
      survival: 0,
      exploration: 0,
      // Finding secrets, mapping terrain
      claiming: 0
      // Establishing territory control
    };
    this.inventory = new Inventory();
    this.position = config.position || { q: 0, r: 0 };
    this.daysAlive = 0;
    this.reputation = {
      castaways: 0,
      // -100 to +100
      tidalClan: 0,
      ridgeClan: 0,
      mercenaries: 0,
      island: 0
      // The island's will itself
    };
    this.moralBackbone = {
      claim: 0,
      // Colonial democracy path
      respect: 0,
      // Native integration path
      exploit: 0,
      // Mercenary domination path
      leave: 0
      // Escape path
    };
    this.perks = [];
    this.isAlive = true;
    this.isConscious = true;
    this.isMoving = false;
  }
  /**
   * Update stats based on time passage
   * Called whenever in-game time advances
   * @param {number} minutes - In-game minutes that passed
   */
  updateStatsForTime(minutes) {
    const hours = minutes / 60;
    this.stats.hunger = Math.max(0, this.stats.hunger - hours * 2);
    this.stats.thirst = Math.max(0, this.stats.thirst - hours * 3);
    if (this.stats.sanity < 100 && this.stats.hunger > 30 && this.stats.thirst > 30) {
      this.stats.sanity = Math.min(100, this.stats.sanity + hours * 0.5);
    }
    if (this.stats.hunger <= 10) {
      this.stats.health = Math.max(0, this.stats.health - hours * 2);
    }
    if (this.stats.thirst <= 10) {
      this.stats.health = Math.max(0, this.stats.health - hours * 3);
    }
    this.clampStats();
    this.checkCriticalStates();
  }
  /**
   * Update status effects over time
   * Called from game loop
   */
  update(deltaTime) {
    if (this.statusEffects.length > 0) {
      this.updateStatusEffects(deltaTime);
    }
  }
  /**
   * Check for critical health states
   */
  checkCriticalStates() {
    if (this.stats.health <= 0) {
      if (this.isAlive) {
        this.isAlive = false;
        console.warn("üíÄ Player has died!");
      }
    }
    if (this.stats.health <= 20 && this.stats.health > 0) {
      if (this.isConscious) {
        this.isConscious = false;
        console.warn("üòµ Player is unconscious!");
      }
    } else if (this.stats.health > 20) {
      this.isConscious = true;
    }
  }
  // ===== NEW TURN-BASED SUPPORT METHODS =====
  /**
   * Consume an item (food, water, medicine)
   */
  consumeItem(item) {
    if (!item.consumable) {
      console.warn("Item is not consumable:", item.name);
      return false;
    }
    if (item.effects) {
      Object.entries(item.effects).forEach(([stat, value]) => {
        if (this.stats[stat] !== void 0) {
          this.stats[stat] += value;
          console.log(`${stat}: ${value > 0 ? "+" : ""}${value}`);
        }
      });
    }
    this.clampStats();
    return true;
  }
  /**
   * Equip an item
   */
  equipItem(item, slot) {
    const result = this.inventory.equip(item, slot);
    if (result) {
      console.log(`Equipped ${item.name} to ${slot} slot`);
    }
    return result;
  }
  /**
   * Unequip an item
   */
  unequipItem(slot) {
    const result = this.inventory.unequip(slot);
    if (result) {
      console.log(`Unequipped ${slot} slot`);
    }
    return result;
  }
  /**
   * Get total bonuses from equipment
   */
  getTotalBonuses() {
    const bonuses = {
      damage: 0,
      defense: 0,
      woodcutting: 0,
      mining: 0,
      fishing: 0,
      crafting: 0,
      capacity: 0,
      speed: 0
    };
    Object.values(this.inventory.equipment).forEach((item) => {
      if (item && item.effects) {
        Object.entries(item.effects).forEach(([key, value]) => {
          if (bonuses[key] !== void 0) {
            bonuses[key] += value;
          }
        });
      }
    });
    return bonuses;
  }
  /**
   * Get effective skill level (base + bonuses - penalties)
   */
  getEffectiveSkill(skillName) {
    const base = this.skills[skillName] || 0;
    const bonuses = this.getTotalBonuses();
    const bonus = bonuses[skillName] || 0;
    let penalty = 0;
    if (this.stats.hunger < 30) {
      penalty += (30 - this.stats.hunger) * 0.3;
    }
    if (this.stats.thirst < 30) {
      penalty += (30 - this.stats.thirst) * 0.4;
    }
    if (this.stats.health < 50) {
      penalty += (50 - this.stats.health) * 0.2;
    }
    return Math.max(0, base + bonus - penalty);
  }
  /**
   * Gain skill experience
   */
  gainSkillXP(skillName, amount) {
    if (this.skills[skillName] !== void 0) {
      this.skills[skillName] += amount;
      if (amount >= 10) {
        console.log(`${skillName} skill increased: +${amount}`);
      }
    }
  }
  /**
   * Adjust reputation with a faction
   */
  adjustReputation(faction, amount) {
    if (this.reputation[faction] !== void 0) {
      this.reputation[faction] += amount;
      this.reputation[faction] = Math.max(-100, Math.min(100, this.reputation[faction]));
      console.log(`Reputation with ${faction}: ${amount > 0 ? "+" : ""}${amount}`);
    }
  }
  /**
   * Adjust moral backbone
   */
  adjustMoralBackbone(path, amount) {
    if (this.moralBackbone[path] !== void 0) {
      this.moralBackbone[path] += amount;
      console.log(`Moral backbone - ${path}: ${amount > 0 ? "+" : ""}${amount}`);
    }
  }
  /**
   * Get dominant moral path
   */
  getDominantPath() {
    let maxPath = null;
    let maxValue = -Infinity;
    Object.entries(this.moralBackbone).forEach(([path, value]) => {
      if (value > maxValue) {
        maxValue = value;
        maxPath = path;
      }
    });
    return { path: maxPath, value: maxValue };
  }
  /**
   * Move to a new position (now handled by travel system)
   */
  moveTo(q, r) {
    this.position = { q, r };
    console.log(`Moved to (${q}, ${r})`);
  }
  /**
   * Get current state description (for UI/narrative)
   */
  getStateDescription() {
    const descriptions = [];
    if (this.stats.health < 20) descriptions.push("critically wounded");
    else if (this.stats.health < 50) descriptions.push("injured");
    else if (this.stats.health < 80) descriptions.push("somewhat hurt");
    if (this.stats.hunger < 20) descriptions.push("starving");
    else if (this.stats.hunger < 50) descriptions.push("hungry");
    if (this.stats.thirst < 20) descriptions.push("severely dehydrated");
    else if (this.stats.thirst < 50) descriptions.push("thirsty");
    if (this.stats.sanity < 20) descriptions.push("mentally broken");
    else if (this.stats.sanity < 50) descriptions.push("stressed");
    return descriptions.length > 0 ? descriptions.join(", ") : "in good condition";
  }
  /**
   * Clamp all stats to valid ranges
   */
  clampStats() {
    this.stats.health = Math.max(0, Math.min(this.stats.maxHealth, this.stats.health));
    this.stats.hunger = Math.max(0, Math.min(100, this.stats.hunger));
    this.stats.thirst = Math.max(0, Math.min(100, this.stats.thirst));
    this.stats.sanity = Math.max(0, Math.min(100, this.stats.sanity));
  }
  /**
   * Serialize player state for saving
   */
  toJSON() {
    return {
      name: this.name,
      gender: this.gender,
      stats: { ...this.stats },
      skills: { ...this.skills },
      inventory: this.inventory.toJSON(),
      position: { ...this.position },
      daysAlive: this.daysAlive,
      reputation: { ...this.reputation },
      moralBackbone: { ...this.moralBackbone },
      perks: [...this.perks],
      isAlive: this.isAlive
    };
  }
  /**
   * Deserialize player state from save
   */
  static fromJSON(data) {
    if (!data) {
      console.warn("‚ö†Ô∏è No player data provided, creating default player");
      return new Player({ name: "Survivor", gender: "neutral" });
    }
    const player2 = new Player({ name: data.name || "Survivor", gender: data.gender || "neutral" });
    if (data.stats) {
      Object.assign(player2.stats, data.stats);
    }
    if (data.skills) {
      Object.assign(player2.skills, data.skills);
    }
    if (data.inventory) {
      player2.inventory = Inventory.fromJSON(data.inventory, itemDB);
    }
    player2.position = data.position || { q: 0, r: 0 };
    player2.daysAlive = data.daysAlive || 0;
    if (data.reputation) {
      Object.assign(player2.reputation, data.reputation);
    }
    if (data.moralBackbone) {
      Object.assign(player2.moralBackbone, data.moralBackbone);
    }
    player2.perks = data.perks || [];
    player2.isAlive = data.isAlive ?? true;
    return player2;
  }
  // Getters for easier stat access
  get health() {
    return this.stats.health;
  }
  get hunger() {
    return this.stats.hunger;
  }
  get thirst() {
    return this.stats.thirst;
  }
  get sanity() {
    return this.stats.sanity;
  }
  get happiness() {
    return this.stats.happiness;
  }
  get energy() {
    return 100;
  }
  // Legacy compatibility - always return 100
}
class ResourceNode {
  constructor(config) {
    this.id = config.id;
    this.type = config.type;
    this.position = config.position;
    this.resourceType = config.resourceType;
    this.baseYield = config.baseYield || { min: 1, max: 3 };
    this.currentUses = config.maxUses || 5;
    this.maxUses = config.maxUses || 5;
    this.requiredTool = config.requiredTool || null;
    this.requiredSkill = config.requiredSkill || null;
    this.minimumSkillLevel = config.minimumSkillLevel || 0;
    this.regenerationTime = config.regenerationTime || 3e5;
    this.regenerationProgress = 0;
    this.isRegenerating = false;
    this.lastGatherTime = null;
    this.state = "full";
    this.discovered = config.discovered || false;
    this.sprite = config.sprite || "üå≥";
    this.depletedSprite = config.depletedSprite || "ü™µ";
    this.size = config.size || "medium";
    this.baseGatherDuration = config.gatherDuration || 30;
    this.gatherTimeMs = config.gatherTimeMs || 2e3;
    this.isRespawnable = config.isRespawnable !== false;
    this.quality = config.quality || "normal";
    this.onGather = config.onGather || null;
    this.onDeplete = config.onDeplete || null;
    this.onRegenerate = config.onRegenerate || null;
  }
  /**
   * Check if player can gather from this node
   */
  canGather(player2) {
    if (this.state === "depleted" && !this.isRegenerating) {
      return { success: false, reason: "Node is depleted" };
    }
    if (!player2.isAlive || !player2.isConscious) {
      return { success: false, reason: "You are not in condition to gather" };
    }
    if (this.requiredTool) {
      const hasTool = this.checkPlayerHasTool(player2, this.requiredTool);
      if (!hasTool) {
        return { success: false, reason: `Requires ${this.requiredTool}` };
      }
    }
    if (this.requiredSkill && this.minimumSkillLevel > 0) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      if (skillLevel < this.minimumSkillLevel) {
        return { success: false, reason: `Requires ${this.requiredSkill} level ${this.minimumSkillLevel}` };
      }
    }
    return { success: true };
  }
  /**
   * Check if player has required tool equipped
   */
  checkPlayerHasTool(player2, toolType) {
    const equipped = player2.inventory.equipment;
    const weapon = equipped.weapon;
    const tool = equipped.tool;
    if (toolType === "axe") {
      return weapon?.category === "axe" || tool?.category === "axe";
    }
    if (toolType === "pickaxe") {
      return weapon?.category === "pickaxe" || tool?.category === "pickaxe";
    }
    if (toolType === "knife") {
      return weapon?.category === "knife" || tool?.category === "knife";
    }
    if (toolType === "fishing_rod") {
      return tool?.category === "fishing";
    }
    return false;
  }
  /**
   * Get the equipped tool being used
   */
  getEquippedTool(player2) {
    const equipped = player2.inventory.equipment;
    if (this.requiredTool === "axe") {
      return equipped.weapon?.category === "axe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "pickaxe") {
      return equipped.weapon?.category === "pickaxe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "knife") {
      return equipped.weapon?.category === "knife" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "fishing_rod") {
      return equipped.tool;
    }
    return null;
  }
  /**
   * Get gather duration in game minutes
   * Duration varies by node type, player skill, and tool quality
   * Range: 15-45 minutes
   */
  getGatherDuration(player2) {
    let duration = this.baseGatherDuration;
    if (this.requiredSkill) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      const skillReduction = Math.floor(skillLevel / 10) * 2;
      duration -= skillReduction;
    }
    const tool = this.getEquippedTool(player2);
    if (tool && tool.rarity !== "common") {
      const rarityReduction = {
        uncommon: 2,
        // -2 minutes
        rare: 5,
        // -5 minutes
        epic: 8,
        // -8 minutes
        legendary: 12
        // -12 minutes
      };
      duration -= rarityReduction[tool.rarity] || 0;
    }
    const qualityModifiers = {
      poor: 1.2,
      // +20% time (harder to extract)
      normal: 1,
      // Normal time
      rich: 0.9,
      // -10% time (easier to extract)
      abundant: 0.8
      // -20% time (very easy)
    };
    duration *= qualityModifiers[this.quality];
    return Math.max(15, Math.ceil(duration));
  }
  /**
   * Attempt to gather resources
   */
  gather(player2) {
    const canGather = this.canGather(player2);
    if (!canGather.success) {
      return {
        success: false,
        reason: canGather.reason
      };
    }
    const baseYield = this.calculateYield(player2);
    const items = this.generateItems(baseYield);
    const tool = this.getEquippedTool(player2);
    if (tool && tool.durability !== void 0) {
      tool.damage(1);
      if (tool.durability <= 0) {
        console.log(`${tool.name} broke!`);
      }
    }
    if (this.requiredSkill) {
      const xpGain = this.calculateSkillXP();
      player2.gainSkillXP(this.requiredSkill, xpGain);
    }
    this.currentUses--;
    this.lastGatherTime = Date.now();
    if (this.currentUses <= 0) {
      this.depleteNode();
    }
    if (this.onGather) {
      this.onGather(player2, items);
    }
    return {
      success: true,
      items,
      xpGained: this.requiredSkill ? this.calculateSkillXP() : 0,
      usesRemaining: this.currentUses
    };
  }
  /**
   * Calculate yield based on player skill and quality
   */
  calculateYield(player2) {
    let yield_amount = Math.floor(
      Math.random() * (this.baseYield.max - this.baseYield.min + 1) + this.baseYield.min
    );
    if (this.requiredSkill) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      const skillBonus = Math.floor(skillLevel / 20);
      yield_amount += skillBonus;
    }
    const qualityMultipliers = {
      poor: 0.5,
      normal: 1,
      rich: 1.5,
      abundant: 2
    };
    yield_amount = Math.floor(yield_amount * qualityMultipliers[this.quality]);
    const tool = this.getEquippedTool(player2);
    if (tool && tool.rarity !== "common") {
      const rarityBonus = {
        uncommon: 1.1,
        rare: 1.25,
        epic: 1.5,
        legendary: 2
      };
      yield_amount = Math.floor(yield_amount * (rarityBonus[tool.rarity] || 1));
    }
    return Math.max(1, yield_amount);
  }
  /**
   * Generate item instances
   */
  generateItems(quantity) {
    const items = [];
    for (let i = 0; i < quantity; i++) {
      items.push(itemDB.get(this.resourceType));
    }
    return items;
  }
  /**
   * Calculate skill XP gain
   */
  calculateSkillXP() {
    const baseXP = 5;
    const qualityXP = {
      poor: 0.5,
      normal: 1,
      rich: 1.5,
      abundant: 2
    };
    return Math.floor(baseXP * qualityXP[this.quality]);
  }
  /**
   * Deplete the node
   */
  depleteNode() {
    this.state = "depleted";
    this.currentUses = 0;
    if (this.isRespawnable) {
      this.startRegeneration();
    }
    if (this.onDeplete) {
      this.onDeplete();
    }
  }
  /**
   * Start regeneration process
   */
  startRegeneration() {
    this.isRegenerating = true;
    this.regenerationProgress = 0;
  }
  /**
   * Update node state (called by game loop)
   */
  update(deltaTime) {
    if (this.isRegenerating) {
      this.regenerationProgress += deltaTime;
      if (this.regenerationProgress >= this.regenerationTime) {
        this.regenerateNode();
      }
    }
  }
  /**
   * Regenerate the node
   */
  regenerateNode() {
    this.state = "full";
    this.currentUses = this.maxUses;
    this.isRegenerating = false;
    this.regenerationProgress = 0;
    if (this.onRegenerate) {
      this.onRegenerate();
    }
  }
  /**
   * Get regeneration progress percentage
   */
  getRegenerationProgress() {
    if (!this.isRegenerating) return 0;
    return this.regenerationProgress / this.regenerationTime * 100;
  }
  /**
   * Get visual representation
   */
  getSprite() {
    if (this.state === "depleted") {
      return this.depletedSprite;
    }
    return this.sprite;
  }
  /**
   * Get node info for UI
   */
  getInfo() {
    return {
      name: this.getName(),
      type: this.type,
      state: this.state,
      usesRemaining: `${this.currentUses}/${this.maxUses}`,
      requiredTool: this.requiredTool || "Bare hands",
      requiredSkill: this.requiredSkill ? `${this.requiredSkill} (${this.minimumSkillLevel})` : "None",
      gatherTime: `${this.gatherTime / 1e3}s`,
      energyCost: this.energyCost,
      quality: this.quality,
      regenerationProgress: this.isRegenerating ? `${Math.floor(this.getRegenerationProgress())}%` : "N/A"
    };
  }
  /**
   * Get display name
   */
  getName() {
    const names = {
      tree: "Tree",
      rock: "Rock Formation",
      berry_bush: "Berry Bush",
      fishing_spot: "Fishing Spot",
      coconut_tree: "Coconut Tree",
      iron_deposit: "Iron Deposit",
      herb_patch: "Herb Patch",
      stone_outcrop: "Stone Outcrop"
    };
    return names[this.type] || this.type;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      position: this.position,
      currentUses: this.currentUses,
      state: this.state,
      regenerationProgress: this.regenerationProgress,
      isRegenerating: this.isRegenerating,
      discovered: this.discovered,
      lastGatherTime: this.lastGatherTime
    };
  }
  /**
   * Deserialize from save
   */
  static fromJSON(data, config) {
    const node = new ResourceNode({ ...config, ...data });
    node.state = data.state;
    node.currentUses = data.currentUses;
    node.regenerationProgress = data.regenerationProgress;
    node.isRegenerating = data.isRegenerating;
    node.discovered = data.discovered;
    node.lastGatherTime = data.lastGatherTime;
    return node;
  }
}
class ResourceNodeManager {
  constructor() {
    this.nodes = /* @__PURE__ */ new Map();
    this.nodesByPosition = /* @__PURE__ */ new Map();
    this.nextNodeId = 1;
  }
  /**
   * Create a new resource node
   */
  createNode(config) {
    const node = new ResourceNode({
      ...config,
      id: config.id || `node_${this.nextNodeId++}`,
      discovered: config.discovered !== void 0 ? config.discovered : false
      // Default to undiscovered
    });
    this.nodes.set(node.id, node);
    const posKey = `${node.position.q},${node.position.r}`;
    if (!this.nodesByPosition.has(posKey)) {
      this.nodesByPosition.set(posKey, []);
    }
    this.nodesByPosition.get(posKey).push(node);
    return node;
  }
  /**
   * Get node by ID
   */
  getNode(id) {
    return this.nodes.get(id);
  }
  /**
   * Get nodes at position
   */
  getNodesAt(q, r) {
    const posKey = `${q},${r}`;
    return this.nodesByPosition.get(posKey) || [];
  }
  /**
   * Get all nodes of a type
   */
  getNodesByType(type) {
    return Array.from(this.nodes.values()).filter((node) => node.type === type);
  }
  /**
   * Get all gatherable nodes (not depleted)
   */
  getGatherableNodes() {
    return Array.from(this.nodes.values()).filter((node) => node.state !== "depleted");
  }
  /**
   * Remove a node
   */
  removeNode(id) {
    const node = this.nodes.get(id);
    if (!node) return;
    const posKey = `${node.position.q},${node.position.r}`;
    const nodesAtPos = this.nodesByPosition.get(posKey);
    if (nodesAtPos) {
      const index = nodesAtPos.indexOf(node);
      if (index !== -1) {
        nodesAtPos.splice(index, 1);
      }
    }
    this.nodes.delete(id);
  }
  /**
   * Update all nodes (called by game loop)
   */
  update(deltaTime) {
    this.nodes.forEach((node) => {
      node.update(deltaTime);
    });
  }
  /**
   * Generate starter resource nodes near player spawn
   */
  generateStarterNodes(spawnPosition, radius = 3) {
    const nodes = [];
    for (let i = 0; i < 5; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "tree",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "wood",
        baseYield: { min: 2, max: 4 },
        maxUses: 5,
        requiredTool: "axe",
        requiredSkill: "woodcutting",
        sprite: "üå≥",
        depletedSprite: "ü™µ",
        gatherTime: 3e3,
        energyCost: 5
      }));
    }
    for (let i = 0; i < 4; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "rock",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "stone",
        baseYield: { min: 2, max: 3 },
        maxUses: 5,
        requiredTool: "pickaxe",
        requiredSkill: "mining",
        sprite: "ü™®",
        depletedSprite: "‚ö´",
        gatherTime: 4e3,
        energyCost: 7
      }));
    }
    for (let i = 0; i < 3; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "berry_bush",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "berries",
        baseYield: { min: 3, max: 6 },
        maxUses: 8,
        requiredTool: null,
        sprite: "ü´ê",
        depletedSprite: "üçÇ",
        gatherTime: 2e3,
        energyCost: 2
      }));
    }
    for (let i = 0; i < 2; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "coconut_tree",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "coconut",
        baseYield: { min: 1, max: 2 },
        maxUses: 3,
        requiredTool: null,
        sprite: "üå¥",
        depletedSprite: "üå¥",
        gatherTime: 2500,
        energyCost: 3
      }));
    }
    return nodes;
  }
  /**
   * Get random hex offset within radius
   */
  getRandomOffset(radius) {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.floor(Math.random() * radius) + 1;
    return {
      q: Math.round(Math.cos(angle) * distance),
      r: Math.round(Math.sin(angle) * distance)
    };
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    const nodesArray = Array.from(this.nodes.values()).map((node) => node.toJSON());
    return {
      nodes: nodesArray,
      nextNodeId: this.nextNodeId
    };
  }
  /**
   * Deserialize from save
   */
  static fromJSON(data, nodeConfigs) {
    const manager = new ResourceNodeManager();
    manager.nextNodeId = data.nextNodeId;
    data.nodes.forEach((nodeData) => {
      const config = nodeConfigs[nodeData.type] || {};
      const node = ResourceNode.fromJSON(nodeData, config);
      manager.nodes.set(node.id, node);
      const posKey = `${node.position.q},${node.position.r}`;
      if (!manager.nodesByPosition.has(posKey)) {
        manager.nodesByPosition.set(posKey, []);
      }
      manager.nodesByPosition.get(posKey).push(node);
    });
    return manager;
  }
}
class NPC {
  constructor(config = {}) {
    this.identity = {
      id: config.identity?.id || config.id || this.generateID(),
      name: config.identity?.name || config.name || "Unnamed",
      title: config.identity?.title || config.title || null,
      // "The Scarred Hunter"
      faction: config.identity?.faction || config.faction || "neutral",
      role: config.identity?.role || config.role || "civilian"
      // 'leader', 'warrior', 'trader', 'healer', etc.
    };
    this.appearance = {
      age: config.appearance?.age || 30,
      ageCategory: config.appearance?.ageCategory || "adult",
      gender: config.appearance?.gender || "male",
      height: config.appearance?.height || "average",
      build: config.appearance?.build || "average",
      skinTone: config.appearance?.skinTone || "bronze",
      hairColor: config.appearance?.hairColor || "black",
      hairStyle: config.appearance?.hairStyle || "short",
      eyeColor: config.appearance?.eyeColor || "brown",
      distinctiveFeatures: config.appearance?.distinctiveFeatures || [],
      clothing: config.appearance?.clothing || "simple garments"
    };
    this.personality = {
      traits: {
        openness: config.personality?.traits?.openness || 50,
        conscientiousness: config.personality?.traits?.conscientiousness || 50,
        extraversion: config.personality?.traits?.extraversion || 50,
        agreeableness: config.personality?.traits?.agreeableness || 50,
        neuroticism: config.personality?.traits?.neuroticism || 50
      },
      values: {
        honor: config.personality?.values?.honor || 50,
        loyalty: config.personality?.values?.loyalty || 50,
        ambition: config.personality?.values?.ambition || 50,
        compassion: config.personality?.values?.compassion || 50,
        pragmatism: config.personality?.values?.pragmatism || 50,
        tradition: config.personality?.values?.tradition || 50
      },
      // AI-generated personality details
      quirks: config.personality?.quirks || [],
      fears: config.personality?.fears || [],
      desires: config.personality?.desires || [],
      motivations: config.personality?.motivations || []
    };
    this.background = {
      birthplace: config.background?.birthplace || "Unknown",
      backstory: config.background?.backstory || "",
      formativeEvent: config.background?.formativeEvent || "",
      occupation: config.background?.occupation || this.identity.role,
      education: config.background?.education || "informal",
      familyStatus: config.background?.familyStatus || "unknown",
      secrets: config.background?.secrets || []
    };
    this.stats = {
      health: config.stats?.health || 100,
      maxHealth: config.stats?.maxHealth || 100,
      stamina: config.stats?.stamina || 100,
      maxStamina: config.stats?.maxStamina || 100,
      // Attributes
      strength: config.stats?.strength || 50,
      agility: config.stats?.agility || 50,
      intelligence: config.stats?.intelligence || 50,
      charisma: config.stats?.charisma || 50,
      willpower: config.stats?.willpower || 50,
      // Needs
      hunger: config.stats?.hunger || 100,
      thirst: config.stats?.thirst || 100
    };
    this.skills = {
      combat: config.skills?.combat || 0,
      hunting: config.skills?.hunting || 0,
      crafting: config.skills?.crafting || 0,
      diplomacy: config.skills?.diplomacy || 0,
      survival: config.skills?.survival || 0,
      medicine: config.skills?.medicine || 0,
      exploration: config.skills?.exploration || 0
    };
    this.relationships = {
      // Relationship with player
      player: {
        opinion: config.relationships?.player?.opinion || 50,
        // -100 to 100
        trust: config.relationships?.player?.trust || 20,
        // 0-100
        respect: config.relationships?.player?.respect || 30,
        // 0-100
        fear: config.relationships?.player?.fear || 0,
        // 0-100
        romantic: config.relationships?.player?.romantic || 0,
        // 0-100
        firstMet: config.relationships?.player?.firstMet || null,
        lastInteraction: config.relationships?.player?.lastInteraction || null,
        interactionCount: config.relationships?.player?.interactionCount || 0
      },
      // Relationships with other NPCs (Map: npcId -> relationship data)
      knownNPCs: new Map(config.relationships?.knownNPCs || [])
    };
    this.location = {
      currentTile: config.location?.currentTile || { q: 0, r: 0 },
      homeLocation: config.location?.homeLocation || { q: 0, r: 0 },
      schedule: config.location?.schedule || []
    };
    this.state = {
      isAlive: config.state?.isAlive !== false,
      isConscious: config.state?.isConscious !== false,
      mood: config.state?.mood || "neutral",
      activity: config.state?.activity || "idle",
      canBeRecruited: config.state?.canBeRecruited || false,
      isRecruited: config.state?.isRecruited || false,
      isHostile: config.state?.isHostile || false,
      isTrader: config.state?.isTrader || false,
      questGiver: config.state?.questGiver || false
    };
    this.inventory = {
      items: config.inventory?.items || [],
      equipped: {
        weapon: config.inventory?.equipped?.weapon || null,
        armor: config.inventory?.equipped?.armor || null,
        accessory: config.inventory?.equipped?.accessory || null
      },
      currency: config.inventory?.currency || 0
    };
    this.memory = {
      events: config.memory?.events || [],
      conversationPhase: config.memory?.conversationPhase || "early",
      // early/familiar/intimate
      conversationHistory: config.memory?.conversationHistory || [],
      sawPlayerSteal: config.memory?.sawPlayerSteal || false,
      sawPlayerKill: config.memory?.sawPlayerKill || [],
      heardRumors: config.memory?.heardRumors || []
    };
    this.dialogue = {
      greeting: config.dialogue?.greeting || {},
      topics: config.dialogue?.topics || [],
      barks: config.dialogue?.barks || {}
    };
    this.ai = {
      aggression: config.ai?.aggression || this.calculateAggression(),
      courage: config.ai?.courage || this.calculateCourage(),
      loyalty: config.ai?.loyalty || this.personality.values.loyalty,
      alertness: config.ai?.alertness || 50,
      routineType: config.ai?.routineType || "wanderer"
    };
    this.meta = {
      importance: config.meta?.importance || "minor",
      // major/minor/background
      canDie: config.meta?.canDie !== false,
      tags: config.meta?.tags || [],
      generatedByAI: config.meta?.generatedByAI || false,
      createdAt: config.meta?.createdAt || Date.now()
    };
  }
  // ========================================
  // HELPER METHODS
  // ========================================
  generateID() {
    return `npc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Calculate aggression from personality traits
   */
  calculateAggression() {
    const { agreeableness, neuroticism } = this.personality.traits;
    const { honor } = this.personality.values;
    return Math.round(
      (100 - agreeableness) * 0.4 + neuroticism * 0.3 + (100 - honor) * 0.3
    );
  }
  /**
   * Calculate courage (willingness to stand ground)
   */
  calculateCourage() {
    const { neuroticism } = this.personality.traits;
    const { honor, loyalty } = this.personality.values;
    return Math.round(
      (100 - neuroticism) * 0.5 + honor * 0.25 + loyalty * 0.25
    );
  }
  /**
   * Calculate current mood from stats and relationships
   */
  getMood() {
    const { health, hunger, thirst } = this.stats;
    const { opinion, trust, fear } = this.relationships.player;
    if (health < 30) return "suffering";
    if (hunger < 30 || thirst < 30) return "desperate";
    if (fear > 70) return "terrified";
    if (fear > 40) return "afraid";
    const relationshipScore = (opinion + trust) / 2;
    if (relationshipScore > 80) return "joyful";
    if (relationshipScore > 60) return "friendly";
    if (relationshipScore > 40) return "neutral";
    if (relationshipScore > 20) return "wary";
    return "hostile";
  }
  /**
   * Build personality summary for AI prompts
   */
  getPersonalitySummary() {
    const { traits, values } = this.personality;
    const descriptors = [];
    if (traits.openness > 70) descriptors.push("curious and creative");
    else if (traits.openness < 30) descriptors.push("traditional and practical");
    if (traits.conscientiousness > 70) descriptors.push("disciplined and organized");
    else if (traits.conscientiousness < 30) descriptors.push("spontaneous and flexible");
    if (traits.extraversion > 70) descriptors.push("outgoing and energetic");
    else if (traits.extraversion < 30) descriptors.push("reserved and quiet");
    if (traits.agreeableness > 70) descriptors.push("compassionate and cooperative");
    else if (traits.agreeableness < 30) descriptors.push("competitive and assertive");
    if (traits.neuroticism > 70) descriptors.push("anxious and sensitive");
    else if (traits.neuroticism < 30) descriptors.push("calm and resilient");
    const topValues = Object.entries(values).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([name, value]) => `${name} (${value})`).join(", ");
    return {
      traits: descriptors.join(", "),
      values: topValues,
      quirks: this.personality.quirks.join("; ")
    };
  }
  /**
   * Update relationship stats
   */
  adjustRelationship(stat, amount, target = "player") {
    if (target === "player") {
      const rel = this.relationships.player;
      switch (stat) {
        case "opinion":
          rel.opinion = Math.max(-100, Math.min(100, rel.opinion + amount));
          break;
        case "trust":
        case "respect":
        case "fear":
        case "romantic":
          rel[stat] = Math.max(0, Math.min(100, rel[stat] + amount));
          break;
      }
      rel.lastInteraction = Date.now();
      this.state.mood = this.getMood();
    }
  }
  /**
   * Remember an event
   */
  remember(event, importance = 1) {
    this.memory.events.push({
      content: event,
      timestamp: Date.now(),
      importance,
      emotionalImpact: this.calculateEmotionalImpact(event)
    });
    if (this.memory.events.length > 100) {
      this.memory.events.sort((a, b) => b.importance - a.importance);
      this.memory.events = this.memory.events.slice(0, 100);
    }
  }
  /**
   * Calculate emotional impact of an event
   */
  calculateEmotionalImpact(event) {
    const eventLower = event.toLowerCase();
    if (eventLower.includes("gift") || eventLower.includes("helped")) return 2;
    if (eventLower.includes("saved") || eventLower.includes("rescued")) return 3;
    if (eventLower.includes("attacked") || eventLower.includes("threatened")) return -3;
    if (eventLower.includes("stole") || eventLower.includes("betrayed")) return -2;
    return 0;
  }
  /**
   * Retrieve relevant memories (for AI context)
   */
  getRelevantMemories(context = "", maxResults = 5) {
    if (this.memory.events.length === 0) return [];
    const keywords = context.toLowerCase().split(" ");
    const scored = this.memory.events.map((mem) => {
      let relevance = mem.importance;
      const memLower = mem.content.toLowerCase();
      keywords.forEach((keyword) => {
        if (memLower.includes(keyword)) relevance += 0.5;
      });
      const hoursSince = (Date.now() - mem.timestamp) / (1e3 * 60 * 60);
      if (hoursSince < 24) relevance += 1;
      else if (hoursSince < 168) relevance += 0.5;
      return { ...mem, relevance };
    });
    return scored.sort((a, b) => b.relevance - a.relevance).slice(0, maxResults).map((m) => m.content);
  }
  /**
   * Update conversation phase based on relationship
   */
  updateConversationPhase() {
    const { opinion, trust, romantic } = this.relationships.player;
    const relationshipScore = (opinion + trust + romantic) / 3;
    if (relationshipScore > 70) {
      this.memory.conversationPhase = "intimate";
    } else if (relationshipScore > 40) {
      this.memory.conversationPhase = "familiar";
    } else {
      this.memory.conversationPhase = "early";
    }
  }
  /**
   * Check if NPC would be hostile to player
   */
  wouldBeHostile() {
    const { opinion, fear } = this.relationships.player;
    if (opinion < -50) return true;
    if (fear > 80 && this.ai.courage < 30) return false;
    return this.state.isHostile;
  }
  // ========================================
  // SERIALIZATION
  // ========================================
  toJSON() {
    return {
      identity: this.identity,
      appearance: this.appearance,
      personality: {
        traits: this.personality.traits,
        values: this.personality.values,
        quirks: this.personality.quirks,
        fears: this.personality.fears,
        desires: this.personality.desires,
        motivations: this.personality.motivations
      },
      background: this.background,
      stats: this.stats,
      skills: this.skills,
      relationships: {
        player: this.relationships.player,
        knownNPCs: Array.from(this.relationships.knownNPCs.entries())
      },
      location: this.location,
      state: this.state,
      inventory: this.inventory,
      memory: {
        events: this.memory.events,
        conversationPhase: this.memory.conversationPhase,
        conversationHistory: this.memory.conversationHistory,
        sawPlayerSteal: this.memory.sawPlayerSteal,
        sawPlayerKill: this.memory.sawPlayerKill,
        heardRumors: this.memory.heardRumors
      },
      dialogue: this.dialogue,
      ai: this.ai,
      meta: this.meta
    };
  }
  static fromJSON(data) {
    if (data.relationships?.knownNPCs) {
      data.relationships.knownNPCs = new Map(data.relationships.knownNPCs);
    }
    if (!data.identity && data.id) {
      data.identity = {
        id: data.id,
        name: data.name,
        title: data.title,
        faction: data.faction,
        role: data.role
      };
    }
    return new NPC(data);
  }
}
class NameDatabase {
  constructor() {
    this.names = this.getNameDefinitions();
    this.usedCombinations = /* @__PURE__ */ new Set();
  }
  /**
   * Get name pools for all factions
   */
  getNameDefinitions() {
    return {
      // Shipwrecked survivors - European/Colonial era names
      castaway: {
        male: [
          "William",
          "James",
          "Thomas",
          "Robert",
          "John",
          "Samuel",
          "Edward",
          "Henry",
          "Charles",
          "George",
          "Richard",
          "Benjamin",
          "Daniel",
          "Joseph",
          "Michael",
          "Peter",
          "Jonathan",
          "Christopher",
          "Matthew",
          "Andrew",
          "Francis",
          "Anthony",
          "Nicholas",
          "Timothy",
          "Stephen",
          "Philip",
          "Simon",
          "Alexander",
          "David",
          "Frederick",
          "Albert",
          "Arthur",
          "Walter",
          "Harry",
          "Louis",
          "Frank",
          "Ernest",
          "Clarence",
          "Theodore",
          "Eugene",
          "Raymond",
          "Harold",
          "Leonard",
          "Vincent",
          "Leroy",
          "Alfred",
          "Clyde",
          "Edwin",
          "Gordon",
          "Marion",
          "Jasper",
          "Caleb",
          "Ethan",
          "Gideon",
          "Isaac",
          "Levi",
          "Silas",
          "Tobias",
          "Zachary",
          "Abraham",
          "Bartholomew",
          "Clement",
          "Darius",
          "Elias",
          "Felix",
          "Hiram",
          "Jethro",
          "Luther",
          "Malachi",
          "Nehemiah",
          "Phineas",
          "Quentin",
          "Reuben",
          "Simeon",
          "Thaddeus",
          "Ulysses",
          "Victor",
          "Wesley",
          "Xavier",
          "Oliver",
          "Patrick",
          "Quincy",
          "Randolph",
          "Stanley",
          "Trevor",
          "Upton",
          "Vaughn",
          "Warren",
          "Wilbur",
          "Amos",
          "Barnabas",
          "Chester",
          "Douglas",
          "Ellis",
          "Floyd",
          "Gilbert",
          "Homer",
          "Irving",
          "Jerome",
          "Kenneth",
          "Lester",
          "Milton",
          "Norman",
          "Oscar",
          "Percy",
          "Ralph",
          "Sidney",
          "Terrence",
          "Virgil",
          "Willis",
          "Ambrose",
          "Bernard",
          "Calvin",
          "Cyrus",
          "Dexter",
          "Emery",
          "Francis",
          "Gerard",
          "Harvey",
          "Edmund",
          "Frederick",
          "Arthur",
          "Albert",
          "Ernest",
          "Walter",
          "Alfred",
          "Herbert",
          "Harold",
          "Leopold",
          "Augustus",
          "Reginald",
          "Percival",
          "Rupert",
          "Cecil",
          "Clive",
          "Basil",
          "Horace",
          "Cyril",
          "Lionel",
          "Mortimer",
          "Humphrey",
          "Godfrey",
          "Benedict",
          "Cornelius",
          "Maximilian",
          "Sebastian",
          "Thaddeus",
          "Bartholomew",
          "Ignatius",
          "Archibald",
          "Clarence",
          "Desmond",
          "Egbert",
          "Ferdinand",
          "Giles",
          "Hugo",
          "Jasper",
          "Alistair",
          "Barnaby",
          "Cedric",
          "Dunstan",
          "Eustace",
          "Fitzwilliam",
          "Godwin",
          "Hector",
          "Inigo",
          "Jerome",
          "Kendrick",
          "Lancelot",
          "Montgomery",
          "Nigel",
          "Oswald",
          "Peregrine",
          "Quinton",
          "Roderick",
          "Septimus",
          "Tobias",
          "Ulric",
          "Vivian",
          "Wilfred",
          "Xerxes",
          "Yardley",
          "Ambrose",
          "Bromley",
          "Caspar",
          "Digby",
          "Everard",
          "Fulton",
          "Griffith",
          "Hamish",
          "Irving",
          "Jocelyn",
          "Kenelm",
          "Ludovic",
          "Merlin",
          "Norbert",
          "Octavius"
        ],
        female: [
          "Mary",
          "Elizabeth",
          "Anne",
          "Margaret",
          "Sarah",
          "Catherine",
          "Jane",
          "Emma",
          "Charlotte",
          "Sophia",
          "Isabella",
          "Amelia",
          "Grace",
          "Eleanor",
          "Rebecca",
          "Rachel",
          "Hannah",
          "Abigail",
          "Emily",
          "Caroline",
          "Victoria",
          "Alice",
          "Clara",
          "Lillian",
          "Rose",
          "Helen",
          "Ruth",
          "Martha",
          "Beatrice",
          "Agnes",
          "Florence",
          "Harriet",
          "Lucy",
          "Mabel",
          "Nora",
          "Olive",
          "Pearl",
          "Ruby",
          "Stella",
          "Vera",
          "Willa",
          "Zoe",
          "Adeline",
          "Cecilia",
          "Daphne",
          "Evelyn",
          "Felicity",
          "Genevieve",
          "Helena",
          "Irene",
          "Josephine",
          "Katherine",
          "Lydia",
          "Matilda",
          "Nadine",
          "Ophelia",
          "Priscilla",
          "Quinn",
          "Rosalind",
          "Sylvia",
          "Theresa",
          "Ursula",
          "Vivian",
          "Adelaide",
          "Bernadette",
          "Constance",
          "Diana",
          "Edith",
          "Frances",
          "Gwendolyn",
          "Hazel",
          "Iris",
          "Juliet",
          "Kathryn",
          "Laura",
          "Miriam",
          "Naomi",
          "Octavia",
          "Penelope",
          "Rosemary",
          "Susannah",
          "Tabitha",
          "Violet",
          "Winifred",
          "Yvonne",
          "Alma",
          "Blanche",
          "Cora",
          "Della",
          "Elsie",
          "Flora",
          "Gladys",
          "Hattie",
          "Ida",
          "June",
          "Kitty",
          "Lena",
          "May",
          "Adelaide",
          "Beatrice",
          "Constance",
          "Dorothy",
          "Edith",
          "Florence",
          "Gertrude",
          "Harriet",
          "Imogen",
          "Josephine",
          "Katherine",
          "Lavinia",
          "Millicent",
          "Octavia",
          "Penelope",
          "Prudence",
          "Rosalind",
          "Tabitha",
          "Ursula",
          "Violet",
          "Winifred",
          "Arabella",
          "Cordelia",
          "Gwendolyn",
          "Henrietta",
          "Meredith",
          "Philippa",
          "Theodora",
          "Agatha",
          "Blanche",
          "Cecilia",
          "Daphne",
          "Estelle",
          "Felicity",
          "Georgiana",
          "Hyacinth",
          "Isolde",
          "Jocasta",
          "Keturah",
          "Lucinda",
          "Marigold",
          "Nerissa",
          "Ondine",
          "Petronilla",
          "Quintessa",
          "Rowena",
          "Seraphina",
          "Thomasina",
          "Venetia",
          "Wilhelmina",
          "Xanthe",
          "Yseult",
          "Zinnia",
          "Annabella",
          "Belinda",
          "Clementine",
          "Delphine",
          "Eugenia",
          "Fidelia",
          "Griselda",
          "Honoria",
          "Ismena",
          "Jessamine",
          "Lettice",
          "Marcelline",
          "Nerissa",
          "Olympia",
          "Perpetua"
        ],
        lastNames: [
          "Smith",
          "Johnson",
          "Williams",
          "Brown",
          "Jones",
          "Miller",
          "Davis",
          "Wilson",
          "Moore",
          "Taylor",
          "Anderson",
          "Thomas",
          "Jackson",
          "White",
          "Harris",
          "Martin",
          "Thompson",
          "Garcia",
          "Martinez",
          "Robinson",
          "Clark",
          "Rodriguez",
          "Lewis",
          "Lee",
          "Walker",
          "Hall",
          "Allen",
          "Young",
          "King",
          "Wright",
          "Scott",
          "Green",
          "Baker",
          "Adams",
          "Nelson",
          "Carter",
          "Mitchell",
          "Roberts",
          "Turner",
          "Phillips",
          "Campbell",
          "Parker",
          "Evans",
          "Edwards",
          "Collins",
          "Stewart",
          "Morris",
          "Cook",
          "Rogers",
          "Morgan",
          "Bell",
          "Murphy",
          "Bailey",
          "Cooper",
          "Reed",
          "Ward",
          "Cox",
          "Howard",
          "Richardson",
          "Wood",
          "Watson",
          "Brooks",
          "Kelly",
          "Sanders",
          "Price",
          "Bennett",
          "Gray",
          "James",
          "Rivera",
          "Watkins",
          "Foster",
          "Gonzalez",
          "Bryant",
          "Alexander",
          "Russell",
          "Griffin",
          "Diaz",
          "Hayes",
          "Myers",
          "Ford",
          "Hamilton",
          "Graham",
          "Sullivan",
          "Wallace",
          "Woods",
          "Cole",
          "West",
          "Jordan",
          "Owens",
          "Reynolds",
          "Fisher",
          "Ellis",
          "Harrison",
          "Gibson",
          "McDonald",
          "Cruz",
          "Marshall",
          "Ortiz",
          "Gomez",
          "Murray",
          "Freeman",
          "Wells",
          "Webb",
          "Simpson",
          "Stevens",
          "Tucker",
          "Porter",
          "Hunter",
          "Hicks",
          "Crawford",
          "Henry",
          "Boyd",
          "Mason",
          "Morales",
          "Kennedy",
          "Warren",
          "Dixon",
          "Ramos",
          "Reyes",
          "Burns",
          "Gordon",
          "Shaw",
          "Holmes",
          "Rice",
          "Robertson",
          "Hunt",
          "Black",
          "Daniels",
          "Palmer",
          "Mills",
          "Nichols",
          "Grant",
          "Knight",
          "Ferguson",
          "Rose",
          "Stone",
          "Hawkins",
          "Dunn",
          "Perkins",
          "Hudson",
          "Spencer",
          "Gardner",
          "Ashworth",
          "Blackwood",
          "Carrington",
          "Drummond",
          "Fairfax",
          "Gladstone",
          "Harrington",
          "Kensington",
          "Lancaster",
          "Montague",
          "Pembroke",
          "Radcliffe",
          "Sutherland",
          "Waverly",
          "Beaumont",
          "Chatsworth",
          "Dunbar",
          "Ellington",
          "Fitzgerald",
          "Grosvenor",
          "Huntington",
          "Kingston",
          "Livingstone",
          "Montgomery",
          "Ponsonby",
          "Ravenswood",
          "Stratford",
          "Wellington",
          "Ashford",
          "Beckett",
          "Caldwell",
          "Davenport",
          "Ellsworth",
          "Finch",
          "Goodwin",
          "Hastings",
          "Irving",
          "Jameson",
          "Kendall",
          "Lawson",
          "Merrick",
          "Norton",
          "Preston",
          "Quincy",
          "Radley",
          "Sinclair",
          "Thornton",
          "Winthrop",
          "Ashby",
          "Barlow",
          "Clifton",
          "Dresden",
          "Emerson",
          "Fletcher",
          "Grantham",
          "Holbrook",
          "Kingsley",
          "Maxwell",
          "Pritchard",
          "Sheffield",
          "Worthington",
          "Aldridge",
          "Blackburn",
          "Cheltenham",
          "Devonshire",
          "Edgeworth",
          "Fenwick",
          "Gloucester",
          "Harrowgate",
          "Islington",
          "Jarvis",
          "Kensington",
          "Langford",
          "Maidstone",
          "Norwood",
          "Oakley",
          "Paddington",
          "Queensbury",
          "Rothwell",
          "Salisbury",
          "Twickenham",
          "Uppingham",
          "Vauxhall",
          "Whitehall",
          "Yarmouth",
          "Ashcroft",
          "Bridgewater",
          "Chadwick",
          "Danvers",
          "Eastwood",
          "Fairchild",
          "Greenwood",
          "Hawthorne",
          "Ironwood",
          "Jarrett",
          "Kimberly",
          "Lockwood",
          "Marlowe",
          "Nightingale",
          "Overbrook"
        ]
      },
      // Indigenous islanders - Polynesian/Pacific names (both tribes share pool)
      native: {
        male: [
          "Koa",
          "Kai",
          "Nalu",
          "Keanu",
          "Makoa",
          "Keahi",
          "Ikaika",
          "Tane",
          "Kane",
          "Keoni",
          "Liko",
          "Manoa",
          "Akoni",
          "Kaimana",
          "Kaleo",
          "Pika",
          "Alika",
          "Lopaka",
          "Maka",
          "Alapai",
          "Ekewaka",
          "Haukea",
          "Kapena",
          "Kawika",
          "Keola",
          "Kiele",
          "Konane",
          "Mahiai",
          "Makani",
          "Palani",
          "Pono",
          "Uluwehi",
          "Kahoku",
          "Kale",
          "Kamea",
          "Kapono",
          "Kaui",
          "Keaka",
          "Kelii",
          "Keonimana",
          "Kuulei",
          "Lono",
          "Makaio",
          "Mana",
          "Nainoa",
          "Noelani",
          "Olakino",
          "Palakiko",
          "Puana",
          "Wahinekoa",
          "Ailani",
          "Anuhea",
          "Haunani",
          "Hiapo",
          "Hoaloha",
          "Iolana",
          "Kahale",
          "Kaimi",
          "Kaiwi",
          "Kamaka",
          "Kanoa",
          "Kekoa",
          "Keoki",
          "Lanakila",
          "Makai",
          "Maleko",
          "Ohana",
          "Pulama"
        ],
        female: [
          "Lani",
          "Malia",
          "Leilani",
          "Nalani",
          "Mahina",
          "Ailani",
          "Hoku",
          "Kalani",
          "Moana",
          "Nani",
          "Pele",
          "Hina",
          "Kailani",
          "Noelani",
          "Palila",
          "Waimea",
          "Halia",
          "Iolana",
          "Liona",
          "Mele",
          "Nohea",
          "Ulani",
          "Emi",
          "Haunani",
          "Kawai",
          "Nalei",
          "Oliana",
          "Pualani",
          "Tahiti",
          "Wailani",
          "Anela",
          "Ipo",
          "Kaila",
          "Kona",
          "Maiha",
          "Naia",
          "Okalani",
          "Pohai",
          "Ualani",
          "Wikolia",
          "Alana",
          "Aukai",
          "Halona",
          "Ilima",
          "Kahiau",
          "Kaimana",
          "Kalena",
          "Keala",
          "Keanu",
          "Kiele",
          "Lana",
          "Lehua",
          "Lilinoe",
          "Makana",
          "Malana",
          "Mililani",
          "Nohealani",
          "Olina",
          "Paloma",
          "Pilikai",
          "Pilialoha",
          "Pua",
          "Puanani",
          "Uluwena",
          "Waialani",
          "Wainani",
          "Alohi",
          "Eleu",
          "Iwalani"
        ],
        lastNames: [
          "Kahale",
          "Kealoha",
          "Akana",
          "Kamaka",
          "Mahoe",
          "Nui",
          "Palakiko",
          "Wahine",
          "Alani",
          "Hoapili",
          "Kaeo",
          "Lilinoe",
          "Manu",
          "Noho",
          "Paki",
          "Uluwehi",
          "Aea",
          "Hoku",
          "Kahalewai",
          "Lono",
          "Mahelona",
          "Nahale",
          "Palani",
          "Waiwaiole",
          "Aikane",
          "Hanohano",
          "Kanaloa",
          "Loe",
          "Makani",
          "Ohana",
          "Pukui",
          "Wikoli",
          "Ahina",
          "Hauoli",
          "Kanoa",
          "Lua",
          "Malama",
          "Olelo",
          "Pueo",
          "Wili",
          "Alohi",
          "Hele",
          "Kapule",
          "Lutu",
          "Mana",
          "Olina",
          "Puna",
          "Waipuna",
          "Aniani",
          "Hoomana",
          "Kauwila",
          "Mahalo",
          "Mele",
          "Palauni",
          "Ulupono",
          "Waena",
          "Apikalia",
          "Ikaika",
          "Kekoa",
          "Makua",
          "Nohili",
          "Palea",
          "Uluaki",
          "Walina",
          "Aiona",
          "Hale",
          "Kama",
          "Lana",
          "Moana",
          "Nalu",
          "Pele",
          "Wai",
          "Akau",
          "Hina",
          "Kani",
          "Lani",
          "Moku",
          "Ola",
          "Pono",
          "Wiki",
          "Ao",
          "Hikina",
          "Kau",
          "Lei",
          "Momi",
          "Onaona",
          "Pua",
          "Wela",
          "Aloha",
          "Honu",
          "Kekai",
          "Loa",
          "Mauka",
          "Pali",
          "Uhane",
          "Wana",
          "Aukai",
          "Hokulani",
          "Kekela",
          "Lua",
          "Mele",
          "Pohaku",
          "Waipio",
          "Aina",
          "Hele",
          "Kiele",
          "Lokahi",
          "Malie",
          "Piko",
          "Wailuku",
          "Alaka",
          "Holo"
        ]
      },
      // Mercenaries - Multinational PMC soldiers with various backgrounds
      mercenary: {
        male: [
          "Jack",
          "Mike",
          "Ryan",
          "Alex",
          "Chris",
          "Sean",
          "Kyle",
          "Brandon",
          "Derek",
          "Travis",
          "Tyler",
          "Jason",
          "Kevin",
          "Marcus",
          "Jake",
          "Nick",
          "Cole",
          "Blake",
          "Shane",
          "Brett",
          "Chase",
          "Hunter",
          "Austin",
          "Logan",
          "Connor",
          "Wyatt",
          "Mason",
          "Carter",
          "Evan",
          "Owen",
          "Luke",
          "Nathan",
          "Ivan",
          "Dmitri",
          "Alexei",
          "Viktor",
          "Sergei",
          "Nikolai",
          "Boris",
          "Yuri",
          "Andre",
          "Marcel",
          "Pierre",
          "Jean",
          "Luc",
          "Henri",
          "Remy",
          "Olivier",
          "Hans",
          "Klaus",
          "Otto",
          "Franz",
          "Werner",
          "Gunter",
          "Dieter",
          "Helmut",
          "Carlos",
          "Diego",
          "Miguel",
          "Pablo",
          "Rafael",
          "Antonio",
          "Jose",
          "Luis",
          "Hassan",
          "Omar",
          "Khalid",
          "Tariq",
          "Malik",
          "Rashid",
          "Jamal",
          "Faisal",
          "Chen",
          "Wei",
          "Li",
          "Zhang",
          "Wang",
          "Liu",
          "Yang",
          "Huang",
          "Raj",
          "Vikram",
          "Arjun",
          "Rohan",
          "Karan",
          "Aditya",
          "Dev",
          "Kabir",
          "Takeshi",
          "Kenji",
          "Hiroshi",
          "Ryu",
          "Satoshi",
          "Koji",
          "Hideo",
          "Makoto",
          "Jack",
          "Billy",
          "Tom",
          "Jim",
          "Sam",
          "Will",
          "Ned",
          "Ben",
          "Jake",
          "Pete",
          "Calico",
          "Black",
          "Red",
          "Long",
          "Dead",
          "Dutch",
          "One-Eye",
          "Peg-Leg",
          "Hook",
          "Jolly",
          "Mad",
          "Wild",
          "Bloody",
          "Iron",
          "Silver",
          "Gold",
          "Brass",
          "Cutlass",
          "Storm",
          "Thunder",
          "Shark",
          "Raven",
          "Crow",
          "Hawk",
          "Morgan",
          "Teach",
          "Kidd",
          "Cutthroat",
          "Scurvy",
          "Salty",
          "Barnacle",
          "Deadshot",
          "Quickdraw",
          "Hooks",
          "Bones",
          "Flint",
          "Drake",
          "Hawkeye",
          "Ironside",
          "Jaws",
          "Knuckles",
          "Lefty",
          "Moody",
          "Nick",
          "Old",
          "Powder",
          "Rusty",
          "Scarface",
          "Tattered",
          "Ugly",
          "Vicious",
          "Wicked",
          "Young",
          "Blackjack",
          "Crimson",
          "Dagger",
          "Eagle-Eye",
          "Firebrand",
          "Grizzled",
          "Hammerhead",
          "Ironjaw",
          "Jackal",
          "Knifey",
          "Longshot",
          "Mangy",
          "Notch",
          "Orcus"
        ],
        female: [
          "Sarah",
          "Jessica",
          "Ashley",
          "Emily",
          "Rachel",
          "Nicole",
          "Jennifer",
          "Amanda",
          "Michelle",
          "Melissa",
          "Stephanie",
          "Rebecca",
          "Laura",
          "Kimberly",
          "Danielle",
          "Amy",
          "Samantha",
          "Kelly",
          "Andrea",
          "Angela",
          "Lisa",
          "Megan",
          "Heather",
          "Shannon",
          "Taylor",
          "Jordan",
          "Morgan",
          "Riley",
          "Casey",
          "Avery",
          "Quinn",
          "Blake",
          "Natasha",
          "Svetlana",
          "Olga",
          "Irina",
          "Elena",
          "Katya",
          "Anya",
          "Nadia",
          "Marie",
          "Sophie",
          "Claire",
          "Elise",
          "Camille",
          "Gabrielle",
          "Isabelle",
          "Monique",
          "Greta",
          "Heidi",
          "Petra",
          "Ursula",
          "Ingrid",
          "Astrid",
          "Marlene",
          "Britta",
          "Carmen",
          "Isabella",
          "Rosa",
          "Lucia",
          "Sofia",
          "Elena",
          "Maria",
          "Ana",
          "Fatima",
          "Amira",
          "Layla",
          "Zahra",
          "Noor",
          "Aisha",
          "Yasmin",
          "Leila",
          "Mei",
          "Ling",
          "Yan",
          "Xiu",
          "Li",
          "Fang",
          "Jing",
          "Hui",
          "Priya",
          "Anjali",
          "Kavita",
          "Neha",
          "Pooja",
          "Riya",
          "Sana",
          "Tara",
          "Yuki",
          "Sakura",
          "Hana",
          "Akira",
          "Emi",
          "Kaori",
          "Mika",
          "Rei",
          "Anne",
          "Mary",
          "Grace",
          "Bonny",
          "Scarlet",
          "Ruby",
          "Pearl",
          "Jade",
          "Amber",
          "Black",
          "Red",
          "Storm",
          "Tempest",
          "Raven",
          "Coral",
          "Lightning",
          "Eagle",
          "Mad",
          "Wild",
          "Bloody",
          "Iron",
          "Silver",
          "Gold",
          "Siren",
          "Vixen",
          "Cutlass",
          "Rose",
          "Jolly",
          "Lucky",
          "Sharp",
          "Swift",
          "Fierce",
          "Blade",
          "Fury",
          "Hawk",
          "Bella",
          "Crimson",
          "Dusk",
          "Emerald",
          "Fang",
          "Gale",
          "Hex",
          "Ivory",
          "Jasmine",
          "Kestrel",
          "Luna",
          "Mist",
          "Onyx",
          "Phoenix",
          "Rogue",
          "Sapphire",
          "Thorn",
          "Venom",
          "Whisper",
          "Azure",
          "Blaze",
          "Cinder",
          "Dawn",
          "Echo",
          "Frost",
          "Grim",
          "Haze",
          "Iris",
          "Jinx",
          "Karma",
          "Lotus",
          "Midnight"
        ],
        lastNames: [
          "Smith",
          "Johnson",
          "Williams",
          "Brown",
          "Jones",
          "Miller",
          "Davis",
          "Wilson",
          "Moore",
          "Taylor",
          "Anderson",
          "Jackson",
          "White",
          "Harris",
          "Martin",
          "Garcia",
          "Thompson",
          "Martinez",
          "Robinson",
          "Clark",
          "Rodriguez",
          "Lewis",
          "Walker",
          "Hall",
          "Petrov",
          "Ivanov",
          "Volkov",
          "Sokolov",
          "Kozlov",
          "Novikov",
          "Morozov",
          "Popov",
          "Dubois",
          "Lefebvre",
          "Martin",
          "Bernard",
          "Moreau",
          "Laurent",
          "Simon",
          "Michel",
          "Mueller",
          "Schmidt",
          "Schneider",
          "Fischer",
          "Weber",
          "Meyer",
          "Wagner",
          "Becker",
          "Hernandez",
          "Lopez",
          "Gonzalez",
          "Perez",
          "Sanchez",
          "Ramirez",
          "Torres",
          "Rivera",
          "Hassan",
          "Ali",
          "Ahmed",
          "Khan",
          "Mahmoud",
          "Hussein",
          "Rashid",
          "Sharif",
          "Chen",
          "Wang",
          "Li",
          "Zhang",
          "Liu",
          "Yang",
          "Huang",
          "Zhao",
          "Patel",
          "Singh",
          "Kumar",
          "Sharma",
          "Reddy",
          "Gupta",
          "Verma",
          "Shah",
          "Tanaka",
          "Suzuki",
          "Takahashi",
          "Watanabe",
          "Yamamoto",
          "Nakamura",
          "Kobayashi",
          "Sato",
          "Black",
          "Stone",
          "Steel",
          "Cross",
          "Fox",
          "Wolf",
          "Hawk",
          "Hunter",
          "Graves",
          "Kane",
          "Storm",
          "Knight",
          "Frost",
          "Rivers",
          "Burns",
          "West",
          "Bonney",
          "Rackham",
          "Teach",
          "Blackbeard",
          "Redbeard",
          "Morgan",
          "Kidd",
          "Flint",
          "Silver",
          "Hawkins",
          "Smollett",
          "Trelawney",
          "Roberts",
          "Bartholomew",
          "Calico",
          "Vane",
          "The Red",
          "The Black",
          "The Bold",
          "The Bloody",
          "The Mad",
          "The Wild",
          "No-Mercy",
          "Ironhand",
          "Steelgaze",
          "Sharktooth",
          "Seadevil",
          "Stormrider",
          "Wavecutter",
          "Reefbreaker",
          "Bloodsail",
          "Blackflag",
          "Skullcrusher",
          "Bonecruncher",
          "Throatslitter",
          "Backstabber",
          "Cutlass",
          "Sabre",
          "Dagger",
          "Dirk",
          "Rapier",
          "Scimitar",
          "Cleaver",
          "Hatchet",
          "Grog",
          "Rum",
          "Whiskey",
          "Gin",
          "Brandy",
          "Ale",
          "Tankard",
          "Swill",
          "Barnacle",
          "Scurvy",
          "Pox",
          "Plague",
          "Scab",
          "Scar",
          "Stump",
          "Gimp",
          "The Cruel",
          "The Fierce",
          "The Merciless",
          "The Ruthless",
          "The Savage",
          "The Terrible",
          "The Vile",
          "Blackheart",
          "Coldsteel",
          "Darksail",
          "Evileye",
          "Firebrand",
          "Grimskull",
          "Hardtack",
          "Ironhook",
          "Jollyroger",
          "Keelhauler",
          "Longshanks",
          "Murdock",
          "Nightshade",
          "Oakum",
          "Plunderer",
          "Quickblade",
          "Raider",
          "Scallywag",
          "Tidecaller",
          "Undertow",
          "Vengeance",
          "Weatherby",
          "Crossbones",
          "Deadwater",
          "Executioner",
          "Freebooter",
          "Gallows",
          "Harpooner"
        ]
      }
    };
  }
  /**
   * Generate a unique name for an NPC
   * @param {string} faction - The NPC's faction
   * @param {string} gender - 'male' or 'female'
   * @param {object} seededRandom - Seeded random generator instance
   * @returns {object} {firstName, lastName, fullName}
   */
  generateName(faction, gender, seededRandom) {
    const factionNames = this.names[faction];
    if (!factionNames) {
      console.warn(`Unknown faction: ${faction}, using castaway names`);
      return this.generateName("castaway", gender, seededRandom);
    }
    const genderPool = factionNames[gender] || factionNames.male;
    if (!genderPool) {
      console.warn(`No ${gender} names for faction ${faction}, using male names`);
      return this.generateName(faction, "male", seededRandom);
    }
    const maxAttempts = 1e3;
    let attempts = 0;
    while (attempts < maxAttempts) {
      const firstName2 = seededRandom.choice(genderPool);
      const lastName2 = seededRandom.choice(factionNames.lastNames);
      const fullName2 = `${firstName2} ${lastName2}`;
      const key = `${faction}:${fullName2}`;
      if (!this.usedCombinations.has(key)) {
        this.usedCombinations.add(key);
        return { firstName: firstName2, lastName: lastName2, fullName: fullName2 };
      }
      attempts++;
    }
    console.warn(`All name combinations exhausted for faction: ${faction}`);
    const firstName = seededRandom.choice(genderPool);
    const lastName = seededRandom.choice(factionNames.lastNames);
    const fullName = `${firstName} ${lastName}`;
    return { firstName, lastName, fullName };
  }
  /**
   * Mark a name as used (for loading saved NPCs)
   */
  markNameAsUsed(faction, fullName) {
    const key = `${faction}:${fullName}`;
    this.usedCombinations.add(key);
  }
  /**
   * Get all used name combinations (for saving)
   */
  getUsedNames() {
    return Array.from(this.usedCombinations);
  }
  /**
   * Load used names (for loading saves)
   */
  loadUsedNames(usedNames) {
    this.usedCombinations = new Set(usedNames || []);
  }
  /**
   * Clear all used names (for new game)
   */
  clearUsedNames() {
    this.usedCombinations.clear();
  }
  /**
   * Get statistics about available names
   */
  getStats(faction = null) {
    if (faction) {
      const factionNames = this.names[faction];
      if (!factionNames) return null;
      const maleCombos = factionNames.male.length * factionNames.lastNames.length;
      const femaleCombos = factionNames.female.length * factionNames.lastNames.length;
      const totalCombinations = maleCombos + femaleCombos;
      const usedCount = Array.from(this.usedCombinations).filter((key) => key.startsWith(`${faction}:`)).length;
      return {
        faction,
        maleCombinations: maleCombos,
        femaleCombinations: femaleCombos,
        totalCombinations,
        used: usedCount,
        available: totalCombinations - usedCount,
        percentUsed: (usedCount / totalCombinations * 100).toFixed(2)
      };
    }
    const stats = {};
    for (const faction2 in this.names) {
      stats[faction2] = this.getStats(faction2);
    }
    return stats;
  }
}
class AppearanceDatabase {
  constructor() {
    this.data = this.getAppearanceData();
  }
  getAppearanceData() {
    return {
      // Age ranges by faction (min, max)
      ageRanges: {
        castaway: { min: 20, max: 60 },
        // Survivors, various ages
        native: { min: 18, max: 70 },
        // Multi-generational islanders
        mercenary: { min: 25, max: 45 }
        // Professional soldiers, peak age
      },
      // Height ranges in cm by gender
      heightRanges: {
        male: { min: 165, max: 195 },
        female: { min: 155, max: 180 },
        other: { min: 160, max: 185 }
      },
      // Skin tones by faction (weighted for diversity)
      skinTones: {
        castaway: [
          // European/Colonial mix
          { tone: "pale", weight: 2 },
          { tone: "fair", weight: 3 },
          { tone: "light tan", weight: 2 },
          { tone: "olive", weight: 2 },
          { tone: "tan", weight: 1 },
          { tone: "brown", weight: 1 },
          { tone: "dark brown", weight: 1 }
        ],
        native: [
          // Pacific Islander tones
          { tone: "golden tan", weight: 3 },
          { tone: "deep tan", weight: 3 },
          { tone: "bronze", weight: 3 },
          { tone: "warm brown", weight: 2 },
          { tone: "rich brown", weight: 2 },
          { tone: "dark brown", weight: 1 }
        ],
        mercenary: [
          // Multinational mix
          { tone: "pale", weight: 2 },
          { tone: "fair", weight: 2 },
          { tone: "olive", weight: 2 },
          { tone: "tan", weight: 2 },
          { tone: "brown", weight: 2 },
          { tone: "dark brown", weight: 2 },
          { tone: "ebony", weight: 1 }
        ]
      },
      // Hair colors by faction
      hairColors: {
        castaway: [
          { color: "blonde", weight: 2 },
          { color: "light brown", weight: 3 },
          { color: "brown", weight: 3 },
          { color: "dark brown", weight: 2 },
          { color: "black", weight: 2 },
          { color: "auburn", weight: 1 },
          { color: "red", weight: 1 },
          { color: "gray", weight: 1 },
          { color: "white", weight: 1 }
        ],
        native: [
          { color: "black", weight: 5 },
          { color: "very dark brown", weight: 3 },
          { color: "dark brown", weight: 2 }
        ],
        mercenary: [
          { color: "black", weight: 3 },
          { color: "dark brown", weight: 3 },
          { color: "brown", weight: 2 },
          { color: "blonde", weight: 2 },
          { color: "red", weight: 1 },
          { color: "gray", weight: 1 },
          { color: "shaved", weight: 2 },
          { color: "dyed black", weight: 1 }
        ]
      },
      // Hair styles by gender and faction
      hairStyles: {
        male: {
          castaway: ["wild and unkempt", "shoulder-length and tangled", "pulled back in rough ponytail", "matted and sun-bleached", "scraggly beard and messy hair", "tied back with vine"],
          native: ["traditional topknot", "long and flowing", "adorned with shells and flowers", "braided with ceremonial beads", "pulled back with bone clasp", "shaved sides with long top"],
          mercenary: ["military buzz cut", "high and tight fade", "cropped short", "tactical crew cut", "shaved head", "slicked back", "military regulation"]
        },
        female: {
          castaway: ["wild and windswept", "long and tangled", "roughly braided", "sun-bleached and wavy", "tied back with torn cloth", "matted and messy"],
          native: ["adorned with flowers and shells", "long flowing with traditional ornaments", "braided with colorful threads", "decorated with feathers", "woven with natural elements", "ceremonial style with beads"],
          mercenary: ["tight military bun", "practical ponytail", "short tactical cut", "braided and secured", "regulation bob", "tight braids"]
        }
      },
      // Hair lengths
      hairLengths: {
        male: ["very short", "short", "medium", "shoulder-length", "long"],
        female: ["short", "shoulder-length", "long", "very long"]
      },
      // Eye colors (mostly natural, some exotic)
      eyeColors: [
        { color: "brown", weight: 4 },
        { color: "dark brown", weight: 4 },
        { color: "hazel", weight: 3 },
        { color: "green", weight: 2 },
        { color: "blue", weight: 2 },
        { color: "gray", weight: 1 },
        { color: "amber", weight: 1 },
        { color: "emerald green", weight: 0.5 },
        { color: "ice blue", weight: 0.5 },
        { color: "violet", weight: 0.3 }
      ],
      // Body builds by gender and faction (weighted)
      bodyBuilds: {
        male: {
          castaway: [
            { build: "lean", weight: 3 },
            { build: "average", weight: 2 },
            { build: "athletic", weight: 2 },
            { build: "muscular", weight: 1 },
            { build: "wiry", weight: 2 }
          ],
          native: [
            { build: "athletic", weight: 4 },
            { build: "muscular", weight: 3 },
            { build: "lean", weight: 2 },
            { build: "stocky", weight: 1 }
          ],
          mercenary: [
            { build: "muscular", weight: 4 },
            { build: "athletic", weight: 3 },
            { build: "stocky", weight: 2 },
            { build: "hulking", weight: 1 }
          ]
        },
        female: {
          castaway: [
            { build: "slim", weight: 3 },
            { build: "average", weight: 2 },
            { build: "athletic", weight: 2 },
            { build: "curvy", weight: 2 },
            { build: "petite", weight: 1 }
          ],
          native: [
            { build: "athletic", weight: 4 },
            { build: "curvy", weight: 3 },
            { build: "average", weight: 2 },
            { build: "voluptuous", weight: 1 }
          ],
          mercenary: [
            { build: "athletic", weight: 4 },
            { build: "muscular", weight: 3 },
            { build: "toned", weight: 2 },
            { build: "average", weight: 1 }
          ]
        }
      },
      // Clothing templates by faction and gender
      clothing: {
        castaway: {
          male: [
            "tattered shirt and torn pants, barefoot",
            "ripped trousers and no shirt, sun-damaged",
            "makeshift loincloth from ship sail",
            "torn dress shirt and ragged slacks",
            "salvaged vest over bare chest, worn pants",
            "threadbare clothing held together with rope"
          ],
          female: [
            "torn dress repurposed as wrap",
            "tattered blouse and makeshift skirt",
            "salvaged fabric tied as halter top and shorts",
            "ripped clothing fashioned into two-piece",
            "sun-bleached dress with many tears",
            "improvised clothing from ship materials"
          ]
        },
        native: {
          male: [
            "traditional loincloth with ceremonial tattoos visible",
            "woven grass skirt and shell necklaces",
            "minimal tribal garments with body paint",
            "decorated loincloth and arm bands",
            "ceremonial wraps with natural dyes",
            "traditional island attire with feather ornaments"
          ],
          female: [
            "woven grass skirt and shell top",
            "traditional sarong with flower lei",
            "ceremonial two-piece with natural decorations",
            "wrapped fabric skirt and decorative top",
            "island dress with traditional patterns",
            "minimal tribal garments with body paint and flowers"
          ]
        },
        mercenary: {
          male: [
            "black tactical vest over combat shirt, cargo pants, boots",
            "urban camouflage fatigues with tactical gear",
            "combat uniform with Blacksteel insignia, armed",
            "tactical clothing, plate carrier, military boots",
            "dark military outfit with equipment harness",
            "PMC tactical gear, subdued patches, combat ready"
          ],
          female: [
            "black tactical vest over fitted combat shirt, cargo pants",
            "tactical outfit with equipment harness, military boots",
            "combat uniform with Blacksteel patch, armed",
            "fitted tactical clothing with gear vest",
            "dark military outfit, plate carrier, boots",
            "PMC tactical gear, professional appearance"
          ]
        }
      },
      // Distinctive features by faction (scars, tattoos, physical traits)
      distinctiveFeatures: {
        castaway: [
          "sun-damaged skin with freckles",
          "long scar across arm from shipwreck",
          "calloused hands from survival work",
          "haunted, tired eyes",
          "badly healed broken nose",
          "rope burn scars on wrists",
          "gaunt, weathered face",
          "missing tooth from accident",
          "deep scar on forehead",
          "perpetually sunburned shoulders",
          "wild, desperate eyes",
          "visible ribs from rationing",
          "salt-crusted hair",
          "permanent squint from sun glare"
        ],
        native: [
          "traditional tribal tattoos on arms",
          "ceremonial scarification patterns",
          "shell or bone piercings",
          "intricate facial tattoos",
          "flower tattoo on shoulder",
          "ritual scars on chest",
          "carved bone necklace",
          "traditional earlobe stretching",
          "sacred tribal markings",
          "decorative face paint",
          "ancestral tattoo sleeves",
          "ceremonial scars on back",
          "ritual piercings",
          "symbolic tattoos on hands"
        ],
        mercenary: [
          "combat scar across cheek",
          "military dog tags",
          "tactical gear tan lines",
          "shrapnel scars on arms",
          "unit tattoo on shoulder",
          "broken nose from combat",
          "knife scar on jaw",
          "Blacksteel insignia tattoo",
          "missing finger from operation",
          "burn scar on neck",
          "cold, calculating eyes",
          "professional posture and bearing",
          "visible gunshot scar",
          "military regulation appearance",
          "tactical calluses on hands"
        ]
      }
    };
  }
  /**
   * Normalize faction name to database key
   * @param {string} faction - Game faction name
   * @returns {string} Database faction key
   */
  normalizeFaction(faction) {
    const factionMap = {
      "castaway": "castaway",
      "natives_clan1": "native",
      "natives_clan2": "native",
      "mercenaries": "mercenary",
      "native": "native",
      "mercenary": "mercenary"
    };
    return factionMap[faction] || "castaway";
  }
  /**
   * Generate complete appearance for NPC
   * @param {string} faction - NPC faction
   * @param {string} gender - NPC gender
   * @param {object} seededRandom - Seeded random generator
   * @returns {object} Complete appearance data
   */
  generateAppearance(faction, gender, seededRandom) {
    console.log("üëó [appearance 1/12] Starting generateAppearance");
    const data = this.data;
    const normalizedFaction = this.normalizeFaction(faction);
    const genderKey = gender === "male" || gender === "female" ? gender : "female";
    console.log(`üëó [appearance 2/12] Gender key: ${genderKey} (from ${gender}), Faction: ${normalizedFaction} (from ${faction})`);
    const ageRange = data.ageRanges[normalizedFaction];
    const age = seededRandom.int(ageRange.min, ageRange.max);
    console.log(`üëó [appearance 3/12] Age: ${age}`);
    const heightRange = data.heightRanges[genderKey];
    const height = seededRandom.int(heightRange.min, heightRange.max);
    console.log(`üëó [appearance 4/12] Height: ${height}`);
    console.log("üëó [appearance 5/12] Generating skin tone...");
    const skinTone = this.weightedChoice(data.skinTones[normalizedFaction], seededRandom);
    console.log(`üëó [appearance 5b/12] Skin tone: ${skinTone}`);
    console.log("üëó [appearance 6/12] Generating hair color...");
    const hairColor = this.weightedChoice(data.hairColors[normalizedFaction], seededRandom);
    console.log(`üëó [appearance 6b/12] Hair color: ${hairColor}`);
    console.log("üëó [appearance 7/12] Generating hair style...");
    const hairStyles = data.hairStyles[genderKey][normalizedFaction];
    const hairStyle = seededRandom.choice(hairStyles);
    console.log(`üëó [appearance 7b/12] Hair style: ${hairStyle}`);
    console.log("üëó [appearance 8/12] Generating hair length...");
    const hairLength = seededRandom.choice(data.hairLengths[genderKey]);
    console.log(`üëó [appearance 8b/12] Hair length: ${hairLength}`);
    console.log("üëó [appearance 9/12] Generating eye color...");
    const eyeColor = this.weightedChoice(data.eyeColors, seededRandom);
    console.log(`üëó [appearance 9b/12] Eye color: ${eyeColor}`);
    console.log("üëó [appearance 10/12] Generating body build...");
    const build = this.weightedChoice(data.bodyBuilds[genderKey][normalizedFaction], seededRandom);
    console.log(`üëó [appearance 10b/12] Build: ${build}`);
    console.log("üëó [appearance 11/12] Generating clothing...");
    const clothingOptions = data.clothing[normalizedFaction][genderKey];
    const clothing = seededRandom.choice(clothingOptions);
    console.log(`üëó [appearance 11b/12] Clothing: ${clothing}`);
    console.log("üëó [appearance 11c/12] Generating distinctive features...");
    const featurePool = data.distinctiveFeatures[normalizedFaction];
    console.log(`üëó [appearance 11c1] Feature pool size: ${featurePool.length}`);
    const featureCount = seededRandom.int(2, 4);
    console.log(`üëó [appearance 11c2] Requested features: ${featureCount}`);
    const distinctiveFeatures = [];
    const usedIndices = /* @__PURE__ */ new Set();
    const maxFeatures = Math.min(featureCount, featurePool.length);
    console.log(`üëó [appearance 11c3] Max features (capped): ${maxFeatures}`);
    let attempts = 0;
    const maxAttempts = featurePool.length * 3;
    while (distinctiveFeatures.length < maxFeatures && attempts < maxAttempts) {
      attempts++;
      const index = seededRandom.int(0, featurePool.length - 1);
      console.log(`üëó [appearance 11c4] Attempt ${attempts}: index=${index}, already used=${usedIndices.has(index)}`);
      if (!usedIndices.has(index)) {
        usedIndices.add(index);
        distinctiveFeatures.push(featurePool[index]);
        console.log(`üëó [appearance 11c5] Added feature: "${featurePool[index]}" (total: ${distinctiveFeatures.length})`);
      }
      if (usedIndices.size >= featurePool.length) {
        console.log(`üëó [appearance 11c6] Used all available features (${usedIndices.size}), breaking`);
        break;
      }
    }
    if (attempts >= maxAttempts) {
      console.warn(`üëó [appearance 11c7] ‚ö†Ô∏è Hit max attempts (${maxAttempts}), forcing exit`);
    }
    console.log(`üëó [appearance 11d/12] Features: ${distinctiveFeatures.length} features selected in ${attempts} attempts`);
    console.log("üëó [appearance 12/12] ‚úÖ Appearance generation complete");
    return {
      gender,
      age,
      height,
      skinTone,
      hairColor,
      hairStyle,
      hairLength,
      eyeColor,
      build,
      clothing,
      distinctiveFeatures
    };
  }
  /**
   * Weighted random selection
   * @param {Array} options - Array of {value, weight} or {color, weight} etc
   * @param {object} seededRandom - Seeded random generator
   * @returns {string} Selected value
   */
  weightedChoice(options, seededRandom) {
    const totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);
    let random = seededRandom.next() * totalWeight;
    for (const option of options) {
      random -= option.weight;
      if (random <= 0) {
        return option.tone || option.color || option.build || option;
      }
    }
    return options[0].tone || options[0].color || options[0].build || options[0];
  }
}
class PersonalityDatabase {
  constructor() {
    this.data = this.getPersonalityData();
  }
  getPersonalityData() {
    return {
      // Big Five personality trait ranges by faction (0-100 scale)
      // Each faction has different baseline tendencies
      traitRanges: {
        castaway: {
          // Survivors - traumatized but resilient
          openness: { min: 30, max: 80 },
          // Variable - depends on pre-island life
          conscientiousness: { min: 40, max: 90 },
          // High - survival requires discipline
          extraversion: { min: 20, max: 70 },
          // Lower - isolation impacts social behavior
          agreeableness: { min: 30, max: 80 },
          // Variable - survival can make selfish or cooperative
          neuroticism: { min: 40, max: 90 }
          // Higher - trauma and stress
        },
        native: {
          // Islanders - traditional, community-oriented
          openness: { min: 30, max: 70 },
          // Moderate - traditional but nature-connected
          conscientiousness: { min: 50, max: 90 },
          // High - community responsibilities
          extraversion: { min: 40, max: 80 },
          // Moderate-high - social culture
          agreeableness: { min: 50, max: 90 },
          // High - cooperative community values
          neuroticism: { min: 20, max: 60 }
          // Lower - stable traditional life
        },
        mercenary: {
          // Blacksteel operators - professional, aggressive
          openness: { min: 30, max: 70 },
          // Moderate - tactical thinking
          conscientiousness: { min: 60, max: 95 },
          // Very high - military discipline
          extraversion: { min: 30, max: 70 },
          // Variable - some leaders, some loners
          agreeableness: { min: 10, max: 50 },
          // Low - trained to be ruthless
          neuroticism: { min: 20, max: 60 }
          // Low-moderate - combat conditioning
        }
      },
      // Sexual orientation distribution (weighted)
      sexualOrientations: [
        { orientation: "heterosexual", weight: 7 },
        { orientation: "bisexual", weight: 2 },
        { orientation: "homosexual", weight: 1 },
        { orientation: "pansexual", weight: 1 }
      ],
      // Sexual preferences (kinks, interests) - adult content
      sexualPreferences: {
        dominance: ["dominant", "submissive", "switch", "neutral"],
        intensity: ["vanilla", "adventurous", "kinky", "extreme"],
        interests: [
          "bondage",
          "roleplay",
          "outdoor",
          "voyeurism",
          "exhibitionism",
          "rough",
          "gentle",
          "sensual",
          "passionate",
          "experimental",
          "traditional",
          "romantic",
          "casual",
          "intense",
          "playful"
        ]
      },
      // Behavioral quirks by faction
      quirks: {
        castaway: [
          "constantly checks the horizon for ships",
          "hoards small items compulsively",
          "talks to themselves when alone",
          "can't sleep without sound of waves",
          "flinches at loud noises",
          "counts everything obsessively",
          "avoids deep water despite being on island",
          "keeps a journal with unreadable scrawl",
          "makes daily marks on a tree to track time",
          "refuses to eat certain foods that remind them of something",
          "mumbles in a language they don't remember",
          "obsessively maintains their appearance despite conditions",
          "saves every scrap of cloth or rope",
          "builds small cairns or markers everywhere"
        ],
        native: [
          "performs small rituals before eating",
          "speaks to ancestors when making decisions",
          "refuses to enter certain areas due to taboos",
          "reads omens in natural phenomena",
          "hums traditional songs while working",
          "touches specific trees for luck",
          "avoids stepping on certain plants",
          "makes offerings to spirits regularly",
          "tells stories using elaborate hand gestures",
          "interprets dreams as prophecies",
          "consults elders before any major decision",
          "wears traditional jewelry at all times",
          "performs cleansing rituals after conflict",
          "shares food with everyone before eating"
        ],
        mercenary: [
          "constantly scans surroundings for threats",
          "sleeps with weapon within reach",
          "uses military time exclusively",
          "maintains gear obsessively",
          "speaks in tactical jargon",
          "never sits with back to door",
          "takes measured bites and chews exactly same number",
          "checks magazine and clears weapon repeatedly",
          "maintains perfect posture at all times",
          "uses compass directions instead of left/right",
          "performs equipment check ritual before sleep",
          "refers to civilians with slight disdain",
          "keeps detailed operational notes",
          "practices tactical drills during downtime",
          "never discusses family or personal life"
        ]
      },
      // Fears by faction
      fears: {
        castaway: [
          "dying alone on the island",
          "never being rescued",
          "losing their remaining memories",
          "going completely insane",
          "being forgotten by the outside world",
          "the ocean and drowning",
          "starvation",
          "tropical storms",
          "isolation",
          "their past catching up to them"
        ],
        native: [
          "angering the island spirits",
          "breaking ancient taboos",
          "outsiders destroying sacred sites",
          "losing traditional ways",
          "being cursed by elders",
          "natural disasters as divine punishment",
          "failing their ancestors",
          "pollution or desecration of the island",
          "their children forgetting traditions",
          "prophecies of doom"
        ],
        mercenary: [
          "mission failure",
          "losing combat effectiveness",
          "betrayal by command",
          "being left behind",
          "losing control in combat",
          "not completing the contract",
          "appearing weak",
          "ambush or surprise attack",
          "their past operations being exposed",
          "dying for a corrupt cause"
        ]
      },
      // Desires/motivations by faction
      desires: {
        castaway: [
          "rescue and return to civilization",
          "recovering their lost memories",
          "finding meaning in their new life",
          "building something permanent",
          "connecting with other survivors",
          "proving they can survive anything",
          "understanding why they were spared",
          "finding love despite circumstances",
          "escaping the island",
          "accepting this as their new home"
        ],
        native: [
          "protecting sacred sites",
          "preserving traditional knowledge",
          "maintaining harmony with nature",
          "raising strong children",
          "earning elder status",
          "defending the island from outsiders",
          "finding a worthy partner",
          "mastering ancestral skills",
          "receiving visions from spirits",
          "keeping their family line strong"
        ],
        mercenary: [
          "completing the mission",
          "getting paid and getting out",
          "advancing in Blacksteel ranks",
          "proving combat superiority",
          "surviving until contract ends",
          "finding worthy opponents",
          "maintaining professional reputation",
          "uncovering what Blacksteel is really doing here",
          "earning enough to retire",
          "power and control"
        ]
      }
    };
  }
  /**
   * Normalize faction name to match database keys
   */
  normalizeFaction(faction) {
    const factionMap = {
      "castaway": "castaway",
      "natives_clan1": "native",
      "natives_clan2": "native",
      "mercenaries": "mercenary",
      "native": "native",
      "mercenary": "mercenary"
    };
    return factionMap[faction] || "castaway";
  }
  /**
   * Generate complete personality for NPC
   * @param {string} faction - NPC faction
   * @param {object} seededRandom - Seeded random generator
   * @returns {object} Complete personality data
   */
  generatePersonality(faction, seededRandom) {
    const data = this.data;
    const normalizedFaction = this.normalizeFaction(faction);
    const ranges = data.traitRanges[normalizedFaction];
    const traits = {
      openness: seededRandom.int(ranges.openness.min, ranges.openness.max),
      conscientiousness: seededRandom.int(ranges.conscientiousness.min, ranges.conscientiousness.max),
      extraversion: seededRandom.int(ranges.extraversion.min, ranges.extraversion.max),
      agreeableness: seededRandom.int(ranges.agreeableness.min, ranges.agreeableness.max),
      neuroticism: seededRandom.int(ranges.neuroticism.min, ranges.neuroticism.max)
    };
    const orientation = this.weightedChoice(data.sexualOrientations, seededRandom);
    const dominance = seededRandom.choice(data.sexualPreferences.dominance);
    const intensity = seededRandom.choice(data.sexualPreferences.intensity);
    const interestCount = seededRandom.int(2, 5);
    const interests = [];
    const availableInterests = [...data.sexualPreferences.interests];
    for (let i = 0; i < interestCount && availableInterests.length > 0; i++) {
      const index = seededRandom.int(0, availableInterests.length - 1);
      interests.push(availableInterests[index]);
      availableInterests.splice(index, 1);
    }
    const quirkCount = seededRandom.int(2, 4);
    const quirks = [];
    const availableQuirks = [...data.quirks[normalizedFaction]];
    for (let i = 0; i < quirkCount && availableQuirks.length > 0; i++) {
      const index = seededRandom.int(0, availableQuirks.length - 1);
      quirks.push(availableQuirks[index]);
      availableQuirks.splice(index, 1);
    }
    const fearCount = seededRandom.int(2, 4);
    const fears = [];
    const availableFears = [...data.fears[normalizedFaction]];
    for (let i = 0; i < fearCount && availableFears.length > 0; i++) {
      const index = seededRandom.int(0, availableFears.length - 1);
      fears.push(availableFears[index]);
      availableFears.splice(index, 1);
    }
    const desireCount = seededRandom.int(2, 4);
    const desires = [];
    const availableDesires = [...data.desires[normalizedFaction]];
    for (let i = 0; i < desireCount && availableDesires.length > 0; i++) {
      const index = seededRandom.int(0, availableDesires.length - 1);
      desires.push(availableDesires[index]);
      availableDesires.splice(index, 1);
    }
    return {
      traits,
      sexuality: {
        orientation,
        dominance,
        intensity,
        interests
      },
      quirks,
      fears,
      desires
    };
  }
  /**
   * Weighted random selection
   * @param {Array} options - Array of {value, weight}
   * @param {object} seededRandom - Seeded random generator
   * @returns {string} Selected value
   */
  weightedChoice(options, seededRandom) {
    const totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);
    let random = seededRandom.next() * totalWeight;
    for (const option of options) {
      random -= option.weight;
      if (random <= 0) {
        return option.orientation || option.value || option;
      }
    }
    return options[0].orientation || options[0].value || options[0];
  }
}
class BackgroundDatabase {
  constructor() {
    this.data = this.getBackgroundData();
  }
  getBackgroundData() {
    return {
      // CASTAWAY - No memory of past, only island identity
      castaway: {
        // Mysterious skills they possess but can't explain
        mysteriousSkills: [
          "knows advanced first aid but doesn't remember training",
          "can tie complex knots without thinking",
          "speaks fragments of multiple languages",
          "instinctively knows hand-to-hand combat",
          "has deep knowledge of sailing",
          "understands engineering principles",
          "recognizes classical music",
          "knows gourmet cooking techniques",
          "can perform emergency surgery",
          "understands military tactics",
          "knows advanced mathematics",
          "can identify expensive wines",
          "has ballroom dancing muscle memory",
          "recognizes art and literature references"
        ],
        // Dream fragments and vague impressions
        dreamMotifs: [
          "recurring dream of a burning ship",
          "visions of a woman's face they can't place",
          "nightmares of being chased",
          "dreams of a grand estate",
          "memories of cold northern weather",
          "flashes of a wedding ceremony",
          "visions of violence and blood",
          "dreams of a crying child",
          "recurring image of a specific city skyline",
          "nightmare of drowning repeatedly",
          "vague memory of uniform and medals",
          "dream of running from authorities",
          "vision of a courtroom",
          "memory of a luxurious lifestyle"
        ],
        // Who they've become on the island
        islandIdentities: [
          "a resourceful scavenger who knows every inch of the beach",
          "a paranoid loner who trusts no one",
          "a natural leader trying to organize other survivors",
          "a broken shell of a person barely hanging on",
          "a philosophical thinker who found peace in isolation",
          "a desperate survivor willing to do anything",
          "a helpful person who finds purpose in aiding others",
          "an obsessive builder constructing elaborate shelters",
          "a wanderer who can't stay in one place",
          "a mystic who believes the island chose them",
          "a pragmatic survivor focused on basics",
          "a social butterfly desperate for human connection"
        ]
      },
      // NATIVE - Full tribal history and cultural background
      native: {
        // Tribal affiliations
        tribes: [
          "the Kaimana tribe of the eastern shores",
          "the Moana people of the volcanic highlands",
          "the Alani clan of the northern reefs",
          "the Kahale tribe of the sacred valleys",
          "the Nalu people of the western beaches",
          "the Lani clan of the mountain villages",
          "the Kai tribe of the fishing grounds",
          "the Hoku people of the stargazer peaks"
        ],
        // Family lineages and status
        lineages: [
          "descended from a long line of chiefs",
          "child of renowned warriors",
          "from a family of spiritual healers",
          "offspring of master craftsmen",
          "heir to a fishing dynasty",
          "from a farming family of modest means",
          "child of a disgraced former leader",
          "orphan raised by the tribe collectively",
          "from a family of navigators and explorers",
          "descended from the island's first inhabitants"
        ],
        // Cultural roles in society
        culturalRoles: [
          "apprentice shaman learning sacred rites",
          "warrior sworn to protect the tribe",
          "master fisherman providing for community",
          "storyteller preserving oral history",
          "craftsperson creating traditional items",
          "farmer tending ancestral lands",
          "navigator reading stars and currents",
          "healer using ancient medicine",
          "scout monitoring the island's borders",
          "elder advisor to the chief",
          "dancer performing ceremonial rituals",
          "hunter tracking in the jungle"
        ],
        // Sacred knowledge they possess
        sacredKnowledge: [
          "knows the location of hidden sacred sites",
          "can interpret the will of ancestors",
          "understands the island's spiritual geography",
          "keeper of forbidden prophecies",
          "knows ancient taboos and their consequences",
          "can communicate with island spirits",
          "understands the sacred calendar",
          "knows ritual phrases in the old tongue",
          "can read omens in natural phenomena",
          "keeper of tribal genealogies"
        ]
      },
      // MERCENARY - Blacksteel Solutions military background
      mercenary: {
        // Ranks within Blacksteel
        ranks: [
          "Operator (entry level)",
          "Senior Operator",
          "Team Leader",
          "Squad Commander",
          "Tactical Specialist",
          "Field Supervisor",
          "Operations Officer",
          "Security Consultant (veteran)"
        ],
        // Military specializations
        specializations: [
          "Close Quarters Combat specialist",
          "Sniper and designated marksman",
          "Explosives and demolitions expert",
          "Communications and signals intelligence",
          "Medic and field trauma specialist",
          "Heavy weapons operator",
          "Reconnaissance and surveillance",
          "Vehicle and maritime operations",
          "Intelligence gathering and analysis",
          "Executive protection detail",
          "Unconventional warfare specialist",
          "Cyber warfare and electronic countermeasures"
        ],
        // Previous military/PMC experience
        previousExperience: [
          "former special forces operator",
          "ex-military police investigator",
          "former infantry soldier",
          "ex-navy SEAL",
          "former marine raider",
          "ex-army ranger",
          "former intelligence operative",
          "ex-military pilot",
          "former combat medic",
          "ex-military contractor from another PMC",
          "former guerrilla fighter",
          "ex-law enforcement SWAT"
        ],
        // Blacksteel mission types
        missionTypes: [
          "security detail for unknown VIP",
          "resource extraction protection",
          "area denial and territorial control",
          "search and acquisition of unknown asset",
          "intelligence gathering on island inhabitants",
          "establishing forward operating base",
          "neutralizing potential threats",
          "securing strategic locations",
          "monitoring and reporting island activities",
          "special operations with classified objectives"
        ],
        // Employers/contractors (who hired Blacksteel)
        employers: [
          "classified government contract",
          "multinational mining corporation",
          "pharmaceutical research company",
          "private billionaire collector",
          "biotech conglomerate",
          "archaeological expedition financier",
          "real estate development firm",
          "intelligence agency front company",
          "military weapons contractor",
          "unknown benefactor (need-to-know basis)"
        ]
      }
    };
  }
  /**
   * Normalize faction name to match database keys
   */
  normalizeFaction(faction) {
    const factionMap = {
      "castaway": "castaway",
      "natives_clan1": "native",
      "natives_clan2": "native",
      "mercenaries": "mercenary",
      "native": "native",
      "mercenary": "mercenary"
    };
    return factionMap[faction] || "castaway";
  }
  /**
   * Generate background foundation for NPC
   * (AI will flesh out full backstory using these elements)
   * @param {string} faction - NPC faction
   * @param {string} role - NPC role
   * @param {object} seededRandom - Seeded random generator
   * @returns {object} Background foundation data
   */
  generateBackground(faction, role, seededRandom) {
    const normalizedFaction = this.normalizeFaction(faction);
    const data = this.data[normalizedFaction];
    if (normalizedFaction === "castaway") {
      return {
        faction: "castaway",
        mysteriousSkill: seededRandom.choice(data.mysteriousSkills),
        dreamMotif: seededRandom.choice(data.dreamMotifs),
        islandIdentity: seededRandom.choice(data.islandIdentities),
        // No birthplace, occupation, or education - they don't remember
        birthplace: "unknown (amnesia)",
        occupation: "unknown (amnesia)",
        education: "unknown (amnesia)",
        familyStatus: "unknown (amnesia)"
      };
    }
    if (normalizedFaction === "native") {
      return {
        faction: "native",
        tribe: seededRandom.choice(data.tribes),
        lineage: seededRandom.choice(data.lineages),
        culturalRole: seededRandom.choice(data.culturalRoles),
        sacredKnowledge: seededRandom.choice(data.sacredKnowledge),
        birthplace: seededRandom.choice(data.tribes),
        // Born in their tribe's territory
        occupation: seededRandom.choice(data.culturalRoles),
        education: "traditional tribal knowledge",
        familyStatus: seededRandom.choice(data.lineages)
      };
    }
    if (normalizedFaction === "mercenary") {
      return {
        faction: "mercenary",
        employer: "Blacksteel Solutions",
        rank: seededRandom.choice(data.ranks),
        specialization: seededRandom.choice(data.specializations),
        previousExperience: seededRandom.choice(data.previousExperience),
        missionType: seededRandom.choice(data.missionTypes),
        contractor: seededRandom.choice(data.employers),
        birthplace: "various (multinational)",
        occupation: seededRandom.choice(data.ranks),
        education: "military training and combat experience",
        familyStatus: "typically estranged or secretive"
      };
    }
    return {};
  }
  /**
   * Get backstory prompt context for AI generation
   * @param {object} npc - NPC with generated foundation
   * @returns {string} Context string for AI prompt
   */
  getBackstoryContext(npc) {
    const bg = npc.background;
    if (bg.faction === "castaway") {
      return `CASTAWAY BACKSTORY CONTEXT:
- Has complete amnesia, no memory of life before the island
- Mysterious skill: ${bg.mysteriousSkill}
- Recurring dream: ${bg.dreamMotif}
- Island identity: ${bg.islandIdentity}
- Current role: ${npc.identity.role}

Generate a 2-3 sentence backstory about their NEW IDENTITY formed on the island.
DO NOT explain their past - they don't remember it.
Focus on: who they've become, how they cope, what drives them now.`;
    }
    if (bg.faction === "native") {
      return `NATIVE BACKSTORY CONTEXT:
- Tribe: ${bg.tribe}
- Family lineage: ${bg.lineage}
- Cultural role: ${bg.culturalRole}
- Sacred knowledge: ${bg.sacredKnowledge}
- Current role: ${npc.identity.role}

Generate a 2-3 sentence backstory about their tribal history and place in island society.
Include: family connections, cultural significance, why they're at their current location.`;
    }
    if (bg.faction === "mercenary") {
      return `MERCENARY BACKSTORY CONTEXT:
- Employer: Blacksteel Solutions (PMC)
- Rank: ${bg.rank}
- Specialization: ${bg.specialization}
- Previous experience: ${bg.previousExperience}
- Current mission: ${bg.missionType}
- Contracted by: ${bg.contractor}
- Current role: ${npc.identity.role}

Generate a 2-3 sentence backstory about their military background and current mission.
Include: why they joined Blacksteel, notable past operations, what they're doing on the island.`;
    }
    return "";
  }
}
class SeededRandom {
  constructor(seed = Date.now()) {
    if (typeof seed === "string") {
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        hash = (hash << 5) - hash + seed.charCodeAt(i);
        hash = hash & hash;
      }
      seed = Math.abs(hash);
      console.log(`üå± SeededRandom constructor: converted string to numeric seed=${seed}`);
    } else {
      console.log(`üå± SeededRandom constructor: seed=${seed}, type=${typeof seed}`);
    }
    this.seed = seed;
    this.state = seed;
    console.log(`üå± SeededRandom state initialized: ${this.state}`);
  }
  // Mulberry32 - fast, high quality PRNG
  next() {
    const oldState = this.state;
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    const result = ((t ^ t >>> 14) >>> 0) / 4294967296;
    console.log(`üé≤ next() called: oldState=${oldState}, newState=${this.state}, t=${t}, result=${result}`);
    return result;
  }
  // Random float between min and max
  range(min, max) {
    return min + this.next() * (max - min);
  }
  // Random integer between min (inclusive) and max (inclusive)
  int(min, max) {
    const nextVal = this.next();
    const range = max - min + 1;
    const result = Math.floor(min + nextVal * range);
    console.log(`üé≤ int(${min}, ${max}): next()=${nextVal.toFixed(6)}, range=${range}, result=${result}`);
    return result;
  }
  // Random boolean
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  // Random element from array
  choice(array) {
    return array[this.int(0, array.length - 1)];
  }
  // Shuffle array in place
  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = this.int(0, i);
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  // Reset to initial seed
  reset() {
    this.state = this.seed;
  }
  // Set new seed
  setSeed(seed) {
    this.seed = seed;
    this.state = seed;
  }
}
function buildDialoguePrompt(npc, playerMessage, context = "", conversationHistory = []) {
  const personality = npc.getPersonalitySummary();
  const mood = npc.getMood();
  const relationship = npc.relationships.player;
  const phase = npc.memory.conversationPhase;
  const relevantMemories = npc.getRelevantMemories(playerMessage, 3);
  let relationshipTone = "neutral";
  if (relationship.opinion > 50) relationshipTone = "friendly";
  if (relationship.opinion > 75) relationshipTone = "warm";
  if (relationship.opinion < -50) relationshipTone = "hostile";
  if (relationship.romantic > 60) relationshipTone = "flirtatious";
  if (relationship.fear > 70) relationshipTone = "fearful";
  const contextSection = `You are roleplaying as ${npc.identity.name}, ${npc.identity.title}.

CHARACTER PROFILE:
- Age: ${npc.appearance.age}, Gender: ${npc.appearance.gender}
- Faction: ${npc.identity.faction}
- Role: ${npc.identity.role}
- Personality: ${personality}
- Current Mood: ${mood}
- Physical Description: ${npc.appearance.distinctiveFeatures?.join(", ") || "unremarkable"}

RELATIONSHIP WITH PLAYER:
- Opinion: ${relationship.opinion}/100 (${relationshipTone})
- Trust: ${relationship.trust}/100
- Respect: ${relationship.respect}/100
- Fear: ${relationship.fear}/100
- Romantic Interest: ${relationship.romantic}/100
- Interaction Count: ${relationship.interactionCount}
- Conversation Phase: ${phase}`;
  let memorySection = "";
  if (relevantMemories.length > 0) {
    memorySection = "\n\nRECENT RELEVANT MEMORIES:";
    relevantMemories.forEach((mem, i) => {
      memorySection += `
${i + 1}. ${mem.description} (importance: ${mem.importance})`;
    });
  }
  let historySection = "";
  if (conversationHistory.length > 0) {
    historySection = "\n\nRECENT CONVERSATION:";
    conversationHistory.forEach((entry) => {
      const speaker = entry.speaker === "player" ? "Player" : npc.identity.name;
      historySection += `
${speaker}: "${entry.message}"`;
    });
  }
  const situationSection = `

CURRENT SITUATION:
${context || "You are talking with the player."}

PLAYER JUST SAID:
"${playerMessage}"`;
  const instructions = `
RESPOND AS ${npc.identity.name.toUpperCase()}:
- Talk like a NORMAL PERSON, not a fortune cookie
- Use simple, direct language - NO poetic metaphors or dramatic flourishes
- NO clich√©s, NO cryptic wisdom, NO theatrical descriptions
- If they're practical, they give practical answers
- If they're friendly, they sound like a friend, not a philosopher
- Match your tone to the relationship status (${relationshipTone})
- Keep response natural and conversational (1-3 sentences)
- DO NOT use narration, actions in asterisks, or meta-commentary
- DO NOT refer to yourself in third person
- DO NOT repeat things you said in recent conversation
- Speak directly as the character`;
  const constraints = `
CRITICAL SPEECH RULES:
- Talk like you're having a real conversation, not writing a novel
- BANNED PHRASES: "heh", mystical nonsense, overly dramatic narration
- NO excessive punctuation (more than 3 dots in a row)
- NO references to tattoos, scars, or appearance unless directly asked
- NO unsolicited life lessons or philosophical musings
- Just answer the question like a human being would
- Response must be direct dialogue only (no "She said:" or *actions*)
- Length: 1-3 sentences maximum
- If hostile (opinion < -50), be curt and unfriendly
- If fearful (fear > 70), be nervous and defensive
- If romantic (romantic > 60), include subtle flirtation
- Return ONLY the spoken dialogue, nothing else

EXAMPLES OF GOOD vs BAD:
‚ùå BAD: "Heh. Navigation's the least of your worries here. That anchor tattoo's not decoration‚ÄîI earned it..."
‚úÖ GOOD: "I know the area. What do you need?"

‚ùå BAD: "This island eats the polite ones faster..."
‚úÖ GOOD: "You're welcome. Be careful out there."

‚ùå BAD: "Lost? Sun's directly overhead‚Äîhow'd you manage that?"
‚úÖ GOOD: "You're lost? How'd that happen?"`;
  return `${contextSection}${memorySection}${historySection}${situationSection}
${instructions}
${constraints}`;
}
function buildRumorPrompt(event, witness) {
  const personality = witness.getPersonalitySummary();
  const prompt = `${witness.identity.name} witnessed this event: "${event}"

Based on their personality (${personality}), how would they describe this event when gossiping to other NPCs?

Generate a short rumor (1 sentence) they might spread. Make it reflect their personality:
- High agreeableness: sympathetic, downplay negatives
- Low agreeableness: harsh, exaggerate negatives
- High neuroticism: anxious, catastrophize
- High extraversion: dramatic, embellished

Return only the rumor text, no formatting.`;
  return prompt;
}
class NPCManager {
  constructor(gameState2, perchanceAI) {
    this.gameState = gameState2;
    this.ai = perchanceAI || new PerchanceAI();
    this.nameDB = new NameDatabase();
    this.appearanceDB = new AppearanceDatabase();
    this.personalityDB = new PersonalityDatabase();
    this.backgroundDB = new BackgroundDatabase();
    this.seededRandom = new SeededRandom(Date.now());
    this.npcs = /* @__PURE__ */ new Map();
    this.npcsByTile = /* @__PURE__ */ new Map();
    this.npcsByFaction = /* @__PURE__ */ new Map();
    this.maxNPCs = 50;
    this.spawnChance = 0.1;
    this.activeConversation = null;
    this.backgroundGeneration = {
      enabled: false,
      paused: false,
      batchSize: 3,
      currentBatch: 0,
      totalGenerated: 0,
      queue: [],
      // NPCs waiting for AI enrichment
      processing: false
    };
    console.log("‚úÖ NPCManager initialized");
  }
  /**
   * Set the seeded random generator (called by gameState with world seed)
   */
  setSeed(seed) {
    this.seededRandom = new SeededRandom(seed);
  }
  /**
   * Generate a new NPC with complete deterministic foundation
   * @param {object} template - Basic template { faction, gender?, age?, role?, tile? }
   * @returns {NPC} Fully generated NPC instance (ready to play without AI)
   */
  generateNPC(template) {
    console.log("üé≤ [generateNPC 1/10] Starting with template:", template);
    const { faction, gender, age, role, tile } = template;
    const factionType = faction || "castaway";
    const npcGender = gender || (this.seededRandom.next() > 0.5 ? "female" : "male");
    console.log(`üé≤ [generateNPC 2/10] Faction: ${factionType}, Gender: ${npcGender}`);
    console.log("üé≤ [generateNPC 3/10] Generating name...");
    const nameData = this.nameDB.generateName(factionType, npcGender, this.seededRandom);
    console.log(`üé≤ [generateNPC 4/10] Name generated: ${nameData.fullName}`);
    console.log("üé≤ [generateNPC 5/10] Generating appearance...");
    const appearance = this.appearanceDB.generateAppearance(factionType, npcGender, this.seededRandom);
    console.log("üé≤ [generateNPC 6/10] Appearance generated");
    console.log("üé≤ [generateNPC 7/10] Generating personality...");
    const personality = this.personalityDB.generatePersonality(factionType, this.seededRandom);
    console.log("üé≤ [generateNPC 8/10] Personality generated");
    const npcRole = role || this.getDefaultRole(factionType);
    console.log(`üé≤ [generateNPC 9/10] Generating background (role: ${npcRole})...`);
    const background = this.backgroundDB.generateBackground(factionType, npcRole, this.seededRandom);
    console.log("üé≤ [generateNPC 9b/10] Background generated");
    console.log("üé≤ [generateNPC 9c/10] Creating NPC instance...");
    const npc = new NPC({
      id: nameData.fullName.replace(/\s+/g, "_").toLowerCase() + "_" + Date.now(),
      identity: {
        name: nameData.fullName,
        title: this.generateTitle(factionType, npcRole),
        faction: factionType,
        role: npcRole
      },
      appearance,
      personality: {
        traits: personality.traits,
        quirks: personality.quirks,
        sexuality: personality.sexuality
      },
      background,
      desires: personality.desires,
      fears: personality.fears,
      location: {
        currentTile: tile || { q: 0, r: 0 },
        homeLocation: tile || { q: 0, r: 0 }
      }
    });
    console.log("üé≤ [generateNPC 9d/10] NPC instance created");
    npc.meta.generatedByAI = false;
    console.log(`üé≤ [generateNPC 10/10] ‚úÖ Generated ${npc.identity.name} (${npc.identity.faction} ${npc.identity.role})`);
    return npc;
  }
  /**
   * Generate a title based on faction and role
   */
  generateTitle(faction, role) {
    const titles = {
      castaway: ["Survivor", "Castaway", "Shipwreck Victim", "Stranded Sailor", "Lost Traveler"],
      native: ["Islander", "Local", "Native", "Village Elder", "Tribe Member"],
      mercenary: ["Blacksteel Operator", "Blacksteel Soldier", "PMC Contractor", "Blacksteel Enforcer", "Security Specialist"]
    };
    const factionTitles = titles[faction] || titles.castaway;
    return this.seededRandom.choice(factionTitles);
  }
  /**
   * Get default role for faction
   * @param {string} faction - Faction name
   * @returns {string} Role
   */
  getDefaultRole(faction) {
    const roles = {
      castaway: ["survivor", "scavenger", "wanderer", "refugee"],
      islander: ["hunter", "gatherer", "elder", "warrior", "shaman"],
      mercenary: ["soldier", "scout", "captain", "enforcer"],
      tourist: ["vacationer", "backpacker", "photographer", "writer"]
    };
    const options = roles[faction] || ["wanderer"];
    return this.seededRandom.choice(options);
  }
  /**
   * Enrich NPC with AI-generated creative content (OPTIONAL)
   * Only generates: backstory, additional quirks, secrets
   * Appearance and personality are already deterministically generated
   * @param {NPC} npc - NPC to enrich
   * @returns {Promise<NPC>} Enriched NPC
   */
  async enrichWithAI(npc) {
    try {
      console.log(`ü§ñ Enriching ${npc.identity.name} with AI backstory...`);
      const backstoryContext = this.backgroundDB.getBackstoryContext(npc);
      const prompt = `${backstoryContext}

Additionally generate:
1. ADDITIONAL QUIRKS (1-2 unique behavioral traits)
2. SECRETS (1-2 hidden elements that create drama/story potential)

Return ONLY valid JSON:
{
  "backstory": "2-3 sentence backstory",
  "additionalQuirks": ["quirk1", "quirk2"],
  "secrets": ["secret1", "secret2"]
}`;
      const response = await this.ai.generateText(prompt, {
        temperature: 0.8,
        max_tokens: 500
        // Much smaller - only 3 fields
      });
      const text = this.ai.extractText(response);
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.warn("‚ö†Ô∏è Failed to parse AI response for NPC enrichment");
        npc.meta.generatedByAI = false;
        return npc;
      }
      const aiData = JSON.parse(jsonMatch[0]);
      if (aiData.backstory) {
        npc.background.backstory = aiData.backstory;
      }
      if (aiData.additionalQuirks && Array.isArray(aiData.additionalQuirks)) {
        npc.personality.quirks = [...npc.personality.quirks, ...aiData.additionalQuirks];
      }
      if (aiData.secrets && Array.isArray(aiData.secrets)) {
        npc.background.secrets = aiData.secrets;
      }
      npc.meta.generatedByAI = true;
      console.log(`‚úÖ ${npc.identity.name} enriched with AI backstory`);
      return npc;
    } catch (error) {
      console.error(`‚ùå Failed to enrich ${npc.identity.name}:`, error);
      npc.meta.generatedByAI = false;
      return npc;
    }
  }
  /**
   * Spawn NPC and add to world
   * @param {object} template - NPC template
   * @param {boolean} enrichWithAI - Whether to enrich with AI
   * @returns {Promise<NPC>} Spawned NPC
   */
  async spawnNPC(template, enrichWithAI = true) {
    console.log("üîß [spawnNPC 1/8] Called with template:", template);
    if (this.npcs.size >= this.maxNPCs) {
      console.warn("‚ö†Ô∏è Max NPCs reached, cannot spawn more");
      return null;
    }
    console.log(`üîß [spawnNPC 2/8] NPC cap check passed (${this.npcs.size}/${this.maxNPCs})`);
    console.log("üîß [spawnNPC 3/8] Calling generateNPC...");
    const npc = this.generateNPC(template);
    console.log("üîß [spawnNPC 4/8] generateNPC returned:", npc?.identity?.name || "UNDEFINED");
    if (enrichWithAI) {
      console.log("üîß [spawnNPC 5/8] Enriching with AI (awaiting)...");
      await this.enrichWithAI(npc);
      console.log("üîß [spawnNPC 5b/8] AI enrichment complete");
    } else {
      console.log("üîß [spawnNPC 5/8] Skipping AI enrichment (enrichWithAI=false)");
    }
    console.log("üîß [spawnNPC 6/8] Adding to storage...");
    this.npcs.set(npc.identity.id, npc);
    const tileKey = `${npc.location.currentTile.q},${npc.location.currentTile.r}`;
    if (!this.npcsByTile.has(tileKey)) {
      this.npcsByTile.set(tileKey, /* @__PURE__ */ new Set());
    }
    this.npcsByTile.get(tileKey).add(npc.identity.id);
    console.log("üîß [spawnNPC 7/8] Added to tile index");
    if (!this.npcsByFaction.has(npc.identity.faction)) {
      this.npcsByFaction.set(npc.identity.faction, /* @__PURE__ */ new Set());
    }
    this.npcsByFaction.get(npc.identity.faction).add(npc.identity.id);
    console.log("üîß [spawnNPC 8/8] Added to faction index");
    console.log(`‚úÖ Spawned ${npc.identity.name} (${npc.identity.faction}) at ${tileKey}`);
    return npc;
  }
  /**
   * Remove NPC from world
   * @param {string} npcId - NPC ID
   */
  despawnNPC(npcId) {
    const npc = this.npcs.get(npcId);
    if (!npc) return;
    const tileKey = `${npc.location.currentTile.q},${npc.location.currentTile.r}`;
    this.npcsByTile.get(tileKey)?.delete(npcId);
    this.npcsByFaction.get(npc.identity.faction)?.delete(npcId);
    this.npcs.delete(npcId);
    console.log(`üóëÔ∏è Despawned ${npc.identity.name}`);
  }
  /**
   * Get NPCs at specific tile
   * @param {object} tile - {q, r}
   * @returns {Array<NPC>} NPCs at tile
   */
  getNPCsAtTile(tile) {
    const tileKey = `${tile.q},${tile.r}`;
    const npcIds = this.npcsByTile.get(tileKey);
    if (!npcIds) return [];
    return Array.from(npcIds).map((id) => this.npcs.get(id)).filter((npc) => npc);
  }
  /**
   * Get NPCs by faction
   * @param {string} faction - Faction name
   * @returns {Array<NPC>} NPCs in faction
   */
  getNPCsByFaction(faction) {
    const npcIds = this.npcsByFaction.get(faction);
    if (!npcIds) return [];
    return Array.from(npcIds).map((id) => this.npcs.get(id)).filter((npc) => npc);
  }
  /**
   * Initiate dialogue with NPC
   * @param {string} npcId - NPC ID
   * @param {string} playerMessage - What player said
   * @param {string} context - Situational context
   * @returns {Promise<string>} NPC response
   */
  async initiateDialogue(npcId, playerMessage, context = "") {
    const npc = this.npcs.get(npcId);
    if (!npc) {
      console.error("NPC not found:", npcId);
      return "The person has left.";
    }
    if (!this.activeConversation || this.activeConversation.npcId !== npcId) {
      this.activeConversation = {
        npcId,
        history: []
      };
      this.pauseBackgroundGeneration();
    }
    const prompt = buildDialoguePrompt(
      npc,
      playerMessage,
      context,
      this.activeConversation.history.slice(-5)
      // Last 5 messages
    );
    let response = "";
    let attempts = 0;
    const maxAttempts = 3;
    const recentResponses = this.activeConversation.history.filter((h) => h.speaker === "npc").slice(-3).map((h) => h.message);
    while (attempts < maxAttempts) {
      const temperature = this.ai.getRegenerationTemperature(attempts);
      const rawResponse = await this.ai.generateText(prompt, {
        temperature,
        max_tokens: 150
      });
      response = this.ai.sanitizeNpcResponse(rawResponse, npc);
      const isRepetitive = this.ai.analyzeResponseForRepetition(response, recentResponses);
      if (!isRepetitive || attempts === maxAttempts - 1) {
        break;
      }
      const variation = this.ai.getVariationStrategy(npc, context);
      prompt += `

NOTE: Your previous response was too similar to recent messages. ${variation}.`;
      attempts++;
    }
    this.activeConversation.history.push(
      { speaker: "player", message: playerMessage, timestamp: Date.now() },
      { speaker: "npc", message: response, npcName: npc.identity.name, timestamp: Date.now() }
    );
    npc.remember(`Talked with player: Player said "${playerMessage}"`, 5);
    npc.relationships.player.lastInteraction = Date.now();
    npc.relationships.player.interactionCount++;
    npc.updateConversationPhase();
    npc.memory.conversationHistory.push(
      { speaker: "player", message: playerMessage, timestamp: Date.now() }
    );
    npc.memory.conversationHistory.push(
      { speaker: "npc", message: response, timestamp: Date.now() }
    );
    if (npc.memory.conversationHistory.length > 50) {
      npc.memory.conversationHistory = npc.memory.conversationHistory.slice(-50);
    }
    return response;
  }
  /**
   * End current conversation
   */
  endConversation() {
    this.activeConversation = null;
    this.resumeBackgroundGeneration();
  }
  /**
   * Start background NPC generation
   * Generates NPCs in batches during idle time
   */
  startBackgroundGeneration() {
    console.log("üîÑ Starting background NPC generation...");
    this.backgroundGeneration.enabled = true;
    this.backgroundGeneration.paused = false;
    this.processNextBatch();
  }
  /**
   * Stop background NPC generation
   */
  stopBackgroundGeneration() {
    console.log("‚è∏Ô∏è Stopping background NPC generation");
    this.backgroundGeneration.enabled = false;
  }
  /**
   * Pause background generation (e.g., during conversation)
   */
  pauseBackgroundGeneration() {
    if (this.backgroundGeneration.enabled && !this.backgroundGeneration.paused) {
      console.log("‚è∏Ô∏è Pausing background NPC generation (conversation started)");
      this.backgroundGeneration.paused = true;
    }
  }
  /**
   * Resume background generation (e.g., after conversation)
   */
  resumeBackgroundGeneration() {
    if (this.backgroundGeneration.enabled && this.backgroundGeneration.paused) {
      console.log("‚ñ∂Ô∏è Resuming background NPC generation (conversation ended)");
      this.backgroundGeneration.paused = false;
      if (this.backgroundGeneration.queue.length > 0 && !this.backgroundGeneration.processing) {
        this.processNextBatch();
      }
    }
  }
  /**
   * Process next batch of background NPC generation
   * This is now fully sequential: generate batch -> enrich ALL with AI -> next batch
   */
  async processNextBatch() {
    if (!this.backgroundGeneration.enabled || this.backgroundGeneration.paused) {
      return;
    }
    if (this.backgroundGeneration.processing) {
      return;
    }
    if (this.npcs.size >= this.maxNPCs) {
      console.log("üõë NPC cap reached, stopping background generation");
      this.stopBackgroundGeneration();
      return;
    }
    this.backgroundGeneration.processing = true;
    this.backgroundGeneration.currentBatch++;
    const batchNum = this.backgroundGeneration.currentBatch;
    const batchSize = Math.min(
      this.backgroundGeneration.batchSize,
      this.maxNPCs - this.npcs.size
    );
    console.log(`üîÑ [Batch ${batchNum}] Generating ${batchSize} NPCs in background...`);
    try {
      const generatedNPCs = [];
      for (let i = 0; i < batchSize; i++) {
        if (!this.backgroundGeneration.enabled || this.backgroundGeneration.paused) {
          console.log(`‚è∏Ô∏è [Batch ${batchNum}] Generation paused at NPC ${i + 1}/${batchSize}`);
          break;
        }
        const faction = this.selectRandomFaction();
        const gender = this.seededRandom.next() > 0.5 ? "female" : "male";
        const npc = this.generateNPC({ faction, gender });
        console.log(`üîÑ [Batch ${batchNum}] Generated ${i + 1}/${batchSize}: ${npc.identity.name} (${faction})`);
        generatedNPCs.push(npc);
        this.backgroundGeneration.totalGenerated++;
      }
      if (generatedNPCs.length > 0) {
        console.log(`‚úÖ [Batch ${batchNum}] Generated ${generatedNPCs.length} NPCs (Total: ${this.backgroundGeneration.totalGenerated})`);
        console.log(`ü§ñ [Batch ${batchNum}] Starting AI enrichment for ${generatedNPCs.length} NPCs...`);
        await this.enrichBatchWithAI(generatedNPCs, batchNum);
        console.log(`‚úÖ [Batch ${batchNum}] All NPCs enriched and ready!`);
      }
    } catch (error) {
      console.error(`‚ùå [Batch ${batchNum}] Error during background generation:`, error);
    } finally {
      this.backgroundGeneration.processing = false;
      if (this.backgroundGeneration.enabled && !this.backgroundGeneration.paused && this.npcs.size < this.maxNPCs) {
        console.log(`‚è±Ô∏è [Batch ${batchNum}] Waiting before next batch...`);
        setTimeout(() => this.processNextBatch(), 2e3);
      }
    }
  }
  /**
   * Enrich an entire batch of NPCs with AI backstories
   * Processes sequentially to respect rate limits
   */
  async enrichBatchWithAI(npcs, batchNum) {
    for (let i = 0; i < npcs.length; i++) {
      if (this.backgroundGeneration.paused) {
        console.log(`‚è∏Ô∏è [Batch ${batchNum}] AI enrichment paused (conversation active)`);
        this.backgroundGeneration.queue.push(...npcs.slice(i));
        return;
      }
      const npc = npcs[i];
      try {
        console.log(`ü§ñ [Batch ${batchNum}] Enriching ${npc.identity.name} (${i + 1}/${npcs.length})...`);
        await this.enrichWithAI(npc);
        console.log(`‚ú® [Batch ${batchNum}] ${npc.identity.name} enriched successfully`);
        if (i < npcs.length - 1) {
          await new Promise((resolve) => setTimeout(resolve, 2e3));
        }
      } catch (error) {
        console.error(`‚ùå [Batch ${batchNum}] Failed to enrich ${npc.identity.name}:`, error);
      }
    }
  }
  /**
   * Resume enriching any NPCs left in the queue (after pause)
   */
  async enrichQueuedNPCs() {
    if (this.backgroundGeneration.queue.length === 0) {
      return;
    }
    console.log(`üîÑ Resuming AI enrichment for ${this.backgroundGeneration.queue.length} queued NPCs...`);
    while (this.backgroundGeneration.queue.length > 0 && this.backgroundGeneration.enabled) {
      if (this.backgroundGeneration.paused) {
        console.log("‚è∏Ô∏è Pausing AI enrichment (conversation active)");
        return;
      }
      const npc = this.backgroundGeneration.queue.shift();
      try {
        console.log(`ü§ñ Enriching ${npc.identity.name} with AI backstory...`);
        await this.enrichWithAI(npc);
        console.log(`‚ú® ${npc.identity.name} enriched successfully`);
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      } catch (error) {
        console.error(`‚ùå Failed to enrich ${npc.identity.name}:`, error);
      }
    }
    console.log("‚úÖ All queued NPCs enriched");
  }
  /**
   * Select a random faction weighted by territory count
   */
  selectRandomFaction() {
    const factionWeights = {
      "castaway": 1,
      "natives_clan1": 3,
      "natives_clan2": 3,
      "mercenaries": 2
    };
    const totalWeight = Object.values(factionWeights).reduce((sum, w) => sum + w, 0);
    let random = this.seededRandom.next() * totalWeight;
    for (const [faction, weight] of Object.entries(factionWeights)) {
      random -= weight;
      if (random <= 0) {
        return faction;
      }
    }
    return "castaway";
  }
  /**
   * Update NPC schedules and positions based on time
   * @param {number} gameTime - Current game time in minutes
   */
  updateNPCSchedules(gameTime) {
  }
  /**
   * Spread rumor among NPCs
   * @param {string} event - Event description
   * @param {string} witnessId - NPC who witnessed
   * @param {number} spreadRange - Tiles from witness
   */
  async spreadRumor(event, witnessId, spreadRange = 3) {
    const witness = this.npcs.get(witnessId);
    if (!witness) return;
    const rumor = await this.ai.generateText(buildRumorPrompt(event, witness), {
      temperature: 0.7,
      max_tokens: 50
    });
    const rumorText = this.ai.extractText(rumor);
    const witnessTile = witness.location.currentTile;
    const nearbyNPCs = Array.from(this.npcs.values()).filter((npc) => {
      if (npc.identity.id === witnessId) return false;
      const distance = Math.abs(npc.location.currentTile.q - witnessTile.q) + Math.abs(npc.location.currentTile.r - witnessTile.r);
      return distance <= spreadRange;
    });
    nearbyNPCs.forEach((npc) => {
      npc.remember(`Heard rumor: ${rumorText}`, 3);
      if (event.includes("kill") || event.includes("attack")) {
        npc.adjustRelationship("opinion", -10);
        npc.adjustRelationship("fear", 5);
      }
    });
    console.log(`üì¢ Rumor spread: "${rumorText}" (${nearbyNPCs.length} NPCs heard)`);
  }
  /**
   * Save all NPCs to JSON
   * @returns {object} Serialized NPCs and name database
   */
  saveNPCs() {
    return {
      npcs: Array.from(this.npcs.values()).map((npc) => npc.toJSON()),
      usedNames: this.nameDB.getUsedNames()
    };
  }
  /**
   * Load NPCs from JSON
   * @param {object} data - Serialized NPCs and name database
   */
  loadNPCs(data) {
    this.npcs.clear();
    this.npcsByTile.clear();
    this.npcsByFaction.clear();
    if (data.usedNames) {
      this.nameDB.loadUsedNames(data.usedNames);
    }
    const npcArray = data.npcs || data;
    npcArray.forEach((npcData) => {
      const npc = NPC.fromJSON(npcData);
      this.npcs.set(npc.identity.id, npc);
      if (npc.identity.name && npc.identity.faction) {
        this.nameDB.markNameAsUsed(npc.identity.faction, npc.identity.name);
      }
      const tileKey = `${npc.location.currentTile.q},${npc.location.currentTile.r}`;
      if (!this.npcsByTile.has(tileKey)) {
        this.npcsByTile.set(tileKey, /* @__PURE__ */ new Set());
      }
      this.npcsByTile.get(tileKey).add(npc.identity.id);
      if (!this.npcsByFaction.has(npc.identity.faction)) {
        this.npcsByFaction.set(npc.identity.faction, /* @__PURE__ */ new Set());
      }
      this.npcsByFaction.get(npc.identity.faction).add(npc.identity.id);
    });
    console.log(`‚úÖ Loaded ${this.npcs.size} NPCs`);
  }
  /**
   * Get NPC by ID
   * @param {string} id - NPC ID
   * @returns {NPC|null} NPC or null
   */
  getNPC(id) {
    return this.npcs.get(id) || null;
  }
  /**
   * Get all NPCs
   * @returns {Array<NPC>} All NPCs
   */
  getAllNPCs() {
    return Array.from(this.npcs.values());
  }
}
class GameState {
  constructor() {
    this.version = "4.0.0";
    this.listeners = /* @__PURE__ */ new Map();
    this.player = null;
    this.resourceManager = null;
    this.npcManager = null;
    this.perchanceAI = null;
    this.uiManagers = {
      playerHUD: null,
      inventoryUI: null,
      gatheringUI: null,
      nodeInspector: null,
      dialogueUI: null
    };
    this.isPaused = false;
    this.timeSpeed = 1;
    this.currentTime = 0;
    this.state = {
      meta: {
        version: this.version,
        saveDate: null,
        saveName: "Autosave",
        playTime: 0,
        // Real-world seconds
        lastTick: Date.now()
      },
      island: {
        seed: null,
        mapRadius: 8,
        discoveredTiles: [],
        controlledZones: []
      },
      characters: [],
      // NPCs
      time: {
        day: 1,
        hour: 6,
        // 0-23 (starts at 6am)
        minute: 0,
        // 0-59
        season: "summer"
      },
      flags: {
        phase: 1,
        // 1-4 (story phases)
        tutorialComplete: false,
        firstCastawayFound: false,
        mercLeaderDefeated: false,
        islanderAlliance: null,
        // null, 'ally', 'enslaved'
        completedQuests: []
      },
      buildings: [],
      economy: {
        money: 0,
        income: 0,
        expenses: 0
      }
    };
    this.gameLoopInterval = null;
  }
  /**
   * Initialize game state (new game or load)
   */
  init(config = {}) {
    const {
      playerName = "Survivor",
      playerGender = "male",
      savedState = null,
      spawnPosition = { q: 0, r: 0 }
    } = config;
    if (savedState) {
      this.loadState(savedState);
    } else {
      this.state.island.seed = this.generateSeed();
      this.player = new Player({
        name: playerName,
        gender: playerGender,
        position: spawnPosition
      });
      this.resourceManager = new ResourceNodeManager();
      this.perchanceAI = new PerchanceAI();
      this.npcManager = new NPCManager(this, this.perchanceAI);
      this.npcManager.setSeed(this.state.island.seed);
      this.resourceManager.generateStarterNodes(spawnPosition, 3);
    }
    this.startGameLoop();
    this.emit("stateInitialized", {
      player: this.player,
      resourceManager: this.resourceManager,
      npcManager: this.npcManager,
      state: this.state
    });
  }
  /**
   * Register UI managers (called by UI initialization)
   */
  registerUI(name, uiInstance) {
    this.uiManagers[name] = uiInstance;
    console.log(`Registered UI: ${name}`);
  }
  /**
   * Get UI manager
   */
  getUI(name) {
    return this.uiManagers[name];
  }
  /**
   * Generate random seed for island generation
   */
  generateSeed() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  /**
   * Start game loop (real-time with speed controls)
   * Time advances continuously based on timeSpeed setting
   */
  startGameLoop() {
    this.gameLoopInterval = setInterval(() => {
      if (this.isPaused) return;
      const now = Date.now();
      const deltaTime = now - this.state.meta.lastTick;
      this.state.meta.lastTick = now;
      this.state.meta.playTime += deltaTime / 1e3;
      if (Math.floor(this.state.meta.playTime / 300) > Math.floor((this.state.meta.playTime - deltaTime / 1e3) / 300)) {
        this.autoSave();
      }
      this.emit("gameLoopTick", {
        deltaTime,
        playTime: this.state.meta.playTime,
        gameTime: this.currentTime,
        timeSpeed: this.timeSpeed
      });
    }, 100);
  }
  /**
   * Advance in-game time by a specified number of minutes
   * Updates day/hour/minute and all time-dependent systems
   */
  advanceTime(minutes) {
    const oldHour = this.state.time.hour;
    const oldDay = this.state.time.day;
    this.currentTime += minutes;
    const totalMinutes = this.currentTime;
    this.state.time.day = Math.floor(totalMinutes / 1440) + 1;
    this.state.time.hour = Math.floor(totalMinutes % 1440 / 60);
    this.state.time.minute = Math.floor(totalMinutes % 60);
    if (this.player) {
      this.player.updateStatsForTime(minutes);
    }
    if (this.resourceManager) {
      this.resourceManager.update(minutes * 60 * 1e3);
    }
    const newHour = this.state.time.hour;
    if (oldHour !== newHour) {
      this.handleHourChange(oldHour, newHour);
    }
    if (oldDay !== this.state.time.day) {
      this.handleDayChange();
    }
    this.emit("timeAdvanced", {
      minutes,
      currentTime: this.currentTime,
      day: this.state.time.day,
      hour: this.state.time.hour,
      minute: this.state.time.minute
    });
  }
  /**
   * Handle hour changes (for time-of-day effects)
   */
  handleHourChange(oldHour, newHour) {
    const timeOfDay = this.getTimeOfDay();
    this.emit("hourChanged", {
      oldHour,
      newHour,
      timeOfDay
    });
  }
  /**
   * Handle day changes
   */
  handleDayChange() {
    if (this.resourceManager) ;
    this.emit("newDay", {
      day: this.state.time.day
    });
    console.log(`üåÖ Day ${this.state.time.day} begins`);
  }
  /**
   * Get time of day category
   */
  getTimeOfDay() {
    const hour = this.state.time.hour;
    if (hour >= 6 && hour < 12) return "morning";
    if (hour >= 12 && hour < 18) return "afternoon";
    if (hour >= 18 && hour < 21) return "evening";
    return "night";
  }
  /**
   * Pause/resume game
   */
  pause() {
    this.isPaused = true;
    this.emit("gamePaused");
  }
  resume() {
    this.isPaused = false;
    this.state.meta.lastTick = Date.now();
    this.emit("gameResumed");
  }
  togglePause() {
    if (this.isPaused) {
      this.resume();
    } else {
      this.pause();
    }
  }
  /**
   * Set time speed (1, 10, 20, 100)
   */
  setTimeSpeed(speed) {
    const validSpeeds = [1, 10, 20, 100];
    if (!validSpeeds.includes(speed)) {
      console.warn("Invalid time speed:", speed, "Valid speeds:", validSpeeds);
      return;
    }
    this.timeSpeed = speed;
    this.emit("timeSpeedChanged", { speed });
    console.log(`‚è© Time speed set to ${speed}x`);
  }
  /**
   * Get current day number
   */
  getCurrentDay() {
    return this.state.time.day;
  }
  /**
   * Get formatted time string
   */
  getTimeString() {
    const hour = this.state.time.hour;
    const minute = this.state.time.minute;
    const ampm = hour >= 12 ? "PM" : "AM";
    const displayHour = hour % 12 || 12;
    return `Day ${this.state.time.day}, ${displayHour}:${minute.toString().padStart(2, "0")} ${ampm}`;
  }
  /**
   * Player actions - Consume item
   * Consuming an item is instant (no time passes)
   */
  consumeItem(itemId) {
    if (!this.player) return false;
    const item = itemDB.get(itemId);
    if (!item || !item.consumable) {
      console.warn("Item cannot be consumed:", itemId);
      return false;
    }
    const hasItem = this.player.inventory.hasItem(itemId);
    if (!hasItem) {
      console.warn("Player does not have item:", itemId);
      return false;
    }
    const success = this.player.consumeItem(item);
    if (success) {
      this.player.inventory.removeItem(itemId, 1);
      this.emit("itemConsumed", { itemId, item, effects: item.effects });
      return true;
    }
    return false;
  }
  /**
   * Player actions - Gather from resource node
   * Gathering takes time based on the node's gather duration
   */
  gatherFromNode(nodeId, onProgress = null) {
    if (!this.player || !this.resourceManager) return null;
    const node = this.resourceManager.getNode(nodeId);
    if (!node) {
      console.warn("Node not found:", nodeId);
      return null;
    }
    const canGather = node.canGather(this.player);
    if (!canGather.success) {
      this.emit("gatherFailed", { nodeId, reason: canGather.reason });
      return { success: false, reason: canGather.reason };
    }
    const gatherDuration = node.getGatherDuration ? node.getGatherDuration(this.player) : 30;
    const gatherTimeMs = 2e3;
    const startTime = Date.now();
    const progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / gatherTimeMs * 100, 100);
      if (onProgress) onProgress(progress);
      if (progress >= 100) {
        clearInterval(progressInterval);
        const result = node.gather(this.player);
        if (result.success) {
          result.items.forEach((item) => {
            this.player.inventory.addItem(item);
          });
          this.advanceTime(gatherDuration);
          this.emit("gatherComplete", { nodeId, result, duration: gatherDuration });
        }
        return result;
      }
    }, 100);
    return { success: true, gathering: true, duration: gatherDuration };
  }
  /**
   * Player actions - Equip item
   */
  equipItem(itemId, slot) {
    if (!this.player) return false;
    const item = this.player.inventory.slots.find((s) => !s.isEmpty() && s.item.id === itemId)?.item;
    if (!item) {
      console.warn("Item not in inventory:", itemId);
      return false;
    }
    const success = this.player.equipItem(item, slot);
    if (success) {
      this.emit("itemEquipped", { itemId, slot });
    }
    return success;
  }
  /**
   * Player actions - Move to position
   */
  movePlayer(q, r) {
    if (!this.player) return false;
    const success = this.player.moveTo(q, r);
    if (success) {
      this.emit("playerMoved", { position: { q, r } });
    }
    return success;
  }
  /**
   * Add character to the game
   */
  addCharacter(character) {
    this.state.characters.push(character);
    this.emit("characterAdded", character);
  }
  /**
   * Update character relationship
   */
  updateRelationship(characterId, delta) {
    const character = this.state.characters.find((c) => c.id === characterId);
    if (character) {
      character.relationship = Math.max(0, Math.min(100, character.relationship + delta));
      this.emit("relationshipChanged", { characterId, relationship: character.relationship, delta });
    }
  }
  /**
   * Add item to player inventory (legacy support + new system)
   */
  addItem(itemId, quantity = 1) {
    if (!this.player) return false;
    for (let i = 0; i < quantity; i++) {
      const item = itemDB.get(itemId);
      if (item) {
        this.player.inventory.addItem(item);
      }
    }
    this.emit("inventoryUpdated", this.player.inventory);
    return true;
  }
  /**
   * Remove item from inventory (legacy support + new system)
   */
  removeItem(itemId, quantity = 1) {
    if (!this.player) return false;
    const removed = this.player.inventory.removeItem(itemId, quantity);
    if (removed) {
      this.emit("inventoryUpdated", this.player.inventory);
    }
    return removed;
  }
  /**
   * Get player inventory (for UI/external access)
   */
  getInventory() {
    return this.player?.inventory || null;
  }
  /**
   * Save game state to localStorage
   */
  save(slotName = "autosave") {
    const saveData = {
      version: this.version,
      meta: {
        ...this.state.meta,
        saveDate: (/* @__PURE__ */ new Date()).toISOString(),
        saveName: slotName
      },
      player: this.player ? this.player.toJSON() : null,
      resourceManager: this.resourceManager ? this.resourceManager.toJSON() : null,
      npcManager: this.npcManager ? this.npcManager.saveNPCs() : [],
      state: {
        ...this.state,
        meta: void 0
        // Don't duplicate meta
      }
    };
    try {
      localStorage.setItem(`hedonism_save_${slotName}`, JSON.stringify(saveData));
      this.emit("gameSaved", { slotName, saveData });
      console.log(`‚úÖ Game saved: ${slotName}`);
      return true;
    } catch (e) {
      console.error("Failed to save game:", e);
      this.emit("saveFailed", { error: e.message });
      return false;
    }
  }
  /**
   * Auto-save
   */
  autoSave() {
    this.save("autosave");
  }
  /**
   * Load game state from localStorage
   */
  load(slotName = "autosave") {
    try {
      const savedData = localStorage.getItem(`hedonism_save_${slotName}`);
      if (!savedData) {
        console.warn(`No save found: ${slotName}`);
        return false;
      }
      const data = JSON.parse(savedData);
      if (!data.version || data.version === "1.0.0") {
        console.log("‚ö†Ô∏è Loading legacy v1.0.0 save - migrating to v2.0.0");
        this.migrateLegacySave(data);
      } else {
        this.loadState(data);
      }
      this.emit("gameLoaded", { slotName, data });
      console.log(`‚úÖ Game loaded: ${slotName} (v${data.version || "1.0.0"})`);
      return true;
    } catch (e) {
      console.error("Failed to load game:", e);
      this.emit("loadFailed", { error: e.message });
      return false;
    }
  }
  /**
   * Load state object into current state
   */
  loadState(data) {
    if (data.state) {
      this.state = { ...this.state, ...data.state };
    }
    if (data.meta) {
      this.state.meta = { ...data.meta, lastTick: Date.now() };
    }
    if (data.timeControl) {
      this.isPaused = data.timeControl.isPaused || false;
      this.timeSpeed = data.timeControl.timeSpeed || 1;
      this.currentTime = data.timeControl.currentTime || 0;
    }
    if (data.player) {
      this.player = Player.fromJSON(data.player);
    }
    if (data.resourceManager) {
      const nodeConfigs = {
        "tree": {
          resourceType: "wood",
          baseYield: { min: 2, max: 4 },
          requiredTool: "axe",
          requiredSkill: "woodcutting",
          sprite: "üå≥",
          depletedSprite: "ü™µ",
          gatherDuration: 30,
          gatherTimeMs: 2e3
        },
        "rock": {
          resourceType: "stone",
          baseYield: { min: 2, max: 3 },
          requiredTool: "pickaxe",
          requiredSkill: "mining",
          sprite: "ü™®",
          depletedSprite: "‚ö´",
          gatherDuration: 40,
          gatherTimeMs: 2500
        },
        "berry_bush": {
          resourceType: "berries",
          baseYield: { min: 3, max: 6 },
          requiredTool: null,
          sprite: "ü´ê",
          depletedSprite: "üçÇ",
          gatherDuration: 15,
          gatherTimeMs: 1500
        },
        "coconut_tree": {
          resourceType: "coconut",
          baseYield: { min: 1, max: 2 },
          requiredTool: null,
          sprite: "üå¥",
          depletedSprite: "üå¥",
          gatherDuration: 20,
          gatherTimeMs: 1800
        }
      };
      this.resourceManager = ResourceNodeManager.fromJSON(data.resourceManager, nodeConfigs);
    }
    if (!this.perchanceAI) {
      this.perchanceAI = new PerchanceAI();
    }
    if (!this.npcManager) {
      this.npcManager = new NPCManager(this, this.perchanceAI);
      this.npcManager.setSeed(this.state.island.seed || this.generateSeed());
    }
    if (data.npcManager) {
      this.npcManager.loadNPCs(data.npcManager);
    }
    this.emit("stateLoaded", { version: data.version || "4.0.0" });
  }
  /**
   * Migrate legacy v1.0.0 save to v2.0.0 format
   */
  migrateLegacySave(legacyData) {
    this.state = { ...legacyData };
    this.state.meta.lastTick = Date.now();
    const oldPlayer = legacyData.player || {};
    this.player = new Player({
      name: oldPlayer.name || "Survivor",
      gender: oldPlayer.gender || "neutral"
    });
    if (oldPlayer.health !== void 0) this.player.stats.health.current = oldPlayer.health;
    if (oldPlayer.hunger !== void 0) this.player.stats.hunger.current = oldPlayer.hunger;
    if (oldPlayer.thirst !== void 0) this.player.stats.thirst.current = oldPlayer.thirst;
    if (oldPlayer.energy !== void 0) this.player.stats.energy.current = oldPlayer.energy;
    if (oldPlayer.position) {
      this.player.position = { ...oldPlayer.position };
    }
    if (legacyData.inventory) {
      Object.entries(legacyData.inventory).forEach(([itemId, quantity]) => {
        const item = itemDB.get(itemId);
        if (item) {
          this.player.inventory.addItem(item, quantity);
        }
      });
    }
    this.resourceManager = new ResourceNodeManager();
    this.resourceManager.generateStarterNodes(this.player.position);
    console.log("‚úÖ Legacy save migrated to v2.0.0");
  }
  /**
   * Export save to JSON file
   */
  exportSave() {
    const saveData = {
      version: this.version,
      meta: {
        ...this.state.meta,
        saveDate: (/* @__PURE__ */ new Date()).toISOString()
      },
      player: this.player ? this.player.toJSON() : null,
      resourceManager: this.resourceManager ? this.resourceManager.toJSON() : null,
      timeControl: {
        isPaused: this.isPaused,
        timeSpeed: this.timeSpeed,
        currentTime: this.currentTime
      },
      state: {
        ...this.state,
        meta: void 0
        // Don't duplicate meta
      }
    };
    const dataStr = JSON.stringify(saveData, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `hedonism_island_day${this.state.time.day}_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    this.emit("saveExported", { filename: a.download });
  }
  /**
   * Import save from JSON file
   */
  importSave(fileContent) {
    try {
      const loadedState = JSON.parse(fileContent);
      this.loadState(loadedState);
      this.save("imported");
      return true;
    } catch (e) {
      console.error("Failed to import save:", e);
      return false;
    }
  }
  /**
   * List all available saves
   */
  listSaves() {
    const saves = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.startsWith("hedonism_save_")) {
        const slotName = key.replace("hedonism_save_", "");
        try {
          const data = JSON.parse(localStorage.getItem(key));
          const version = data.version || "1.0.0";
          let saveInfo = {
            slotName,
            version,
            saveDate: data.meta?.saveDate || "Unknown"
          };
          if (version === "2.0.0") {
            saveInfo.playerName = data.player?.name || "Survivor";
            saveInfo.day = data.state?.time?.day || 0;
            saveInfo.playTime = data.meta?.playTime || 0;
            saveInfo.health = data.player?.stats?.health?.current || 100;
            saveInfo.characterCount = data.state?.characters?.length || 0;
          } else {
            saveInfo.playerName = data.player?.name || "Survivor";
            saveInfo.day = data.time?.day || 0;
            saveInfo.playTime = data.meta?.playTime || 0;
            saveInfo.health = data.player?.health || 100;
            saveInfo.characterCount = data.characters?.length || 0;
          }
          saves.push(saveInfo);
        } catch (e) {
          console.error(`Failed to parse save ${slotName}:`, e);
        }
      }
    }
    return saves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
  }
  /**
   * Delete save
   */
  deleteSave(slotName) {
    localStorage.removeItem(`hedonism_save_${slotName}`);
    this.emit("saveDeleted", { slotName });
  }
  /**
   * Event bus - subscribe to state changes
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }
  /**
   * Event bus - subscribe once (auto-removes after first call)
   */
  once(event, callback) {
    const wrapper = (data) => {
      callback(data);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }
  /**
   * Event bus - unsubscribe from event
   */
  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  /**
   * Event bus - emit event
   */
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach((callback) => callback(data));
    }
  }
  /**
   * Stop game loop (cleanup)
   */
  destroy() {
    if (this.gameLoopInterval) {
      clearInterval(this.gameLoopInterval);
    }
  }
  /**
   * Get current state (read-only)
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Set flag
   */
  setFlag(flagName, value) {
    this.state.flags[flagName] = value;
    this.emit("flagChanged", { flagName, value });
  }
  /**
   * Check flag
   */
  hasFlag(flagName) {
    return !!this.state.flags[flagName];
  }
}
class SettingsManager {
  constructor() {
    this.settings = {
      // Gender distribution per faction (percentages, must sum to 100)
      genderDistribution: {
        castaways: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        islanders: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        mercenaries: {
          female: 20,
          male: 60,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        tourists: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        }
      },
      // NPC disposition sliders (0-100)
      npcDisposition: {
        friendliness: 50,
        // 0=hostile, 100=friendly
        romanceInterest: 70,
        // 0=not interested, 100=very interested
        sexualOpenness: 80,
        // 0=prude, 100=complete horndog
        hostility: 20,
        // 0=peaceful, 100=aggressive
        submissiveness: 50
        // 0=dominant, 100=submissive
      },
      // AI Image generation style
      aiImageStyle: {
        preset: "photo-realistic",
        // or 'anime', 'painterly', etc.
        custom: ""
        // Custom style keywords if preset is 'custom'
      },
      // Available presets
      aiImageStylePresets: [
        "photo-realistic",
        "anime",
        "manga",
        "painterly",
        "watercolor",
        "cartoon",
        "comic-book",
        "cinematic",
        "professional-studio",
        "fantasy-art",
        "pixel-art",
        "3d-render",
        "custom"
      ],
      // Difficulty settings
      difficulty: {
        survival: "normal",
        // easy, normal, hard, hardcore
        combat: "normal",
        // easy, normal, hard, permadeath
        economy: "normal"
        // generous, normal, challenging
      },
      // Gameplay toggles
      gameplay: {
        permadeath: false,
        autosaveFrequency: 5,
        // minutes
        tutorialEnabled: true,
        explicitContent: "full",
        // full, fade-to-black, off
        bloodViolence: "full",
        // full, reduced, off
        eventPacing: "normal"
        // slow, normal, fast
      },
      // Cheat panel
      cheats: {
        godMode: false,
        infiniteHealth: false,
        infiniteEnergy: false,
        infiniteResources: false,
        noHungerThirst: false,
        relationshipMultiplier: 1,
        // 0.1 - 10.0
        resourceMultiplier: 1
        // 0.5 - 10.0
      },
      // Content preferences (kinks)
      contentPreferences: {
        vanillaRomance: true,
        bdsm: false,
        submission: false,
        groupScenes: false,
        publicExhibition: false,
        voyeurism: false,
        breedingPregnancy: false,
        nonConDubCon: false,
        furryMonster: false,
        feet: false,
        lactation: false,
        ageGap: false,
        interracial: true,
        surpriseMe: false
        // Random kink inclusion
      },
      // Accessibility
      accessibility: {
        textSize: "medium",
        // small, medium, large, extra-large
        colorblindMode: "none",
        // none, protanopia, deuteranopia, tritanopia
        screenReader: false,
        animations: "full",
        // full, reduced, off
        autoAdvanceText: false,
        autoAdvanceSpeed: 3
        // 1-5 seconds
      }
    };
    this.load();
  }
  /**
   * Save settings to localStorage
   */
  save() {
    try {
      localStorage.setItem("hedonism_settings", JSON.stringify(this.settings));
      return true;
    } catch (e) {
      console.error("Failed to save settings:", e);
      return false;
    }
  }
  /**
   * Load settings from localStorage
   */
  load() {
    try {
      const saved = localStorage.getItem("hedonism_settings");
      if (saved) {
        const loadedSettings = JSON.parse(saved);
        this.settings = this.deepMerge(this.settings, loadedSettings);
      }
      return true;
    } catch (e) {
      console.error("Failed to load settings:", e);
      return false;
    }
  }
  /**
   * Deep merge two objects
   */
  deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }
  /**
   * Get specific setting
   */
  get(path) {
    const keys = path.split(".");
    let value = this.settings;
    for (const key of keys) {
      value = value[key];
      if (value === void 0) return null;
    }
    return value;
  }
  /**
   * Set specific setting
   */
  set(path, value) {
    const keys = path.split(".");
    let obj = this.settings;
    for (let i = 0; i < keys.length - 1; i++) {
      obj = obj[keys[i]];
    }
    obj[keys[keys.length - 1]] = value;
    this.save();
  }
  /**
   * Get gender for random NPC generation
   */
  getRandomGender(faction = "castaways") {
    const distribution = this.settings.genderDistribution[faction];
    const rand = Math.random() * 100;
    let cumulative = 0;
    for (const [gender, percentage] of Object.entries(distribution)) {
      cumulative += percentage;
      if (rand <= cumulative) {
        return gender;
      }
    }
    return "female";
  }
  /**
   * Get AI image style string for prompt
   */
  getAIImageStyle() {
    const style = this.settings.aiImageStyle;
    if (style.preset === "custom") {
      return style.custom;
    }
    const styleMap = {
      "photo-realistic": "photorealistic, professional photography, high quality",
      "anime": "anime style, manga art, japanese animation",
      "manga": "manga style, black and white, detailed lineart",
      "painterly": "oil painting, painterly style, artistic",
      "watercolor": "watercolor painting, soft colors, artistic",
      "cartoon": "cartoon style, animated, colorful",
      "comic-book": "comic book style, bold lines, pop art",
      "cinematic": "cinematic, film still, dramatic lighting",
      "professional-studio": "professional studio photography, high end, glamorous",
      "fantasy-art": "fantasy art, epic, detailed illustration",
      "pixel-art": "pixel art, retro, 8-bit style",
      "3d-render": "3d render, cgi, digital art"
    };
    return styleMap[style.preset] || styleMap["photo-realistic"];
  }
  /**
   * Check if specific kink is enabled
   */
  isKinkEnabled(kinkName) {
    return this.settings.contentPreferences[kinkName] || false;
  }
  /**
   * Get active kinks list
   */
  getActiveKinks() {
    return Object.entries(this.settings.contentPreferences).filter(([key, value]) => value && key !== "surpriseMe").map(([key]) => key);
  }
  /**
   * Apply difficulty modifiers
   */
  getDifficultyMultipliers() {
    const survival = this.settings.difficulty.survival;
    const combat = this.settings.difficulty.combat;
    const multipliers = {
      hungerDrain: 1,
      thirstDrain: 1,
      energyDrain: 1,
      resourceYield: 1,
      enemyStrength: 1,
      deathRisk: 0.01
      // 1% base death chance in combat
    };
    switch (survival) {
      case "easy":
        multipliers.hungerDrain = 0.5;
        multipliers.thirstDrain = 0.5;
        multipliers.energyDrain = 0.5;
        multipliers.resourceYield = 1.5;
        break;
      case "hard":
        multipliers.hungerDrain = 1.5;
        multipliers.thirstDrain = 1.5;
        multipliers.energyDrain = 1.5;
        multipliers.resourceYield = 0.7;
        break;
      case "hardcore":
        multipliers.hungerDrain = 2;
        multipliers.thirstDrain = 2;
        multipliers.energyDrain = 2;
        multipliers.resourceYield = 0.5;
        break;
    }
    switch (combat) {
      case "easy":
        multipliers.enemyStrength = 0.7;
        multipliers.deathRisk = 1e-3;
        break;
      case "hard":
        multipliers.enemyStrength = 1.3;
        multipliers.deathRisk = 0.05;
        break;
      case "permadeath":
        multipliers.enemyStrength = 1.5;
        multipliers.deathRisk = 0.1;
        break;
    }
    if (this.settings.cheats.resourceMultiplier !== 1) {
      multipliers.resourceYield *= this.settings.cheats.resourceMultiplier;
    }
    return multipliers;
  }
  /**
   * Reset settings to defaults
   */
  reset() {
    localStorage.removeItem("hedonism_settings");
    this.settings = this.constructor.prototype.settings;
    return true;
  }
  /**
   * Export settings to JSON
   */
  export() {
    const dataStr = JSON.stringify(this.settings, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "hedonism_settings.json";
    a.click();
    URL.revokeObjectURL(url);
  }
  /**
   * Import settings from JSON
   */
  import(fileContent) {
    try {
      const imported = JSON.parse(fileContent);
      this.settings = this.deepMerge(this.settings, imported);
      this.save();
      return true;
    } catch (e) {
      console.error("Failed to import settings:", e);
      return false;
    }
  }
}
class SettingsMenu {
  constructor(settingsManager2) {
    this.settings = settingsManager2;
    this.currentTab = "gender";
    this.isOpen = false;
  }
  /**
   * Open settings menu
   */
  open() {
    this.isOpen = true;
    this.render();
  }
  /**
   * Close settings menu
   */
  close() {
    this.isOpen = false;
    const menu = document.getElementById("settings-menu");
    if (menu) {
      menu.remove();
    }
  }
  /**
   * Render settings menu
   */
  render() {
    const existing = document.getElementById("settings-menu");
    if (existing) existing.remove();
    const menu = document.createElement("div");
    menu.id = "settings-menu";
    menu.className = "modal-overlay";
    menu.innerHTML = `
      <div class="modal-content settings-modal">
        <div class="modal-header">
          <h2>‚öôÔ∏è Settings</h2>
          <button class="close-btn" id="close-settings">‚úï</button>
        </div>
        
        <div class="settings-body">
          <div class="settings-tabs">
            <button class="tab-btn ${this.currentTab === "gender" ? "active" : ""}" data-tab="gender">
              Gender Distribution
            </button>
            <button class="tab-btn ${this.currentTab === "disposition" ? "active" : ""}" data-tab="disposition">
              NPC Disposition
            </button>
            <button class="tab-btn ${this.currentTab === "ai-style" ? "active" : ""}" data-tab="ai-style">
              AI Style
            </button>
            <button class="tab-btn ${this.currentTab === "difficulty" ? "active" : ""}" data-tab="difficulty">
              Difficulty
            </button>
            <button class="tab-btn ${this.currentTab === "gameplay" ? "active" : ""}" data-tab="gameplay">
              Gameplay
            </button>
            <button class="tab-btn ${this.currentTab === "cheats" ? "active" : ""}" data-tab="cheats">
              Cheats
            </button>
            <button class="tab-btn ${this.currentTab === "content" ? "active" : ""}" data-tab="content">
              Content/Kinks
            </button>
            <button class="tab-btn ${this.currentTab === "accessibility" ? "active" : ""}" data-tab="accessibility">
              Accessibility
            </button>
          </div>
          
          <div class="settings-content">
            ${this.renderCurrentTab()}
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn btn-secondary" id="reset-settings">Reset to Defaults</button>
          <button class="btn btn-secondary" id="export-settings">Export Settings</button>
          <div class="spacer"></div>
          <button class="btn btn-secondary" id="cancel-settings">Cancel</button>
          <button class="btn btn-primary" id="save-settings">Save & Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(menu);
    this.attachEventListeners();
  }
  /**
   * Render current tab content
   */
  renderCurrentTab() {
    switch (this.currentTab) {
      case "gender":
        return this.renderGenderTab();
      case "disposition":
        return this.renderDispositionTab();
      case "ai-style":
        return this.renderAIStyleTab();
      case "difficulty":
        return this.renderDifficultyTab();
      case "gameplay":
        return this.renderGameplayTab();
      case "cheats":
        return this.renderCheatsTab();
      case "content":
        return this.renderContentTab();
      case "accessibility":
        return this.renderAccessibilityTab();
      default:
        return "<p>Select a tab</p>";
    }
  }
  /**
   * Render Gender Distribution tab
   */
  renderGenderTab() {
    const factions = ["castaways", "islanders", "mercenaries", "tourists"];
    const genders = ["female", "male", "futanari", "transWoman", "transMale"];
    const genderLabels = {
      female: "Female",
      male: "Male",
      futanari: "Futanari",
      transWoman: "Trans Woman",
      transMale: "Trans Man"
    };
    let html = '<div class="tab-content"><h3>Gender Distribution by Faction</h3>';
    html += '<p class="help-text">Adjust the likelihood of each gender appearing in procedurally generated characters. Percentages must total 100% per faction.</p>';
    for (const faction of factions) {
      html += `<div class="faction-section">
        <h4>${faction.charAt(0).toUpperCase() + faction.slice(1)}</h4>`;
      for (const gender of genders) {
        const value = this.settings.get(`genderDistribution.${faction}.${gender}`);
        html += `
          <div class="slider-control">
            <label>${genderLabels[gender]}</label>
            <input type="range" min="0" max="100" value="${value}" 
                   data-setting="genderDistribution.${faction}.${gender}"
                   class="slider">
            <span class="slider-value">${value}%</span>
          </div>
        `;
      }
      html += "</div>";
    }
    html += "</div>";
    return html;
  }
  /**
   * Render NPC Disposition tab
   */
  renderDispositionTab() {
    const dispositions = {
      friendliness: { label: "Friendliness", min: "Hostile", max: "Friendly" },
      romanceInterest: { label: "Romance Interest", min: "Not Interested", max: "Very Interested" },
      sexualOpenness: { label: "Sexual Openness", min: "Prude", max: "Complete Horndog" },
      hostility: { label: "Hostility", min: "Peaceful", max: "Aggressive" },
      submissiveness: { label: "Submissiveness", min: "Dominant", max: "Submissive" }
    };
    let html = '<div class="tab-content"><h3>NPC Disposition</h3>';
    html += '<p class="help-text">These sliders affect the baseline personality traits of generated NPCs.</p>';
    for (const [key, config] of Object.entries(dispositions)) {
      const value = this.settings.get(`npcDisposition.${key}`);
      html += `
        <div class="slider-control wide">
          <label>${config.label}</label>
          <div class="slider-labels">
            <span>${config.min}</span>
            <span>${config.max}</span>
          </div>
          <input type="range" min="0" max="100" value="${value}"
                 data-setting="npcDisposition.${key}"
                 class="slider">
          <span class="slider-value">${value}</span>
        </div>
      `;
    }
    html += "</div>";
    return html;
  }
  /**
   * Render AI Style tab
   */
  renderAIStyleTab() {
    const currentPreset = this.settings.get("aiImageStyle.preset");
    const customValue = this.settings.get("aiImageStyle.custom");
    const presets = this.settings.settings.aiImageStylePresets;
    let html = '<div class="tab-content"><h3>AI Image Generation Style</h3>';
    html += '<p class="help-text">Choose how AI-generated character portraits and scenes should look.</p>';
    html += '<div class="style-selector">';
    for (const preset of presets) {
      const label = preset.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
      html += `
        <label class="radio-card">
          <input type="radio" name="ai-style" value="${preset}" 
                 ${currentPreset === preset ? "checked" : ""}>
          <span>${label}</span>
        </label>
      `;
    }
    html += "</div>";
    html += `
      <div class="custom-style ${currentPreset === "custom" ? "" : "hidden"}" id="custom-style-input">
        <label>Custom Style Keywords</label>
        <input type="text" value="${customValue}" 
               data-setting="aiImageStyle.custom"
               placeholder="e.g., vintage photograph, sepia tone, 1920s">
        <p class="help-text">Enter Perchance-compatible style keywords.</p>
      </div>
    `;
    html += "</div>";
    return html;
  }
  /**
   * Render Difficulty tab
   */
  renderDifficultyTab() {
    const survival = this.settings.get("difficulty.survival");
    const combat = this.settings.get("difficulty.combat");
    const economy = this.settings.get("difficulty.economy");
    return `
      <div class="tab-content">
        <h3>Difficulty Settings</h3>
        
        <div class="difficulty-section">
          <h4>Survival Difficulty</h4>
          <select data-setting="difficulty.survival">
            <option value="easy" ${survival === "easy" ? "selected" : ""}>Easy - Slow hunger/thirst drain, abundant resources</option>
            <option value="normal" ${survival === "normal" ? "selected" : ""}>Normal - Balanced survival challenge</option>
            <option value="hard" ${survival === "hard" ? "selected" : ""}>Hard - Fast stat drain, scarce resources</option>
            <option value="hardcore" ${survival === "hardcore" ? "selected" : ""}>Hardcore - Extreme challenge, for masochists</option>
          </select>
        </div>
        
        <div class="difficulty-section">
          <h4>Combat Difficulty</h4>
          <select data-setting="difficulty.combat">
            <option value="easy" ${combat === "easy" ? "selected" : ""}>Easy - Weak enemies, very rare deaths</option>
            <option value="normal" ${combat === "normal" ? "selected" : ""}>Normal - Balanced combat, injury common</option>
            <option value="hard" ${combat === "hard" ? "selected" : ""}>Hard - Strong enemies, death possible</option>
            <option value="permadeath" ${combat === "permadeath" ? "selected" : ""}>Permadeath - Death is permanent. Good luck.</option>
          </select>
        </div>
        
        <div class="difficulty-section">
          <h4>Economy Difficulty (Phase 4)</h4>
          <select data-setting="difficulty.economy">
            <option value="generous" ${economy === "generous" ? "selected" : ""}>Generous - Money flows freely</option>
            <option value="normal" ${economy === "normal" ? "selected" : ""}>Normal - Balanced economy</option>
            <option value="challenging" ${economy === "challenging" ? "selected" : ""}>Challenging - Every coin counts</option>
          </select>
        </div>
      </div>
    `;
  }
  /**
   * Render Gameplay tab
   */
  renderGameplayTab() {
    const gameplay = this.settings.settings.gameplay;
    return `
      <div class="tab-content">
        <h3>Gameplay Options</h3>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="gameplay.permadeath" ${gameplay.permadeath ? "checked" : ""}>
            <span>Permadeath - Characters can die permanently</span>
          </label>
        </div>
        
        <div class="slider-control">
          <label>Autosave Frequency (minutes)</label>
          <input type="range" min="1" max="30" value="${gameplay.autosaveFrequency}"
                 data-setting="gameplay.autosaveFrequency" class="slider">
          <span class="slider-value">${gameplay.autosaveFrequency}</span>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="gameplay.tutorialEnabled" ${gameplay.tutorialEnabled ? "checked" : ""}>
            <span>Tutorial Hints Enabled</span>
          </label>
        </div>
        
        <div class="select-control">
          <label>Explicit Content Display</label>
          <select data-setting="gameplay.explicitContent">
            <option value="full" ${gameplay.explicitContent === "full" ? "selected" : ""}>Full - Show everything (recommended)</option>
            <option value="fade-to-black" ${gameplay.explicitContent === "fade-to-black" ? "selected" : ""}>Fade to Black - Implied only (for cowards)</option>
            <option value="off" ${gameplay.explicitContent === "off" ? "selected" : ""}>Off - No sexual content (why are you here?)</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Blood & Violence</label>
          <select data-setting="gameplay.bloodViolence">
            <option value="full" ${gameplay.bloodViolence === "full" ? "selected" : ""}>Full - Realistic violence</option>
            <option value="reduced" ${gameplay.bloodViolence === "reduced" ? "selected" : ""}>Reduced - Minimal gore</option>
            <option value="off" ${gameplay.bloodViolence === "off" ? "selected" : ""}>Off - Cartoon violence</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Event Pacing</label>
          <select data-setting="gameplay.eventPacing">
            <option value="slow" ${gameplay.eventPacing === "slow" ? "selected" : ""}>Slow - Take your time</option>
            <option value="normal" ${gameplay.eventPacing === "normal" ? "selected" : ""}>Normal - Balanced</option>
            <option value="fast" ${gameplay.eventPacing === "fast" ? "selected" : ""}>Fast - Quick progression</option>
          </select>
        </div>
      </div>
    `;
  }
  /**
   * Render Cheats tab
   */
  renderCheatsTab() {
    const cheats = this.settings.settings.cheats;
    return `
      <div class="tab-content">
        <h3>Cheat Panel</h3>
        <p class="help-text warning">‚ö†Ô∏è Using cheats may affect achievements (if we add them later)</p>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.godMode" ${cheats.godMode ? "checked" : ""}>
            <span>God Mode - All cheats enabled</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteHealth" ${cheats.infiniteHealth ? "checked" : ""}>
            <span>Infinite Health</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteEnergy" ${cheats.infiniteEnergy ? "checked" : ""}>
            <span>Infinite Energy</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteResources" ${cheats.infiniteResources ? "checked" : ""}>
            <span>Infinite Resources</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.noHungerThirst" ${cheats.noHungerThirst ? "checked" : ""}>
            <span>No Hunger/Thirst</span>
          </label>
        </div>
        
        <div class="slider-control">
          <label>Relationship Gain Multiplier</label>
          <input type="range" min="0.1" max="10" step="0.1" value="${cheats.relationshipMultiplier}"
                 data-setting="cheats.relationshipMultiplier" class="slider">
          <span class="slider-value">${cheats.relationshipMultiplier}x</span>
        </div>
        
        <div class="slider-control">
          <label>Resource Gather Multiplier</label>
          <input type="range" min="0.5" max="10" step="0.1" value="${cheats.resourceMultiplier}"
                 data-setting="cheats.resourceMultiplier" class="slider">
          <span class="slider-value">${cheats.resourceMultiplier}x</span>
        </div>
      </div>
    `;
  }
  /**
   * Render Content/Kinks tab
   */
  renderContentTab() {
    const prefs = this.settings.settings.contentPreferences;
    const kinks = [
      { key: "vanillaRomance", label: "Vanilla Romance", desc: "Standard romantic content" },
      { key: "bdsm", label: "BDSM/Dominance", desc: "Bondage, discipline, dominance scenes" },
      { key: "submission", label: "Submission/Slavery", desc: "Submissive dynamics, slavery content" },
      { key: "groupScenes", label: "Group Scenes", desc: "Threesomes, orgies, multiple partners" },
      { key: "publicExhibition", label: "Public/Exhibition", desc: "Public sex, being watched" },
      { key: "voyeurism", label: "Voyeurism", desc: "Watching others" },
      { key: "breedingPregnancy", label: "Breeding/Pregnancy", desc: "Impregnation, pregnancy content" },
      { key: "nonConDubCon", label: "Non-Con/Dubious Consent", desc: "Forced or questionable consent scenarios" },
      { key: "furryMonster", label: "Furry/Monster", desc: "Non-human characters" },
      { key: "feet", label: "Feet", desc: "Foot fetish content" },
      { key: "lactation", label: "Lactation", desc: "Breastfeeding, milk" },
      { key: "ageGap", label: "Age Gap (18+)", desc: "Significant age differences, all 18+" },
      { key: "interracial", label: "Interracial", desc: "Diverse ethnic pairings" },
      { key: "surpriseMe", label: "Surprise Me!", desc: "Random kink inclusion" }
    ];
    let html = '<div class="tab-content"><h3>Content Preferences / Kinks</h3>';
    html += '<p class="help-text">Enable the types of sexual content you want to encounter. Disabled content will be filtered out.</p>';
    html += '<div class="kink-grid">';
    for (const kink of kinks) {
      html += `
        <div class="kink-card">
          <label>
            <input type="checkbox" data-setting="contentPreferences.${kink.key}" ${prefs[kink.key] ? "checked" : ""}>
            <div class="kink-label">
              <strong>${kink.label}</strong>
              <span class="kink-desc">${kink.desc}</span>
            </div>
          </label>
        </div>
      `;
    }
    html += "</div></div>";
    return html;
  }
  /**
   * Render Accessibility tab
   */
  renderAccessibilityTab() {
    const acc = this.settings.settings.accessibility;
    return `
      <div class="tab-content">
        <h3>Accessibility Options</h3>
        
        <div class="select-control">
          <label>Text Size</label>
          <select data-setting="accessibility.textSize">
            <option value="small" ${acc.textSize === "small" ? "selected" : ""}>Small</option>
            <option value="medium" ${acc.textSize === "medium" ? "selected" : ""}>Medium</option>
            <option value="large" ${acc.textSize === "large" ? "selected" : ""}>Large</option>
            <option value="extra-large" ${acc.textSize === "extra-large" ? "selected" : ""}>Extra Large</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Colorblind Mode</label>
          <select data-setting="accessibility.colorblindMode">
            <option value="none" ${acc.colorblindMode === "none" ? "selected" : ""}>None</option>
            <option value="protanopia" ${acc.colorblindMode === "protanopia" ? "selected" : ""}>Protanopia (Red-Green)</option>
            <option value="deuteranopia" ${acc.colorblindMode === "deuteranopia" ? "selected" : ""}>Deuteranopia (Red-Green)</option>
            <option value="tritanopia" ${acc.colorblindMode === "tritanopia" ? "selected" : ""}>Tritanopia (Blue-Yellow)</option>
          </select>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="accessibility.screenReader" ${acc.screenReader ? "checked" : ""}>
            <span>Screen Reader Support</span>
          </label>
        </div>
        
        <div class="select-control">
          <label>Animations</label>
          <select data-setting="accessibility.animations">
            <option value="full" ${acc.animations === "full" ? "selected" : ""}>Full</option>
            <option value="reduced" ${acc.animations === "reduced" ? "selected" : ""}>Reduced</option>
            <option value="off" ${acc.animations === "off" ? "selected" : ""}>Off</option>
          </select>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="accessibility.autoAdvanceText" ${acc.autoAdvanceText ? "checked" : ""}>
            <span>Auto-Advance Text</span>
          </label>
        </div>
        
        <div class="slider-control ${acc.autoAdvanceText ? "" : "disabled"}">
          <label>Auto-Advance Speed (seconds)</label>
          <input type="range" min="1" max="10" value="${acc.autoAdvanceSpeed}"
                 data-setting="accessibility.autoAdvanceSpeed" class="slider"
                 ${acc.autoAdvanceText ? "" : "disabled"}>
          <span class="slider-value">${acc.autoAdvanceSpeed}s</span>
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    document.getElementById("close-settings").onclick = () => this.close();
    document.getElementById("cancel-settings").onclick = () => this.close();
    document.querySelectorAll(".tab-btn").forEach((btn) => {
      btn.onclick = () => {
        this.currentTab = btn.dataset.tab;
        this.render();
      };
    });
    document.querySelectorAll('input[type="range"]').forEach((slider) => {
      slider.oninput = (e) => {
        const valueDisplay = e.target.nextElementSibling;
        if (valueDisplay && valueDisplay.classList.contains("slider-value")) {
          const setting = e.target.dataset.setting;
          if (setting && setting.includes("genderDistribution")) {
            valueDisplay.textContent = `${e.target.value}%`;
          } else if (setting && setting.includes("Multiplier")) {
            valueDisplay.textContent = `${e.target.value}x`;
          } else if (setting === "accessibility.autoAdvanceSpeed") {
            valueDisplay.textContent = `${e.target.value}s`;
          } else {
            valueDisplay.textContent = e.target.value;
          }
        }
      };
    });
    document.querySelectorAll('input[name="ai-style"]').forEach((radio) => {
      radio.onchange = (e) => {
        this.settings.set("aiImageStyle.preset", e.target.value);
        const customInput = document.getElementById("custom-style-input");
        if (customInput) {
          if (e.target.value === "custom") {
            customInput.classList.remove("hidden");
          } else {
            customInput.classList.add("hidden");
          }
        }
      };
    });
    document.getElementById("save-settings").onclick = () => this.saveSettings();
    document.getElementById("reset-settings").onclick = () => {
      if (confirm("Reset all settings to defaults? This cannot be undone.")) {
        this.settings.reset();
        this.render();
      }
    };
    document.getElementById("export-settings").onclick = () => this.settings.export();
  }
  /**
   * Save all settings
   */
  saveSettings() {
    document.querySelectorAll("[data-setting]").forEach((input) => {
      const setting = input.dataset.setting;
      let value;
      if (input.type === "checkbox") {
        value = input.checked;
      } else if (input.type === "range") {
        value = parseFloat(input.value);
      } else {
        value = input.value;
      }
      this.settings.set(setting, value);
    });
    this.settings.save();
    this.close();
    this.showNotification("Settings saved successfully!");
  }
  /**
   * Show notification toast
   */
  showNotification(message) {
    const toast = document.createElement("div");
    toast.className = "notification-toast";
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.classList.add("show"), 10);
    setTimeout(() => {
      toast.classList.remove("show");
      setTimeout(() => toast.remove(), 300);
    }, 3e3);
  }
}
class MainMenu {
  constructor(gameState2, settingsManager2, settingsMenu2, characterCreation2) {
    this.gameState = gameState2;
    this.settings = settingsManager2;
    this.settingsMenu = settingsMenu2;
    this.characterCreation = characterCreation2;
    console.log("üéØ MainMenu initialized with:", {
      gameState: !!gameState2,
      settingsManager: !!settingsManager2,
      settingsMenu: !!settingsMenu2,
      characterCreation: !!characterCreation2
    });
  }
  /**
   * Initialize main menu
   */
  init() {
    console.log("üìã MainMenu.init() called");
    this.attachEventListeners();
    this.checkContinueButton();
    console.log("‚úÖ MainMenu.init() complete");
  }
  /**
   * Attach event listeners to menu buttons
   */
  attachEventListeners() {
    const continueBtn = document.getElementById("btn-continue");
    const newGameBtn = document.getElementById("btn-new-game");
    const loadBtn = document.getElementById("btn-load");
    const clearSavesBtn = document.getElementById("btn-clear-saves");
    const settingsBtn = document.getElementById("btn-settings");
    const creditsBtn = document.getElementById("btn-credits");
    console.log("üîó Attaching event listeners:", {
      continueBtn: !!continueBtn,
      newGameBtn: !!newGameBtn,
      loadBtn: !!loadBtn,
      clearSavesBtn: !!clearSavesBtn,
      settingsBtn: !!settingsBtn,
      creditsBtn: !!creditsBtn
    });
    if (continueBtn) {
      continueBtn.onclick = () => this.continueGame();
    }
    if (newGameBtn) {
      newGameBtn.onclick = () => {
        console.log("üéÆ New Game button clicked!");
        this.newGame();
      };
    }
    if (loadBtn) {
      loadBtn.onclick = () => this.showLoadMenu();
    }
    if (clearSavesBtn) {
      clearSavesBtn.onclick = () => this.clearOldSaves();
    }
    if (settingsBtn) {
      settingsBtn.onclick = () => this.settingsMenu.open();
    }
    if (creditsBtn) {
      creditsBtn.onclick = () => this.showCredits();
    }
  }
  /**
   * Check if there's a save to continue from
   */
  checkContinueButton() {
    const continueBtn = document.getElementById("btn-continue");
    if (!continueBtn) return;
    const hasSave = localStorage.getItem("hedonism_save_autosave");
    if (hasSave) {
      continueBtn.disabled = false;
    } else {
      continueBtn.disabled = true;
    }
  }
  /**
   * Clear old incompatible saves
   */
  clearOldSaves() {
    const confirmMessage = `‚ö†Ô∏è Clear Old Saves?

This will delete ALL saved games and cannot be undone.

Recommended if you're experiencing issues with old saves from previous versions.

Continue?`;
    if (!confirm(confirmMessage)) {
      return;
    }
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.startsWith("hedonism")) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
    console.log(`üóëÔ∏è Cleared ${keysToRemove.length} save entries`);
    this.checkContinueButton();
    alert(`‚úÖ Cleared ${keysToRemove.length} save file(s).

You can now start a fresh game with "New Game".`);
  }
  /**
   * Continue from last save
   */
  continueGame() {
    const savedData = localStorage.getItem("hedonism_save_autosave");
    if (savedData) {
      try {
        const saveState = JSON.parse(savedData);
        const saveVersion = saveState.meta?.version || "1.0.0";
        const currentVersion = window.GAME_VERSION || "3.0.0";
        if (saveVersion !== currentVersion && !window.COMPATIBLE_VERSIONS?.includes(saveVersion)) {
          alert(
            `üö´ INCOMPATIBLE SAVE FILE

Your save is from version ${saveVersion}, but you're running version ${currentVersion}.

‚ùå This save CANNOT be loaded due to major system changes:
‚Ä¢ Complete rewrite to turn-based energy system
‚Ä¢ New tile interaction system (resources, NPCs, events)
‚Ä¢ Completely new fog of war mechanics
‚Ä¢ Updated save format and game state

üéÆ Please use "Clear Old Saves" then start a NEW GAME.

The new version is completely different and much better!`
          );
          return;
        }
        this.gameState.emit("loadGame", saveState);
        const menu = document.getElementById("main-menu");
        if (menu) menu.classList.add("hidden");
      } catch (e) {
        console.error("Failed to continue game:", e);
        const menu = document.getElementById("main-menu");
        if (menu) menu.classList.remove("hidden");
        const startNew = confirm("Failed to load save game. Would you like to start a new game instead?");
        if (startNew) {
          this.newGame();
        }
      }
    } else {
      const startNew = confirm("No save game found. Would you like to start a new game?");
      if (startNew) {
        this.newGame();
      }
    }
  }
  /**
   * Start new game
   */
  newGame() {
    console.log("üéÆ New Game clicked");
    const hasSave = localStorage.getItem("hedonism_save_autosave");
    if (hasSave) {
      const confirmed = confirm("Starting a new game will overwrite your current progress. Continue?");
      if (!confirmed) return;
    }
    console.log("üìù Initializing game state...");
    this.gameState.init();
    console.log("üé® Showing character creation...");
    this.characterCreation.show();
    this.gameState.once("characterCreated", () => {
      console.log("‚úÖ Character created, starting game...");
      this.startGame();
    });
  }
  /**
   * Show load game menu
   */
  showLoadMenu() {
    if (window.game && window.game.saveManager) {
      window.game.saveManager.show();
      return;
    }
    const saves = this.gameState.listSaves();
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "load-menu";
    let savesHTML = "";
    if (saves.length === 0) {
      savesHTML = '<div class="no-saves">No saved games found.</div>';
    } else {
      savesHTML = '<div class="save-list">';
      saves.forEach((save) => {
        const date = new Date(save.saveDate).toLocaleString();
        savesHTML += `
          <div class="save-item" data-slot="${save.slotName}">
            <div class="save-info">
              <h4>${save.slotName}</h4>
              <p>Day ${save.day} ‚Ä¢ ${save.characterCount} characters ‚Ä¢ ${this.formatPlayTime(save.playTime)}</p>
              <p class="save-date">${date}</p>
            </div>
            <div class="save-actions">
              <button class="btn-load" data-slot="${save.slotName}">Load</button>
              <button class="btn-delete" data-slot="${save.slotName}">Delete</button>
            </div>
          </div>
        `;
      });
      savesHTML += "</div>";
    }
    modal.innerHTML = `
      <div class="modal-content load-game-modal">
        <div class="modal-header">
          <h2>Load Game</h2>
          <button class="close-btn" id="close-load-menu">‚úï</button>
        </div>
        <div class="modal-body">
          ${savesHTML}
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="cancel-load">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-load-menu").onclick = () => modal.remove();
    document.getElementById("cancel-load").onclick = () => modal.remove();
    modal.querySelectorAll(".btn-load").forEach((btn) => {
      btn.onclick = (e) => {
        const slot = e.target.dataset.slot;
        const savedData = localStorage.getItem(`hedonism_save_${slot}`);
        if (savedData) {
          try {
            const saveState = JSON.parse(savedData);
            modal.remove();
            const menu = document.getElementById("main-menu");
            if (menu) menu.classList.add("hidden");
            this.gameState.emit("loadGame", saveState);
          } catch (e2) {
            console.error("Failed to load game:", e2);
            alert("Failed to load save game.");
          }
        } else {
          alert("Save file not found.");
        }
      };
    });
    modal.querySelectorAll(".btn-delete").forEach((btn) => {
      btn.onclick = (e) => {
        const slot = e.target.dataset.slot;
        if (confirm(`Delete save "${slot}"?`)) {
          this.gameState.deleteSave(slot);
          modal.remove();
          this.showLoadMenu();
        }
      };
    });
  }
  /**
   * Show credits
   */
  showCredits() {
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "credits-menu";
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h2>Credits</h2>
          <button class="close-btn" id="close-credits">‚úï</button>
        </div>
        <div class="modal-body credits-content">
          <h3>Hedonism Island</h3>
          <p>A survival/management/dating sim where morality is optional</p>
          
          <div class="credit-section">
            <h4>Development</h4>
            <p>Built with Vite, vanilla JavaScript, and pure degeneracy</p>
          </div>
          
          <div class="credit-section">
            <h4>AI Generation</h4>
            <p>Powered by Perchance AI</p>
            <p>Text-to-Image Plugin ‚Ä¢ AI Text Plugin</p>
          </div>
          
          <div class="credit-section">
            <h4>Special Thanks</h4>
            <p>To everyone who said "you can't make that"</p>
            <p>We fucking did it anyway</p>
          </div>
          
          <div class="credit-section">
            <h4>Content Warning</h4>
            <p>This game contains explicit sexual content,</p>
            <p>player-choice morality including slavery and violence,</p>
            <p>and themes that would give your grandmother a heart attack.</p>
            <p><strong>18+ ONLY</strong></p>
          </div>
          
          <p style="margin-top: 30px; font-style: italic; color: #999;">
            "Survival is optional. Pleasure is mandatory."
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="close-credits-btn">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-credits").onclick = () => modal.remove();
    document.getElementById("close-credits-btn").onclick = () => modal.remove();
  }
  /**
   * Start the game (deprecated - now handled by story intro ‚Üí game view flow)
   */
  startGame() {
    console.warn("MainMenu.startGame() is deprecated. Game flow is now: Character Creation ‚Üí Story Intro ‚Üí Game View");
  }
  /**
   * Show main menu (hide game view)
   */
  showMenu() {
    const menu = document.getElementById("main-menu");
    const gameView2 = document.getElementById("game-view");
    if (menu) menu.classList.remove("hidden");
    if (gameView2) gameView2.classList.add("hidden");
    this.checkContinueButton();
  }
  /**
   * Format play time in human-readable format
   */
  formatPlayTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else {
      return `${minutes}m`;
    }
  }
}
class CharacterCreator {
  constructor() {
    this.currentCharacter = this.getDefaultCharacter();
    this.presets = this.loadPresets();
    this.backgroundBonuses = {};
    this.manualSkillPoints = {
      survival: 0,
      combat: 0,
      charisma: 0,
      crafting: 0,
      medical: 0,
      leadership: 0
    };
  }
  getDefaultCharacter() {
    return {
      // Basic Info
      name: "",
      age: 25,
      gender: "female",
      // female, male, futanari, Cuntboy, other
      // Physical Appearance
      body: {
        height: "average",
        // petite, short, average, tall, very-tall, custom
        heightCustom: "",
        build: "average",
        // skinny, slim, average, athletic, curvy, muscular, heavyset, custom
        buildCustom: "",
        skinTone: "tan",
        // pale, fair, tan, olive, brown, dark, custom
        skinToneCustom: "",
        // Face
        faceShape: "oval",
        // oval, round, square, heart, diamond, custom
        faceShapeCustom: "",
        eyeColor: "brown",
        // brown, blue, green, hazel, gray, amber, heterochromia, custom
        eyeColorCustom: "",
        eyeShape: "almond",
        // almond, round, hooded, upturned, downturned, custom
        eyeShapeCustom: "",
        hairColor: "brown",
        // black, brown, blonde, red, auburn, gray, white, unusual, custom
        hairColorCustom: "",
        hairLength: "shoulder",
        // buzzed, short, shoulder, long, very-long, custom
        hairLengthCustom: "",
        hairStyle: "straight",
        // straight, wavy, curly, kinky, braided, tied-up, custom
        hairStyleCustom: "",
        // Body Features
        breastSize: "medium",
        // flat, small, medium, large, very-large, huge, custom
        breastSizeCustom: "",
        buttSize: "medium",
        // small, medium, large, very-large, custom
        buttSizeCustom: "",
        muscleTone: "average",
        // soft, toned, average, muscular, very-muscular, custom
        muscleToneCustom: "",
        // Distinctive Features
        scars: "none",
        // none, few, many, prominent, custom
        scarsCustom: "",
        scarLocation: null,
        // face, chest, back, arms, legs, custom
        scarLocationCustom: "",
        birthmarks: false,
        birthmarksCustom: "",
        // Custom description if birthmarks = true
        freckles: "none",
        // none, light, moderate, heavy, custom
        frecklesCustom: "",
        beautyMark: false,
        beautyMarkCustom: "",
        // Custom description if beautyMark = true
        distinctiveFeaturesCustom: "",
        // General custom distinctive features
        // Genitals (explicit customization)
        primaryGenitals: "vagina",
        // penis, vagina, both
        secondaryGenitals: null,
        // null, penis, vagina (for futanari/andromorph)
        // Penis details (if applicable)
        penisSize: "average",
        // small, average, large, very-large, huge, custom
        penisSizeCustom: "",
        penisGirth: "average",
        // thin, average, thick, very-thick, custom
        penisGirthCustom: "",
        circumcised: false,
        // Vagina details (if applicable)
        vaginaTightness: "average",
        // tight, average, loose, custom
        vaginaTightnessCustom: "",
        vaginaDepth: "average",
        // shallow, average, deep, custom
        vaginaDepthCustom: "",
        // Other
        pubicHair: "trimmed",
        // none, trimmed, natural, styled, custom
        pubicHairCustom: "",
        bodyHair: "minimal",
        // none, minimal, average, hairy, custom
        bodyHairCustom: "",
        tattoos: "none",
        // none, few, many, custom
        tattoosCustom: "",
        piercings: "none",
        // none, ears, face, body, nipples, genital, multiple, custom
        piercingsCustom: ""
      },
      // Personality Traits (developed through gameplay, start neutral)
      personality: {
        dominance: 50,
        // 0-100 (submissive to dominant)
        openness: 50,
        // 0-100 (reserved to promiscuous)
        morality: 50,
        // 0-100 (cruel to kind)
        confidence: 50,
        // 0-100 (shy to confident)
        intelligence: 50,
        // 0-100 (simple to clever)
        aggression: 50
        // 0-100 (passive to aggressive)
      },
      // Background & Skills
      background: "tourist",
      // tourist, sailor, scientist, criminal, drifter, pilot
      traits: [],
      // Special traits from background and achievements
      skills: {
        survival: 0,
        combat: 0,
        charisma: 0,
        crafting: 0,
        medical: 0,
        leadership: 0
      },
      // Sexual Preferences & Experience
      sexualProfile: {
        experience: "experienced",
        // virgin, inexperienced, experienced, veteran
        preferredRole: "versatile",
        // dominant, submissive, versatile, switch
        virginityStatus: {
          vaginal: false,
          // Only applies if has vagina
          anal: false,
          oral: false
        },
        kinks: [],
        // Will be populated from settings
        turnOns: [],
        // Specific preferences
        limits: []
        // Hard no's
      },
      // Generated Portrait
      portraitUrl: null,
      portraitPrompt: ""
    };
  }
  loadPresets() {
    return {
      female: [
        {
          name: "Beach Babe",
          description: "Curvy, confident surfer girl with sun-kissed skin",
          character: {
            age: 23,
            gender: "female",
            body: {
              height: "average",
              build: "curvy",
              skinTone: "tan",
              faceShape: "heart",
              eyeColor: "blue",
              eyeShape: "almond",
              hairColor: "blonde",
              hairLength: "long",
              hairStyle: "wavy",
              breastSize: "large",
              buttSize: "large",
              muscleTone: "toned",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "average",
              pubicHair: "trimmed",
              bodyHair: "none",
              tattoos: "few",
              piercings: "ears"
            },
            personality: {
              dominance: 60,
              openness: 70,
              morality: 50,
              confidence: 75,
              intelligence: 50,
              aggression: 40
            },
            background: "tourist",
            skills: { survival: 1, charisma: 3, crafting: 1 }
          }
        },
        {
          name: "Jungle Explorer",
          description: "Athletic researcher with a curious mind",
          character: {
            age: 28,
            gender: "female",
            body: {
              height: "tall",
              build: "athletic",
              skinTone: "olive",
              faceShape: "oval",
              eyeColor: "green",
              eyeShape: "upturned",
              hairColor: "brown",
              hairLength: "shoulder",
              hairStyle: "tied-up",
              breastSize: "medium",
              buttSize: "medium",
              muscleTone: "muscular",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "tight",
              vaginaDepth: "average",
              pubicHair: "natural",
              bodyHair: "minimal",
              tattoos: "none",
              piercings: "none"
            },
            personality: {
              dominance: 55,
              openness: 50,
              morality: 65,
              confidence: 70,
              intelligence: 80,
              aggression: 45
            },
            background: "scientist",
            skills: { survival: 3, medical: 2, crafting: 2 }
          }
        },
        {
          name: "Island Siren",
          description: "Seductive beauty with dangerous charm",
          character: {
            age: 26,
            gender: "female",
            body: {
              height: "average",
              build: "slim",
              skinTone: "fair",
              faceShape: "diamond",
              eyeColor: "hazel",
              eyeShape: "hooded",
              hairColor: "red",
              hairLength: "very-long",
              hairStyle: "straight",
              breastSize: "medium",
              buttSize: "medium",
              muscleTone: "soft",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "deep",
              pubicHair: "none",
              bodyHair: "none",
              tattoos: "many",
              piercings: "multiple"
            },
            personality: {
              dominance: 70,
              openness: 85,
              morality: 30,
              confidence: 85,
              intelligence: 65,
              aggression: 55
            },
            background: "criminal",
            skills: { charisma: 4, combat: 2, survival: 1 }
          }
        }
      ],
      male: [
        {
          name: "Rugged Survivor",
          description: "Strong, capable man built for the wilderness",
          character: {
            age: 32,
            gender: "male",
            body: {
              height: "tall",
              build: "muscular",
              skinTone: "tan",
              faceShape: "square",
              eyeColor: "brown",
              eyeShape: "almond",
              hairColor: "brown",
              hairLength: "short",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "large",
              penisGirth: "thick",
              circumcised: true,
              pubicHair: "trimmed",
              bodyHair: "average",
              tattoos: "few",
              piercings: "none"
            },
            personality: {
              dominance: 70,
              openness: 50,
              morality: 60,
              confidence: 75,
              intelligence: 55,
              aggression: 65
            },
            background: "sailor",
            skills: { survival: 3, combat: 3, crafting: 2 }
          }
        },
        {
          name: "Smooth Talker",
          description: "Charismatic and charming ladies man",
          character: {
            age: 27,
            gender: "male",
            body: {
              height: "average",
              build: "athletic",
              skinTone: "olive",
              faceShape: "oval",
              eyeColor: "blue",
              eyeShape: "upturned",
              hairColor: "black",
              hairLength: "short",
              hairStyle: "styled",
              breastSize: "flat",
              buttSize: "small",
              muscleTone: "toned",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "average",
              penisGirth: "average",
              circumcised: false,
              pubicHair: "trimmed",
              bodyHair: "minimal",
              tattoos: "none",
              piercings: "ears"
            },
            personality: {
              dominance: 50,
              openness: 75,
              morality: 50,
              confidence: 80,
              intelligence: 70,
              aggression: 35
            },
            background: "tourist",
            skills: { charisma: 4, survival: 1, medical: 1 }
          }
        },
        {
          name: "Brutal Fighter",
          description: "Aggressive warrior with no mercy",
          character: {
            age: 35,
            gender: "male",
            body: {
              height: "very-tall",
              build: "muscular",
              skinTone: "brown",
              faceShape: "square",
              eyeColor: "gray",
              eyeShape: "downturned",
              hairColor: "black",
              hairLength: "buzzed",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "very-large",
              penisGirth: "very-thick",
              circumcised: true,
              pubicHair: "natural",
              bodyHair: "hairy",
              tattoos: "many",
              piercings: "body"
            },
            personality: {
              dominance: 90,
              openness: 60,
              morality: 20,
              confidence: 85,
              intelligence: 40,
              aggression: 90
            },
            background: "criminal",
            skills: { combat: 4, survival: 2, leadership: 1 }
          }
        }
      ],
      futanari: [
        {
          name: "Exotic Beauty",
          description: "Stunning futanari with feminine grace and masculine power",
          character: {
            age: 24,
            gender: "futanari",
            body: {
              height: "tall",
              build: "curvy",
              skinTone: "tan",
              faceShape: "heart",
              eyeColor: "amber",
              eyeShape: "almond",
              hairColor: "unusual",
              hairLength: "long",
              hairStyle: "straight",
              breastSize: "large",
              buttSize: "large",
              muscleTone: "toned",
              primaryGenitals: "both",
              secondaryGenitals: null,
              penisSize: "large",
              penisGirth: "thick",
              circumcised: false,
              vaginaTightness: "tight",
              vaginaDepth: "average",
              pubicHair: "trimmed",
              bodyHair: "none",
              tattoos: "few",
              piercings: "multiple"
            },
            personality: {
              dominance: 75,
              openness: 80,
              morality: 50,
              confidence: 80,
              intelligence: 60,
              aggression: 50
            },
            background: "tourist",
            skills: { charisma: 3, survival: 1, combat: 2 }
          }
        }
      ],
      Cuntboy: [
        {
          name: "Tough Guy",
          description: "Masculine build with unexpected anatomy",
          character: {
            age: 29,
            gender: "Cuntboy",
            body: {
              height: "tall",
              build: "muscular",
              skinTone: "fair",
              faceShape: "square",
              eyeColor: "blue",
              eyeShape: "almond",
              hairColor: "blonde",
              hairLength: "short",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "tight",
              vaginaDepth: "shallow",
              pubicHair: "trimmed",
              bodyHair: "average",
              tattoos: "few",
              piercings: "none"
            },
            personality: {
              dominance: 65,
              openness: 55,
              morality: 55,
              confidence: 70,
              intelligence: 50,
              aggression: 70
            },
            background: "sailor",
            skills: { combat: 3, survival: 2, crafting: 2 }
          }
        }
      ],
      other: [
        {
          name: "Mysterious Stranger",
          description: "Androgynous beauty defying categorization",
          character: {
            age: 25,
            gender: "other",
            body: {
              height: "average",
              build: "slim",
              skinTone: "pale",
              faceShape: "oval",
              eyeColor: "heterochromia",
              eyeShape: "round",
              hairColor: "unusual",
              hairLength: "shoulder",
              hairStyle: "wavy",
              breastSize: "small",
              buttSize: "small",
              muscleTone: "soft",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "average",
              pubicHair: "styled",
              bodyHair: "none",
              tattoos: "many",
              piercings: "multiple"
            },
            personality: {
              dominance: 50,
              openness: 70,
              morality: 60,
              confidence: 60,
              intelligence: 75,
              aggression: 40
            },
            background: "scientist",
            skills: { medical: 2, crafting: 2, charisma: 2 }
          }
        }
      ]
    };
  }
  getPresetsForGender(gender) {
    return this.presets[gender] || [];
  }
  applyPreset(gender, presetIndex) {
    const presets = this.getPresetsForGender(gender);
    if (presets[presetIndex]) {
      const preset = JSON.parse(JSON.stringify(presets[presetIndex].character));
      const defaultChar = this.getDefaultCharacter();
      this.currentCharacter = {
        ...defaultChar,
        ...preset,
        skills: {
          ...defaultChar.skills,
          // Start with all 6 skills at 0
          ...preset.skills
          // Override with preset values
        },
        personality: {
          dominance: 50,
          openness: 50,
          morality: 50,
          confidence: 50,
          intelligence: 50,
          aggression: 50
        }
      };
      return true;
    }
    return false;
  }
  setGender(gender) {
    this.currentCharacter.gender = gender;
    if (!this.currentCharacter.name) {
      this.currentCharacter.name = this.getDefaultName(gender);
    }
    if (gender === "male" || gender === "Cuntboy") {
      this.currentCharacter.body.breastSize = "flat";
      this.currentCharacter.body.build = "athletic";
    }
    if (gender === "male") {
      this.currentCharacter.body.primaryGenitals = "penis";
    } else if (gender === "female") {
      this.currentCharacter.body.primaryGenitals = "vagina";
    } else if (gender === "futanari") {
      this.currentCharacter.body.primaryGenitals = "both";
    } else if (gender === "Cuntboy") {
      this.currentCharacter.body.primaryGenitals = "vagina";
    }
  }
  getDefaultName(gender) {
    const defaultNames = {
      female: "Isla",
      male: "Kai",
      futanari: "Sage",
      Cuntboy: "River",
      other: "Quinn"
    };
    return defaultNames[gender] || "Survivor";
  }
  updateAttribute(path, value) {
    const keys = path.split(".");
    let obj = this.currentCharacter;
    for (let i = 0; i < keys.length - 1; i++) {
      obj = obj[keys[i]];
    }
    obj[keys[keys.length - 1]] = value;
    if (path === "background") {
      this.applyBackgroundBonuses(value);
    }
  }
  applyBackgroundBonuses(background) {
    this.backgroundBonuses = {
      survival: 0,
      combat: 0,
      charisma: 0,
      crafting: 0,
      medical: 0,
      leadership: 0
    };
    this.currentCharacter.traits = [];
    const bonuses = {
      tourist: {
        skills: { charisma: 2, crafting: 1 },
        trait: "Quick Learner"
      },
      sailor: {
        skills: { survival: 2, combat: 2 },
        trait: "Sea Legs"
      },
      scientist: {
        skills: { medical: 2, crafting: 2 },
        trait: "Analytical Mind"
      },
      criminal: {
        skills: { combat: 2, charisma: 1, survival: 1 },
        trait: "Streetwise"
      },
      drifter: {
        skills: { survival: 2, crafting: 1, leadership: 1 },
        trait: "Self-Reliant"
      },
      pilot: {
        skills: { crafting: 2, leadership: 1, charisma: 1 },
        trait: "Cool Under Pressure"
      },
      custom: {
        skills: {},
        // No background bonuses
        trait: null
        // No trait
      }
    };
    const bonus = bonuses[background];
    if (bonus) {
      Object.keys(bonus.skills).forEach((skill) => {
        this.backgroundBonuses[skill] = bonus.skills[skill];
      });
      if (bonus.trait) {
        this.currentCharacter.traits.push(bonus.trait);
      }
    }
    this.updateTotalSkills();
  }
  updateTotalSkills() {
    Object.keys(this.currentCharacter.skills).forEach((skill) => {
      const backgroundBonus = this.backgroundBonuses[skill] || 0;
      const manualPoints = this.manualSkillPoints[skill] || 0;
      this.currentCharacter.skills[skill] = backgroundBonus + manualPoints;
    });
  }
  getBackgroundBonuses() {
    return { ...this.backgroundBonuses };
  }
  addManualSkillPoint(skill) {
    const totalManual = Object.values(this.manualSkillPoints).reduce((a, b) => a + b, 0);
    const maxPoints = this.currentCharacter.background === "custom" ? 11 : 7;
    if (totalManual < maxPoints) {
      this.manualSkillPoints[skill]++;
      this.updateTotalSkills();
      return true;
    }
    return false;
  }
  removeManualSkillPoint(skill) {
    if (this.manualSkillPoints[skill] > 0) {
      this.manualSkillPoints[skill]--;
      this.updateTotalSkills();
      return true;
    }
    return false;
  }
  getAttribute(path) {
    const keys = path.split(".");
    let value = this.currentCharacter;
    for (const key of keys) {
      value = value[key];
      if (value === void 0) return null;
    }
    return value;
  }
  // Helper to get display value (use custom text if value is 'custom')
  getDisplayValue(value, customPath) {
    if (value === "custom") {
      const customValue = this.getAttribute(customPath);
      return customValue || "custom";
    }
    return value;
  }
  // Unified method that generates comprehensive character description
  // Used for both preview display AND portrait generation
  generateCharacterDescription() {
    const c = this.currentCharacter;
    const body = c.body;
    const height = this.getDisplayValue(body.height, "body.heightCustom");
    const build = this.getDisplayValue(body.build, "body.buildCustom");
    const skinTone = this.getDisplayValue(body.skinTone, "body.skinToneCustom");
    const faceShape = this.getDisplayValue(body.faceShape, "body.faceShapeCustom");
    const eyeColor = this.getDisplayValue(body.eyeColor, "body.eyeColorCustom");
    const eyeShape = this.getDisplayValue(body.eyeShape, "body.eyeShapeCustom");
    const hairColor = this.getDisplayValue(body.hairColor, "body.hairColorCustom");
    const hairLength = this.getDisplayValue(body.hairLength, "body.hairLengthCustom");
    const hairStyle = this.getDisplayValue(body.hairStyle, "body.hairStyleCustom");
    const breastSize = this.getDisplayValue(body.breastSize, "body.breastSizeCustom");
    const buttSize = this.getDisplayValue(body.buttSize, "body.buttSizeCustom");
    const muscleTone = this.getDisplayValue(body.muscleTone, "body.muscleToneCustom");
    const scars = this.getDisplayValue(body.scars, "body.scarsCustom");
    const scarLocation = this.getDisplayValue(body.scarLocation, "body.scarLocationCustom");
    const freckles = this.getDisplayValue(body.freckles, "body.frecklesCustom");
    const birthmarks = body.birthmarks ? body.birthmarksCustom || "birthmarks" : null;
    const beautyMark = body.beautyMark ? body.beautyMarkCustom || "beauty mark" : null;
    const tattoos = this.getDisplayValue(body.tattoos, "body.tattoosCustom");
    const piercings = this.getDisplayValue(body.piercings, "body.piercingsCustom");
    const pubicHair = this.getDisplayValue(body.pubicHair, "body.pubicHairCustom");
    const bodyHair = this.getDisplayValue(body.bodyHair, "body.bodyHairCustom");
    const distinctiveFeaturesCustom = body.distinctiveFeaturesCustom || "";
    return {
      // Basic info
      age: c.age,
      gender: c.gender,
      name: c.name || "Unnamed",
      // Body
      height,
      build,
      skinTone,
      faceShape,
      eyeColor,
      eyeShape,
      hairColor,
      hairLength,
      hairStyle,
      breastSize,
      buttSize,
      muscleTone,
      // Body hair
      pubicHair,
      bodyHair,
      // Distinctive features
      scars,
      scarLocation,
      freckles,
      birthmarks,
      beautyMark,
      tattoos,
      piercings,
      distinctiveFeaturesCustom,
      // Background
      background: c.background,
      backgroundCustom: body.backgroundCustom || "",
      // Skills and traits
      skills: { ...c.skills },
      traits: [...c.traits]
    };
  }
  // Generate AI portrait prompt from character description
  generatePortraitPrompt() {
    const desc = this.generateCharacterDescription();
    let prompt = `Full body portrait of a ${desc.age} year old ${desc.gender === "other" ? "androgynous person" : desc.gender}, `;
    prompt += `${desc.height} height, ${desc.build} build, ${desc.muscleTone} muscle tone, `;
    prompt += `${desc.skinTone} skin, ${desc.faceShape} face shape, `;
    prompt += `${desc.eyeColor} ${desc.eyeShape} eyes, `;
    prompt += `${desc.hairLength} ${desc.hairStyle} ${desc.hairColor} hair, `;
    if (desc.gender === "female" || desc.gender === "futanari") {
      prompt += `${desc.breastSize} breasts, `;
    }
    prompt += `${desc.buttSize} butt, `;
    if (desc.bodyHair && desc.bodyHair !== "minimal" && desc.bodyHair !== "average") {
      prompt += `${desc.bodyHair} body hair, `;
    }
    if (desc.freckles && desc.freckles !== "none") {
      prompt += `${desc.freckles} freckles, `;
    }
    if (desc.beautyMark) {
      prompt += `${desc.beautyMark}, `;
    }
    if (desc.birthmarks) {
      prompt += `${desc.birthmarks}, `;
    }
    if (desc.scars && desc.scars !== "none") {
      if (desc.scarLocation && desc.scarLocation !== "none") {
        prompt += `${desc.scars} scars on ${desc.scarLocation}, `;
      } else {
        prompt += `${desc.scars} scars, `;
      }
    }
    if (desc.tattoos && desc.tattoos !== "none") {
      prompt += `${desc.tattoos} tattoos, `;
    }
    if (desc.piercings && desc.piercings !== "none") {
      prompt += `${desc.piercings} piercings, `;
    }
    if (desc.distinctiveFeaturesCustom) {
      prompt += `${desc.distinctiveFeaturesCustom}, `;
    }
    prompt += `standing pose, attractive appearance, `;
    prompt += `photorealistic, detailed, high quality, full body shot, natural lighting, `;
    prompt += `isolated on transparent background, no background elements`;
    return prompt;
  }
  async generatePortrait(aiModule, styleOverride = null) {
    const style = styleOverride || "realistic";
    try {
      const prompt = this.generatePortraitPrompt();
      this.currentCharacter.portraitPrompt = prompt;
      const imageUrl = await aiModule.generateImageFromPrompt(prompt, style);
      this.currentCharacter.portraitUrl = imageUrl;
      this.currentCharacter.portraitStyle = style;
      return imageUrl;
    } catch (error) {
      console.error("Failed to generate portrait:", error);
      throw error;
    }
  }
  getCharacter() {
    return JSON.parse(JSON.stringify(this.currentCharacter));
  }
  setCharacter(character) {
    this.currentCharacter = character;
  }
  validateCharacter() {
    const errors = [];
    if (!this.currentCharacter.name || this.currentCharacter.name.trim() === "") {
      errors.push("Character name is required");
    }
    if (this.currentCharacter.age < 18) {
      errors.push("Character must be 18 or older");
    }
    if (!this.currentCharacter.portraitUrl) {
      errors.push("Portrait image is required (click Generate Portrait)");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  randomizeStep(step) {
    const body = this.currentCharacter.body;
    switch (step) {
      case 1:
        const genders = ["female", "male", "futanari", "Cuntboy", "other"];
        const currentIndex = genders.indexOf(this.currentCharacter.gender);
        const nextIndex = (currentIndex + 1) % genders.length;
        this.setGender(genders[nextIndex]);
        break;
      case 3:
        const heights = ["petite", "short", "average", "tall", "very-tall"];
        const builds = ["skinny", "slim", "average", "athletic", "curvy", "muscular", "heavyset"];
        const skins = ["pale", "fair", "tan", "olive", "brown", "dark"];
        const faces = ["oval", "round", "square", "heart", "diamond"];
        const eyeColors = ["brown", "blue", "green", "hazel", "gray", "amber", "heterochromia"];
        const eyeShapes = ["almond", "round", "hooded", "upturned", "downturned"];
        const hairColors = ["black", "brown", "blonde", "red", "auburn", "gray", "white", "unusual"];
        const hairLengths = ["buzzed", "short", "shoulder", "long", "very-long"];
        const hairStyles = ["straight", "wavy", "curly", "kinky", "braided", "tied-up"];
        const breastSizes = ["flat", "small", "medium", "large", "very-large", "huge"];
        const buttSizes = ["small", "medium", "large", "very-large"];
        const muscleTones = ["soft", "toned", "average", "muscular", "very-muscular"];
        const scarsOptions = ["none", "few", "many", "prominent"];
        const frecklesOptions = ["none", "light", "moderate", "heavy"];
        const pubicHairOptions = ["none", "trimmed", "natural", "styled"];
        const bodyHairOptions = ["none", "minimal", "average", "hairy"];
        const tattooOptions = ["none", "few", "many", "custom"];
        const piercingOptions = ["none", "ears", "face", "body", "nipples", "genital", "multiple"];
        body.height = heights[Math.floor(Math.random() * heights.length)];
        body.build = builds[Math.floor(Math.random() * builds.length)];
        body.skinTone = skins[Math.floor(Math.random() * skins.length)];
        body.faceShape = faces[Math.floor(Math.random() * faces.length)];
        body.eyeColor = eyeColors[Math.floor(Math.random() * eyeColors.length)];
        body.eyeShape = eyeShapes[Math.floor(Math.random() * eyeShapes.length)];
        body.hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
        body.hairLength = hairLengths[Math.floor(Math.random() * hairLengths.length)];
        body.hairStyle = hairStyles[Math.floor(Math.random() * hairStyles.length)];
        body.buttSize = buttSizes[Math.floor(Math.random() * buttSizes.length)];
        body.muscleTone = muscleTones[Math.floor(Math.random() * muscleTones.length)];
        body.scars = scarsOptions[Math.floor(Math.random() * scarsOptions.length)];
        body.freckles = frecklesOptions[Math.floor(Math.random() * frecklesOptions.length)];
        body.birthmarks = Math.random() > 0.7;
        body.beautyMark = Math.random() > 0.8;
        body.pubicHair = pubicHairOptions[Math.floor(Math.random() * pubicHairOptions.length)];
        body.bodyHair = bodyHairOptions[Math.floor(Math.random() * bodyHairOptions.length)];
        body.tattoos = tattooOptions[Math.floor(Math.random() * tattooOptions.length)];
        body.piercings = piercingOptions[Math.floor(Math.random() * piercingOptions.length)];
        if (this.currentCharacter.gender === "female" || this.currentCharacter.gender === "futanari") {
          body.breastSize = breastSizes[Math.floor(Math.random() * breastSizes.length)];
        }
        if (body.scars !== "none") {
          const locations = ["face", "chest", "back", "arms", "legs"];
          body.scarLocation = locations[Math.floor(Math.random() * locations.length)];
        } else {
          body.scarLocation = null;
        }
        break;
      case 4:
        const backgrounds = ["tourist", "sailor", "scientist", "criminal", "drifter", "pilot"];
        const currentBg = backgrounds.indexOf(this.currentCharacter.background);
        const nextBg = (currentBg + 1) % backgrounds.length;
        this.setBackground(backgrounds[nextBg]);
        break;
    }
  }
  getPreviewSummary() {
    const desc = this.generateCharacterDescription();
    let descParts = [];
    descParts.push(`${desc.height} ${desc.build} build`);
    descParts.push(`${desc.muscleTone} muscle tone`);
    descParts.push(`${desc.skinTone} skin`);
    descParts.push(`${desc.faceShape} face`);
    descParts.push(`${desc.hairLength} ${desc.hairStyle} ${desc.hairColor} hair`);
    descParts.push(`${desc.eyeColor} ${desc.eyeShape} eyes`);
    if (desc.gender === "female" || desc.gender === "futanari") {
      descParts.push(`${desc.breastSize} breasts`);
    }
    descParts.push(`${desc.buttSize} butt`);
    if (desc.freckles && desc.freckles !== "none") {
      descParts.push(`${desc.freckles} freckles`);
    }
    if (desc.beautyMark) {
      descParts.push(desc.beautyMark);
    }
    if (desc.birthmarks) {
      descParts.push(desc.birthmarks);
    }
    if (desc.scars && desc.scars !== "none") {
      if (desc.scarLocation) {
        descParts.push(`${desc.scars} scars (${desc.scarLocation})`);
      } else {
        descParts.push(`${desc.scars} scars`);
      }
    }
    if (desc.tattoos && desc.tattoos !== "none") {
      descParts.push(`${desc.tattoos} tattoos`);
    }
    if (desc.piercings && desc.piercings !== "none") {
      descParts.push(`${desc.piercings} piercings`);
    }
    if (desc.bodyHair && desc.bodyHair !== "minimal") {
      descParts.push(`${desc.bodyHair} body hair`);
    }
    if (desc.distinctiveFeaturesCustom) {
      descParts.push(desc.distinctiveFeaturesCustom);
    }
    return {
      name: desc.name,
      age: desc.age,
      gender: desc.gender,
      description: descParts.join(", "),
      background: desc.background,
      skills: desc.skills,
      traits: desc.traits
    };
  }
}
class CharacterCreationUI {
  constructor(gameState2, settingsManager2, perchanceAI) {
    this.gameState = gameState2;
    this.settingsManager = settingsManager2;
    this.ai = perchanceAI;
    this.creator = new CharacterCreator();
    this.currentStep = 1;
    this.totalSteps = 5;
    this.usePreset = false;
  }
  show() {
    this.currentStep = 1;
    this.render();
    const mainMenu2 = document.getElementById("main-menu");
    if (mainMenu2) {
      mainMenu2.classList.add("hidden");
    }
    const container = document.getElementById("character-creation");
    container.style.display = "flex";
    container.offsetHeight;
    container.classList.add("active");
    console.log("‚úÖ Character creation UI shown");
  }
  hide() {
    const container = document.getElementById("character-creation");
    container.classList.remove("active");
    setTimeout(() => {
      container.style.display = "none";
    }, 400);
    console.log("‚úÖ Character creation UI hidden");
  }
  render() {
    const container = document.getElementById("character-creation");
    const preview = this.creator.getPreviewSummary();
    container.innerHTML = `
      <div class="char-creation-wrapper">
        <div class="char-creation-container">
          <div class="char-creation-header">
            <h1>Create Your Character</h1>
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${this.currentStep / this.totalSteps * 100}%"></div>
            </div>
            <p class="step-indicator">Step ${this.currentStep} of ${this.totalSteps}</p>
            ${[1, 3, 4].includes(this.currentStep) ? '<button id="randomize-btn" class="btn-randomize" title="Randomize this step">üé≤ Random</button>' : ""}
          </div>
          
          <div class="char-creation-content">
            ${this.renderStep()}
          </div>
          
          <div class="char-creation-footer">
            ${this.currentStep > 1 ? '<button id="prev-step-btn" class="btn-secondary">‚Üê Previous</button>' : ""}
            ${this.currentStep < this.totalSteps ? '<button id="next-step-btn" class="btn-primary">Next ‚Üí</button>' : ""}
            ${this.currentStep === this.totalSteps ? '<button id="confirm-character-btn" class="btn-primary">Start Game ‚Üí</button>' : ""}
          </div>
        </div>
        
        <div class="char-preview-panel">
          <h3>Character Preview</h3>
          <div class="preview-content">
            <div class="preview-field">
              <span class="preview-label">Name:</span>
              <span class="preview-value ${!preview.name || preview.name === "Unnamed" ? "preview-missing" : ""}">${preview.name}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Age:</span>
              <span class="preview-value">${preview.age}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Gender:</span>
              <span class="preview-value">${preview.gender.charAt(0).toUpperCase() + preview.gender.slice(1)}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Description:</span>
              <span class="preview-value">${preview.description || "Not yet defined"}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Background:</span>
              <span class="preview-value">${preview.background.charAt(0).toUpperCase() + preview.background.slice(1)}</span>
            </div>
            
            <div class="preview-section">
              <h4>Skills</h4>
              ${Object.entries(preview.skills).map(([skill, value]) => `
                <div class="preview-skill">
                  <span>${skill.charAt(0).toUpperCase() + skill.slice(1)}</span>
                  <span class="skill-dots">${"‚óè".repeat(value)}${"‚óã".repeat(Math.max(0, 10 - value))}</span>
                </div>
              `).join("")}
            </div>
            
            ${preview.traits.length > 0 ? `
              <div class="preview-section">
                <h4>Traits</h4>
                <div class="preview-traits">
                  ${preview.traits.map((trait) => `<span class="trait-badge">${trait}</span>`).join("")}
                </div>
              </div>
            ` : ""}
          </div>
        </div>
      </div>
    `;
    this.attachEventListeners();
  }
  renderStep() {
    switch (this.currentStep) {
      case 1:
        return this.renderGenderStep();
      case 2:
        return this.renderPresetStep();
      case 3:
        return this.renderAppearanceStep();
      case 4:
        return this.renderBackgroundStep();
      case 5:
        return this.renderPortraitStep();
      default:
        return "";
    }
  }
  renderGenderStep() {
    const currentSeed = this.creator.currentCharacter.mapSeed || "";
    return `
      <div class="step-content">
        <h2>Choose Your Gender</h2>
        <p class="step-description">Select the gender identity for your character</p>
        
        \x3C!-- Map Seed Input -->
        <div style="margin-bottom: 25px; padding: 20px; background: rgba(74, 222, 128, 0.1); border: 2px solid rgba(74, 222, 128, 0.3); border-radius: 12px;">
          <label for="map-seed-input" style="display: block; font-weight: bold; color: #4ade80; margin-bottom: 8px; font-size: 1.1em;">
            üó∫Ô∏è Map Seed (Optional)
          </label>
          <input 
            type="text" 
            id="map-seed-input" 
            value="${currentSeed}"
            placeholder="Leave empty for random seed"
            style="width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.9); border: 2px solid rgba(74, 222, 128, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 1em; font-family: 'Courier New', monospace;"
          />
          <p style="margin-top: 8px; font-size: 0.85em; color: #94a3b8;">
            Enter a seed (text or number) to generate a specific map, or leave blank for a random map. Using the same seed will create the same island layout.
          </p>
        </div>
        
        \x3C!-- Quick Start Button -->
        <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(255, 215, 0, 0.1); border: 2px dashed #ffd700; border-radius: 8px;">
          <button id="quick-start-btn" class="btn-primary" style="font-size: 1.2em; padding: 12px 24px; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); color: #000; font-weight: bold;">
            ‚ö° QUICK START - Skip Character Creation
          </button>
          <p style="margin-top: 10px; font-size: 0.9em; color: #aaa;">(Creates default female character for testing)</p>
        </div>
        
        <div class="gender-options">
          ${this.renderGenderOption("female", "Female", "‚ôÄ", "Feminine body with vagina")}
          ${this.renderGenderOption("male", "Male", "‚ôÇ", "Masculine body with penis")}
          ${this.renderGenderOption("futanari", "Futanari", "‚ö•", "Feminine body with both penis and vagina")}
          ${this.renderGenderOption("Cuntboy", "Cuntboy", "‚ö≤", "Masculine body with vagina")}
          ${this.renderGenderOption("other", "Other/Non-Binary", "‚ö™", "Androgynous or custom configuration")}
        </div>
      </div>
    `;
  }
  renderGenderOption(value, label, symbol, description) {
    const selected = this.creator.currentCharacter.gender === value ? "selected" : "";
    return `
      <div class="gender-card ${selected}" data-gender="${value}">
        <div class="gender-symbol">${symbol}</div>
        <div class="gender-label">${label}</div>
        <div class="gender-description">${description}</div>
      </div>
    `;
  }
  renderPresetStep() {
    const gender = this.creator.currentCharacter.gender;
    const presets = this.creator.getPresetsForGender(gender);
    return `
      <div class="step-content">
        <h2>Choose Creation Method</h2>
        <p class="step-description">Use a preset or customize every detail</p>
        
        <div class="creation-method-options">
          <div class="method-card ${!this.usePreset ? "selected" : ""}" data-method="custom">
            <h3>‚ú® Full Customization</h3>
            <p>Choose every detail of your character's appearance, personality, and background</p>
          </div>
          
          <div class="method-card ${this.usePreset ? "selected" : ""}" data-method="preset">
            <h3>‚ö° Quick Presets</h3>
            <p>Start with a pre-made character template</p>
          </div>
        </div>
        
        ${this.usePreset ? `
          <div class="preset-selection">
            <h3>Select a Preset</h3>
            <div class="preset-options">
              ${presets.map((preset, index) => `
                <div class="preset-card" data-preset="${index}">
                  <h4>${preset.name}</h4>
                  <p>${preset.description}</p>
                </div>
              `).join("")}
            </div>
          </div>
        ` : ""}
      </div>
    `;
  }
  renderAppearanceStep() {
    const body = this.creator.currentCharacter.body;
    const gender = this.creator.currentCharacter.gender;
    return `
      <div class="step-content appearance-step">
        <h2>Customize Appearance</h2>
        <p class="step-description">Design every detail of your character's body</p>
        
        <div class="appearance-sections">
          \x3C!-- Basic Body -->
          <div class="appearance-section">
            <h3>Body Type</h3>
            ${this.renderSelect("body.height", "Height", ["petite", "short", "average", "tall", "very-tall"])}
            ${this.renderSelect("body.build", "Build", ["skinny", "slim", "average", "athletic", "curvy", "muscular", "heavyset"])}
            ${this.renderSelect("body.skinTone", "Skin Tone", ["pale", "fair", "tan", "olive", "brown", "dark"])}
            ${this.renderSelect("body.muscleTone", "Muscle Tone", ["soft", "toned", "average", "muscular", "very-muscular"])}
          </div>
          
          \x3C!-- Face -->
          <div class="appearance-section">
            <h3>Face</h3>
            ${this.renderSelect("body.faceShape", "Face Shape", ["oval", "round", "square", "heart", "diamond"])}
            ${this.renderSelect("body.eyeColor", "Eye Color", ["brown", "blue", "green", "hazel", "gray", "amber", "heterochromia"])}
            ${this.renderSelect("body.eyeShape", "Eye Shape", ["almond", "round", "hooded", "upturned", "downturned"])}
          </div>
          
          \x3C!-- Hair -->
          <div class="appearance-section">
            <h3>Hair</h3>
            ${this.renderSelect("body.hairColor", "Hair Color", ["black", "brown", "blonde", "red", "auburn", "gray", "white", "unusual"])}
            ${this.renderSelect("body.hairLength", "Hair Length", ["buzzed", "short", "shoulder", "long", "very-long"])}
            ${this.renderSelect("body.hairStyle", "Hair Style", ["straight", "wavy", "curly", "kinky", "braided", "tied-up"])}
          </div>
          
          \x3C!-- Body Features -->
          <div class="appearance-section">
            <h3>Body Features</h3>
            ${gender === "female" || gender === "futanari" ? this.renderSelect("body.breastSize", "Breast Size", ["flat", "small", "medium", "large", "very-large", "huge"]) : ""}
            ${this.renderSelect("body.buttSize", "Butt Size", ["small", "medium", "large", "very-large"])}
            ${this.renderSelect("body.pubicHair", "Pubic Hair", ["none", "trimmed", "natural", "styled"])}
            ${this.renderSelect("body.bodyHair", "Body Hair", ["none", "minimal", "average", "hairy"])}
            ${this.renderSelect("body.tattoos", "Tattoos", ["none", "few", "many", "custom"])}
            ${this.renderSelect("body.piercings", "Piercings", ["none", "ears", "face", "body", "nipples", "genital", "multiple"])}
          </div>
          
          \x3C!-- Distinctive Features -->
          <div class="appearance-section">
            <h3>Distinctive Features</h3>
            ${this.renderSelect("body.scars", "Scars", ["none", "few", "many", "prominent"])}
            ${body.scars !== "none" && body.scars !== "custom" ? this.renderSelect("body.scarLocation", "Scar Location", ["face", "chest", "back", "arms", "legs"]) : ""}
            ${this.renderSelect("body.freckles", "Freckles", ["none", "light", "moderate", "heavy"])}
            ${this.renderCheckbox("body.birthmarks", "Has Birthmark(s)", true)}
            ${this.renderCheckbox("body.beautyMark", "Has Beauty Mark", true)}
            
            <div class="form-group">
              <label>Additional Distinctive Features</label>
              <input type="text" 
                     class="custom-text-input" 
                     data-path="body.distinctiveFeaturesCustom" 
                     value="${this.creator.currentCharacter.body.distinctiveFeaturesCustom || ""}" 
                     placeholder="e.g., Unique eyes, distinctive voice, unusual marking...">
              <small style="color: #aaa; font-size: 0.85rem;">Optional: Add any unique features not covered above</small>
            </div>
          </div>
          
          \x3C!-- Sexual Experience -->
          <div class="appearance-section">
            <h3>Sexual Experience</h3>
            ${this.renderSelect("sexualProfile.experience", "Overall Experience", ["virgin", "inexperienced", "experienced", "veteran"])}
            ${this.renderSelect("sexualProfile.preferredRole", "Preferred Role", ["dominant", "submissive", "versatile", "switch"])}
          </div>
          
          \x3C!-- Genitals (Explicit) -->
          <div class="appearance-section explicit-section">
            <h3>‚ö†Ô∏è Genital Customization (Explicit)</h3>
            ${this.renderGenitalOptions()}
          </div>
        </div>
      </div>
    `;
  }
  renderGenitalOptions() {
    const gender = this.creator.currentCharacter.gender;
    const body = this.creator.currentCharacter.body;
    let html = "";
    if (gender === "male" || gender === "futanari" || body.primaryGenitals === "penis" || body.primaryGenitals === "both") {
      html += `
        <div class="genital-subsection">
          <h4>Penis Details</h4>
          ${this.renderSelect("body.penisSize", "Size", ["small", "average", "large", "very-large", "huge"])}
          ${this.renderSelect("body.penisGirth", "Girth", ["thin", "average", "thick", "very-thick"])}
          ${this.renderCheckbox("body.circumcised", "Circumcised")}
        </div>
      `;
    }
    if (gender === "female" || gender === "Cuntboy" || gender === "futanari" || body.primaryGenitals === "vagina" || body.primaryGenitals === "both") {
      html += `
        <div class="genital-subsection">
          <h4>Vagina Details</h4>
          ${this.renderSelect("body.vaginaTightness", "Tightness", ["tight", "average", "loose"])}
          ${this.renderSelect("body.vaginaDepth", "Depth", ["shallow", "average", "deep"])}
        </div>
      `;
    }
    return html;
  }
  renderPersonalityStep() {
    return `
      <div class="step-content personality-step">
        <h2>Define Personality</h2>
        <p class="step-description">Shape your character's behavior and attitudes</p>
        
        <div class="personality-sliders">
          ${this.renderSlider("personality.dominance", "Dominance", "Submissive", "Dominant")}
          ${this.renderSlider("personality.openness", "Sexual Openness", "Reserved", "Promiscuous")}
          ${this.renderSlider("personality.morality", "Morality", "Cruel", "Kind")}
          ${this.renderSlider("personality.confidence", "Confidence", "Shy", "Confident")}
          ${this.renderSlider("personality.intelligence", "Intelligence", "Simple", "Clever")}
          ${this.renderSlider("personality.aggression", "Aggression", "Passive", "Aggressive")}
        </div>
        
        <div class="sexual-preferences">
          <h3>Sexual Experience</h3>
          ${this.renderSelect("preferences.experience", "Experience Level", ["virgin", "inexperienced", "experienced", "expert", "veteran"])}
        </div>
      </div>
    `;
  }
  renderBackgroundStep() {
    return `
      <div class="step-content background-step">
        <h2>Character Background</h2>
        <p class="step-description">Define your character's name, age, and past life before becoming a castaway</p>
        
        <div class="background-form">
          <div class="form-group">
            <label for="char-name">Name</label>
            <input type="text" id="char-name" class="text-input" value="${this.creator.currentCharacter.name}" placeholder="Enter character name">
          </div>
          
          <div class="form-group">
            <label for="char-age">Age (18+)</label>
            <input type="number" id="char-age" class="text-input" min="18" max="99" value="${this.creator.currentCharacter.age}">
          </div>
          
          <div class="form-group">
            <label for="char-background">Previous Life</label>
            ${this.renderSelect("background", "Who were you before you ended up here?", [
      "tourist",
      "sailor",
      "scientist",
      "criminal",
      "drifter",
      "pilot"
    ])}
            <p class="background-description">${this.getBackgroundDescription()}</p>
          </div>
          
          <div class="skills-allocation">
            <h3>Starting Skills</h3>
            <p class="skills-info">Your background determines your starting skill bonuses</p>
            ${this.renderSkillPoints()}
          </div>
        </div>
      </div>
    `;
  }
  renderPortraitStep() {
    const character = this.creator.currentCharacter;
    const preview = this.creator.getPreviewSummary();
    return `
      <div class="step-content portrait-step">
        <h2>Generate Portrait</h2>
        <p class="step-description">Create an AI-generated image of your character based on your choices</p>
        
        <div class="portrait-container">
          <div class="portrait-preview">
            ${character.portraitUrl ? `<img src="${character.portraitUrl}" alt="Character Portrait" class="portrait-image">` : `<div class="portrait-placeholder">
                <div class="placeholder-icon">üë§</div>
                <p>No portrait generated yet</p>
              </div>`}
          </div>
          
          <div class="portrait-controls">
            <button id="generate-portrait-btn" class="btn-primary">
              ${character.portraitUrl ? "üîÑ Regenerate Portrait" : "‚ú® Generate Portrait"}
            </button>
            
            <div class="portrait-info">
              <h4>Character Description</h4>
              <p class="character-description">${preview.description}</p>
              ${character.portraitPrompt ? `
                <details class="prompt-details">
                  <summary>View Full AI Prompt</summary>
                  <p class="prompt-preview">${character.portraitPrompt}</p>
                </details>
              ` : ""}
              ${character.portraitUrl ? '<p class="success-msg">‚úì Portrait generated successfully!</p>' : ""}
            </div>
          </div>
        </div>
      </div>
    `;
  }
  // Helper render methods
  renderSelect(path, label, options, allowCustom = true) {
    const value = this.creator.getAttribute(path);
    const customPath = path + "Custom";
    const customValue = this.creator.getAttribute(customPath) || "";
    if (allowCustom && !options.includes("custom")) {
      options = [...options, "custom"];
    }
    return `
      <div class="form-group">
        <label>${label}</label>
        <select class="char-select" data-path="${path}">
          ${options.map((opt) => `
            <option value="${opt}" ${value === opt ? "selected" : ""}>
              ${opt.replace("-", " ").replace(/\b\w/g, (l) => l.toUpperCase())}
            </option>
          `).join("")}
        </select>
        ${value === "custom" ? `
          <input type="text" 
                 class="custom-text-input" 
                 data-path="${customPath}" 
                 value="${customValue}" 
                 placeholder="Enter custom ${label.toLowerCase()}...">
        ` : ""}
      </div>
    `;
  }
  renderSlider(path, label, minLabel, maxLabel) {
    const value = this.creator.getAttribute(path);
    return `
      <div class="slider-group">
        <label>${label}</label>
        <div class="slider-labels">
          <span>${minLabel}</span>
          <span>${maxLabel}</span>
        </div>
        <input type="range" min="0" max="100" value="${value}" class="char-slider" data-path="${path}">
        <div class="slider-value">${value}</div>
      </div>
    `;
  }
  renderCheckbox(path, label, allowCustom = false) {
    const value = this.creator.getAttribute(path);
    const customPath = path + "Custom";
    const customValue = this.creator.getAttribute(customPath) || "";
    return `
      <div class="checkbox-group">
        <label>
          <input type="checkbox" 
                 class="char-checkbox" 
                 data-path="${path}" 
                 data-allow-custom="${allowCustom}"
                 ${value ? "checked" : ""}>
          ${label}
        </label>
        ${allowCustom && value ? `
          <input type="text" 
                 class="custom-text-input" 
                 data-path="${customPath}" 
                 value="${customValue}" 
                 placeholder="Describe ${label.toLowerCase()}...">
        ` : ""}
      </div>
    `;
  }
  renderSkillPoints() {
    const skills = this.creator.currentCharacter.skills;
    const backgroundBonuses = this.creator.getBackgroundBonuses();
    const manualPoints = {};
    Object.keys(skills).forEach((skill) => {
      const bonus = backgroundBonuses[skill] || 0;
      manualPoints[skill] = skills[skill] - bonus;
    });
    const totalManual = Object.values(manualPoints).reduce((a, b) => a + b, 0);
    const maxPoints = this.creator.currentCharacter.background === "custom" ? 11 : 7;
    const remaining = maxPoints - totalManual;
    return `
      <div class="skills-remaining">Manual Points Remaining: <strong>${remaining}</strong> / ${maxPoints}</div>
      <div class="skills-grid">
        ${Object.keys(skills).map((skill) => {
      const bonus = backgroundBonuses[skill] || 0;
      return `
            <div class="skill-item">
              <label>${skill.replace(/\b\w/g, (l) => l.toUpperCase())}</label>
              <div class="skill-breakdown">
                ${bonus > 0 ? `<span class="skill-bonus">+${bonus} (background)</span>` : ""}
              </div>
              <div class="skill-controls">
                <button type="button" class="skill-btn" data-skill="${skill}" data-action="decrease">‚àí</button>
                <span class="skill-value">${skills[skill]}</span>
                <button type="button" class="skill-btn" data-skill="${skill}" data-action="increase">+</button>
              </div>
            </div>
          `;
    }).join("")}
      </div>
    `;
  }
  getBackgroundDescription() {
    const backgrounds = {
      tourist: "You were on vacation when disaster struck. Resourceful but unprepared. +2 Charisma, +1 Crafting. Trait: Quick Learner",
      sailor: "Experienced seafarer who knows the ocean well. Strong and capable. +2 Survival, +2 Combat. Trait: Sea Legs",
      scientist: "Here on a research expedition. Intelligent and analytical. +2 Medical, +2 Crafting. Trait: Analytical Mind",
      criminal: "Fleeing the law when you crashed. Street-smart and dangerous. +2 Combat, +1 Charisma, +1 Survival. Trait: Streetwise",
      drifter: "Wanderer with no roots, used to hardship and solitude. +2 Survival, +1 Crafting, +1 Leadership. Trait: Self-Reliant",
      pilot: "Your plane went down. Technical skills and leadership. +2 Crafting, +1 Leadership, +1 Charisma. Trait: Cool Under Pressure",
      custom: "Create your own unique background story. No preset bonuses or trait, but you get 11 skill points to allocate freely (instead of 7)!"
    };
    return backgrounds[this.creator.currentCharacter.background] || "";
  }
  attachEventListeners() {
    const nextBtn = document.getElementById("next-step-btn");
    const prevBtn = document.getElementById("prev-step-btn");
    const confirmBtn = document.getElementById("confirm-character-btn");
    const randomizeBtn = document.getElementById("randomize-btn");
    const quickStartBtn = document.getElementById("quick-start-btn");
    if (nextBtn) nextBtn.addEventListener("click", () => this.nextStep());
    if (prevBtn) prevBtn.addEventListener("click", () => this.prevStep());
    if (confirmBtn) confirmBtn.addEventListener("click", () => this.confirmCharacter());
    if (randomizeBtn) {
      randomizeBtn.addEventListener("click", () => {
        this.creator.randomizeStep(this.currentStep);
        this.render();
      });
    }
    if (quickStartBtn) {
      quickStartBtn.addEventListener("click", () => this.quickStart());
    }
    const mapSeedInput = document.getElementById("map-seed-input");
    if (mapSeedInput) {
      mapSeedInput.addEventListener("input", (e) => {
        this.creator.currentCharacter.mapSeed = e.target.value.trim();
        console.log("Map seed set to:", this.creator.currentCharacter.mapSeed || "(random)");
      });
    }
    document.querySelectorAll(".gender-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const gender = e.currentTarget.dataset.gender;
        this.creator.setGender(gender);
        this.render();
      });
    });
    document.querySelectorAll(".method-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const method = e.currentTarget.dataset.method;
        this.usePreset = method === "preset";
        this.render();
      });
    });
    document.querySelectorAll(".preset-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const presetIndex = parseInt(e.currentTarget.dataset.preset);
        const gender = this.creator.currentCharacter.gender;
        this.creator.applyPreset(gender, presetIndex);
        this.render();
      });
    });
    document.querySelectorAll(".char-select").forEach((select) => {
      select.addEventListener("change", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.value);
        const formGroup = e.target.closest(".form-group");
        const existingCustomInput = formGroup.querySelector(".custom-text-input");
        if (e.target.value === "custom" && !existingCustomInput) {
          const customPath = e.target.dataset.path + "Custom";
          const customValue = this.creator.getAttribute(customPath) || "";
          const label = formGroup.querySelector("label").textContent;
          const customInput = document.createElement("input");
          customInput.type = "text";
          customInput.className = "custom-text-input";
          customInput.dataset.path = customPath;
          customInput.value = customValue;
          customInput.placeholder = `Enter custom ${label.toLowerCase()}...`;
          customInput.addEventListener("input", (e2) => {
            this.creator.updateAttribute(e2.target.dataset.path, e2.target.value);
            this.updatePreview();
          });
          e.target.parentNode.appendChild(customInput);
          customInput.focus();
        } else if (e.target.value !== "custom" && existingCustomInput) {
          existingCustomInput.remove();
        }
        this.updatePreview();
        e.target.dataset.lastValue = e.target.value;
      });
    });
    document.querySelectorAll(".char-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.checked);
        const checkboxGroup = e.target.closest(".checkbox-group");
        const existingCustomInput = checkboxGroup.querySelector(".custom-text-input");
        const allowCustom = e.target.dataset.allowCustom === "true";
        if (e.target.checked && allowCustom && !existingCustomInput) {
          const customPath = e.target.dataset.path + "Custom";
          const customValue = this.creator.getAttribute(customPath) || "";
          const label = checkboxGroup.querySelector("label").textContent.trim();
          const customInput = document.createElement("input");
          customInput.type = "text";
          customInput.className = "custom-text-input";
          customInput.dataset.path = customPath;
          customInput.value = customValue;
          customInput.placeholder = `Describe ${label.toLowerCase()}...`;
          customInput.addEventListener("input", (e2) => {
            this.creator.updateAttribute(e2.target.dataset.path, e2.target.value);
            this.updatePreview();
          });
          checkboxGroup.appendChild(customInput);
          customInput.focus();
        } else if (!e.target.checked && existingCustomInput) {
          existingCustomInput.remove();
        }
        this.updatePreview();
      });
    });
    document.querySelectorAll(".custom-text-input").forEach((input) => {
      input.addEventListener("input", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.value);
        this.updatePreview();
      });
    });
    document.querySelectorAll(".char-slider").forEach((slider) => {
      slider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        this.creator.updateAttribute(e.target.dataset.path, value);
        e.target.nextElementSibling.textContent = value;
      });
    });
    const nameInput = document.getElementById("char-name");
    const ageInput = document.getElementById("char-age");
    if (nameInput) {
      nameInput.addEventListener("input", (e) => {
        this.creator.updateAttribute("name", e.target.value);
        this.updatePreview();
      });
    }
    if (ageInput) {
      ageInput.addEventListener("change", (e) => {
        const age = Math.max(18, parseInt(e.target.value));
        this.creator.updateAttribute("age", age);
        e.target.value = age;
        this.updatePreview();
      });
    }
    document.querySelectorAll(".skill-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const skill = e.target.dataset.skill;
        const action = e.target.dataset.action;
        let changed = false;
        if (action === "increase") {
          changed = this.creator.addManualSkillPoint(skill);
        } else if (action === "decrease") {
          changed = this.creator.removeManualSkillPoint(skill);
        }
        if (changed) {
          this.updateSkillsDisplay();
        }
      });
    });
    const generateBtn = document.getElementById("generate-portrait-btn");
    if (generateBtn) {
      generateBtn.addEventListener("click", async () => {
        generateBtn.disabled = true;
        generateBtn.textContent = "‚è≥ Generating...";
        try {
          await this.creator.generatePortrait(this.ai);
          this.render();
        } catch (error) {
          alert("Failed to generate portrait. Please try again.");
          console.error(error);
        }
      });
    }
  }
  nextStep() {
    if (this.currentStep < this.totalSteps) {
      this.currentStep++;
      this.render();
    }
  }
  prevStep() {
    if (this.currentStep > 1) {
      this.currentStep--;
      this.render();
    }
  }
  async confirmCharacter() {
    const validation = this.creator.validateCharacter();
    if (!validation.valid) {
      alert("Please complete all required fields:\n" + validation.errors.join("\n"));
      return;
    }
    const character = this.creator.getCharacter();
    this.gameState.state.player = {
      ...this.gameState.state.player,
      ...character
    };
    this.hide();
    this.gameState.emit("characterCreated", character);
  }
  /**
   * Quick Start - Creates a default character and skips all creation steps
   * Perfect for testing and development
   */
  quickStart() {
    console.log("‚ö° Quick Start activated - Creating default character");
    this.creator.setGender("female");
    this.creator.applyPreset("female", 0);
    this.creator.updateAttribute("name", "Tori");
    this.creator.updateAttribute("age", 25);
    this.creator.updateAttribute("background", "tourist");
    this.creator.applyBackgroundBonuses();
    this.creator.updateAttribute("portraitUrl", 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><rect fill="%23f0f0f0" width="200" height="200"/><text x="50%" y="50%" font-size="100" text-anchor="middle" dy=".3em">üèùÔ∏è</text></svg>');
    this.creator.updateAttribute("portraitPrompt", "Quick start character - no AI generation");
    const validation = this.creator.validateCharacter();
    if (!validation.valid) {
      console.error("Quick start character failed validation:", validation.errors);
      alert("Quick start failed. Please create character manually.");
      return;
    }
    const character = this.creator.getCharacter();
    this.gameState.state.player = {
      ...this.gameState.state.player,
      ...character
    };
    console.log("‚úÖ Quick start character created:", character.name);
    this.hide();
    this.gameState.emit("characterCreated", character);
  }
  updateSkillsDisplay() {
    const skillsContainer = document.querySelector(".skills-allocation");
    if (skillsContainer) {
      const newSkillsHTML = `
        <h3>Starting Skills</h3>
        <p class="skills-info">Your background determines your starting skill bonuses</p>
        ${this.renderSkillPoints()}
      `;
      skillsContainer.innerHTML = newSkillsHTML;
      skillsContainer.querySelectorAll(".skill-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const skill = e.target.dataset.skill;
          const action = e.target.dataset.action;
          let changed = false;
          if (action === "increase") {
            changed = this.creator.addManualSkillPoint(skill);
          } else if (action === "decrease") {
            changed = this.creator.removeManualSkillPoint(skill);
          }
          if (changed) {
            this.updateSkillsDisplay();
            this.updatePreview();
          }
        });
      });
    }
  }
  updatePreview() {
    const previewPanel = document.querySelector(".char-preview-panel");
    if (!previewPanel) return;
    const preview = this.creator.getPreviewSummary();
    const previewContent = previewPanel.querySelector(".preview-content");
    if (previewContent) {
      previewContent.innerHTML = `
        <div class="preview-field">
          <span class="preview-label">Name:</span>
          <span class="preview-value ${!preview.name || preview.name === "Unnamed" ? "preview-missing" : ""}">${preview.name}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Age:</span>
          <span class="preview-value">${preview.age}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Gender:</span>
          <span class="preview-value">${preview.gender.charAt(0).toUpperCase() + preview.gender.slice(1)}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Description:</span>
          <span class="preview-value">${preview.description || "Not yet defined"}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Background:</span>
          <span class="preview-value">${preview.background.charAt(0).toUpperCase() + preview.background.slice(1)}</span>
        </div>
        
        <div class="preview-section">
          <h4>Skills</h4>
          ${Object.entries(preview.skills).map(([skill, value]) => `
            <div class="preview-skill">
              <span>${skill.charAt(0).toUpperCase() + skill.slice(1)}</span>
              <span class="skill-dots">${"‚óè".repeat(value)}${"‚óã".repeat(Math.max(0, 10 - value))}</span>
            </div>
          `).join("")}
        </div>
        
        ${preview.traits.length > 0 ? `
          <div class="preview-section">
            <h4>Traits</h4>
            <div class="preview-traits">
              ${preview.traits.map((trait) => `<span class="trait-badge">${trait}</span>`).join("")}
            </div>
          </div>
        ` : ""}
      `;
    }
  }
}
class StoryIntro {
  constructor(gameState2) {
    this.gameState = gameState2;
    this.currentScene = 0;
    this.currentLine = 0;
    this.scenes = this.getIntroScenes();
    this.keyHandler = null;
  }
  getIntroScenes() {
    return [
      // Scene 1: Pre-crash tension
      {
        background: "#1a1a1a",
        lines: [
          "Flight 447 to Fiji.",
          "You settle into your seat, earbuds in, ready for a long flight.",
          "The vacation of a lifetime awaits.",
          "Or so you thought..."
        ]
      },
      // Scene 2: Turbulence begins
      {
        background: "linear-gradient(180deg, #1a1a1a 0%, #2d3561 100%)",
        lines: [
          "Three hours in, the plane shudders.",
          "Once. Twice.",
          "The seatbelt sign dings on.",
          `"This is your captain speaking. We're experiencing some unexpected turbulence..."`
        ]
      },
      // Scene 3: Disaster strikes
      {
        background: "linear-gradient(180deg, #2d3561 0%, #5e0000 100%)",
        lines: [
          "BANG!",
          "The plane lurches violently to the left.",
          "Screams fill the cabin.",
          "Oxygen masks drop from above.",
          '"BRACE FOR IMPACT!"'
        ]
      },
      // Scene 4: The crash
      {
        background: "#000",
        lines: [
          "The world spins.",
          "Metal tears. Glass shatters.",
          "A deafening roar.",
          "",
          "Then... nothing."
        ]
      },
      // Scene 5: Underwater struggle
      {
        background: "linear-gradient(180deg, #000428 0%, #004e92 100%)",
        lines: [
          "Cold.",
          "Pressure.",
          "Salt water burns your throat.",
          "Your eyes snap open.",
          "You're underwater. The plane is sinking."
        ]
      },
      // Scene 6: Swimming to surface
      {
        background: "linear-gradient(180deg, #004e92 0%, #0066cc 100%)",
        lines: [
          "Kick. Swim. Survive.",
          "Your lungs scream for air.",
          "Light above. Keep going.",
          "Almost there...",
          "GASP!"
        ]
      },
      // Scene 7: Ocean survival
      {
        background: "linear-gradient(180deg, #0066cc 0%, #00aaff 100%)",
        lines: [
          "You break the surface, gasping for air.",
          "Debris floats everywhere. People crying out.",
          "You grab onto a piece of the fuselage.",
          "In the distance... an island.",
          "You have to swim. It's your only chance."
        ]
      },
      // Scene 8: The swim
      {
        background: "linear-gradient(180deg, #00aaff 0%, #44bbff 100%)",
        lines: [
          "You swim.",
          "Every stroke burns.",
          "The island grows closer.",
          "Don't give up.",
          "Just a little further..."
        ]
      },
      // Scene 9: Beach arrival
      {
        background: "linear-gradient(135deg, #c9d6ff 0%, #e2e2e2 100%)",
        lines: [
          "Your hand touches sand.",
          "You crawl onto the beach.",
          "Your body collapses.",
          "The sun beats down on your back.",
          "Everything fades to black."
        ]
      },
      // Scene 10: Waking up
      {
        background: "linear-gradient(135deg, #f4e4c1 0%, #ffd89b 100%)",
        lines: [
          "How long were you out?",
          "The sun is lower now. Late afternoon.",
          "You push yourself to your knees.",
          "Your entire body aches.",
          "But you're alive."
        ]
      },
      // Scene 11: Taking stock
      {
        background: "linear-gradient(135deg, #ffd89b 0%, #ffb347 100%)",
        lines: [
          "You look around.",
          "A pristine beach. Untouched jungle beyond.",
          "No signs of civilization.",
          "No rescue in sight.",
          "You're completely alone."
        ]
      },
      // Scene 12: Title reveal
      {
        background: "linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%)",
        lines: [
          "Welcome to paradise.",
          "",
          "HEDONISM ISLAND",
          "",
          "Your survival begins now."
        ]
      }
    ];
  }
  show() {
    const container = document.getElementById("story-intro");
    if (!container) {
      console.error("Story intro container not found");
      return;
    }
    container.classList.remove("hidden");
    container.innerHTML = `
      <div class="vn-container">
        <div class="vn-background" id="vn-background"></div>
        <div class="vn-textbox">
          <div class="vn-text" id="vn-text"></div>
          <div class="vn-continue">‚ñº Click to continue</div>
        </div>
        <button class="vn-skip" id="vn-skip">Skip Intro</button>
      </div>
    `;
    this.currentScene = 0;
    this.currentLine = 0;
    this.showScene();
    this.attachEventListeners();
  }
  hide() {
    const container = document.getElementById("story-intro");
    if (container) {
      container.classList.add("hidden");
      container.innerHTML = "";
    }
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
      this.keyHandler = null;
    }
  }
  showScene() {
    if (this.currentScene >= this.scenes.length) {
      this.complete();
      return;
    }
    const scene = this.scenes[this.currentScene];
    const background = document.getElementById("vn-background");
    if (background) {
      background.style.backgroundColor = scene.background;
    }
    this.showLine();
  }
  showLine() {
    const scene = this.scenes[this.currentScene];
    const textEl = document.getElementById("vn-text");
    if (!textEl) return;
    if (this.currentLine >= scene.lines.length) {
      this.currentScene++;
      this.currentLine = 0;
      if (this.currentScene >= this.scenes.length) {
        this.complete();
        return;
      }
      const bg = document.getElementById("vn-background");
      if (bg) {
        bg.style.opacity = "0";
        setTimeout(() => {
          this.showScene();
          bg.style.opacity = "1";
        }, 500);
      } else {
        this.showScene();
      }
      return;
    }
    const line = scene.lines[this.currentLine];
    textEl.style.opacity = "0";
    setTimeout(() => {
      textEl.textContent = line;
      textEl.style.opacity = "1";
    }, 100);
  }
  advance() {
    this.currentLine++;
    this.showLine();
  }
  complete() {
    console.log("‚úÖ Story intro complete");
    this.hide();
    this.gameState.emit("introComplete");
  }
  attachEventListeners() {
    const container = document.getElementById("story-intro");
    if (!container) return;
    const textbox = container.querySelector(".vn-textbox");
    if (textbox) {
      textbox.addEventListener("click", () => this.advance());
    }
    const skipBtn = document.getElementById("vn-skip");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => this.complete());
    }
    this.keyHandler = (e) => {
      if (e.key === "Escape") {
        this.complete();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
}
class TerrainTextureGenerator {
  constructor() {
    this.noiseCache = /* @__PURE__ */ new Map();
  }
  /**
   * Generate noise value for a specific position
   * Uses simple pseudo-random based on coordinates
   */
  noise(x, y, seed = 0) {
    const key = `${x},${y},${seed}`;
    if (this.noiseCache.has(key)) {
      return this.noiseCache.get(key);
    }
    let n = Math.sin(x * 12.9898 + y * 78.233 + seed * 43758.5453) * 43758.5453;
    n = n - Math.floor(n);
    this.noiseCache.set(key, n);
    return n;
  }
  /**
   * Get texture pattern for terrain type at specific hex coordinates
   * Returns { color, alpha } for overlay on base terrain
   */
  getTexturePattern(terrain, q, r, scale = 1) {
    const patterns = [];
    switch (terrain) {
      case "forest":
      case "rainforest":
        for (let i = 0; i < 8; i++) {
          const noise = this.noise(q, r, i * 10);
          if (noise > 0.7) {
            patterns.push({
              x: (noise * 30 - 15) / scale,
              y: (this.noise(q, r, i * 10 + 1) * 30 - 15) / scale,
              size: 2 + this.noise(q, r, i * 10 + 2) * 3,
              color: terrain === "rainforest" ? "#0f3d0f" : "#1a5c1a",
              alpha: 0.4
            });
          }
        }
        break;
      case "jungle-hill":
        for (let i = 0; i < 12; i++) {
          const noise = this.noise(q, r, i * 7);
          if (noise > 0.6) {
            patterns.push({
              x: (noise * 35 - 17.5) / scale,
              y: (this.noise(q, r, i * 7 + 1) * 35 - 17.5) / scale,
              size: 1.5 + this.noise(q, r, i * 7 + 2) * 2.5,
              color: "#2d5016",
              alpha: 0.5
            });
          }
        }
        break;
      case "beach":
        for (let i = 0; i < 15; i++) {
          const noise = this.noise(q, r, i * 5);
          if (noise > 0.5) {
            patterns.push({
              x: (noise * 40 - 20) / scale,
              y: (this.noise(q, r, i * 5 + 1) * 40 - 20) / scale,
              size: 0.8 + this.noise(q, r, i * 5 + 2) * 1.2,
              color: "#ffffff",
              alpha: 0.15
            });
          }
        }
        break;
      case "rocky-peak":
      case "misty-peak":
        for (let i = 0; i < 10; i++) {
          const noise = this.noise(q, r, i * 8);
          if (noise > 0.65) {
            patterns.push({
              x: (noise * 30 - 15) / scale,
              y: (this.noise(q, r, i * 8 + 1) * 30 - 15) / scale,
              size: 2 + this.noise(q, r, i * 8 + 2) * 4,
              color: "#3d3d3d",
              alpha: 0.3,
              angular: true
            });
          }
        }
        break;
      case "savanna":
      case "dry-hill":
        for (let i = 0; i < 12; i++) {
          const noise = this.noise(q, r, i * 6);
          if (noise > 0.6) {
            patterns.push({
              x: (noise * 35 - 17.5) / scale,
              y: (this.noise(q, r, i * 6 + 1) * 35 - 17.5) / scale,
              size: 1 + this.noise(q, r, i * 6 + 2) * 2,
              color: "#a67c52",
              alpha: 0.25
            });
          }
        }
        break;
      case "mangrove":
        for (let i = 0; i < 8; i++) {
          const noise = this.noise(q, r, i * 9);
          if (noise > 0.68) {
            patterns.push({
              x: (noise * 32 - 16) / scale,
              y: (this.noise(q, r, i * 9 + 1) * 32 - 16) / scale,
              size: 2.5 + this.noise(q, r, i * 9 + 2) * 3,
              color: "#0a1f0a",
              alpha: 0.5
            });
          }
        }
        break;
      case "palm-grove":
        for (let i = 0; i < 6; i++) {
          const noise = this.noise(q, r, i * 11);
          if (noise > 0.72) {
            patterns.push({
              x: (noise * 28 - 14) / scale,
              y: (this.noise(q, r, i * 11 + 1) * 28 - 14) / scale,
              size: 2.5 + this.noise(q, r, i * 11 + 2) * 2,
              color: "#6ee700",
              alpha: 0.4
            });
          }
        }
        break;
    }
    return patterns;
  }
  /**
   * Calculate hillshading value based on elevation and neighboring tiles
   * Simulates light from NW direction
   */
  calculateHillshade(elevation, qOffset = 0, rOffset = 0, neighborElevation = null) {
    if (!neighborElevation) return 0;
    const slope = elevation - neighborElevation;
    const lightAngle = qOffset + rOffset;
    return slope * lightAngle * 0.15;
  }
  /**
   * Get elevation-based color gradient
   * Returns brightness multiplier (0.6 - 1.4)
   */
  getElevationBrightness(elevation, minElev = 0, maxElev = 1) {
    if (elevation === void 0 || elevation === null || isNaN(elevation)) {
      return 1;
    }
    if (minElev === maxElev) {
      return 1;
    }
    const normalized = (elevation - minElev) / (maxElev - minElev);
    const clamped = Math.max(0, Math.min(1, normalized));
    const brightness = 0.6 + Math.pow(clamped, 0.8) * 0.8;
    return brightness;
  }
}
class MapRenderer {
  constructor(canvas, hexGrid) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.hexGrid = hexGrid;
    this.textureGenerator = new TerrainTextureGenerator();
    this.offsetX = 0;
    this.offsetY = 0;
    this.scale = 1;
    this.fogOfWarEnabled = false;
    this.terrainColors = {
      // WATER/COAST
      "sea": "#1e3a8a",
      // Deep blue
      "beach": "#f4e4c1",
      // Sandy beige
      "cliff": "#57534e",
      // Warm grey
      "river": "#3b82f6",
      // Bright blue
      // LOWLANDS
      "savanna": "#d4b896",
      // Golden tan
      "forest": "#2d5016",
      // Rich forest green
      "rainforest": "#1a3a1a",
      // Deep jungle green
      "mangrove": "#166534",
      // Dark swampy green
      "palm-grove": "#84cc16",
      // Bright tropical green
      // HILLS
      "dry-hill": "#a8a29e",
      // Tan/grey
      "jungle-hill": "#3d5a2c",
      // Olive green (darker than before)
      "cloud-forest": "#5f9ea0",
      // Cadet blue/teal
      "bamboo-forest": "#86efac",
      // Light fresh green
      "scrubland": "#c2b280",
      // Dusty sage
      // MOUNTAINS
      "rocky-peak": "#696969",
      // Dim grey
      "misty-peak": "#d3d3d3"
      // Light grey
    };
    this.setupCanvas();
  }
  setupCanvas() {
    this.canvas.width = this.canvas.clientWidth;
    this.canvas.height = this.canvas.clientHeight;
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
  }
  // ========================================
  // MAIN RENDER
  // ========================================
  render(tiles, territoryManager2 = null, playerPosition = null) {
    this.territoryManager = territoryManager2;
    this.playerPosition = playerPosition;
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "#0f172a";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.save();
    this.ctx.translate(this.offsetX, this.offsetY);
    this.ctx.scale(this.scale, this.scale);
    for (const [key, tile] of tiles) {
      this.renderHex(tile);
    }
    if (playerPosition) {
      this.highlightPlayerTile(playerPosition);
    }
    this.ctx.restore();
    this.addFilmGrain();
  }
  // ========================================
  // HEX RENDERING
  // ========================================
  renderHex(tile) {
    const corners = this.hexGrid.getHexCorners(tile.q, tile.r);
    const territory = this.territoryManager?.getTerritory(tile.q, tile.r);
    this.ctx.beginPath();
    this.ctx.moveTo(corners[0].x, corners[0].y);
    for (let i = 1; i < corners.length; i++) {
      this.ctx.lineTo(corners[i].x, corners[i].y);
    }
    this.ctx.closePath();
    const baseColor = this.terrainColors[tile.terrain] || "#666666";
    let brightness = 1;
    if (tile.isLand && tile.elevation !== void 0 && !isNaN(tile.elevation)) {
      brightness = this.textureGenerator.getElevationBrightness(tile.elevation, 0, 1);
      if (isNaN(brightness) || brightness < 0.5 || brightness > 1.5) {
        brightness = 1;
      }
    }
    this.ctx.fillStyle = this.adjustBrightness(baseColor, brightness);
    this.ctx.fill();
    if (this.scale > 0.5) {
      this.renderTerrainTexture(tile, corners);
    }
    if (territory?.discovered && territory.owner && territory.owner !== "neutral") {
      const territoryColors = {
        "player": "rgba(251, 191, 36, ALPHA)",
        // Warm yellow
        "castaways": "rgba(251, 191, 36, ALPHA)",
        // Warm yellow
        "natives_clan1": "rgba(34, 139, 34, ALPHA)",
        // Forest green
        "natives_clan2": "rgba(32, 178, 170, ALPHA)",
        // Light sea green  
        "mercenaries": "rgba(70, 130, 180, ALPHA)"
        // Steel blue
      };
      let alpha = this.scale < 0.4 ? 0.35 : 0.25;
      const colorTemplate = territoryColors[territory.owner];
      if (colorTemplate) {
        this.ctx.fillStyle = colorTemplate.replace("ALPHA", alpha.toString());
        this.ctx.fill();
      }
    }
    if (territory && !territory.visited) {
      this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      this.ctx.fill();
    }
    this.ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
    this.ctx.lineWidth = 0.5;
    this.ctx.stroke();
    if (territory?.discovered && territory.owner && territory.owner !== "neutral") {
      this.renderEnhancedTerritoryBorders(tile, corners, territory);
    }
    if (tile.isStrategic) {
      this.renderStrategicMarker(tile);
    }
    if (this.scale > 0.8) {
      const center = this.hexGrid.axialToPixel(tile.q, tile.r);
      this.ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      this.ctx.font = "8px monospace";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText(`${tile.q},${tile.r}`, center.x, center.y - 6);
      this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      this.ctx.font = "6px monospace";
      this.ctx.fillText(tile.terrain || "?", center.x, center.y + 6);
    }
  }
  /**
   * Render procedural terrain textures
   */
  renderTerrainTexture(tile, corners) {
    const patterns = this.textureGenerator.getTexturePattern(tile.terrain, tile.q, tile.r, this.scale);
    const center = this.hexGrid.axialToPixel(tile.q, tile.r);
    this.ctx.save();
    this.ctx.beginPath();
    this.ctx.moveTo(corners[0].x, corners[0].y);
    for (let i = 1; i < corners.length; i++) {
      this.ctx.lineTo(corners[i].x, corners[i].y);
    }
    this.ctx.closePath();
    this.ctx.clip();
    for (const pattern of patterns) {
      this.ctx.globalAlpha = pattern.alpha;
      this.ctx.fillStyle = pattern.color;
      if (pattern.angular) {
        this.ctx.fillRect(
          center.x + pattern.x - pattern.size / 2,
          center.y + pattern.y - pattern.size / 2,
          pattern.size,
          pattern.size
        );
      } else {
        this.ctx.beginPath();
        this.ctx.arc(center.x + pattern.x, center.y + pattern.y, pattern.size, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
    this.ctx.globalAlpha = 1;
    this.ctx.restore();
  }
  /**
   * Render enhanced territory borders between different factions
   * FIXED: Properly detects all borders, not just perimeter tiles
   */
  renderEnhancedTerritoryBorders(tile, corners, territory) {
    const borderColors = {
      "player": "#fbbf24",
      // Warm yellow
      "castaways": "#fbbf24",
      // Warm yellow  
      "natives_clan1": "#228B22",
      // Forest green
      "natives_clan2": "#20B2AA",
      // Light sea green
      "mercenaries": "#4682B4"
      // Steel blue
    };
    const borderColor = borderColors[territory.owner] || "#666";
    const directions = [
      { q: 1, r: 0 },
      // E
      { q: 1, r: -1 },
      // NE
      { q: 0, r: -1 },
      // NW
      { q: -1, r: 0 },
      // W
      { q: -1, r: 1 },
      // SW
      { q: 0, r: 1 }
      // SE
    ];
    for (let i = 0; i < 6; i++) {
      const dir = directions[i];
      const neighborQ = tile.q + dir.q;
      const neighborR = tile.r + dir.r;
      const neighborTerr = this.territoryManager?.getTerritory(neighborQ, neighborR);
      const shouldDrawBorder = !neighborTerr || neighborTerr.owner !== territory.owner || neighborTerr.owner === "neutral";
      if (shouldDrawBorder) {
        const strength = (territory.controlStrength || 50) / 100;
        const lineWidth = 2 + strength * 2;
        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = lineWidth;
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";
        const startCorner = corners[i];
        const endCorner = corners[(i + 1) % 6];
        const center = this.hexGrid.axialToPixel(tile.q, tile.r);
        const inset = 0.1;
        const startX = startCorner.x + (center.x - startCorner.x) * inset;
        const startY = startCorner.y + (center.y - startCorner.y) * inset;
        const endX = endCorner.x + (center.x - endCorner.x) * inset;
        const endY = endCorner.y + (center.y - endCorner.y) * inset;
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
        if (this.scale > 0.6) {
          this.ctx.strokeStyle = borderColor + "40";
          this.ctx.lineWidth = lineWidth + 2;
          this.ctx.beginPath();
          this.ctx.moveTo(startX, startY);
          this.ctx.lineTo(endX, endY);
          this.ctx.stroke();
        }
      }
    }
  }
  /**
   * OLD method - kept for backward compatibility but not used
   */
  renderTerritoryBorders(tile, corners, territory) {
    this.renderEnhancedTerritoryBorders(tile, corners, territory);
  }
  // Helper method to get tile (needs to be added)
  getTile(q, r) {
    return window.game?.mapData?.tiles?.get(`${q},${r}`);
  }
  /**
   * Render special markers for strategic locations
   */
  renderStrategicMarker(tile) {
    const center = this.hexGrid.axialToPixel(tile.q, tile.r);
    const location = tile.strategicLocation;
    if (!location) return;
    this.ctx.save();
    this.ctx.translate(center.x, center.y);
    switch (location.type) {
      case "starting-point":
        this.ctx.fillStyle = "#fbbf24";
        this.ctx.strokeStyle = "#92400e";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#92400e";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚òÖ", 0, 0);
        break;
      case "native-village":
        if (location.faction === "tidal-clan") {
          this.ctx.fillStyle = "#3b82f6";
        } else {
          this.ctx.fillStyle = "#84cc16";
        }
        this.ctx.strokeStyle = "#000";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 14px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚åÇ", 0, 0);
        break;
      case "hostile-base":
        this.ctx.fillStyle = "#dc2626";
        this.ctx.strokeStyle = "#000";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 10, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 14px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚öî", 0, 0);
        break;
      case "sacred-site":
        this.ctx.fillStyle = "#a78bfa";
        this.ctx.strokeStyle = "#5b21b6";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fef3c7";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚ú¶", 0, 0);
        break;
      case "shipwreck":
        this.ctx.fillStyle = "#92400e";
        this.ctx.strokeStyle = "#000";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fbbf24";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚öì", 0, 0);
        break;
      case "waterfall":
        this.ctx.fillStyle = "#3b82f6";
        this.ctx.strokeStyle = "#1e3a8a";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚âã", 0, 0);
        break;
      case "hot-spring":
        this.ctx.fillStyle = "#f97316";
        this.ctx.strokeStyle = "#ea580c";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚ô®", 0, 0);
        break;
      case "cave":
        this.ctx.fillStyle = "#1c1917";
        this.ctx.strokeStyle = "#78716c";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#a8a29e";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚óê", 0, 0);
        break;
      case "harbor":
        this.ctx.fillStyle = "#0ea5e9";
        this.ctx.strokeStyle = "#0284c7";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("‚öì", 0, 0);
        break;
      case "ruins":
        this.ctx.fillStyle = "#78716c";
        this.ctx.strokeStyle = "#44403c";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 9, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        this.ctx.fillStyle = "#d6d3d1";
        this.ctx.font = "bold 14px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("üèõ", 0, 0);
        break;
    }
    this.ctx.restore();
  }
  // ========================================
  // CAMERA CONTROLS
  // ========================================
  pan(dx, dy) {
    this.offsetX += dx;
    this.offsetY += dy;
  }
  zoom(delta, mouseX, mouseY) {
    const oldScale = this.scale;
    this.scale *= 1 + delta;
    this.scale = Math.max(0.3, Math.min(3, this.scale));
    const scaleChange = this.scale / oldScale;
    this.offsetX = mouseX - (mouseX - this.offsetX) * scaleChange;
    this.offsetY = mouseY - (mouseY - this.offsetY) * scaleChange;
  }
  resetView() {
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
    this.scale = 1;
  }
  // ========================================
  // UTILITIES
  // ========================================
  /**
   * Highlight the player's current tile with pulsing glow
   */
  highlightPlayerTile(position) {
    const corners = this.hexGrid.getHexCorners(position.q, position.r);
    const pulseSpeed = 2e3;
    const pulse = (Math.sin(Date.now() / pulseSpeed * Math.PI * 2) + 1) / 2;
    const alpha = 0.2 + pulse * 0.3;
    this.ctx.beginPath();
    this.ctx.moveTo(corners[0].x, corners[0].y);
    for (let i = 1; i < corners.length; i++) {
      this.ctx.lineTo(corners[i].x, corners[i].y);
    }
    this.ctx.closePath();
    this.ctx.strokeStyle = `rgba(251, 191, 36, ${alpha})`;
    this.ctx.lineWidth = 4;
    this.ctx.stroke();
    this.ctx.strokeStyle = `rgba(251, 191, 36, ${alpha * 0.5})`;
    this.ctx.lineWidth = 8;
    this.ctx.stroke();
  }
  /**
   * Add subtle film grain overlay for organic feel
   */
  addFilmGrain() {
    if (this.scale < 0.5) return;
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const pixels = imageData.data;
    for (let i = 0; i < pixels.length; i += 40) {
      const noise = (Math.random() - 0.5) * 8;
      pixels[i] = Math.max(0, Math.min(255, pixels[i] + noise));
      pixels[i + 1] = Math.max(0, Math.min(255, pixels[i + 1] + noise));
      pixels[i + 2] = Math.max(0, Math.min(255, pixels[i + 2] + noise));
    }
    this.ctx.putImageData(imageData, 0, 0);
  }
  adjustBrightness(color, factor) {
    if (!color || typeof color !== "string") return "#666666";
    if (isNaN(factor) || factor === void 0) factor = 1;
    const r = parseInt(color.slice(1, 3), 16);
    const g = parseInt(color.slice(3, 5), 16);
    const b = parseInt(color.slice(5, 7), 16);
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      console.warn("Invalid color:", color);
      return "#666666";
    }
    const nr = Math.min(255, Math.max(0, Math.floor(r * factor)));
    const ng = Math.min(255, Math.max(0, Math.floor(g * factor)));
    const nb = Math.min(255, Math.max(0, Math.floor(b * factor)));
    return `rgb(${nr}, ${ng}, ${nb})`;
  }
  // Convert screen coordinates to hex coordinates
  screenToHex(screenX, screenY) {
    const rect = this.canvas.getBoundingClientRect();
    const canvasX = screenX - rect.left;
    const canvasY = screenY - rect.top;
    const worldX = (canvasX - this.offsetX) / this.scale;
    const worldY = (canvasY - this.offsetY) / this.scale;
    return this.hexGrid.pixelToAxial(worldX, worldY);
  }
}
class GameView {
  constructor(gameState2, mapData, player2, inventory2, resourceNodeManager2, territoryManager2, travelSystem2) {
    this.gameState = gameState2;
    this.mapData = mapData;
    this.player = player2;
    this.inventory = inventory2;
    this.resourceNodeManager = resourceNodeManager2;
    this.territoryManager = territoryManager2;
    this.travelSystem = travelSystem2;
    this.renderer = null;
    this.moveCount = 0;
  }
  show() {
    const container = document.getElementById("game-view");
    if (!container) {
      console.error("Game view container not found");
      return;
    }
    const mainMenu2 = document.querySelector(".main-menu");
    if (mainMenu2) {
      mainMenu2.classList.add("hidden");
    }
    container.classList.remove("hidden");
    this.render();
    console.log("‚úÖ Game view shown");
  }
  hide() {
    const container = document.getElementById("game-view");
    if (container) {
      container.classList.add("hidden");
    }
  }
  render() {
    const container = document.getElementById("game-view");
    const character = this.gameState.state.player;
    const timeString = this.gameState.getTimeString ? this.gameState.getTimeString() : `Day ${this.gameState.state.time?.day || 1}`;
    const timeOfDay = this.gameState.getTimeOfDay ? this.gameState.getTimeOfDay() : "morning";
    const isPaused = this.gameState.isPaused || false;
    const timeSpeed = this.gameState.timeSpeed || 1;
    container.innerHTML = `
      <div class="game-container">
        \x3C!-- Optimized HUD -->
        <div class="game-hud">
          \x3C!-- Left: Player Profile & Stats -->
          <div class="hud-left">
            <div class="player-profile">
              <div class="player-portrait">
                ${character.portraitUrl ? `<img src="${character.portraitUrl}" alt="${character.name}">` : '<div class="portrait-placeholder">üë§</div>'}
              </div>
              <div class="player-name">${character.name}</div>
            </div>
            
            <div class="stats-grid">
              <div class="stat-cell" id="health-cell">
                <div class="stat-icon">‚ù§Ô∏è</div>
                <div class="stat-bar-mini">
                  <div class="stat-bar-fill health" style="width: ${this.player.health}%" id="health-bar"></div>
                </div>
                <div class="stat-num" id="health-value">${Math.round(this.player.health)}</div>
              </div>
              <div class="stat-cell" id="hunger-cell">
                <div class="stat-icon">üçñ</div>
                <div class="stat-bar-mini">
                  <div class="stat-bar-fill hunger" style="width: ${this.player.hunger}%" id="hunger-bar"></div>
                </div>
                <div class="stat-num" id="hunger-value">${Math.round(this.player.hunger)}</div>
              </div>
              <div class="stat-cell" id="thirst-cell">
                <div class="stat-icon">üíß</div>
                <div class="stat-bar-mini">
                  <div class="stat-bar-fill thirst" style="width: ${this.player.thirst}%" id="thirst-bar"></div>
                </div>
                <div class="stat-num" id="thirst-value">${Math.round(this.player.thirst)}</div>
              </div>
              <div class="stat-cell" id="happiness-cell">
                <div class="stat-icon">üòä</div>
                <div class="stat-bar-mini">
                  <div class="stat-bar-fill happiness" style="width: ${this.player.happiness || 75}%" id="happiness-bar"></div>
                </div>
                <div class="stat-num" id="happiness-value">${Math.round(this.player.happiness || 75)}</div>
              </div>
            </div>
          </div>
          
          \x3C!-- Center: Action Buttons -->
          <div class="hud-center">
            <div class="action-grid">
              <button class="action-btn" id="inventory-btn" title="Inventory (I)">üéí</button>
              <button class="action-btn" id="crafting-btn" title="Crafting (C)">üî®</button>
              <button class="action-btn" id="skills-btn" title="Skills (K)">‚≠ê</button>
              <button class="action-btn" id="journal-btn" title="Journal (Coming Soon)">üìñ</button>
              <button class="action-btn" id="map-btn" title="Map (Coming Soon)">üó∫Ô∏è</button>
              <button class="action-btn" id="game-menu-btn" title="Menu">‚öôÔ∏è</button>
            </div>
          </div>
          
          \x3C!-- Right: Time Controls -->
          <div class="hud-right">
            <div class="time-display">
              <div class="time-icon">${this.getTimeOfDayIcon(timeOfDay)}</div>
              <div class="time-info">
                <div class="time-string">${timeString}</div>
              </div>
            </div>
            
            <div class="time-controls">
              <button class="time-btn ${isPaused ? "active" : ""}" id="pause-btn" title="Pause (Space)">
                ${isPaused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è"}
              </button>
              <button class="time-btn ${!isPaused && timeSpeed === 1 ? "active" : ""}" id="speed-1x" title="1x Speed">1x</button>
              <button class="time-btn ${!isPaused && timeSpeed === 5 ? "active" : ""}" id="speed-5x" title="5x Speed">5x</button>
              <button class="time-btn ${!isPaused && timeSpeed === 10 ? "active" : ""}" id="speed-10x" title="10x Speed">10x</button>
              <button class="time-btn ${!isPaused && timeSpeed === 20 ? "active" : ""}" id="speed-20x" title="20x Speed">20x</button>
            </div>
          </div>
        </div>

        \x3C!-- Map Display -->
        <div class="map-display">
          <canvas id="game-canvas"></canvas>
          
          \x3C!-- Map Controls -->
          <div class="map-controls">
            <button class="map-control-btn" id="zoom-in-btn" title="Zoom In">üîç+</button>
            <button class="map-control-btn" id="zoom-out-btn" title="Zoom Out">üîç-</button>
            <button class="map-control-btn" id="center-player-btn" title="Center on Player">üéØ</button>
            <button class="map-control-btn" id="toggle-legend-btn" title="Toggle Legend">üó∫Ô∏è</button>
            <button class="map-control-btn" id="toggle-fog-btn" title="Toggle Fog of War (Debug)">üëÅÔ∏è</button>
          </div>
          
          \x3C!-- Action Log Button/Panel (positioned below map controls) -->
          <div class="action-log-container collapsed" id="action-log-container">
            <div class="action-log-button" id="toggle-log-btn" title="Action Log">
              üìú
            </div>
            <div class="action-log-expanded">
              <div class="action-log-header" id="action-log-header">
                <h4>üìú Action Log</h4>
                <span class="collapse-hint">Click to collapse</span>
              </div>
              <div class="log-content" id="action-log">
                <p class="log-entry">You wake up on an unfamiliar beach...</p>
                <p class="log-entry">The plane crash knocked you unconscious.</p>
                <p class="log-entry">You need to find water and shelter soon.</p>
              </div>
            </div>
          </div>
          
          \x3C!-- Tile Info -->
          <div class="tile-info" id="tile-info">
            <div class="tile-info-content">
              <h4>Tile Info</h4>
              <p>Hover over tiles to see details</p>
            </div>
          </div>

          \x3C!-- Tutorial Hint -->
          <div class="tutorial-hint">
            <p>üñ±Ô∏è <strong>Click</strong> adjacent tiles to travel</p>
            <p>ÔøΩ <strong>Click</strong> resource nodes to gather</p>
            <p>‚å®Ô∏è <strong>I</strong>=Inventory ‚Ä¢ <strong>C</strong>=Craft ‚Ä¢ <strong>K</strong>=Skills</p>
          </div>
        </div>
      </div>
    `;
    this.initializeMap();
    this.attachEventListeners();
    if (window.game?.tileInteractionUI) {
      window.game.tileInteractionUI.initialize("#tile-info");
      const startTerritory = this.territoryManager.getTerritory(this.player.position.q, this.player.position.r);
      window.game.tileInteractionUI.updateCurrentTile(this.player.position, startTerritory);
    }
  }
  initializeMap() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas || !this.mapData) return;
    this.renderer = new MapRenderer(canvas, this.mapData.hexGrid);
    this.renderer.render(this.mapData.tiles, this.territoryManager, this.player.position);
    this.updateFogButton();
    console.log(`üèñÔ∏è Player at (${this.player.position.q}, ${this.player.position.r})`);
    this.renderPlayerMarker();
    this.renderResourceNodes();
    setTimeout(() => this.centerOnPlayer(), 100);
  }
  renderPlayerMarker() {
    if (!this.renderer) return;
    this.renderer.render(this.mapData.tiles, this.territoryManager, this.player.position);
    if (window.game.mapTravelUI) {
      window.game.mapTravelUI.render();
    }
    this.renderResourceNodes();
    const ctx = this.renderer.ctx;
    ctx.save();
    ctx.translate(this.renderer.offsetX, this.renderer.offsetY);
    ctx.scale(this.renderer.scale, this.renderer.scale);
    const center = this.renderer.hexGrid.axialToPixel(
      this.player.position.q,
      this.player.position.r
    );
    ctx.beginPath();
    ctx.arc(center.x, center.y, 15, 0, Math.PI * 2);
    ctx.fillStyle = "#4dd0e1";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üìç", center.x, center.y);
    ctx.restore();
  }
  renderResourceNodes() {
    if (!this.renderer || !this.resourceNodeManager) return;
    const ctx = this.renderer.ctx;
    ctx.save();
    ctx.translate(this.renderer.offsetX, this.renderer.offsetY);
    ctx.scale(this.renderer.scale, this.renderer.scale);
    this.resourceNodeManager.nodes.forEach((node) => {
      if (!node || !node.position) return;
      const territory = this.territoryManager?.getTerritory(node.position.q, node.position.r);
      if (!territory || !territory.discovered) return;
      if (!node.discovered) return;
      const center = this.renderer.hexGrid.axialToPixel(
        node.position.q,
        node.position.r
      );
      const icons = {
        tree: "üå≥",
        rock: "ü™®",
        bush: "üåø",
        fish: "ÔøΩ"
      };
      const icon = icons[node.type] || "‚ùì";
      ctx.beginPath();
      ctx.arc(center.x, center.y - 15, 12, 0, Math.PI * 2);
      if (node.state === "full") {
        ctx.fillStyle = "rgba(74, 222, 128, 0.8)";
      } else if (node.state === "depleted") {
        ctx.fillStyle = "rgba(156, 163, 175, 0.6)";
      } else {
        ctx.fillStyle = "rgba(251, 191, 36, 0.7)";
      }
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(icon, center.x, center.y - 15);
    });
    ctx.restore();
  }
  attachEventListeners() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) return;
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;
    let dragStartX = 0;
    let dragStartY = 0;
    const DRAG_THRESHOLD = 5;
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      console.log("üñ±Ô∏è MOUSEDOWN at", dragStartX, dragStartY);
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        const currentDragDistance = Math.sqrt(
          Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2)
        );
        if (currentDragDistance > DRAG_THRESHOLD && currentDragDistance < DRAG_THRESHOLD + 10) {
          console.log("üñ±Ô∏è DRAGGING - distance:", currentDragDistance.toFixed(1), "px (threshold:", DRAG_THRESHOLD, ")");
        }
        this.renderer.pan(dx, dy);
        this.renderPlayerMarker();
        lastX = e.clientX;
        lastY = e.clientY;
      } else {
        this.showTileInfo(e);
      }
    });
    canvas.addEventListener("mouseup", (e) => {
      const totalDragDistance = Math.sqrt(
        Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2)
      );
      console.log("üñ±Ô∏è MOUSEUP at", e.clientX, e.clientY);
      console.log("üñ±Ô∏è Total drag distance:", totalDragDistance.toFixed(1), "px (threshold:", DRAG_THRESHOLD, ")");
      if (isDragging && totalDragDistance < DRAG_THRESHOLD) {
        console.log("‚úÖ CLICK detected - handling tile click");
        this.handleTileClick(e);
      } else {
        console.log("‚ùå DRAG detected - ignoring click (distance too large)");
      }
      isDragging = false;
    });
    canvas.addEventListener("mouseleave", () => {
      isDragging = false;
    });
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = -Math.sign(e.deltaY) * 0.1;
      this.renderer.zoom(delta, e.clientX, e.clientY);
      this.renderPlayerMarker();
    });
    document.getElementById("zoom-in-btn")?.addEventListener("click", () => {
      this.renderer.zoom(0.2, canvas.width / 2, canvas.height / 2);
      this.renderPlayerMarker();
    });
    document.getElementById("zoom-out-btn")?.addEventListener("click", () => {
      this.renderer.zoom(-0.2, canvas.width / 2, canvas.height / 2);
      this.renderPlayerMarker();
    });
    document.getElementById("center-player-btn")?.addEventListener("click", () => {
      this.centerOnPlayer();
    });
    document.getElementById("toggle-legend-btn")?.addEventListener("click", () => {
      const legend = document.getElementById("territory-legend");
      if (legend) {
        legend.style.display = legend.style.display === "none" ? "block" : "none";
      }
    });
    document.getElementById("toggle-fog-btn")?.addEventListener("click", () => {
      this.renderer.fogOfWarEnabled = !this.renderer.fogOfWarEnabled;
      this.updateFogButton();
      this.renderPlayerMarker();
    });
    document.getElementById("toggle-log-btn")?.addEventListener("click", () => {
      this.toggleActionLog();
    });
    document.getElementById("action-log-header")?.addEventListener("click", () => {
      this.toggleActionLog();
    });
    window.addEventListener("resize", () => {
      this.renderer.setupCanvas();
      this.renderPlayerMarker();
    });
    document.getElementById("inventory-btn")?.addEventListener("click", () => {
      window.game.inventoryUI?.toggle();
    });
    document.getElementById("crafting-btn")?.addEventListener("click", () => {
      window.game.craftingUI?.toggle();
    });
    document.getElementById("skills-btn")?.addEventListener("click", () => {
      this.showSkillsMenu();
    });
    document.getElementById("journal-btn")?.addEventListener("click", () => {
      console.log("Journal coming soon!");
    });
    document.getElementById("map-btn")?.addEventListener("click", () => {
      console.log("Map overview coming soon!");
    });
    document.getElementById("game-menu-btn")?.addEventListener("click", () => {
      window.game.optionsMenu?.show();
    });
    document.getElementById("pause-btn")?.addEventListener("click", () => {
      this.gameState.togglePause();
      this.updateTimeDisplay();
    });
    document.getElementById("speed-1x")?.addEventListener("click", () => {
      if (this.gameState.isPaused) this.gameState.resume();
      this.gameState.setTimeSpeed(1);
      this.updateTimeDisplay();
    });
    document.getElementById("speed-5x")?.addEventListener("click", () => {
      if (this.gameState.isPaused) this.gameState.resume();
      this.gameState.setTimeSpeed(5);
      this.updateTimeDisplay();
    });
    document.getElementById("speed-10x")?.addEventListener("click", () => {
      if (this.gameState.isPaused) this.gameState.resume();
      this.gameState.setTimeSpeed(10);
      this.updateTimeDisplay();
    });
    document.getElementById("speed-20x")?.addEventListener("click", () => {
      if (this.gameState.isPaused) this.gameState.resume();
      this.gameState.setTimeSpeed(20);
      this.updateTimeDisplay();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        window.game.inventoryUI?.hide();
        window.game.craftingUI?.hide();
      }
    });
  }
  showTileInfo(event) {
    const hex = this.renderer.screenToHex(event.clientX, event.clientY);
    const tile = this.mapData.tiles.get(`${hex.q},${hex.r}`);
    if (!tile) {
      if (window.game?.tileInteractionUI) {
        window.game.tileInteractionUI.clearHoverInfo();
      }
      return;
    }
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (window.game?.tileInteractionUI && territory) {
      window.game.tileInteractionUI.updateHoverInfo(hex, territory);
    }
  }
  handleTileClick(event) {
    const hex = this.renderer.screenToHex(event.clientX, event.clientY);
    const tile = this.mapData.tiles.get(`${hex.q},${hex.r}`);
    if (!tile) {
      console.log("‚ùå No tile found at", hex);
      return;
    }
    const dq = Math.abs(hex.q - this.player.position.q);
    const dr = Math.abs(hex.r - this.player.position.r);
    const ds = Math.abs(-hex.q - hex.r - (-this.player.position.q - this.player.position.r));
    const distance = Math.max(dq, dr, ds);
    console.log("üñ±Ô∏è Tile clicked:", {
      position: hex,
      playerPosition: this.player.position,
      distance,
      terrain: tile.terrain,
      isPassable: tile.isPassable
    });
    if (distance === 0) {
      console.log("üìç Clicking current tile - showing tile actions");
      this.showTileActions(tile, hex);
      return;
    }
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    const nodes = this.resourceNodeManager?.getNodesAt(hex.q, hex.r) || [];
    let hasNPCs = false;
    if (window.game?.state?.npcManager) {
      const npcs = window.game.state.npcManager.getNPCsAtTile(hex);
      hasNPCs = npcs.length > 0;
    }
    const hasPOIs = nodes.length > 0 || hasNPCs || territory?.hasEvent;
    if (distance === 1 && hasPOIs) {
      if (window.game?.tileInteractionUI) {
        window.game.tileInteractionUI.show(hex, territory);
      } else {
        console.error("‚ùå tileInteractionUI not found on window.game!");
        this.addLogEntry("üîç Something interesting here. Move closer to interact.");
      }
      return;
    }
    if (!tile.isPassable) {
      this.addLogEntry("‚ùå You can't travel there.");
      return;
    }
    if (distance > 1) {
      console.log("‚ùå Too far to travel");
      this.addLogEntry("‚ùå Too far to travel in one move.");
      return;
    }
    console.log("üö∂ Attempting travel to", hex);
    const result = this.travelSystem.startTravel(hex.q, hex.r);
    if (!result.success) {
      this.addLogEntry(`‚ùå ${result.reason}`);
    }
  }
  /**
   * Show available actions for current tile
   */
  showTileActions(tile, hex) {
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (window.game?.tileInteractionUI) {
      window.game.tileInteractionUI.show(hex, territory);
    } else {
      const nodes = this.resourceNodeManager.getNodesAt(hex.q, hex.r);
      let message = `üìç Current Location: ${tile.terrain}`;
      if (nodes && nodes.length > 0) {
        message += ` | üå≤ Resources available`;
      }
      if (territory && territory.owner) {
        message += ` | üè¥ Controlled by ${territory.owner}`;
      }
      this.addLogEntry(message);
    }
  }
  triggerTerrainEvent(tile) {
    const events = {
      "beach": [
        "üêö You find some seashells.",
        "üåä The waves lap gently at your feet.",
        "‚òÄÔ∏è The sun warms your skin."
      ],
      "forest": [
        "üçé You spot some edible berries.",
        "üåø The forest is thick here.",
        "ü¶é A lizard scurries away."
      ],
      "rainforest": [
        "üåßÔ∏è Moisture drips from the canopy.",
        "ü¶ú You hear exotic bird calls.",
        "üçÑ Strange mushrooms grow nearby."
      ]
    };
    const terrainEvents = events[tile.terrain];
    if (terrainEvents && Math.random() < 0.3) {
      const event = terrainEvents[Math.floor(Math.random() * terrainEvents.length)];
      this.addLogEntry(event);
    }
  }
  // Update HUD with real-time player stats
  updateHUD() {
    if (!this.player) return;
    const healthBar = document.getElementById("health-bar");
    const hungerBar = document.getElementById("hunger-bar");
    const thirstBar = document.getElementById("thirst-bar");
    const energyBar = document.getElementById("energy-bar");
    const healthValue = document.getElementById("health-value");
    const hungerValue = document.getElementById("hunger-value");
    const thirstValue = document.getElementById("thirst-value");
    const energyValue = document.getElementById("energy-value");
    if (healthBar) healthBar.style.width = `${this.player.health}%`;
    if (hungerBar) hungerBar.style.width = `${this.player.hunger}%`;
    if (thirstBar) thirstBar.style.width = `${this.player.thirst}%`;
    if (energyBar) energyBar.style.width = `${this.player.energy}%`;
    if (healthValue) healthValue.textContent = `${Math.round(this.player.health)}`;
    if (hungerValue) hungerValue.textContent = `${Math.round(this.player.hunger)}`;
    if (thirstValue) thirstValue.textContent = `${Math.round(this.player.thirst)}`;
    if (energyValue) energyValue.textContent = `${Math.round(this.player.energy)}`;
    this.updateTimeDisplay();
  }
  updateTimeDisplay() {
    const timeString = this.gameState.getTimeString ? this.gameState.getTimeString() : `Day ${this.gameState.state.time?.day || 1}`;
    const timeOfDay = this.gameState.getTimeOfDay ? this.gameState.getTimeOfDay() : "morning";
    const timeStringEl = document.querySelector(".time-string");
    const timeIconEl = document.querySelector(".time-icon");
    if (timeStringEl) {
      timeStringEl.textContent = timeString;
    }
    if (timeIconEl) {
      timeIconEl.textContent = this.getTimeOfDayIcon(timeOfDay);
    }
    const isPaused = this.gameState.isPaused || false;
    const timeSpeed = this.gameState.timeSpeed || 1;
    const pauseBtn = document.getElementById("pause-btn");
    const speed1x = document.getElementById("speed-1x");
    const speed5x = document.getElementById("speed-5x");
    const speed10x = document.getElementById("speed-10x");
    const speed20x = document.getElementById("speed-20x");
    if (pauseBtn) {
      pauseBtn.classList.toggle("active", isPaused);
      pauseBtn.textContent = isPaused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
    }
    if (speed1x) speed1x.classList.toggle("active", !isPaused && timeSpeed === 1);
    if (speed5x) speed5x.classList.toggle("active", !isPaused && timeSpeed === 5);
    if (speed10x) speed10x.classList.toggle("active", !isPaused && timeSpeed === 10);
    if (speed20x) speed20x.classList.toggle("active", !isPaused && timeSpeed === 20);
  }
  // Show skills menu
  showSkillsMenu() {
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "skills-modal";
    let skillsHTML = '<div class="skills-grid">';
    Object.entries(this.player.skills).forEach(([skill, data]) => {
      const progress = data.experience % 100 / 100 * 100;
      skillsHTML += `
        <div class="skill-card">
          <h4>${skill}</h4>
          <div class="skill-level">Level ${data.level}</div>
          <div class="skill-progress-bar">
            <div class="skill-progress-fill" style="width: ${progress}%"></div>
          </div>
          <div class="skill-xp">${data.experience} XP</div>
        </div>
      `;
    });
    skillsHTML += "</div>";
    modal.innerHTML = `
      <div class="modal-content skills-modal">
        <div class="modal-header">
          <h2>‚≠ê Skills</h2>
          <button class="close-btn" id="close-skills">‚úï</button>
        </div>
        <div class="modal-body">
          ${skillsHTML}
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="close-skills-btn">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-skills").onclick = () => modal.remove();
    document.getElementById("close-skills-btn").onclick = () => modal.remove();
    const escHandler = (e) => {
      if (e.key === "Escape") {
        modal.remove();
        document.removeEventListener("keydown", escHandler);
      }
    };
    document.addEventListener("keydown", escHandler);
  }
  centerOnPlayer() {
    if (!this.renderer) return;
    const canvas = document.getElementById("game-canvas");
    const center = this.renderer.hexGrid.axialToPixel(
      this.player.position.q,
      this.player.position.r
    );
    this.renderer.offsetX = canvas.width / 2 - center.x * this.renderer.scale;
    this.renderer.offsetY = canvas.height / 2 - center.y * this.renderer.scale;
    this.renderPlayerMarker();
  }
  addLogEntry(text) {
    const log = document.getElementById("action-log");
    if (!log) return;
    const entry = document.createElement("p");
    entry.className = "log-entry";
    entry.textContent = text;
    log.insertBefore(entry, log.firstChild);
    while (log.children.length > 50) {
      log.removeChild(log.lastChild);
    }
  }
  getTerrainName(terrain) {
    const names = {
      "sea": "Ocean",
      "beach": "Beach",
      "river": "River",
      "savanna": "Savanna",
      "forest": "Forest",
      "rainforest": "Rainforest",
      "dry-hill": "Dry Hill",
      "jungle-hill": "Jungle Hill",
      "cloud-forest": "Cloud Forest",
      "rocky-peak": "Rocky Peak",
      "misty-peak": "Misty Peak"
    };
    return names[terrain] || "Unknown";
  }
  getTimeOfDayIcon(timeOfDay) {
    const icons = {
      "dawn": "üåÖ",
      "morning": "‚òÄÔ∏è",
      "afternoon": "üå§Ô∏è",
      "evening": "üåá",
      "night": "üåô"
    };
    return icons[timeOfDay] || "üåû";
  }
  updateFogButton() {
    const btn = document.getElementById("toggle-fog-btn");
    if (!btn || !this.renderer) return;
    btn.title = this.renderer.fogOfWarEnabled ? "Fog of War: ON (Click to disable)" : "Fog of War: OFF (Click to enable)";
    btn.style.opacity = this.renderer.fogOfWarEnabled ? "1.0" : "0.5";
  }
  toggleActionLog() {
    const container = document.getElementById("action-log-container");
    if (!container) return;
    container.classList.toggle("collapsed");
  }
}
class SaveManager {
  constructor(gameState2) {
    this.gameState = gameState2;
    this.view = {
      tab: "manual",
      // 'manual' or 'auto'
      sortKey: "savedAt",
      sortDir: "desc",
      // 'asc' or 'desc'
      query: "",
      selectedId: null
    };
    this.modal = null;
    this.editingNameId = null;
  }
  /**
   * Show save manager modal
   */
  show() {
    if (this.modal) return;
    this.modal = document.createElement("div");
    this.modal.className = "save-manager-modal";
    this.modal.innerHTML = this.buildHTML();
    document.body.appendChild(this.modal);
    this.attachEventListeners();
    this.updateButtonStates();
    this.render();
  }
  /**
   * Check if there's an active game (not on main menu)
   */
  hasActiveGame() {
    const mainMenu2 = document.getElementById("main-menu");
    const isOnMainMenu = mainMenu2 && !mainMenu2.classList.contains("hidden");
    if (isOnMainMenu) return false;
    const hasPlayer = this.gameState.state.player && this.gameState.state.player.name;
    return hasPlayer;
  }
  /**
   * Update button states based on game state
   */
  updateButtonStates() {
    if (!this.modal) return;
    const hasGame = this.hasActiveGame();
    const quickSaveBtn = this.modal.querySelector("#sm-quick-save");
    const exportBtn = this.modal.querySelector("#sm-export");
    if (quickSaveBtn) {
      quickSaveBtn.disabled = !hasGame;
      if (!hasGame) {
        quickSaveBtn.title = "Start a game first to save";
      }
    }
    if (exportBtn) {
      const { manual, auto } = this.getSaves();
      const hasSaves = manual.length > 0 || auto.length > 0;
      exportBtn.disabled = !hasSaves;
      if (!hasSaves) {
        exportBtn.title = "No saves to export";
      }
    }
  }
  /**
   * Hide and cleanup
   */
  hide() {
    if (this.modal) {
      this.modal.remove();
      this.modal = null;
    }
  }
  /**
   * Build main HTML structure
   */
  buildHTML() {
    return `
      <div class="save-manager-container">
        \x3C!-- Header -->
        <div class="save-manager-header">
          <div class="save-manager-title">
            <div class="save-manager-logo">üíæ</div>
            <div>
              <h2>Save Manager</h2>
              <div class="save-manager-subtitle">Continue ‚Ä¢ Save/Load ‚Ä¢ Import/Export</div>
            </div>
          </div>
          <button class="save-manager-close" id="sm-close">‚úï</button>
        </div>

        \x3C!-- Actions -->
        <div class="save-manager-actions">
          <button class="sm-btn accent" id="sm-continue">‚ñ∂ Continue</button>
          <button class="sm-btn success" id="sm-quick-save">‚è∫ Quick Save</button>
          <button class="sm-btn primary" id="sm-quick-load">‚èÆ Quick Load</button>
          <button class="sm-btn" id="sm-export">‚¨á Export</button>
          <button class="sm-btn" id="sm-import">‚¨Ü Import</button>
          <input type="file" id="sm-import-file" accept=".json" style="display: none;">
        </div>

        \x3C!-- Toolbar -->
        <div class="save-manager-toolbar">
          <div class="save-tab-group">
            <button class="save-tab active" id="sm-tab-manual">Manual Saves</button>
            <button class="save-tab" id="sm-tab-auto">Autosaves</button>
          </div>
          <div class="save-search-box">
            <span class="save-search-icon">üîç</span>
            <input type="text" id="sm-search" placeholder="Search by name, location, character..." />
          </div>
        </div>

        \x3C!-- Save List -->
        <div class="save-list-container">
          <table class="save-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="name">Name <span class="sort-arrow">‚ñæ</span></th>
                <th class="sortable" data-sort="day">Day/Time</th>
                <th class="sortable" data-sort="savedAt">Saved At</th>
                <th>Character</th>
                <th>Location</th>
                <th class="sortable" data-sort="playTime">Playtime</th>
                <th style="width: 200px;">Actions</th>
              </tr>
            </thead>
            <tbody id="sm-tbody">
              \x3C!-- Rows generated dynamically -->
            </tbody>
          </table>
        </div>

        \x3C!-- Footer -->
        <div class="save-manager-footer">
          <div class="save-footer-hint">
            <span>Tip:</span>
            <span><span class="kbd">F5</span> Quick Save</span>
            <span><span class="kbd">F9</span> Quick Load</span>
            <span><span class="kbd">Esc</span> Close</span>
          </div>
          <div class="save-count" id="sm-count"></div>
        </div>
      </div>
    `;
  }
  /**
   * Attach all event listeners
   */
  attachEventListeners() {
    const closeBtn = this.modal.querySelector("#sm-close");
    closeBtn?.addEventListener("click", () => this.hide());
    this.modal.addEventListener("click", (e) => {
      if (e.target === this.modal) this.hide();
    });
    const manualTab = this.modal.querySelector("#sm-tab-manual");
    const autoTab = this.modal.querySelector("#sm-tab-auto");
    manualTab?.addEventListener("click", () => this.switchTab("manual"));
    autoTab?.addEventListener("click", () => this.switchTab("auto"));
    const searchInput = this.modal.querySelector("#sm-search");
    searchInput?.addEventListener("input", (e) => {
      this.view.query = e.target.value.toLowerCase();
      this.render();
    });
    this.modal.querySelectorAll("th.sortable").forEach((th) => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (this.view.sortKey === key) {
          this.view.sortDir = this.view.sortDir === "asc" ? "desc" : "asc";
        } else {
          this.view.sortKey = key;
          this.view.sortDir = "desc";
        }
        this.render();
      });
    });
    const continueBtn = this.modal.querySelector("#sm-continue");
    const quickSaveBtn = this.modal.querySelector("#sm-quick-save");
    const quickLoadBtn = this.modal.querySelector("#sm-quick-load");
    const exportBtn = this.modal.querySelector("#sm-export");
    const importBtn = this.modal.querySelector("#sm-import");
    const importFile = this.modal.querySelector("#sm-import-file");
    continueBtn?.addEventListener("click", () => this.handleContinue());
    quickSaveBtn?.addEventListener("click", () => this.handleQuickSave());
    quickLoadBtn?.addEventListener("click", () => this.handleQuickLoad());
    exportBtn?.addEventListener("click", () => this.handleExport());
    importBtn?.addEventListener("click", () => importFile?.click());
    importFile?.addEventListener("change", (e) => this.handleImport(e));
    this.keyHandler = (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        this.hide();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
  /**
   * Switch between manual/auto tabs
   */
  switchTab(tab) {
    this.view.tab = tab;
    const manualTab = this.modal.querySelector("#sm-tab-manual");
    const autoTab = this.modal.querySelector("#sm-tab-auto");
    if (tab === "manual") {
      manualTab?.classList.add("active");
      autoTab?.classList.remove("active");
    } else {
      autoTab?.classList.add("active");
      manualTab?.classList.remove("active");
    }
    this.render();
  }
  /**
   * Get all saves from GameState
   */
  getSaves() {
    const saves = this.gameState.listSaves();
    const manual = saves.filter((s) => s.slotName !== "autosave" && !s.slotName.startsWith("auto_"));
    const auto = saves.filter((s) => s.slotName === "autosave" || s.slotName.startsWith("auto_"));
    return { manual, auto, all: saves };
  }
  /**
   * Format time duration
   */
  formatDuration(seconds) {
    if (!seconds) return "0m";
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
  }
  /**
   * Format date
   */
  formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString();
  }
  /**
   * Get save type tag
   */
  getSaveTag(slotName) {
    if (slotName === "autosave") return '<span class="save-tag auto">autosave</span>';
    if (slotName.startsWith("auto_")) return '<span class="save-tag auto">auto</span>';
    if (slotName.startsWith("quick_")) return '<span class="save-tag quick">quick</span>';
    return '<span class="save-tag">manual</span>';
  }
  /**
   * Build table row HTML
   */
  buildRowHTML(save) {
    const isSelected = this.view.selectedId === save.slotName;
    const selectedClass = isSelected ? "selected" : "";
    return `
      <tr class="${selectedClass}" data-slot="${save.slotName}">
        <td>
          <div class="save-name-cell">
            <input 
              type="text" 
              class="save-name-input" 
              value="${save.slotName}" 
              data-slot="${save.slotName}"
              data-original="${save.slotName}"
            />
            ${this.getSaveTag(save.slotName)}
          </div>
        </td>
        <td class="meta">Day ${save.day || 1}</td>
        <td class="meta">${this.formatDate(save.saveDate)}</td>
        <td>${this.gameState.state.player?.name || "Unknown"}</td>
        <td>${this.gameState.state.player?.position ? "Exploring" : "Unknown"}</td>
        <td class="meta">${this.formatDuration(save.playTime)}</td>
        <td>
          <div class="save-row-actions">
            <button class="save-action-btn load" data-action="load" data-slot="${save.slotName}">Load</button>
            <button class="save-action-btn export" data-action="export" data-slot="${save.slotName}">Export</button>
            <button class="save-action-btn delete" data-action="delete" data-slot="${save.slotName}">‚úï</button>
          </div>
        </td>
      </tr>
    `;
  }
  /**
   * Build create new save row
   */
  buildCreateRow() {
    return `
      <tr class="create-row" id="sm-create-row">
        <td colspan="7">
          <span class="create-save-link">
            <span>+</span>
            <span>Create New Save</span>
          </span>
        </td>
      </tr>
    `;
  }
  /**
   * Build empty state
   */
  buildEmptyState() {
    return `
      <tr>
        <td colspan="7">
          <div class="save-list-empty">
            <div class="save-list-empty-icon">üíæ</div>
            <div class="save-list-empty-text">No saves found</div>
            <div class="save-list-empty-hint">Click "Quick Save" or "Create New Save" to get started</div>
          </div>
        </td>
      </tr>
    `;
  }
  /**
   * Render save list
   */
  render() {
    const tbody = this.modal.querySelector("#sm-tbody");
    if (!tbody) return;
    const { manual, auto } = this.getSaves();
    const list = this.view.tab === "manual" ? manual : auto;
    let filtered = [...list];
    if (this.view.query) {
      filtered = filtered.filter((s) => {
        const searchStr = `${s.slotName} ${this.gameState.state.player?.name || ""}`.toLowerCase();
        return searchStr.includes(this.view.query);
      });
    }
    filtered.sort((a, b) => {
      let aVal, bVal;
      switch (this.view.sortKey) {
        case "name":
          aVal = a.slotName.toLowerCase();
          bVal = b.slotName.toLowerCase();
          break;
        case "day":
          aVal = a.day || 0;
          bVal = b.day || 0;
          break;
        case "savedAt":
          aVal = new Date(a.saveDate).getTime();
          bVal = new Date(b.saveDate).getTime();
          break;
        case "playTime":
          aVal = a.playTime || 0;
          bVal = b.playTime || 0;
          break;
        default:
          aVal = new Date(a.saveDate).getTime();
          bVal = new Date(b.saveDate).getTime();
      }
      const dir = this.view.sortDir === "asc" ? 1 : -1;
      return aVal > bVal ? dir : aVal < bVal ? -dir : 0;
    });
    let html = "";
    if (this.view.tab === "manual" && this.hasActiveGame()) {
      html += this.buildCreateRow();
    }
    if (filtered.length === 0 && this.view.tab !== "manual") {
      html += this.buildEmptyState();
    } else {
      html += filtered.map((s) => this.buildRowHTML(s)).join("");
    }
    tbody.innerHTML = html;
    const countEl = this.modal.querySelector("#sm-count");
    if (countEl) {
      countEl.textContent = `${manual.length} manual ‚Ä¢ ${auto.length} autosaves ‚Ä¢ showing ${filtered.length}`;
    }
    this.modal.querySelectorAll("th.sortable").forEach((th) => {
      const arrow = th.querySelector(".sort-arrow");
      if (th.dataset.sort === this.view.sortKey) {
        th.classList.add("sorted");
        if (arrow) arrow.textContent = this.view.sortDir === "asc" ? "‚ñ¥" : "‚ñæ";
      } else {
        th.classList.remove("sorted");
        if (arrow) arrow.textContent = "‚ñæ";
      }
    });
    this.attachRowListeners();
  }
  /**
   * Attach event listeners to dynamically created rows
   */
  attachRowListeners() {
    const createRow = this.modal.querySelector("#sm-create-row");
    createRow?.addEventListener("click", () => this.handleCreateSave());
    this.modal.querySelectorAll("tr[data-slot]").forEach((row) => {
      row.addEventListener("click", (e) => {
        if (e.target.closest("button") || e.target.closest("input")) return;
        this.view.selectedId = row.dataset.slot;
        this.render();
      });
    });
    this.modal.querySelectorAll(".save-name-input").forEach((input) => {
      input.addEventListener("blur", (e) => this.handleRename(e));
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.target.blur();
        }
      });
    });
    this.modal.querySelectorAll("[data-action]").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const slot = btn.dataset.slot;
        switch (action) {
          case "load":
            this.handleLoad(slot);
            break;
          case "export":
            this.handleExportSingle(slot);
            break;
          case "delete":
            this.handleDelete(slot);
            break;
        }
      });
    });
  }
  /**
   * Handle continue (load most recent save)
   */
  handleContinue() {
    const { manual, auto } = this.getSaves();
    const allSaves = [...manual, ...auto];
    if (allSaves.length === 0) {
      this.showNotification("No saves available", "error");
      return;
    }
    const latest = allSaves.sort(
      (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
    )[0];
    this.handleLoad(latest.slotName);
  }
  /**
   * Handle quick save
   */
  handleQuickSave() {
    if (!this.hasActiveGame()) {
      this.showNotification("Start a game first to save", "error");
      return;
    }
    const timestamp = Date.now();
    const slotName = `quick_${timestamp}`;
    const success = this.gameState.save(slotName);
    if (success) {
      this.showNotification("Quick saved!", "success");
      this.render();
    } else {
      this.showNotification("Failed to save", "error");
    }
  }
  /**
   * Handle quick load (load most recent quick save)
   */
  handleQuickLoad() {
    const saves = this.gameState.listSaves();
    const quickSaves = saves.filter((s) => s.slotName.startsWith("quick_"));
    if (quickSaves.length === 0) {
      this.showNotification("No quick saves found", "error");
      return;
    }
    const latest = quickSaves.sort(
      (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
    )[0];
    this.handleLoad(latest.slotName);
  }
  /**
   * Handle create new save
   */
  handleCreateSave() {
    if (!this.hasActiveGame()) {
      this.showNotification("Start a game first to save", "error");
      return;
    }
    const timestamp = Date.now();
    const slotName = `save_${timestamp}`;
    const success = this.gameState.save(slotName);
    if (success) {
      this.showNotification("Save created!", "success");
      this.view.selectedId = slotName;
      this.render();
    } else {
      this.showNotification("Failed to create save", "error");
    }
  }
  /**
   * Handle rename save
   */
  handleRename(event) {
    const input = event.target;
    const oldSlot = input.dataset.original;
    const newName = input.value.trim();
    if (!newName || newName === oldSlot) {
      input.value = oldSlot;
      return;
    }
    const saves = this.gameState.listSaves();
    if (saves.some((s) => s.slotName === newName)) {
      this.showNotification("Save name already exists", "error");
      input.value = oldSlot;
      return;
    }
    const success = this.gameState.load(oldSlot);
    if (success) {
      this.gameState.save(newName);
      this.gameState.deleteSave(oldSlot);
      if (this.view.selectedId === oldSlot) {
        this.view.selectedId = newName;
      }
      this.showNotification("Save renamed", "success");
      this.render();
    } else {
      input.value = oldSlot;
      this.showNotification("Failed to rename", "error");
    }
  }
  /**
   * Handle load save
   */
  handleLoad(slotName) {
    const success = this.gameState.load(slotName);
    if (success) {
      this.showNotification("Loading game...", "success");
      this.hide();
      const storyIntro2 = document.getElementById("story-intro");
      const characterCreation2 = document.getElementById("character-creation");
      const mainMenu2 = document.getElementById("main-menu");
      if (storyIntro2) storyIntro2.classList.add("hidden");
      if (characterCreation2) characterCreation2.classList.add("hidden");
      if (mainMenu2) mainMenu2.classList.add("hidden");
      this.gameState.emit("loadGame", this.gameState.state);
    } else {
      this.showNotification("Failed to load save", "error");
    }
  }
  /**
   * Handle delete save
   */
  handleDelete(slotName) {
    this.gameState.deleteSave(slotName);
    if (this.view.selectedId === slotName) {
      this.view.selectedId = null;
    }
    this.showNotification("Save deleted", "success");
    this.render();
  }
  /**
   * Handle export selected or most recent
   */
  handleExport() {
    const { manual, auto } = this.getSaves();
    const allSaves = [...manual, ...auto];
    let saveToExport;
    if (this.view.selectedId) {
      saveToExport = allSaves.find((s) => s.slotName === this.view.selectedId);
    } else {
      saveToExport = allSaves.sort(
        (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
      )[0];
    }
    if (!saveToExport) {
      this.showNotification("No save to export", "error");
      return;
    }
    this.handleExportSingle(saveToExport.slotName);
  }
  /**
   * Handle export single save
   */
  handleExportSingle(slotName) {
    const savedData = localStorage.getItem(`hedonism_save_${slotName}`);
    if (!savedData) {
      this.showNotification("Save not found", "error");
      return;
    }
    const blob = new Blob([savedData], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `hedonism_island_${slotName}.json`;
    a.click();
    URL.revokeObjectURL(url);
    this.showNotification("Save exported", "success");
  }
  /**
   * Handle import save
   */
  handleImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target.result;
        const success = this.gameState.importSave(content);
        if (success) {
          this.showNotification("Save imported successfully", "success");
          this.render();
        } else {
          this.showNotification("Failed to import save", "error");
        }
      } catch (err) {
        console.error("Import error:", err);
        this.showNotification("Invalid save file", "error");
      }
    };
    reader.readAsText(file);
    event.target.value = "";
  }
  /**
   * Show notification (simple toast)
   */
  showNotification(message, type = "info") {
    const toast = document.createElement("div");
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: ${type === "success" ? "#10b37f" : type === "error" ? "#ff5d7a" : "#0bbbd1"};
      color: ${type === "error" ? "#fff" : "#000"};
      border-radius: 8px;
      font-weight: 600;
      z-index: 100000;
      animation: slideIn 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = "slideOut 0.3s ease";
      setTimeout(() => toast.remove(), 300);
    }, 2e3);
  }
  /**
   * Cleanup when destroyed
   */
  destroy() {
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
    }
    this.hide();
  }
}
class OptionsMenu {
  constructor(gameState2, settingsMenu2, saveManager2) {
    this.gameState = gameState2;
    this.settingsMenu = settingsMenu2;
    this.saveManager = saveManager2;
    this.modal = null;
  }
  /**
   * Show options menu modal
   */
  show() {
    if (this.modal) return;
    this.modal = document.createElement("div");
    this.modal.className = "options-menu-modal";
    this.modal.innerHTML = this.buildHTML();
    document.body.appendChild(this.modal);
    this.attachEventListeners();
  }
  /**
   * Hide and cleanup
   */
  hide() {
    if (this.modal) {
      this.modal.remove();
      this.modal = null;
    }
  }
  /**
   * Build main HTML structure
   */
  buildHTML() {
    return `
      <div class="options-menu-overlay">
        <div class="options-menu-container">
          <div class="options-menu-header">
            <h2>‚öôÔ∏è Options</h2>
            <button class="options-close-btn" id="opt-close">‚úï</button>
          </div>
          
          <div class="options-menu-grid">
            <button class="option-card" id="opt-save-load">
              <div class="option-icon">üíæ</div>
              <div class="option-title">Save / Load</div>
              <div class="option-desc">Manage your saved games</div>
            </button>

            <button class="option-card" id="opt-settings">
              <div class="option-icon">‚öôÔ∏è</div>
              <div class="option-title">Settings</div>
              <div class="option-desc">Game preferences and options</div>
            </button>

            <button class="option-card" id="opt-main-menu">
              <div class="option-icon">üè†</div>
              <div class="option-title">Main Menu</div>
              <div class="option-desc">Return to main menu</div>
            </button>

            <button class="option-card" id="opt-continue">
              <div class="option-icon">‚ñ∂Ô∏è</div>
              <div class="option-title">Resume</div>
              <div class="option-desc">Continue playing</div>
            </button>
          </div>
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    const closeBtn = this.modal.querySelector("#opt-close");
    closeBtn?.addEventListener("click", () => this.hide());
    const overlay = this.modal.querySelector(".options-menu-overlay");
    overlay?.addEventListener("click", (e) => {
      if (e.target === overlay) this.hide();
    });
    const saveLoadBtn = this.modal.querySelector("#opt-save-load");
    saveLoadBtn?.addEventListener("click", () => {
      this.hide();
      this.saveManager.show();
    });
    const settingsBtn = this.modal.querySelector("#opt-settings");
    settingsBtn?.addEventListener("click", () => {
      this.hide();
      this.settingsMenu.open();
    });
    const mainMenuBtn = this.modal.querySelector("#opt-main-menu");
    mainMenuBtn?.addEventListener("click", () => {
      this.handleMainMenu();
    });
    const continueBtn = this.modal.querySelector("#opt-continue");
    continueBtn?.addEventListener("click", () => {
      this.hide();
    });
    this.keyHandler = (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        this.hide();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
  /**
   * Handle return to main menu
   */
  handleMainMenu() {
    this.gameState.save("autosave");
    this.hide();
    const storyIntro2 = document.getElementById("story-intro");
    const gameView2 = document.getElementById("game-view");
    const characterCreation2 = document.getElementById("character-creation");
    if (storyIntro2) storyIntro2.classList.add("hidden");
    if (gameView2) gameView2.classList.add("hidden");
    if (characterCreation2) characterCreation2.classList.add("hidden");
    const mainMenuEl = document.getElementById("main-menu");
    if (mainMenuEl) mainMenuEl.classList.remove("hidden");
    if (window.game && window.game.mainMenu && typeof window.game.mainMenu.checkContinueButton === "function") {
      window.game.mainMenu.checkContinueButton();
    }
  }
  /**
   * Cleanup when destroyed
   */
  destroy() {
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
    }
    this.hide();
  }
}
class HexGrid {
  constructor(radius = 7) {
    this.radius = radius;
    this.hexSize = 40;
  }
  // ========================================
  // COORDINATE CONVERSIONS
  // ========================================
  // Convert axial (q, r) to cube (x, y, z) coordinates
  axialToCube(q, r) {
    const x = q;
    const z = r;
    const y = -x - z;
    return { x, y, z };
  }
  // Convert cube to axial coordinates
  cubeToAxial(x, y, z) {
    const q = x;
    const r = z;
    return { q, r };
  }
  // Convert axial to pixel coordinates (for rendering)
  axialToPixel(q, r) {
    const x = this.hexSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
    const y = this.hexSize * (3 / 2 * r);
    return { x, y };
  }
  // Convert pixel to axial coordinates (for mouse clicks)
  pixelToAxial(x, y) {
    const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / this.hexSize;
    const r = 2 / 3 * y / this.hexSize;
    return this.roundAxial(q, r);
  }
  // Round fractional axial coordinates to nearest hex
  roundAxial(q, r) {
    return this.cubeToAxial(...this.roundCube(q, -q - r, r));
  }
  // Round fractional cube coordinates
  roundCube(x, y, z) {
    let rx = Math.round(x);
    let ry = Math.round(y);
    let rz = Math.round(z);
    const x_diff = Math.abs(rx - x);
    const y_diff = Math.abs(ry - y);
    const z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) {
      rx = -ry - rz;
    } else if (y_diff > z_diff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }
    return [rx, ry, rz];
  }
  // ========================================
  // DISTANCE & NEIGHBORS
  // ========================================
  // Distance between two hexes (in hex units)
  distance(q1, r1, q2, r2) {
    const cube1 = this.axialToCube(q1, r1);
    const cube2 = this.axialToCube(q2, r2);
    return Math.max(
      Math.abs(cube1.x - cube2.x),
      Math.abs(cube1.y - cube2.y),
      Math.abs(cube1.z - cube2.z)
    );
  }
  // Get all 6 neighbors of a hex
  getNeighbors(q, r) {
    const directions = [
      { q: 1, r: 0 },
      // East
      { q: 1, r: -1 },
      // Northeast
      { q: 0, r: -1 },
      // Northwest
      { q: -1, r: 0 },
      // West
      { q: -1, r: 1 },
      // Southwest
      { q: 0, r: 1 }
      // Southeast
    ];
    return directions.map((dir) => ({
      q: q + dir.q,
      r: r + dir.r
    }));
  }
  // Get specific neighbor by direction (0-5)
  getNeighbor(q, r, direction) {
    const neighbors = this.getNeighbors(q, r);
    return neighbors[direction % 6];
  }
  // ========================================
  // AREA QUERIES
  // ========================================
  // Get all hexes within a certain range
  getHexesInRange(centerQ, centerR, range) {
    const hexes = [];
    for (let q = -range; q <= range; q++) {
      const r1 = Math.max(-range, -q - range);
      const r2 = Math.min(range, -q + range);
      for (let r = r1; r <= r2; r++) {
        hexes.push({ q: centerQ + q, r: centerR + r });
      }
    }
    return hexes;
  }
  // Get hexes in a ring at exact distance
  getRing(centerQ, centerR, radius) {
    const results = [];
    if (radius === 0) {
      return [{ q: centerQ, r: centerR }];
    }
    let hex = { q: centerQ - radius, r: centerR + radius };
    const directions = [
      { q: 1, r: -1 },
      { q: 1, r: 0 },
      { q: 0, r: 1 },
      { q: -1, r: 1 },
      { q: -1, r: 0 },
      { q: 0, r: -1 }
    ];
    for (let i = 0; i < 6; i++) {
      for (let j = 0; j < radius; j++) {
        results.push({ ...hex });
        hex.q += directions[i].q;
        hex.r += directions[i].r;
      }
    }
    return results;
  }
  // Get all hexes in a line between two points
  getLine(q1, r1, q2, r2) {
    const dist = this.distance(q1, r1, q2, r2);
    if (dist === 0) return [{ q: q1, r: r1 }];
    const results = [];
    for (let i = 0; i <= dist; i++) {
      const t = i / dist;
      const q = q1 * (1 - t) + q2 * t;
      const r = r1 * (1 - t) + r2 * t;
      const rounded = this.roundAxial(q, r);
      results.push(rounded);
    }
    return results;
  }
  // ========================================
  // MAP GENERATION HELPERS
  // ========================================
  // Generate all hexes in a circular map
  generateCircularMap(radius) {
    const hexes = [];
    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        if (this.distance(0, 0, q, r) <= radius) {
          hexes.push({ q, r });
        }
      }
    }
    return hexes;
  }
  // Check if hex is within map bounds
  isInBounds(q, r, radius) {
    return this.distance(0, 0, q, r) <= radius;
  }
  // ========================================
  // PATHFINDING (A*)
  // ========================================
  // Find shortest path between two hexes
  findPath(startQ, startR, goalQ, goalR, costFn = () => 1) {
    const start2 = { q: startQ, r: startR };
    const goal = { q: goalQ, r: goalR };
    const frontier = [{ hex: start2, priority: 0 }];
    const cameFrom = /* @__PURE__ */ new Map();
    const costSoFar = /* @__PURE__ */ new Map();
    const key = (hex) => `${hex.q},${hex.r}`;
    cameFrom.set(key(start2), null);
    costSoFar.set(key(start2), 0);
    while (frontier.length > 0) {
      frontier.sort((a, b) => a.priority - b.priority);
      const current2 = frontier.shift().hex;
      if (current2.q === goal.q && current2.r === goal.r) {
        break;
      }
      const neighbors = this.getNeighbors(current2.q, current2.r);
      for (const next of neighbors) {
        const newCost = costSoFar.get(key(current2)) + costFn(next.q, next.r);
        const nextKey = key(next);
        if (!costSoFar.has(nextKey) || newCost < costSoFar.get(nextKey)) {
          costSoFar.set(nextKey, newCost);
          const priority = newCost + this.distance(next.q, next.r, goal.q, goal.r);
          frontier.push({ hex: next, priority });
          cameFrom.set(nextKey, current2);
        }
      }
    }
    const path = [];
    let current = goal;
    while (current) {
      path.unshift(current);
      current = cameFrom.get(key(current));
    }
    return path.length > 0 && path[0].q === start2.q && path[0].r === start2.r ? path : [];
  }
  // ========================================
  // RENDERING HELPERS
  // ========================================
  // Get polygon points for drawing a hex
  getHexCorners(q, r) {
    const center = this.axialToPixel(q, r);
    const corners = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 6;
      corners.push({
        x: center.x + this.hexSize * Math.cos(angle),
        y: center.y + this.hexSize * Math.sin(angle)
      });
    }
    return corners;
  }
}
class SimplexNoise {
  constructor(seed = 0) {
    if (typeof seed === "string") {
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        hash = (hash << 5) - hash + seed.charCodeAt(i);
        hash = hash & hash;
      }
      seed = Math.abs(hash);
    }
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ];
    this.p = [];
    for (let i = 0; i < 256; i++) {
      this.p[i] = i;
    }
    let n, q;
    for (let i = 255; i > 0; i--) {
      n = Math.floor((seed = seed * 16807 % 2147483647) / 2147483647 * (i + 1));
      q = this.p[i];
      this.p[i] = this.p[n];
      this.p[n] = q;
    }
    this.perm = [];
    this.permMod12 = [];
    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }
  dot(g, x, y) {
    return g[0] * x + g[1] * y;
  }
  noise2D(xin, yin) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    let n0, n1, n2;
    const s = (xin + yin) * F2;
    const i = Math.floor(xin + s);
    const j = Math.floor(yin + s);
    const t = (i + j) * G2;
    const X0 = i - t;
    const Y0 = j - t;
    const x0 = xin - X0;
    const y0 = yin - Y0;
    let i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    const x1 = x0 - i1 + G2;
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2;
    const y2 = y0 - 1 + 2 * G2;
    const ii = i & 255;
    const jj = j & 255;
    const permJJ = this.perm[jj] || 0;
    const permJJ1 = this.perm[jj + j1 & 255] || 0;
    const permJJ2 = this.perm[jj + 1 & 255] || 0;
    const gi0 = this.permMod12[ii + permJJ & 511] || 0;
    const gi1 = this.permMod12[ii + i1 + permJJ1 & 511] || 0;
    const gi2 = this.permMod12[ii + 1 + permJJ2 & 511] || 0;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      const g0 = this.grad3[gi0];
      n0 = g0 ? t0 * t0 * this.dot(g0, x0, y0) : 0;
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      const g1 = this.grad3[gi1];
      n1 = g1 ? t1 * t1 * this.dot(g1, x1, y1) : 0;
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) {
      n2 = 0;
    } else {
      t2 *= t2;
      const g2 = this.grad3[gi2];
      n2 = g2 ? t2 * t2 * this.dot(g2, x2, y2) : 0;
    }
    return 70 * (n0 + n1 + n2);
  }
  // Fractal/Octave noise for more natural terrain
  fractal(x, y, octaves = 4, persistence = 0.5, lacunarity = 2) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;
    for (let i = 0; i < octaves; i++) {
      total += this.noise2D(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= persistence;
      frequency *= lacunarity;
    }
    return total / maxValue;
  }
}
class MapEngine {
  constructor(hexGrid, noise, rng) {
    this.hexGrid = hexGrid;
    this.noise = noise;
    this.rng = rng;
    this.seed = rng.seed;
    this.tiles = /* @__PURE__ */ new Map();
    this.config = {
      radius: 20,
      oceanBoundaryWidth: 1,
      // Minimal ocean boundary - land extends to near edge
      elevationScale: 0.12,
      // Lower = smoother terrain (less fragmentation)
      moistureScale: 0.14,
      falloffExponent: 1.5,
      // Lower = gentler falloff (land extends further out)
      beachWidth: 1,
      riverSources: 3,
      // More rivers for a larger island
      landThreshold: 0.25,
      // Lower = more land coverage
      edgeNoiseStrength: 0.15,
      // Reduced for smoother coastline
      continentBlend: 0.6
      // Balanced blend (60% falloff, 40% noise for natural edges)
    };
  }
  // ========================================
  // MAIN GENERATION PIPELINE
  // ========================================
  generate() {
    console.log(`üèùÔ∏è Generating island with seed: ${this.seed}`);
    const hexes = this.hexGrid.generateCircularMap(this.config.radius);
    console.log(`üìê Generated ${hexes.length} hexes in circular pattern`);
    this.generateElevation(hexes);
    console.log(`‚õ∞Ô∏è  Generated elevation with radial falloff`);
    this.thresholdLandSea();
    console.log(`üåä Separated land from sea`);
    this.ensureSingleLandmass();
    console.log(`üèùÔ∏è  Ensured single connected landmass`);
    this.markBeaches();
    console.log(`üèñÔ∏è  Marked beach tiles`);
    this.markCliffs();
    console.log(`üèîÔ∏è  Marked cliff coastlines`);
    this.carveRiver();
    console.log(`üèûÔ∏è  Carved rivers from mountains to sea`);
    this.generateMoisture();
    console.log(`üíß Generated moisture distribution`);
    this.assignBiomes();
    console.log(`üå¥ Assigned biomes based on elevation and moisture`);
    this.smoothBiomes();
    console.log(`‚ú® Smoothed biome transitions`);
    this.placeStrategicLocations();
    console.log(`üìç Placed strategic locations`);
    this.generateFactionTerritories();
    console.log(`‚öîÔ∏è  Generated faction territories`);
    const stats = this.getMapStats();
    console.log(`üìä Map Stats:`, stats);
    return {
      tiles: this.tiles,
      hexGrid: this.hexGrid,
      seed: this.seed,
      stats,
      config: this.config,
      strategicLocations: this.strategicLocations,
      territories: this.territories
    };
  }
  // ========================================
  // STEP 1: ELEVATION GENERATION
  // ========================================
  generateElevation(hexes) {
    const noise = new SimplexNoise(this.seed);
    const edgeNoise = new SimplexNoise(this.seed + 500);
    for (const hex of hexes) {
      const distFromCenter = this.hexGrid.distance(0, 0, hex.q, hex.r);
      distFromCenter / this.config.radius;
      const oceanBoundaryDist = this.config.radius - this.config.oceanBoundaryWidth;
      if (distFromCenter > oceanBoundaryDist) {
        this.setTile(hex.q, hex.r, {
          q: hex.q,
          r: hex.r,
          elevation: 0,
          terrain: null,
          moisture: 0,
          isEdge: true
        });
        continue;
      }
      const landRadius = oceanBoundaryDist;
      const landDist = distFromCenter / landRadius;
      const coastlineNoise = edgeNoise.noise2D(hex.q * 0.2, hex.r * 0.2);
      const adjustedLandDist = Math.max(0, landDist + coastlineNoise * this.config.edgeNoiseStrength);
      const falloff = Math.pow(1 - adjustedLandDist, this.config.falloffExponent);
      const noiseValue = noise.fractal(
        hex.q * this.config.elevationScale,
        hex.r * this.config.elevationScale,
        4,
        // octaves
        0.5,
        // persistence
        2
        // lacunarity
      );
      const elevation = this.config.continentBlend * falloff + (1 - this.config.continentBlend) * (noiseValue * 0.5 + 0.5);
      this.setTile(hex.q, hex.r, {
        q: hex.q,
        r: hex.r,
        elevation: Math.max(0, Math.min(1, elevation)),
        terrain: null,
        moisture: 0,
        isEdge: false
      });
    }
  }
  // ========================================
  // STEP 2: LAND/SEA THRESHOLD
  // ========================================
  thresholdLandSea() {
    for (const [key, tile] of this.tiles) {
      if (tile.isEdge || tile.elevation <= this.config.landThreshold) {
        tile.terrain = "sea";
        tile.isLand = false;
        tile.isPassable = false;
      } else {
        tile.isLand = true;
        tile.isPassable = true;
      }
    }
  }
  // ========================================
  // STEP 2.5: ENSURE SINGLE LANDMASS
  // ========================================
  ensureSingleLandmass() {
    const landmasses = [];
    const visited = /* @__PURE__ */ new Set();
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || visited.has(key)) continue;
      const landmass = [];
      const queue = [tile];
      visited.add(key);
      while (queue.length > 0) {
        const current = queue.shift();
        landmass.push(current);
        const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
        for (const n of neighbors) {
          const neighborKey = this.key(n.q, n.r);
          if (visited.has(neighborKey)) continue;
          const neighbor = this.getTile(n.q, n.r);
          if (!neighbor || !neighbor.isLand) continue;
          visited.add(neighborKey);
          queue.push(neighbor);
        }
      }
      landmasses.push(landmass);
    }
    if (landmasses.length === 0) {
      console.warn("‚ö†Ô∏è  No landmass found! Adjusting parameters...");
      return;
    }
    landmasses.sort((a, b) => b.length - a.length);
    const mainLandmass = landmasses[0];
    console.log(`üèùÔ∏è  Found ${landmasses.length} landmass(es). Largest: ${mainLandmass.length} tiles`);
    let removedTiles = 0;
    for (let i = 1; i < landmasses.length; i++) {
      for (const tile of landmasses[i]) {
        tile.terrain = "sea";
        tile.isLand = false;
        tile.isPassable = false;
        tile.elevation = 0;
        removedTiles++;
      }
    }
    if (removedTiles > 0) {
      console.log(`üåä Removed ${removedTiles} tiles from ${landmasses.length - 1} small island(s)`);
    }
  }
  // ========================================
  // STEP 3: BEACHES
  // ========================================
  markBeaches() {
    const beachTiles = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand) continue;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const hasSeaNeighbor = neighbors.some((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.terrain === "sea";
      });
      if (hasSeaNeighbor) {
        tile.terrain = "beach";
        tile.distanceToWater = 0;
        beachTiles.push(tile);
      }
    }
    this.calculateWaterDistance(beachTiles);
  }
  calculateWaterDistance(waterTiles) {
    const queue = [...waterTiles];
    const visited = new Set(waterTiles.map((t) => this.key(t.q, t.r)));
    while (queue.length > 0) {
      const current = queue.shift();
      const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
      for (const n of neighbors) {
        const key = this.key(n.q, n.r);
        if (visited.has(key)) continue;
        const neighbor = this.getTile(n.q, n.r);
        if (!neighbor || !neighbor.isLand) continue;
        neighbor.distanceToWater = (current.distanceToWater || 0) + 1;
        visited.add(key);
        queue.push(neighbor);
      }
    }
  }
  // ========================================
  // STEP 3.5: CLIFFS
  // ========================================
  markCliffs() {
    let cliffCount = 0;
    for (const [key, tile] of this.tiles) {
      if (tile.terrain !== "beach") continue;
      if (tile.elevation >= 0.6) {
        tile.terrain = "cliff";
        tile.isPassable = true;
        tile.canLandFromSea = false;
        tile.isCliff = true;
        cliffCount++;
      }
    }
    console.log(`üèîÔ∏è  Converted ${cliffCount} high-elevation beaches to cliffs`);
  }
  // ========================================
  // STEP 4: RIVER CARVING
  // ========================================
  carveRiver() {
    const potentialSources = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach") continue;
      if (tile.elevation > 0.65 && tile.distanceToWater > 3) {
        potentialSources.push(tile);
      }
    }
    if (potentialSources.length === 0) {
      console.warn("‚ö†Ô∏è  No suitable river sources found");
      return;
    }
    potentialSources.sort((a, b) => b.elevation - a.elevation);
    const numRivers = Math.min(this.config.riverSources, potentialSources.length);
    const riverSources = potentialSources.slice(0, numRivers);
    console.log(`üèûÔ∏è  Carving ${numRivers} river(s) from sources at elevation ${riverSources[0].elevation.toFixed(2)}`);
    let totalRiverTiles = 0;
    for (let i = 0; i < riverSources.length; i++) {
      const source = riverSources[i];
      const riverPath = [];
      let current = source;
      const visited = /* @__PURE__ */ new Set();
      while (current && current.terrain !== "sea" && riverPath.length < 100) {
        riverPath.push(current);
        visited.add(this.key(current.q, current.r));
        const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
        let lowest = null;
        let lowestScore = Infinity;
        for (const n of neighbors) {
          const neighbor = this.getTile(n.q, n.r);
          if (!neighbor || visited.has(this.key(n.q, n.r))) continue;
          const elevationScore = neighbor.elevation * 100;
          const waterScore = (neighbor.distanceToWater || 10) * 2;
          const score = elevationScore + waterScore;
          if (score < lowestScore) {
            lowestScore = score;
            lowest = neighbor;
          }
        }
        current = lowest;
      }
      for (const tile of riverPath) {
        if (tile.terrain !== "beach") {
          tile.terrain = "river";
          tile.isRiver = true;
          tile.isPassable = true;
          tile.distanceToWater = 0;
          totalRiverTiles++;
        }
      }
      console.log(`   River ${i + 1}: ${riverPath.length} tiles`);
    }
    console.log(`üèûÔ∏è  Total river tiles: ${totalRiverTiles}`);
  }
  // ========================================
  // STEP 5: MOISTURE GENERATION
  // ========================================
  generateMoisture() {
    const noise = new SimplexNoise(this.seed + 1e3);
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand) {
        tile.moisture = 0;
        continue;
      }
      const baseMoisture = noise.fractal(
        tile.q * this.config.moistureScale,
        tile.r * this.config.moistureScale,
        3
      ) * 0.5 + 0.5;
      const waterProximity = 1 / (1 + (tile.distanceToWater || 10) * 0.3);
      tile.moisture = Math.max(0, Math.min(1, baseMoisture * 0.6 + waterProximity * 0.4));
    }
  }
  // ========================================
  // STEP 6: BIOME ASSIGNMENT
  // ========================================
  assignBiomes() {
    for (const [key, tile] of this.tiles) {
      if (tile.terrain === "sea" || tile.terrain === "beach" || tile.terrain === "cliff" || tile.terrain === "river") {
        continue;
      }
      const elev = tile.elevation;
      const moist = tile.moisture;
      const distToWater = tile.distanceToWater || 999;
      if (elev < 0.4 && moist > 0.7 && distToWater <= 2) {
        tile.terrain = "mangrove";
        continue;
      }
      if (elev < 0.45 && moist > 0.6 && distToWater === 1) {
        tile.terrain = "palm-grove";
        continue;
      }
      if (elev < 0.5) {
        if (moist < 0.3) tile.terrain = "savanna";
        else if (moist < 0.6) tile.terrain = "forest";
        else tile.terrain = "rainforest";
      } else if (elev < 0.7) {
        if (moist < 0.35) {
          tile.terrain = "scrubland";
        } else if (moist < 0.5) {
          tile.terrain = "dry-hill";
        } else if (moist < 0.75) {
          if (moist > 0.65 && elev >= 0.45 && elev < 0.6) {
            tile.terrain = "bamboo-forest";
          } else {
            tile.terrain = "jungle-hill";
          }
        } else {
          tile.terrain = "cloud-forest";
        }
      } else {
        if (moist < 0.5) tile.terrain = "rocky-peak";
        else tile.terrain = "misty-peak";
      }
    }
    this.ensureBiomeDiversity();
  }
  /**
   * Ensure all major biomes are represented on the map
   * This prevents unlucky RNG from creating monotonous islands
   */
  ensureBiomeDiversity() {
    const requiredBiomes = [
      "savanna",
      "forest",
      "rainforest",
      "dry-hill",
      "jungle-hill",
      "cloud-forest",
      "rocky-peak",
      "misty-peak",
      // New biomes (optional but encouraged)
      "mangrove",
      "palm-grove",
      "bamboo-forest",
      "scrubland"
    ];
    const biomeCounts = {};
    for (const [key, tile] of this.tiles) {
      if (tile.isLand && tile.terrain !== "beach" && tile.terrain !== "cliff" && tile.terrain !== "river") {
        biomeCounts[tile.terrain] = (biomeCounts[tile.terrain] || 0) + 1;
      }
    }
    const missingBiomes = requiredBiomes.filter((b) => !biomeCounts[b] || biomeCounts[b] < 3);
    if (missingBiomes.length > 0) {
      console.log(`üé≤ Seeding missing biomes: ${missingBiomes.join(", ")}`);
      for (const biome of missingBiomes) {
        const candidates = [];
        for (const [key, tile] of this.tiles) {
          if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "cliff" || tile.terrain === "river") continue;
          const suitability = this.getBiomeSuitability(tile, biome);
          if (suitability > 0.5) {
            candidates.push({ tile, suitability });
          }
        }
        candidates.sort((a, b) => b.suitability - a.suitability);
        const numToConvert = Math.min(5, candidates.length);
        for (let i = 0; i < numToConvert; i++) {
          candidates[i].tile.terrain = biome;
        }
      }
    }
  }
  /**
   * Calculate how suitable a tile is for a given biome (0-1)
   */
  getBiomeSuitability(tile, biome) {
    const elev = tile.elevation;
    const moist = tile.moisture;
    const distToWater = tile.distanceToWater || 999;
    const biomeRanges = {
      "savanna": { elevMin: 0.35, elevMax: 0.5, moistMin: 0, moistMax: 0.3 },
      "forest": { elevMin: 0.35, elevMax: 0.5, moistMin: 0.3, moistMax: 0.6 },
      "rainforest": { elevMin: 0.35, elevMax: 0.5, moistMin: 0.6, moistMax: 1 },
      "mangrove": { elevMin: 0.25, elevMax: 0.4, moistMin: 0.7, moistMax: 1, maxDistToWater: 2 },
      "palm-grove": { elevMin: 0.25, elevMax: 0.45, moistMin: 0.6, moistMax: 1, maxDistToWater: 1 },
      "scrubland": { elevMin: 0.35, elevMax: 0.55, moistMin: 0, moistMax: 0.35 },
      "dry-hill": { elevMin: 0.5, elevMax: 0.7, moistMin: 0, moistMax: 0.5 },
      "jungle-hill": { elevMin: 0.5, elevMax: 0.7, moistMin: 0.4, moistMax: 0.75 },
      "bamboo-forest": { elevMin: 0.45, elevMax: 0.6, moistMin: 0.65, moistMax: 1 },
      "cloud-forest": { elevMin: 0.5, elevMax: 0.7, moistMin: 0.7, moistMax: 1 },
      "rocky-peak": { elevMin: 0.7, elevMax: 1, moistMin: 0, moistMax: 0.5 },
      "misty-peak": { elevMin: 0.7, elevMax: 1, moistMin: 0.5, moistMax: 1 }
    };
    const range = biomeRanges[biome];
    if (!range) return 0;
    const elevScore = elev >= range.elevMin && elev <= range.elevMax ? 1 : 0;
    const moistScore = moist >= range.moistMin && moist <= range.moistMax ? 1 : 0;
    let waterScore = 1;
    if (range.maxDistToWater !== void 0) {
      waterScore = distToWater <= range.maxDistToWater ? 1 : 0;
    }
    return (elevScore + moistScore + waterScore) / 3;
  }
  // ========================================
  // STEP 7: SMOOTHING
  // ========================================
  smoothBiomes(passes = 2) {
    for (let pass = 0; pass < passes; pass++) {
      const changes = [];
      for (const [key, tile] of this.tiles) {
        if (!tile.isLand || tile.isRiver || tile.terrain === "beach" || tile.terrain === "cliff") continue;
        const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
        const neighborTerrains = neighbors.map((n) => this.getTile(n.q, n.r)).filter((n) => n && n.isLand).map((n) => n.terrain);
        const counts = {};
        for (const terrain of neighborTerrains) {
          counts[terrain] = (counts[terrain] || 0) + 1;
        }
        const modal = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
        if (modal && modal[1] >= 4 && modal[0] !== tile.terrain) {
          changes.push({ tile, newTerrain: modal[0] });
        }
      }
      for (const { tile, newTerrain } of changes) {
        tile.terrain = newTerrain;
      }
    }
  }
  // ========================================
  // UTILITY METHODS
  // ========================================
  key(q, r) {
    return `${q},${r}`;
  }
  getTile(q, r) {
    return this.tiles.get(this.key(q, r));
  }
  setTile(q, r, data) {
    this.tiles.set(this.key(q, r), data);
  }
  getMapStats() {
    const stats = {
      totalTiles: this.tiles.size,
      terrainCounts: {},
      landTiles: 0,
      seaTiles: 0,
      landPercentage: 0,
      edgeTiles: 0
    };
    for (const [key, tile] of this.tiles) {
      stats.terrainCounts[tile.terrain] = (stats.terrainCounts[tile.terrain] || 0) + 1;
      if (tile.isLand) stats.landTiles++;
      else stats.seaTiles++;
      if (tile.isEdge) stats.edgeTiles++;
    }
    stats.landPercentage = (stats.landTiles / stats.totalTiles * 100).toFixed(1);
    return stats;
  }
  // ========================================
  // STRATEGIC LOCATIONS PLACEMENT
  // ========================================
  /**
   * Get the quadrant of a hex coordinate (for distributing locations)
   * Returns: 'NE', 'SE', 'SW', 'NW' based on q and r values
   */
  getQuadrant(q, r) {
    if (q >= 0 && r < 0) return "NE";
    if (q > 0 && r >= 0) return "SE";
    if (q <= 0 && r > 0) return "SW";
    return "NW";
  }
  /**
   * Place strategic locations: villages, sacred sites, compounds, etc.
   * These are story-critical locations that serve as faction capitals
   * and major POIs for the narrative.
   */
  placeStrategicLocations() {
    this.strategicLocations = {
      tidalVillage: null,
      ridgeVillage: null,
      mercenaryCompound: null,
      castawayBeach: null,
      sacredSites: [],
      shipwrecks: [],
      landmarks: {
        waterfall: null,
        hotSpring: null,
        caves: [],
        harbor: null
      },
      ruins: []
    };
    const minDistanceBetweenBases = Math.floor(this.config.radius * 0.6);
    const placedLocations = [];
    this.strategicLocations.castawayBeach = this.findCastawayStartingBeach();
    if (this.strategicLocations.castawayBeach) {
      placedLocations.push(this.strategicLocations.castawayBeach.tile);
    }
    this.strategicLocations.tidalVillage = this.findTidalVillage(placedLocations, minDistanceBetweenBases);
    if (this.strategicLocations.tidalVillage) {
      placedLocations.push(this.strategicLocations.tidalVillage.tile);
    }
    this.strategicLocations.ridgeVillage = this.findRidgeVillage(placedLocations, minDistanceBetweenBases);
    if (this.strategicLocations.ridgeVillage) {
      placedLocations.push(this.strategicLocations.ridgeVillage.tile);
    }
    this.strategicLocations.mercenaryCompound = this.findMercenaryCompound(placedLocations, minDistanceBetweenBases);
    if (this.strategicLocations.mercenaryCompound) {
      placedLocations.push(this.strategicLocations.mercenaryCompound.tile);
    }
    this.strategicLocations.sacredSites = this.placeSacredSites();
    this.strategicLocations.shipwrecks = this.placeShipwrecks();
    this.placeNaturalLandmarks();
    this.strategicLocations.ruins = this.placeAncientRuins();
    this.markStrategicTiles();
    const totalPOIs = (this.strategicLocations.castawayBeach ? 1 : 0) + (this.strategicLocations.tidalVillage ? 1 : 0) + (this.strategicLocations.ridgeVillage ? 1 : 0) + (this.strategicLocations.mercenaryCompound ? 1 : 0) + this.strategicLocations.sacredSites.length + this.strategicLocations.shipwrecks.length + (this.strategicLocations.landmarks.waterfall ? 1 : 0) + (this.strategicLocations.landmarks.hotSpring ? 1 : 0) + this.strategicLocations.landmarks.caves.length + (this.strategicLocations.landmarks.harbor ? 1 : 0) + this.strategicLocations.ruins.length;
    console.log(`üìç POI Summary: ${totalPOIs} total locations`, {
      villages: 2,
      compounds: 1,
      sacredSites: this.strategicLocations.sacredSites.length,
      shipwrecks: this.strategicLocations.shipwrecks.length,
      landmarks: (this.strategicLocations.landmarks.waterfall ? 1 : 0) + (this.strategicLocations.landmarks.hotSpring ? 1 : 0) + this.strategicLocations.landmarks.caves.length + (this.strategicLocations.landmarks.harbor ? 1 : 0),
      ruins: this.strategicLocations.ruins.length
    });
    if (this.strategicLocations.castawayBeach && this.strategicLocations.tidalVillage) {
      const dist = this.hexGrid.distance(
        this.strategicLocations.castawayBeach.tile.q,
        this.strategicLocations.castawayBeach.tile.r,
        this.strategicLocations.tidalVillage.tile.q,
        this.strategicLocations.tidalVillage.tile.r
      );
      console.log(`  üìè Castaway ‚Üî Tidal: ${dist} tiles`);
    }
  }
  /**
   * Find suitable location for castaway starting beach
   * Requirements: Beach, southern area, accessible to interior
   */
  findCastawayStartingBeach() {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (tile.terrain !== "beach") continue;
      if (tile.isCliff) continue;
      const southScore = Math.max(0, tile.r) / this.config.radius;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const landNeighbors = neighbors.filter((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.isLand && neighbor.terrain !== "sea";
      }).length;
      const accessScore = landNeighbors / 6;
      const distFromCenter = this.hexGrid.distance(0, 0, tile.q, tile.r);
      const edgeScore = distFromCenter / this.config.radius;
      const totalScore = southScore * 0.4 + accessScore * 0.4 + edgeScore * 0.2;
      candidates.push({ tile, score: totalScore });
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Castaway Beach",
      type: "starting-point",
      tile: candidates[0].tile,
      description: "Where your journey began. The wreckage of your arrival still litters the sand."
    };
  }
  /**
   * Find suitable location for Tidal Clan village
   * Requirements: Coastal, near river mouth, moderate elevation, far from other bases
   */
  findTidalVillage(existingLocations = [], minDistance = 10) {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (tile.terrain === "sea") continue;
      if (existingLocations.length > 0) {
        const tooClose = existingLocations.some(
          (loc) => this.hexGrid.distance(tile.q, tile.r, loc.q, loc.r) < minDistance
        );
        if (tooClose) continue;
      }
      let coastalScore = 0;
      if (tile.terrain === "beach") {
        coastalScore = 1;
      } else {
        const neighbors2 = this.hexGrid.getNeighbors(tile.q, tile.r);
        const hasBeachNeighbor = neighbors2.some((n) => {
          const neighbor = this.getTile(n.q, n.r);
          return neighbor && neighbor.terrain === "beach";
        });
        if (hasBeachNeighbor && tile.isLand) {
          coastalScore = 0.7;
        } else {
          continue;
        }
      }
      let riverScore = 0;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const nearRiver = neighbors.some((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.terrain === "river";
      });
      if (nearRiver) riverScore = 1;
      const elevScore = tile.elevation < 0.5 ? 1 : 0.3;
      const terrainScore = tile.terrain === "forest" || tile.terrain === "savanna" ? 1 : 0.5;
      let quadrantBonus = 0;
      if (existingLocations.length > 0) {
        const tileQuadrant = this.getQuadrant(tile.q, tile.r);
        const differentQuadrants = existingLocations.every(
          (loc) => this.getQuadrant(loc.q, loc.r) !== tileQuadrant
        );
        if (differentQuadrants) quadrantBonus = 0.5;
      }
      const totalScore = coastalScore * 0.4 + riverScore * 0.3 + elevScore * 0.15 + terrainScore * 0.1 + quadrantBonus * 0.05;
      candidates.push({ tile, score: totalScore });
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Tidal Village",
      type: "native-village",
      faction: "tidal-clan",
      tile: candidates[0].tile,
      description: "The Tidal Clan's seaside settlement. They are masters of fishing and sailing."
    };
  }
  /**
   * Find suitable location for Ridge Clan village
   * Requirements: Highland/mountain area, defensible, far from other bases
   */
  findRidgeVillage(existingLocations = [], minDistance = 10) {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "sea") continue;
      if (tile.elevation < 0.6) continue;
      if (existingLocations.length > 0) {
        const tooClose = existingLocations.some(
          (loc) => this.hexGrid.distance(tile.q, tile.r, loc.q, loc.r) < minDistance
        );
        if (tooClose) continue;
      }
      const elevScore = tile.elevation;
      const terrainScore = tile.terrain.includes("hill") || tile.terrain.includes("peak") ? 1 : 0.5;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const difficultNeighbors = neighbors.filter((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return !neighbor || !neighbor.isPassable || neighbor.elevation > 0.6;
      }).length;
      const defenseScore = difficultNeighbors / 6;
      const interiorScore = (tile.distanceToWater || 0) / 10;
      let quadrantBonus = 0;
      if (existingLocations.length > 0) {
        const tileQuadrant = this.getQuadrant(tile.q, tile.r);
        const differentQuadrants = existingLocations.every(
          (loc) => this.getQuadrant(loc.q, loc.r) !== tileQuadrant
        );
        if (differentQuadrants) quadrantBonus = 0.5;
      }
      const totalScore = elevScore * 0.25 + terrainScore * 0.25 + defenseScore * 0.2 + interiorScore * 0.15 + quadrantBonus * 0.15;
      candidates.push({ tile, score: totalScore });
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Ridge Village",
      type: "native-village",
      faction: "ridge-clan",
      tile: candidates[0].tile,
      description: "The Ridge Clan's highland fortress. They are fierce warriors and spiritual guides."
    };
  }
  /**
   * Find suitable location for mercenary compound
   * Requirements: Defensible, resource-rich area, not too remote, far from other bases
   */
  findMercenaryCompound(existingLocations = [], minDistance = 10) {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "sea") continue;
      if (existingLocations.length > 0) {
        const tooClose = existingLocations.some(
          (loc) => this.hexGrid.distance(tile.q, tile.r, loc.q, loc.r) < minDistance
        );
        if (tooClose) continue;
      }
      const idealElev = 0.55;
      const elevScore = 1 - Math.abs(tile.elevation - idealElev);
      const resourceBiomes = ["forest", "jungle-hill", "dry-hill"];
      const resourceScore = resourceBiomes.includes(tile.terrain) ? 1 : 0.5;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const passableNeighbors = neighbors.filter((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.isPassable;
      }).length;
      const defenseScore = 1 - passableNeighbors / 6;
      const centralityScore = 1 - this.hexGrid.distance(0, 0, tile.q, tile.r) / this.config.radius;
      let quadrantBonus = 0;
      if (existingLocations.length > 0) {
        const tileQuadrant = this.getQuadrant(tile.q, tile.r);
        const differentQuadrants = existingLocations.every(
          (loc) => this.getQuadrant(loc.q, loc.r) !== tileQuadrant
        );
        if (differentQuadrants) quadrantBonus = 0.5;
      }
      const totalScore = elevScore * 0.25 + resourceScore * 0.25 + defenseScore * 0.15 + centralityScore * 0.15 + quadrantBonus * 0.2;
      candidates.push({ tile, score: totalScore });
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Blacksteel Compound",
      type: "hostile-base",
      faction: "mercenaries",
      tile: candidates[0].tile,
      description: "A fortified compound controlled by ruthless mercenaries. Approach with caution."
    };
  }
  /**
   * Place sacred sites (3-5 locations)
   * Requirements: High elevation, special biomes, distributed across map
   */
  placeSacredSites() {
    const sacredSites = [];
    const numSites = 3 + Math.floor(this.rng.next() * 3);
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "cliff" || tile.terrain === "sea") continue;
      let score = 0;
      if (tile.terrain === "misty-peak" || tile.terrain === "rocky-peak") {
        score += tile.elevation * 2;
      }
      if (tile.terrain === "cloud-forest") {
        score += 1.5;
      }
      const remoteness = (tile.distanceToWater || 5) / 10;
      score += remoteness * 0.5;
      if (score > 0) {
        candidates.push({ tile, score });
      }
    }
    if (candidates.length === 0) return sacredSites;
    candidates.sort((a, b) => b.score - a.score);
    for (let i = 0; i < Math.min(numSites, candidates.length); i++) {
      const candidate = candidates[i];
      const tooClose = sacredSites.some((site) => {
        return this.hexGrid.distance(
          site.tile.q,
          site.tile.r,
          candidate.tile.q,
          candidate.tile.r
        ) < 5;
      });
      if (!tooClose) {
        sacredSites.push({
          name: `Sacred Site ${String.fromCharCode(65 + sacredSites.length)}`,
          // A, B, C...
          type: "sacred-site",
          tile: candidate.tile,
          description: "A place where the Pulse flows strong. The natives hold this land as sacred."
        });
      }
    }
    return sacredSites;
  }
  /**
   * Place shipwrecks (2-3 locations)
   * Requirements: Beach/coast, remote, salvageable loot
   */
  placeShipwrecks() {
    const numWrecks = 2 + Math.floor(this.rng.next() * 2);
    const wrecks = [];
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (tile.terrain !== "beach") continue;
      const distFromCenter = this.hexGrid.distance(0, 0, tile.q, tile.r);
      const remoteness = distFromCenter / this.config.radius;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const nearSea = neighbors.some((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.terrain === "sea";
      });
      if (!nearSea) continue;
      const score = remoteness * 0.7 + this.rng.next() * 0.3;
      candidates.push({ tile, score });
    }
    if (candidates.length === 0) {
      console.warn("‚ö†Ô∏è  No suitable shipwreck locations found");
      return wrecks;
    }
    candidates.sort((a, b) => b.score - a.score);
    for (let i = 0; i < Math.min(numWrecks, candidates.length); i++) {
      const candidate = candidates[i];
      const tooClose = wrecks.some(
        (w) => this.hexGrid.distance(w.tile.q, w.tile.r, candidate.tile.q, candidate.tile.r) < 8
      );
      if (!tooClose) {
        const wreckNames = ["Broken Promise", "Sea Maiden", "Fortune's Folly", "Last Hope", "Wayward Soul"];
        const lootQuality = this.rng.next();
        wrecks.push({
          name: `Shipwreck: ${wreckNames[i % wreckNames.length]}`,
          type: "shipwreck",
          tile: candidate.tile,
          description: "The remains of a ship that wasn't so lucky. May contain salvage.",
          lootQuality: lootQuality > 0.7 ? "rich" : lootQuality > 0.3 ? "normal" : "poor",
          looted: false
        });
      }
    }
    console.log(`‚öì Placed ${wrecks.length} shipwrecks on remote beaches`);
    return wrecks;
  }
  /**
   * Place natural landmarks (waterfalls, caves, hot springs, harbors)
   */
  placeNaturalLandmarks() {
    this.strategicLocations.landmarks.waterfall = this.findWaterfall();
    this.strategicLocations.landmarks.hotSpring = this.findHotSpring();
    this.strategicLocations.landmarks.caves = this.findCaves(2);
    this.strategicLocations.landmarks.harbor = this.findNaturalHarbor();
    const landmarkCount = (this.strategicLocations.landmarks.waterfall ? 1 : 0) + (this.strategicLocations.landmarks.hotSpring ? 1 : 0) + this.strategicLocations.landmarks.caves.length + (this.strategicLocations.landmarks.harbor ? 1 : 0);
    console.log(`üóª Placed ${landmarkCount} natural landmarks`);
  }
  /**
   * Find a waterfall location (river + elevation drop)
   */
  findWaterfall() {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (tile.terrain !== "river") continue;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      let maxElevDiff = 0;
      for (const n of neighbors) {
        const neighbor = this.getTile(n.q, n.r);
        if (!neighbor || !neighbor.isLand) continue;
        const elevDiff = Math.abs(tile.elevation - neighbor.elevation);
        maxElevDiff = Math.max(maxElevDiff, elevDiff);
      }
      if (maxElevDiff > 0.15) {
        candidates.push({ tile, elevDiff: maxElevDiff });
      }
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.elevDiff - a.elevDiff);
    return {
      name: "Cascade Falls",
      type: "waterfall",
      tile: candidates[0].tile,
      description: "A beautiful waterfall cascading down the mountainside. Fresh water and a peaceful resting spot."
    };
  }
  /**
   * Find hot spring (rare, high elevation + high moisture)
   */
  findHotSpring() {
    if (this.rng.next() > 0.3) return null;
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "cliff") continue;
      if (tile.elevation >= 0.6 && tile.moisture >= 0.7) {
        const terrainBonus = tile.terrain === "misty-peak" || tile.terrain === "cloud-forest" ? 0.5 : 0;
        const score = tile.elevation + tile.moisture + terrainBonus;
        candidates.push({ tile, score });
      }
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Steaming Springs",
      type: "hot-spring",
      tile: candidates[0].tile,
      description: "Natural hot springs warmed by geothermal activity. Restorative and relaxing."
    };
  }
  /**
   * Find cave systems
   */
  findCaves(numCaves = 2) {
    const caves = [];
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "cliff") continue;
      if (tile.elevation >= 0.55) {
        const score = tile.elevation + this.rng.next() * 0.3;
        candidates.push({ tile, score });
      }
    }
    if (candidates.length === 0) return caves;
    candidates.sort((a, b) => b.score - a.score);
    for (let i = 0; i < Math.min(numCaves, candidates.length); i++) {
      const candidate = candidates[i];
      const tooClose = caves.some(
        (c) => this.hexGrid.distance(c.tile.q, c.tile.r, candidate.tile.q, candidate.tile.r) < 10
      );
      if (!tooClose) {
        caves.push({
          name: `Cave ${caves.length === 0 ? "of Echoes" : "of Shadows"}`,
          type: "cave",
          tile: candidate.tile,
          description: "A dark cave entrance. Could provide shelter, or hide dangers."
        });
      }
    }
    return caves;
  }
  /**
   * Find natural harbor (protected coastal area)
   */
  findNaturalHarbor() {
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (tile.terrain !== "beach") continue;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      let seaCount = 0;
      let landCount = 0;
      for (const n of neighbors) {
        const neighbor = this.getTile(n.q, n.r);
        if (!neighbor) continue;
        if (neighbor.terrain === "sea") seaCount++;
        else if (neighbor.isLand) landCount++;
      }
      if (seaCount >= 2 && seaCount <= 3 && landCount >= 3) {
        const score = landCount + this.rng.next() * 2;
        candidates.push({ tile, score });
      }
    }
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.score - a.score);
    return {
      name: "Safe Harbor",
      type: "harbor",
      tile: candidates[0].tile,
      description: "A naturally protected cove, sheltered from rough seas. Perfect for boats."
    };
  }
  /**
   * Place ancient ruins (1-2 mysterious locations)
   */
  placeAncientRuins() {
    const numRuins = 1 + Math.floor(this.rng.next() * 2);
    const ruins = [];
    const candidates = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach" || tile.terrain === "cliff" || tile.terrain === "sea") continue;
      let score = 0;
      if (tile.terrain === "rainforest" || tile.terrain === "jungle-hill") {
        score = 2 + (tile.distanceToWater || 0) / 10;
      } else if (tile.terrain === "rocky-peak" || tile.terrain === "misty-peak") {
        score = 1.8 + tile.elevation;
      } else if (tile.terrain === "cloud-forest" || tile.terrain === "bamboo-forest") {
        score = 1.5 + (tile.distanceToWater || 0) / 10;
      }
      if (score > 0) {
        let tooCloseToVillage = false;
        if (this.strategicLocations.tidalVillage) {
          const dist = this.hexGrid.distance(
            tile.q,
            tile.r,
            this.strategicLocations.tidalVillage.tile.q,
            this.strategicLocations.tidalVillage.tile.r
          );
          if (dist < 8) tooCloseToVillage = true;
        }
        if (this.strategicLocations.ridgeVillage) {
          const dist = this.hexGrid.distance(
            tile.q,
            tile.r,
            this.strategicLocations.ridgeVillage.tile.q,
            this.strategicLocations.ridgeVillage.tile.r
          );
          if (dist < 8) tooCloseToVillage = true;
        }
        if (!tooCloseToVillage) {
          candidates.push({ tile, score });
        }
      }
    }
    if (candidates.length === 0) {
      console.warn("‚ö†Ô∏è  No suitable ruin locations found");
      return ruins;
    }
    candidates.sort((a, b) => b.score - a.score);
    const ruinTypes = [
      { name: "Ancient Temple", description: "Stone ruins covered in vines. What civilization built this?" },
      { name: "Observatory Ruins", description: "Crumbling stone circles aligned with the stars. Ancient astronomers worked here." },
      { name: "Forgotten Shrine", description: "A weathered shrine to unknown gods. Strange energy lingers." },
      { name: "Overgrown Plaza", description: "Stone pathways and broken pillars hint at a once-great city." }
    ];
    for (let i = 0; i < Math.min(numRuins, candidates.length); i++) {
      const candidate = candidates[i];
      const tooClose = ruins.some(
        (r) => this.hexGrid.distance(r.tile.q, r.tile.r, candidate.tile.q, candidate.tile.r) < 10
      );
      if (!tooClose) {
        const ruinType = ruinTypes[i % ruinTypes.length];
        ruins.push({
          name: ruinType.name,
          type: "ruins",
          tile: candidate.tile,
          description: ruinType.description,
          explored: false,
          lootQuality: this.rng.next() > 0.5 ? "rich" : "abundant"
        });
      }
    }
    console.log(`üèõÔ∏è  Placed ${ruins.length} ancient ruins`);
    return ruins;
  }
  /**
   * Mark strategic location tiles with special properties
   */
  markStrategicTiles() {
    if (this.strategicLocations.castawayBeach) {
      const tile = this.strategicLocations.castawayBeach.tile;
      tile.strategicLocation = this.strategicLocations.castawayBeach;
      tile.isStrategic = true;
    }
    if (this.strategicLocations.tidalVillage) {
      const tile = this.strategicLocations.tidalVillage.tile;
      tile.strategicLocation = this.strategicLocations.tidalVillage;
      tile.isStrategic = true;
      tile.faction = "tidal-clan";
    }
    if (this.strategicLocations.ridgeVillage) {
      const tile = this.strategicLocations.ridgeVillage.tile;
      tile.strategicLocation = this.strategicLocations.ridgeVillage;
      tile.isStrategic = true;
      tile.faction = "ridge-clan";
    }
    if (this.strategicLocations.mercenaryCompound) {
      const tile = this.strategicLocations.mercenaryCompound.tile;
      tile.strategicLocation = this.strategicLocations.mercenaryCompound;
      tile.isStrategic = true;
      tile.faction = "mercenaries";
    }
    for (const site of this.strategicLocations.sacredSites) {
      const tile = site.tile;
      tile.strategicLocation = site;
      tile.isStrategic = true;
      tile.isSacred = true;
    }
    for (const wreck of this.strategicLocations.shipwrecks) {
      const tile = wreck.tile;
      tile.strategicLocation = wreck;
      tile.isStrategic = true;
      tile.isShipwreck = true;
    }
    const landmarks = this.strategicLocations.landmarks;
    if (landmarks.waterfall) {
      const tile = landmarks.waterfall.tile;
      tile.strategicLocation = landmarks.waterfall;
      tile.isStrategic = true;
      tile.isLandmark = true;
    }
    if (landmarks.hotSpring) {
      const tile = landmarks.hotSpring.tile;
      tile.strategicLocation = landmarks.hotSpring;
      tile.isStrategic = true;
      tile.isLandmark = true;
    }
    for (const cave of landmarks.caves) {
      const tile = cave.tile;
      tile.strategicLocation = cave;
      tile.isStrategic = true;
      tile.isLandmark = true;
    }
    if (landmarks.harbor) {
      const tile = landmarks.harbor.tile;
      tile.strategicLocation = landmarks.harbor;
      tile.isStrategic = true;
      tile.isLandmark = true;
    }
    for (const ruin of this.strategicLocations.ruins) {
      const tile = ruin.tile;
      tile.strategicLocation = ruin;
      tile.isStrategic = true;
      tile.isRuin = true;
    }
  }
  // ========================================
  // FACTION TERRITORY GENERATION
  // ========================================
  /**
   * Generate faction territories based on strategic locations
   * Uses flood-fill from capital tiles with terrain preferences
   */
  generateFactionTerritories() {
    this.territories = {
      castaways: { capital: null, tiles: [], color: "#fbbf24", name: "Castaways" },
      tidalClan: { capital: null, tiles: [], color: "#3b82f6", name: "Tidal Clan" },
      ridgeClan: { capital: null, tiles: [], color: "#84cc16", name: "Ridge Clan" },
      mercenaries: { capital: null, tiles: [], color: "#dc2626", name: "Mercenaries" },
      neutral: { tiles: [] }
    };
    const factionConfigs = {
      castaways: {
        capital: this.strategicLocations.castawayBeach?.tile,
        maxRadius: 6,
        preferredTerrains: ["beach", "savanna", "forest"],
        growthRate: 0.8
      },
      tidalClan: {
        capital: this.strategicLocations.tidalVillage?.tile,
        maxRadius: 12,
        preferredTerrains: ["beach", "forest", "savanna", "river"],
        growthRate: 1
      },
      ridgeClan: {
        capital: this.strategicLocations.ridgeVillage?.tile,
        maxRadius: 10,
        preferredTerrains: ["jungle-hill", "cloud-forest", "dry-hill", "rocky-peak", "misty-peak"],
        growthRate: 0.9
      },
      mercenaries: {
        capital: this.strategicLocations.mercenaryCompound?.tile,
        maxRadius: 8,
        preferredTerrains: ["forest", "jungle-hill", "dry-hill", "savanna"],
        growthRate: 0.7
      }
    };
    const growthOrder = ["tidalClan", "ridgeClan", "mercenaries", "castaways"];
    for (const factionKey of growthOrder) {
      const config = factionConfigs[factionKey];
      if (!config.capital) {
        console.warn(`‚ö†Ô∏è  No capital for ${factionKey}, skipping territory`);
        continue;
      }
      this.territories[factionKey].capital = config.capital;
      this.growTerritory(factionKey, config);
    }
    for (const [key, tile] of this.tiles) {
      if (tile.isLand && !tile.faction && !tile.isSacred) {
        tile.faction = "neutral";
        this.territories.neutral.tiles.push(tile);
      }
    }
    this.markFrontierTiles();
    console.log("üó∫Ô∏è  Territory Distribution:", {
      castaways: this.territories.castaways.tiles.length,
      tidalClan: this.territories.tidalClan.tiles.length,
      ridgeClan: this.territories.ridgeClan.tiles.length,
      mercenaries: this.territories.mercenaries.tiles.length,
      neutral: this.territories.neutral.tiles.length
    });
  }
  /**
   * Grow territory from capital using flood-fill with constraints
   */
  growTerritory(factionKey, config) {
    const { capital, maxRadius, preferredTerrains, growthRate } = config;
    const territory = this.territories[factionKey];
    const queue = [{ tile: capital, distance: 0 }];
    const visited = /* @__PURE__ */ new Set([this.key(capital.q, capital.r)]);
    capital.faction = factionKey;
    capital.territoryDistance = 0;
    territory.tiles.push(capital);
    while (queue.length > 0) {
      const { tile: current, distance } = queue.shift();
      if (distance >= maxRadius) continue;
      const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
      for (const n of neighbors) {
        const key = this.key(n.q, n.r);
        if (visited.has(key)) continue;
        const neighbor = this.getTile(n.q, n.r);
        if (!neighbor || !neighbor.isLand) continue;
        if (neighbor.faction) continue;
        if (neighbor.isSacred) continue;
        visited.add(key);
        let expandChance = growthRate;
        if (preferredTerrains.includes(neighbor.terrain)) {
          expandChance += 0.3;
        }
        if (neighbor.terrain === "river") {
          expandChance -= 0.5;
        }
        const distancePenalty = distance / maxRadius;
        expandChance -= distancePenalty * 0.4;
        if (this.rng.next() < Math.max(0.1, expandChance)) {
          neighbor.faction = factionKey;
          neighbor.territoryDistance = distance + 1;
          territory.tiles.push(neighbor);
          queue.push({ tile: neighbor, distance: distance + 1 });
        }
      }
    }
  }
  /**
   * Mark frontier tiles (borders between different factions)
   */
  markFrontierTiles() {
    for (const [key, tile] of this.tiles) {
      if (!tile.faction || tile.faction === "neutral") continue;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const hasDifferentFactionNeighbor = neighbors.some((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.faction && neighbor.faction !== tile.faction;
      });
      if (hasDifferentFactionNeighbor) {
        tile.isFrontier = true;
      }
    }
  }
  // ========================================
  // FUTURE FEATURES - PLACEHOLDERS
  // ========================================
  /**
   * FUTURE: Place Points of Interest (POIs)
   * Examples: Shipwreck, ancient ruins, cave system, waterfall, 
   * volcano crater, mysterious monolith, abandoned camp, etc.
   * 
   * Design Notes:
   * - Each POI should have narrative significance
   * - Limit to 5-10 major POIs per map
   * - Place based on terrain suitability
   * - Ensure they're discoverable but not too obvious
   * - Can unlock quests, resources, or story events
   */
  placePOIs() {
    const pois = [];
    return pois;
  }
  /**
   * FUTURE: Define Faction Territories
   * Examples: Survivor camps, native tribes, wildlife zones, 
   * "claimed" areas, danger zones, etc.
   * 
   * Design Notes:
   * - Factions control regions, not individual tiles
   * - Should have organic boundaries (follow terrain features)
   * - 3-5 major factions maximum
   * - Player starts neutral or with one faction
   * - Territories can overlap (contested zones)
   * - Affects encounters, resources, quests
   */
  defineFactionTerritories() {
    const territories = [];
    return territories;
  }
  /**
   * FUTURE: Place Resource Nodes
   * Examples: Fruit trees, freshwater springs, stone quarries,
   * fishing spots, herb patches, wildlife dens, etc.
   * 
   * Design Notes:
   * - Should be numerous but not overwhelming
   * - Cluster by terrain type
   * - Some renewable (fruit, fish), some finite (stone, minerals)
   * - Higher quality resources in dangerous areas
   * - Can be depleted and regenerate over time
   */
  placeResourceNodes() {
    const resources = [];
    return resources;
  }
  /**
   * FUTURE: Fog of War System
   * 
   * Design Notes:
   * - All tiles start hidden except player's starting location
   * - Tiles reveal when player moves adjacent to them
   * - Three states: unexplored, explored, visible
   * - Can see terrain type when explored, but not current details
   * - High ground (mountains) reveals larger area
   * - Story events can reveal specific areas
   */
  initializeFogOfWar(startingTile) {
  }
  /**
   * FUTURE: Landmarks System
   * Special one-of-a-kind locations that serve as waypoints
   * 
   * Examples: The Great Banyan, Skull Rock, Crystal Lagoon,
   * The Spire, Dead Man's Cove, etc.
   * 
   * Design Notes:
   * - Visually distinctive on map
   * - Named and memorable
   * - Often multi-tile structures
   * - Used for navigation and quests
   * - 3-5 major landmarks per map
   */
  placeLandmarks() {
    const landmarks = [];
    return landmarks;
  }
}
class Territory {
  constructor(position) {
    this.position = position;
    this.owner = null;
    this.discovered = false;
    this.visited = false;
    this.visibleFromFog = false;
    this.hasResourceNode = false;
    this.resourceNodeId = null;
    this.hasEvent = false;
    this.eventId = null;
    this.hasNPC = false;
    this.npcId = null;
    this.hasSettlement = false;
    this.controlStrength = 0;
    this.lastVisited = null;
    this.discoveredBy = null;
    this.explorationProgress = 0;
    this.fullyExplored = false;
    this.explorationAttempts = 0;
    this.explorationDifficulty = 50;
    this.claimProgress = 0;
    this.claimingInProgress = false;
    this.claimingBy = null;
    this.claimAttempts = 0;
    this.claimDifficulty = 50;
    this.previousOwner = null;
    this.factionAlerted = false;
    this.isPerimeter = false;
    this.travelCostModifier = 1;
    this.travelSpeedModifier = 1;
    this.terrain = null;
    this.elevation = 0;
    this.biome = null;
  }
  /**
   * Set the owner of this territory
   */
  setOwner(faction, strength = 50) {
    this.owner = faction;
    this.controlStrength = strength;
    this.updateTravelModifiers();
  }
  /**
   * Update travel modifiers based on ownership
   */
  updateTravelModifiers() {
    if (this.owner === "player") {
      this.travelCostModifier = 0.5;
      this.travelSpeedModifier = 1.5;
    } else if (this.owner) {
      this.travelCostModifier = 1.2;
      this.travelSpeedModifier = 0.9;
    } else {
      this.travelCostModifier = 1;
      this.travelSpeedModifier = 1;
    }
  }
  /**
   * Discover this territory
   */
  discover(discoveredBy) {
    if (!this.discovered) {
      this.discovered = true;
      this.discoveredBy = discoveredBy;
      this.visibleFromFog = true;
    }
  }
  /**
   * Visit this territory
   */
  visit() {
    this.visited = true;
    this.lastVisited = Date.now();
    this.discover("player");
  }
  /**
   * Get faction color
   */
  getFactionColor() {
    const colors = {
      player: "#4dd0e1",
      // Cyan
      castaways: "#4ade80",
      // Green
      natives_clan1: "#fbbf24",
      // Yellow
      natives_clan2: "#f97316",
      // Orange
      mercenaries: "#dc2626"
      // Red
    };
    return colors[this.owner] || null;
  }
  /**
   * Explore this territory (skill-based, incremental progress)
   * Reveals resources and POIs as exploration progresses
   */
  explore(player2) {
    if (this.fullyExplored) {
      return {
        success: false,
        message: "This area has already been fully explored.",
        alreadyComplete: true
      };
    }
    const terrainDifficulty = this.getExplorationDifficulty();
    const skillLevel = player2.skills.exploration || 0;
    const roll = Math.random() * 100;
    const successChance = 50 + skillLevel - terrainDifficulty;
    const success = roll < successChance;
    this.explorationAttempts++;
    if (success) {
      const progress = 10 + Math.floor(skillLevel / 5);
      const oldProgress = this.explorationProgress;
      this.explorationProgress = Math.min(100, this.explorationProgress + progress);
      const discoveries = this.checkForDiscoveries(oldProgress, this.explorationProgress);
      const xpGained = Math.floor(terrainDifficulty / 2);
      player2.gainSkillXP("exploration", xpGained);
      if (this.explorationProgress >= 100) {
        this.fullyExplored = true;
        return {
          success: true,
          progress: this.explorationProgress,
          complete: true,
          message: `You've fully explored this ${this.terrain}! The area holds no more secrets.`,
          xpGained,
          discoveries
        };
      }
      return {
        success: true,
        progress: this.explorationProgress,
        complete: false,
        message: `Exploration progress: ${this.explorationProgress}%. You learn more about the area.`,
        xpGained,
        discoveries
      };
    } else {
      player2.gainSkillXP("exploration", 1);
      return {
        success: false,
        progress: this.explorationProgress,
        message: `You didn't discover anything new this time. Keep exploring!`,
        xpGained: 1,
        discoveries: []
      };
    }
  }
  /**
   * Check if exploration progress reveals any resources or POIs
   * Resources are discovered at different exploration thresholds
   */
  checkForDiscoveries(oldProgress, newProgress) {
    const discoveries = [];
    const resourceManager = window.game?.resourceNodeManager;
    if (!resourceManager) return discoveries;
    const allNodes = Array.from(resourceManager.nodes.values());
    const resourcesHere = allNodes.filter(
      (node) => node.position.q === this.position.q && node.position.r === this.position.r && !node.discovered
    );
    const thresholds = [25, 50, 75, 100];
    thresholds.forEach((threshold) => {
      if (oldProgress < threshold && newProgress >= threshold && resourcesHere.length > 0) {
        const undiscovered = resourcesHere.filter((r) => !r.discovered);
        if (undiscovered.length > 0) {
          const resource = undiscovered[0];
          resource.discovered = true;
          discoveries.push({
            type: "resource",
            resourceType: resource.type,
            name: resource.resourceType,
            threshold
          });
        }
      }
    });
    if (oldProgress < 50 && newProgress >= 50) {
      if (this.hasNPC) {
        discoveries.push({
          type: "npc",
          name: "an inhabitant",
          threshold: 50
        });
      }
    }
    if (oldProgress < 100 && newProgress >= 100) {
      if (this.hasEvent) {
        discoveries.push({
          type: "event",
          name: "something unusual",
          threshold: 100
        });
      }
      if (this.hasSettlement) {
        discoveries.push({
          type: "settlement",
          name: "a settlement",
          threshold: 100
        });
      }
    }
    return discoveries;
  }
  /**
   * Calculate exploration difficulty based on terrain
   */
  getExplorationDifficulty() {
    const terrainDifficulties = {
      "beach": 20,
      "lowland": 30,
      "grassland": 25,
      "forest": 40,
      "rainforest": 60,
      "jungle": 70,
      "swamp": 65,
      "mangrove": 55,
      "rocky": 50,
      "highland": 55,
      "mountain": 80,
      "cliff": 85,
      "bamboo_forest": 45,
      "volcanic": 90
    };
    return terrainDifficulties[this.terrain] || this.explorationDifficulty;
  }
  /**
   * Attempt to claim this territory (skill-based, time-consuming, potentially dangerous)
   */
  attemptClaim(player2, gameState2) {
    if (!this.fullyExplored) {
      return {
        success: false,
        message: "You must fully explore this area before claiming it.",
        requiresExploration: true
      };
    }
    if (this.owner === "player" && this.controlStrength >= 100) {
      return {
        success: false,
        message: "You already control this territory.",
        alreadyOwned: true
      };
    }
    const isContested = this.owner && this.owner !== "player";
    const previousOwner = this.owner;
    if (isContested && !this.factionAlerted) {
      this.factionAlerted = true;
      this.previousOwner = this.owner;
    }
    const baseDifficulty = 40;
    const contestedModifier = isContested ? 30 : 0;
    const strengthModifier = this.controlStrength * 0.3;
    const totalDifficulty = baseDifficulty + contestedModifier + strengthModifier;
    const skillLevel = player2.skills.claiming || 0;
    const roll = Math.random() * 100;
    const successChance = 50 + skillLevel - totalDifficulty;
    const success = roll < successChance;
    this.claimAttempts++;
    this.claimingInProgress = true;
    this.claimingBy = "player";
    const timeAdvanced = 60;
    if (gameState2 && gameState2.advanceTime) {
      gameState2.advanceTime(timeAdvanced);
    }
    if (success) {
      const progress = 15 + Math.floor(skillLevel / 4);
      this.claimProgress = Math.min(100, this.claimProgress + progress);
      const xpGained = Math.floor(totalDifficulty / 3);
      player2.gainSkillXP("claiming", xpGained);
      if (this.claimProgress >= 100) {
        this.setOwner("player", 100);
        this.claimingInProgress = false;
        this.factionAlerted = false;
        return {
          success: true,
          progress: this.claimProgress,
          complete: true,
          contested: isContested,
          previousOwner,
          timeAdvanced,
          message: isContested ? `You've successfully claimed this territory from the ${previousOwner}!` : `You've claimed this territory! It's now under your control.`,
          xpGained
        };
      }
      return {
        success: true,
        progress: this.claimProgress,
        complete: false,
        contested: isContested,
        timeAdvanced,
        message: `Claiming progress: ${this.claimProgress}%. ${isContested ? "The " + this.owner + " may respond soon!" : "Continue to establish control."}`,
        xpGained
      };
    } else {
      player2.gainSkillXP("claiming", 2);
      if (isContested && Math.random() < 0.3) {
        this.claimProgress = Math.max(0, this.claimProgress - 10);
        return {
          success: false,
          progress: this.claimProgress,
          contested: true,
          timeAdvanced,
          message: `Your claim attempt was resisted! You lost some progress. (${this.claimProgress}%)`,
          xpGained: 2
        };
      }
      return {
        success: false,
        progress: this.claimProgress,
        contested: isContested,
        timeAdvanced,
        message: `Claim attempt failed. Current progress: ${this.claimProgress}%`,
        xpGained: 2
      };
    }
  }
  /**
   * Get control strength color (for visualization)
   */
  getControlColor() {
    const baseColor = this.getFactionColor();
    if (!baseColor) return null;
    const alpha = this.controlStrength / 100;
    return `${baseColor}${Math.floor(alpha * 255).toString(16).padStart(2, "0")}`;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      position: this.position,
      owner: this.owner,
      discovered: this.discovered,
      visited: this.visited,
      controlStrength: this.controlStrength,
      hasResourceNode: this.hasResourceNode,
      resourceNodeId: this.resourceNodeId,
      hasEvent: this.hasEvent,
      eventId: this.eventId,
      hasNPC: this.hasNPC,
      npcId: this.npcId,
      lastVisited: this.lastVisited
    };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data) {
    const territory = new Territory(data.position);
    Object.assign(territory, data);
    territory.updateTravelModifiers();
    return territory;
  }
}
class TerritoryManager {
  constructor() {
    this.territories = /* @__PURE__ */ new Map();
    this.factionTerritories = {
      player: [],
      castaways: [],
      natives_clan1: [],
      natives_clan2: [],
      mercenaries: []
    };
  }
  /**
   * Initialize territories from map data
   */
  initFromMap(mapData) {
    mapData.tiles.forEach((tile, key) => {
      const [q, r] = key.split(",").map(Number);
      const territory = new Territory({ q, r });
      territory.terrain = tile.terrain || tile.type;
      territory.elevation = tile.elevation;
      territory.biome = tile.biome || this.getBiomeFromTerrain(tile.terrain || tile.type);
      territory.isPassable = tile.isPassable !== false;
      this.territories.set(key, territory);
    });
    console.log(`üó∫Ô∏è Initialized ${this.territories.size} territories`);
  }
  /**
   * Get biome from terrain type
   */
  getBiomeFromTerrain(terrain) {
    const biomes = {
      "deep_water": "ocean",
      "water": "ocean",
      "beach": "coastal",
      "lowland": "tropical",
      "forest": "jungle",
      "highland": "hills",
      "mountain": "mountain"
    };
    return biomes[terrain] || "tropical";
  }
  /**
   * Get territory at position
   */
  getTerritory(q, r) {
    return this.territories.get(`${q},${r}`) || null;
  }
  /**
   * Get all territories owned by faction
   */
  getFactionTerritories(faction) {
    return Array.from(this.territories.values()).filter((t) => t.owner === faction);
  }
  /**
   * Set territory owner
   */
  setOwner(q, r, faction, strength = 50) {
    const territory = this.getTerritory(q, r);
    if (territory) {
      territory.setOwner(faction, strength);
      this.updatePerimeters();
      return true;
    }
    return false;
  }
  /**
   * Expand faction territory (claim adjacent tiles)
   */
  expandTerritory(q, r, faction, strength = 30) {
    const adjacent = this.getAdjacentTerritories(q, r);
    const claimed = [];
    for (const territory of adjacent) {
      if (!territory.owner || territory.controlStrength < 30) {
        territory.setOwner(faction, strength);
        claimed.push(territory);
      }
    }
    return claimed;
  }
  /**
   * Get adjacent territories
   */
  getAdjacentTerritories(q, r) {
    const directions = [
      { q: 1, r: 0 },
      { q: 1, r: -1 },
      { q: 0, r: -1 },
      { q: -1, r: 0 },
      { q: -1, r: 1 },
      { q: 0, r: 1 }
    ];
    return directions.map((dir) => this.getTerritory(q + dir.q, r + dir.r)).filter((t) => t !== null);
  }
  /**
   * Get visible territories (fog of war)
   */
  getVisibleTerritories(playerPosition, visionRange = 2) {
    const visible = [];
    const center = this.getTerritory(playerPosition.q, playerPosition.r);
    if (!center) return visible;
    center.visibleFromFog = true;
    visible.push(center);
    for (let q = -visionRange; q <= visionRange; q++) {
      for (let r = -visionRange; r <= visionRange; r++) {
        const distance = Math.abs(q) + Math.abs(r) + Math.abs(-q - r);
        if (distance <= visionRange * 2) {
          const territory = this.getTerritory(
            playerPosition.q + q,
            playerPosition.r + r
          );
          if (territory) {
            territory.visibleFromFog = true;
            visible.push(territory);
          }
        }
      }
    }
    return visible;
  }
  /**
   * Update fog of war based on discoveries
   */
  updateFogOfWar(discoveredPositions) {
    discoveredPositions.forEach((pos) => {
      const territory = this.getTerritory(pos.q, pos.r);
      if (territory) {
        territory.discover("player");
      }
    });
  }
  /**
   * Update perimeter status for all territories
   * A perimeter tile is one that borders a different faction or neutral territory
   */
  updatePerimeters() {
    this.territories.forEach((territory) => {
      if (!territory.owner || territory.owner === "neutral") {
        territory.isPerimeter = false;
        return;
      }
      const adjacent = this.getAdjacentTerritories(territory.position.q, territory.position.r);
      territory.isPerimeter = adjacent.some(
        (neighbor) => neighbor.owner !== territory.owner
      );
    });
  }
  /**
   * Generate starting territories
   */
  generateStartingTerritories(playerStart) {
    console.log(`üèÅ Generating starting territories at (${playerStart.q}, ${playerStart.r})`);
    const territory = this.getTerritory(playerStart.q, playerStart.r);
    if (territory) {
      territory.discover("player");
      territory.visit();
      console.log(`‚úÖ Starting location discovered and visited (NOT owned - must claim)`);
    } else {
      console.error(`‚ùå No territory found at player start position (${playerStart.q}, ${playerStart.r})`);
    }
    const visible = this.getVisibleTerritories(playerStart, 2);
    console.log(`üëÅÔ∏è Revealed ${visible.length} visible territories`);
    this.generateFactionTerritories(playerStart);
    this.updatePerimeters();
    console.log("üèÅ Starting territories generated");
  }
  /**
   * Generate faction territories across the island
   */
  generateFactionTerritories(playerStart) {
    const allTerritories = Array.from(this.territories.values());
    const minDistanceFromPlayer = 15;
    const suitable = allTerritories.filter((t) => {
      if (t.terrain === "deep_water" || t.terrain === "water") return false;
      if (t.elevation > 0.85) return false;
      if (t.owner) return false;
      const dq = Math.abs(t.position.q - playerStart.q);
      const dr = Math.abs(t.position.r - playerStart.r);
      const distance = (dq + dr + Math.abs(-dq - dr)) / 2;
      return distance >= minDistanceFromPlayer;
    });
    const factions = [
      { id: "natives_clan1", count: 5, strength: 60 },
      { id: "natives_clan2", count: 4, strength: 55 },
      { id: "mercenaries", count: 2, strength: 70 }
    ];
    factions.forEach((faction) => {
      for (let i = 0; i < faction.count; i++) {
        if (suitable.length === 0) break;
        const randomIndex = Math.floor(Math.random() * suitable.length);
        const territory = suitable[randomIndex];
        if (territory) {
          territory.setOwner(faction.id, faction.strength);
          const expanded = this.expandTerritory(
            territory.position.q,
            territory.position.r,
            faction.id,
            faction.strength - 10
          );
          suitable.splice(randomIndex, 1);
          expanded.forEach((t) => {
            const idx = suitable.indexOf(t);
            if (idx !== -1) suitable.splice(idx, 1);
          });
        }
      }
    });
    Object.keys(this.factionTerritories).forEach((faction) => {
      const count = this.getFactionTerritories(faction).length;
      if (count > 0) {
        console.log(`  ${faction}: ${count} territories`);
      }
    });
  }
  /**
   * Get territory statistics
   */
  getStats() {
    const stats = {
      total: this.territories.size,
      discovered: 0,
      visited: 0,
      owned: {},
      unclaimed: 0
    };
    this.territories.forEach((territory) => {
      if (territory.discovered) stats.discovered++;
      if (territory.visited) stats.visited++;
      if (territory.owner) {
        stats.owned[territory.owner] = (stats.owned[territory.owner] || 0) + 1;
      } else {
        stats.unclaimed++;
      }
    });
    return stats;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    const territories = {};
    this.territories.forEach((territory, key) => {
      territories[key] = territory.toJSON();
    });
    return { territories };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data) {
    const manager = new TerritoryManager();
    Object.entries(data.territories).forEach(([key, territoryData]) => {
      manager.territories.set(key, Territory.fromJSON(territoryData));
    });
    return manager;
  }
}
class TravelSystem {
  constructor(player2, territoryManager2) {
    this.player = player2;
    this.territoryManager = territoryManager2;
    this.currentPosition = { q: 0, r: 0 };
    this.targetPosition = null;
    this.travelPath = [];
    this.isTraveling = false;
    this.travelProgress = 0;
    this.travelSpeed = 1;
    this.currentTravelDuration = 0;
    this.baseTravelDuration = 10;
    this.eventHandlers = [];
    this.lastEventCheck = Date.now();
    this.eventCheckInterval = 2e3;
  }
  /**
   * Calculate travel duration for traveling to a tile (in game minutes)
   * Duration depends on:
   * - Discovery state (undiscovered takes longer to navigate)
   * - Terrain type (harder terrain = longer travel)
   * - Elevation changes (steep = slower)
   * Range: 5-15 minutes base, with modifiers
   */
  calculateTravelDuration(fromPos, toPos) {
    const fromTerritory = this.territoryManager.getTerritory(fromPos.q, fromPos.r);
    const toTerritory = this.territoryManager.getTerritory(toPos.q, toPos.r);
    if (!toTerritory) return Infinity;
    let baseDuration;
    if (!toTerritory.discovered) {
      baseDuration = 15;
    } else if (toTerritory.owner === "player") {
      baseDuration = 5;
    } else {
      baseDuration = 10;
    }
    const terrainMultipliers = {
      "deep_water": 999,
      // Can't travel through deep water
      "water": 2,
      // Very slow (swimming/wading)
      "beach": 0.9,
      // Easy
      "lowland": 1,
      // Normal
      "plains": 0.9,
      // Easy
      "scrubland": 1.2,
      // Slower through brush
      "forest": 1.3,
      // Thick vegetation
      "jungle": 1.5,
      // Dense jungle
      "highland": 1.4,
      // Uphill
      "mountain": 1.6,
      // Steep
      "swamp": 1.8,
      // Very slow
      "mangrove": 1.4,
      // Thick roots
      "bamboo-forest": 1.3,
      // Dense but navigable
      "palm-grove": 1.1
      // Relatively open
    };
    const terrainMult = terrainMultipliers[toTerritory.terrain] || 1.2;
    baseDuration *= terrainMult;
    if (fromTerritory && toTerritory.elevation !== void 0 && fromTerritory.elevation !== void 0 && !isNaN(toTerritory.elevation) && !isNaN(fromTerritory.elevation)) {
      const elevationChange = Math.abs(toTerritory.elevation - fromTerritory.elevation);
      baseDuration *= 1 + elevationChange * 0.2;
    }
    if (isNaN(baseDuration)) {
      console.warn("NaN travel duration calculated for", toPos, "terrain:", toTerritory.terrain);
      return 10;
    }
    return Math.max(5, Math.ceil(baseDuration));
  }
  /**
   * Check if can travel to position
   */
  canTravelTo(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) {
      return false;
    }
    if (territory.terrain === "sea" || territory.terrain === "deep_water") {
      return false;
    }
    const dq = Math.abs(q - this.currentPosition.q);
    const dr = Math.abs(r - this.currentPosition.r);
    const ds = Math.abs(-q - r - (-this.currentPosition.q - this.currentPosition.r));
    const distance = Math.max(dq, dr, ds);
    if (distance === 0) {
      return false;
    }
    if (distance > 1) {
      return false;
    }
    return true;
  }
  /**
   * Start traveling to a position
   * Returns the travel duration so caller can advance game time
   */
  startTravel(q, r) {
    if (this.isTraveling) {
      return {
        success: false,
        reason: "Already traveling"
      };
    }
    if (!this.canTravelTo(q, r)) {
      return {
        success: false,
        reason: "Cannot travel to that location"
      };
    }
    const travelDuration = this.calculateTravelDuration(this.currentPosition, { q, r });
    const travelTimeMs = 1e3;
    this.targetPosition = { q, r };
    this.isTraveling = true;
    this.travelProgress = 0;
    this.travelSpeed = 1e3 / travelTimeMs;
    this.currentTravelDuration = travelDuration;
    this.emitEvent("travelStart", {
      from: { ...this.currentPosition },
      to: { q, r },
      duration: travelDuration
    });
    console.log(`üö∂ Started travel to (${q}, ${r}) - Duration: ${travelDuration} minutes`);
    return {
      success: true,
      duration: travelDuration
      // Return duration for time advancement
    };
  }
  /**
   * Update travel progress (called from game loop)
   */
  update(deltaTime) {
    if (!this.isTraveling) return;
    this.travelProgress += this.travelSpeed * deltaTime / 1e3;
    if (this.travelProgress >= 1) {
      this.arriveAtDestination();
    }
    const now = Date.now();
    if (now - this.lastEventCheck >= this.eventCheckInterval) {
      this.checkForTravelEvents();
      this.lastEventCheck = now;
    }
  }
  /**
   * Arrive at destination
   */
  arriveAtDestination() {
    if (!this.targetPosition) return;
    const oldPosition = { ...this.currentPosition };
    const duration = this.currentTravelDuration;
    this.currentPosition = { ...this.targetPosition };
    this.targetPosition = null;
    this.isTraveling = false;
    this.travelProgress = 0;
    this.currentTravelDuration = 0;
    const territory = this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
    if (territory) {
      territory.visit();
      const adjacentTiles = this.territoryManager.getVisibleTerritories(this.currentPosition, 1);
      adjacentTiles.forEach((tile) => {
        if (!tile.discovered) {
          tile.discover("player");
          console.log(`üîç Discovered adjacent tile at (${tile.position.q}, ${tile.position.r})`);
        }
      });
      this.checkForDiscoveries(territory);
    }
    this.player.moveTo(this.currentPosition.q, this.currentPosition.r);
    this.emitEvent("travelComplete", {
      from: oldPosition,
      to: this.currentPosition,
      territory,
      duration
      // Pass duration to event handler
    });
    console.log(`üö∂ Arrived at (${this.currentPosition.q}, ${this.currentPosition.r})`);
  }
  /**
   * Check for discoveries at new territory
   */
  checkForDiscoveries(territory) {
    const discoveries = [];
    if (!territory.hasResourceNode && Math.random() < 0.3) {
      const nodeTypes = ["tree", "rock", "bush"];
      const nodeType = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
      territory.hasResourceNode = true;
      territory.resourceNodeId = `${nodeType}_${territory.position.q}_${territory.position.r}`;
      discoveries.push({
        type: "resource",
        nodeType,
        nodeId: territory.resourceNodeId
      });
    }
    if (!territory.hasEvent && Math.random() < 0.2) {
      territory.hasEvent = true;
      territory.eventId = this.generateRandomEvent(territory);
      discoveries.push({
        type: "event",
        eventId: territory.eventId
      });
    }
    if (discoveries.length > 0) {
      this.emitEvent("discoveries", {
        territory,
        discoveries
      });
    }
  }
  /**
   * Check for travel events (while traveling)
   */
  checkForTravelEvents() {
    if (!this.isTraveling) return;
    const currentTerritory = this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
    if (!currentTerritory || !currentTerritory.owner) return;
    const faction = currentTerritory.owner;
    const relationship = this.getRelationshipWithFaction(faction);
    this.rollFactionEncounter(faction, relationship, currentTerritory);
  }
  /**
   * Get relationship with faction
   */
  getRelationshipWithFaction(faction) {
    if (faction === "player") return 100;
    const rep = this.player.reputation[faction] || 0;
    if (rep >= 75) return "ally";
    if (rep >= 50) return "friendly";
    if (rep >= 25) return "neutral";
    if (rep >= -25) return "unfriendly";
    if (rep >= -50) return "hostile";
    return "enemy";
  }
  /**
   * Roll for faction encounters
   */
  rollFactionEncounter(faction, relationship, territory) {
    let encounterChance = 0;
    const baseChances = {
      castaways: 0.15,
      natives_clan1: 0.2,
      natives_clan2: 0.18,
      mercenaries: 0.3
    };
    encounterChance = baseChances[faction] || 0.1;
    encounterChance *= territory.controlStrength / 50;
    if (Math.random() > encounterChance) return;
    const encounterType = this.determineEncounterType(relationship);
    this.emitEvent("factionEncounter", {
      faction,
      relationship,
      encounterType,
      territory
    });
  }
  /**
   * Determine encounter type based on relationship
   */
  determineEncounterType(relationship) {
    const encounters = {
      ally: ["trade", "gift", "quest", "chat"],
      friendly: ["trade", "chat", "help"],
      neutral: ["chat", "ignore", "warning"],
      unfriendly: ["warning", "demand", "threat"],
      hostile: ["ambush", "attack", "chase"],
      enemy: ["attack", "ambush"]
    };
    const options = encounters[relationship] || ["ignore"];
    return options[Math.floor(Math.random() * options.length)];
  }
  /**
   * Generate random event
   */
  generateRandomEvent(territory) {
    const events = [
      "chest_found",
      "strange_sound",
      "animal_tracks",
      "abandoned_camp",
      "mysterious_shrine",
      "hidden_cave",
      "fruit_tree",
      "fresh_water"
    ];
    return events[Math.floor(Math.random() * events.length)];
  }
  /**
   * Get current territory
   */
  getCurrentTerritory() {
    return this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
  }
  /**
   * Set player position (for initialization)
   */
  setPosition(q, r) {
    this.currentPosition = { q, r };
    const territory = this.territoryManager.getTerritory(q, r);
    if (territory) {
      territory.visit();
    }
  }
  /**
   * Event system
   */
  on(event, handler) {
    this.eventHandlers.push({ event, handler });
  }
  emitEvent(event, data) {
    this.eventHandlers.filter((h) => h.event === event).forEach((h) => h.handler(data));
  }
  /**
   * Get travel info for UI
   */
  getTravelInfo(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) return null;
    const canTravel = this.canTravelTo(q, r);
    const duration = this.calculateTravelDuration(this.currentPosition, { q, r });
    return {
      canTravel,
      duration,
      territory,
      reason: !canTravel ? this.getCannotTravelReason(q, r) : null
    };
  }
  /**
   * Get reason why can't travel
   */
  getCannotTravelReason(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) return "Invalid location";
    if (territory.terrain === "deep_water" || territory.terrain === "sea") return "Cannot cross water";
    return "Too far away";
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      currentPosition: this.currentPosition,
      isTraveling: this.isTraveling,
      targetPosition: this.targetPosition,
      travelProgress: this.travelProgress
    };
  }
  /**
   * Load from saved data
   */
  loadFromJSON(data) {
    this.currentPosition = data.currentPosition || { q: 0, r: 0 };
    this.isTraveling = data.isTraveling || false;
    this.targetPosition = data.targetPosition || null;
    this.travelProgress = data.travelProgress || 0;
  }
}
class InventoryUI {
  constructor(inventory2) {
    this.inventory = inventory2;
    this.container = null;
    this.selectedSlot = null;
    this.draggedSlot = null;
    this.isOpen = false;
    this.createUI();
    this.setupEventListeners();
  }
  /**
   * Create the main UI structure
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "inventory-overlay";
    this.container.style.display = "none";
    const modal = document.createElement("div");
    modal.className = "inventory-modal";
    const header = this.createHeader();
    modal.appendChild(header);
    const content = document.createElement("div");
    content.className = "inventory-content";
    const equipmentPanel = this.createEquipmentPanel();
    content.appendChild(equipmentPanel);
    const gridPanel = this.createGridPanel();
    content.appendChild(gridPanel);
    modal.appendChild(content);
    const detailsPanel = this.createDetailsPanel();
    modal.appendChild(detailsPanel);
    this.container.appendChild(modal);
    document.body.appendChild(this.container);
  }
  /**
   * Create header with title and close button
   */
  createHeader() {
    const header = document.createElement("div");
    header.className = "inventory-header";
    const title = document.createElement("h2");
    title.textContent = "INVENTORY";
    header.appendChild(title);
    const closeBtn = document.createElement("button");
    closeBtn.className = "inventory-close";
    closeBtn.innerHTML = "√ó";
    closeBtn.onclick = () => this.close();
    header.appendChild(closeBtn);
    return header;
  }
  /**
   * Create equipment panel (left side)
   */
  createEquipmentPanel() {
    const panel = document.createElement("div");
    panel.className = "equipment-panel";
    const title = document.createElement("h3");
    title.textContent = "EQUIPMENT";
    panel.appendChild(title);
    const slots = ["weapon", "tool", "clothing", "backpack"];
    slots.forEach((slotType) => {
      const slotContainer = this.createEquipmentSlot(slotType);
      panel.appendChild(slotContainer);
    });
    return panel;
  }
  /**
   * Create individual equipment slot
   */
  createEquipmentSlot(slotType) {
    const container = document.createElement("div");
    container.className = "equipment-slot-container";
    const label = document.createElement("div");
    label.className = "equipment-label";
    label.textContent = slotType.toUpperCase();
    container.appendChild(label);
    const slot = document.createElement("div");
    slot.className = "equipment-slot";
    slot.dataset.slotType = slotType;
    const placeholder = document.createElement("div");
    placeholder.className = "equipment-placeholder";
    placeholder.textContent = this.getEquipmentIcon(slotType);
    slot.appendChild(placeholder);
    container.appendChild(slot);
    return container;
  }
  /**
   * Get icon for equipment slot
   */
  getEquipmentIcon(slotType) {
    const icons = {
      weapon: "‚öîÔ∏è",
      tool: "üîß",
      clothing: "üëï",
      backpack: "üéí"
    };
    return icons[slotType] || "?";
  }
  /**
   * Create grid panel (center)
   */
  createGridPanel() {
    const panel = document.createElement("div");
    panel.className = "grid-panel";
    const grid = document.createElement("div");
    grid.className = "inventory-grid";
    for (let i = 0; i < 20; i++) {
      const slot = this.createInventorySlot(i);
      grid.appendChild(slot);
    }
    panel.appendChild(grid);
    const weightBar = this.createWeightBar();
    panel.appendChild(weightBar);
    const actions = this.createActionButtons();
    panel.appendChild(actions);
    return panel;
  }
  /**
   * Create individual inventory slot
   */
  createInventorySlot(index) {
    const slot = document.createElement("div");
    slot.className = "inventory-slot";
    slot.dataset.slotIndex = index;
    const icon = document.createElement("div");
    icon.className = "slot-icon";
    slot.appendChild(icon);
    const count = document.createElement("div");
    count.className = "slot-count";
    slot.appendChild(count);
    const border = document.createElement("div");
    border.className = "slot-border";
    slot.appendChild(border);
    slot.addEventListener("click", () => this.selectSlot(index));
    slot.addEventListener("dragstart", (e) => this.onDragStart(e, index));
    slot.addEventListener("dragover", (e) => this.onDragOver(e));
    slot.addEventListener("drop", (e) => this.onDrop(e, index));
    slot.addEventListener("mouseenter", () => this.showTooltip(index));
    slot.addEventListener("mouseleave", () => this.hideTooltip());
    return slot;
  }
  /**
   * Create weight capacity bar
   */
  createWeightBar() {
    const container = document.createElement("div");
    container.className = "weight-container";
    const label = document.createElement("div");
    label.className = "weight-label";
    container.appendChild(label);
    const barBg = document.createElement("div");
    barBg.className = "weight-bar-bg";
    const barFill = document.createElement("div");
    barFill.className = "weight-bar-fill";
    barBg.appendChild(barFill);
    container.appendChild(barBg);
    return container;
  }
  /**
   * Create action buttons
   */
  createActionButtons() {
    const container = document.createElement("div");
    container.className = "action-buttons";
    const sortBtn = this.createButton("Sort", () => this.sortInventory());
    const stackBtn = this.createButton("Stack All", () => this.stackAll());
    const dropBtn = this.createButton("Drop All", () => this.dropAll());
    container.appendChild(sortBtn);
    container.appendChild(stackBtn);
    container.appendChild(dropBtn);
    return container;
  }
  /**
   * Create details panel (bottom)
   */
  createDetailsPanel() {
    const panel = document.createElement("div");
    panel.className = "details-panel";
    const empty = document.createElement("div");
    empty.className = "details-empty";
    empty.textContent = "Select an item to view details";
    panel.appendChild(empty);
    const details = document.createElement("div");
    details.className = "details-content";
    details.style.display = "none";
    const icon = document.createElement("div");
    icon.className = "details-icon";
    details.appendChild(icon);
    const info = document.createElement("div");
    info.className = "details-info";
    const name = document.createElement("div");
    name.className = "details-name";
    info.appendChild(name);
    const description = document.createElement("div");
    description.className = "details-description";
    info.appendChild(description);
    const durability = document.createElement("div");
    durability.className = "details-durability";
    info.appendChild(durability);
    const effects = document.createElement("div");
    effects.className = "details-effects";
    info.appendChild(effects);
    details.appendChild(info);
    const buttons = document.createElement("div");
    buttons.className = "details-buttons";
    const useBtn = this.createButton("Use", () => this.useSelectedItem());
    const equipBtn = this.createButton("Equip", () => this.equipSelectedItem());
    const dropBtn = this.createButton("Drop", () => this.dropSelectedItem());
    buttons.appendChild(useBtn);
    buttons.appendChild(equipBtn);
    buttons.appendChild(dropBtn);
    details.appendChild(buttons);
    panel.appendChild(details);
    return panel;
  }
  /**
   * Create a button
   */
  createButton(text, onclick) {
    const btn = document.createElement("button");
    btn.className = "inventory-button";
    btn.textContent = text;
    btn.onclick = onclick;
    return btn;
  }
  /**
   * Setup event listeners
   */
  setupEventListeners() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isOpen) {
        this.close();
      }
    });
    this.container.addEventListener("click", (e) => {
      if (e.target === this.container) {
        this.close();
      }
    });
  }
  /**
   * Open inventory
   */
  open() {
    this.isOpen = true;
    this.container.style.display = "flex";
    this.refresh();
  }
  /**
   * Close inventory
   */
  close() {
    this.isOpen = false;
    this.container.style.display = "none";
    this.selectedSlot = null;
  }
  /**
   * Toggle inventory
   */
  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * Refresh all UI elements
   */
  refresh() {
    this.refreshInventoryGrid();
    this.refreshEquipmentSlots();
    this.refreshWeightBar();
    this.refreshDetails();
  }
  /**
   * Refresh inventory grid
   */
  refreshInventoryGrid() {
    const slots = this.container.querySelectorAll(".inventory-slot");
    slots.forEach((slotElement, index) => {
      const slot = this.inventory.slots[index];
      const icon = slotElement.querySelector(".slot-icon");
      const count = slotElement.querySelector(".slot-count");
      const border = slotElement.querySelector(".slot-border");
      if (slot && !slot.isEmpty()) {
        const item = slot.item;
        icon.style.display = "block";
        icon.textContent = this.getItemIcon(item);
        if (item.stackable && slot.quantity > 1) {
          count.style.display = "block";
          count.textContent = slot.quantity;
        } else {
          count.style.display = "none";
        }
        border.style.display = "block";
        border.style.borderColor = this.getRarityColor(item.rarity);
        slotElement.draggable = true;
      } else {
        icon.style.display = "none";
        count.style.display = "none";
        border.style.display = "none";
        slotElement.draggable = false;
      }
      if (this.selectedSlot === index) {
        slotElement.classList.add("selected");
      } else {
        slotElement.classList.remove("selected");
      }
    });
  }
  /**
   * Refresh equipment slots
   */
  refreshEquipmentSlots() {
    const slotTypes = ["weapon", "tool", "clothing", "backpack"];
    slotTypes.forEach((slotType) => {
      const slotElement = this.container.querySelector(`[data-slot-type="${slotType}"]`);
      const item = this.inventory.equipment[slotType];
      slotElement.innerHTML = "";
      if (item) {
        const icon = document.createElement("div");
        icon.className = "equipment-icon";
        icon.textContent = this.getItemIcon(item);
        slotElement.appendChild(icon);
        const border = document.createElement("div");
        border.className = "equipment-border";
        border.style.borderColor = this.getRarityColor(item.rarity);
        slotElement.appendChild(border);
      } else {
        const placeholder = document.createElement("div");
        placeholder.className = "equipment-placeholder";
        placeholder.textContent = this.getEquipmentIcon(slotType);
        slotElement.appendChild(placeholder);
      }
      slotElement.onclick = () => {
        if (item) {
          this.inventory.unequip(slotType);
          this.refresh();
        }
      };
    });
  }
  /**
   * Refresh weight bar
   */
  refreshWeightBar() {
    const currentWeight = this.inventory.getTotalWeight();
    const maxWeight = this.inventory.maxWeight;
    const percentage = currentWeight / maxWeight * 100;
    const label = this.container.querySelector(".weight-label");
    const fill = this.container.querySelector(".weight-bar-fill");
    label.textContent = `Weight: ${currentWeight.toFixed(1)} / ${maxWeight} lbs`;
    fill.style.width = `${Math.min(percentage, 100)}%`;
    if (percentage >= 100) {
      fill.style.backgroundColor = "#e74c3c";
    } else if (percentage >= 80) {
      fill.style.backgroundColor = "#f39c12";
    } else if (percentage >= 60) {
      fill.style.backgroundColor = "#f1c40f";
    } else {
      fill.style.backgroundColor = "#2ecc71";
    }
  }
  /**
   * Refresh details panel
   */
  refreshDetails() {
    const empty = this.container.querySelector(".details-empty");
    const content = this.container.querySelector(".details-content");
    if (this.selectedSlot === null || this.inventory.slots[this.selectedSlot].isEmpty()) {
      empty.style.display = "block";
      content.style.display = "none";
      return;
    }
    empty.style.display = "none";
    content.style.display = "flex";
    const slot = this.inventory.slots[this.selectedSlot];
    const item = slot.item;
    const icon = content.querySelector(".details-icon");
    icon.textContent = this.getItemIcon(item);
    icon.style.borderColor = this.getRarityColor(item.rarity);
    const name = content.querySelector(".details-name");
    name.textContent = item.name;
    name.style.color = this.getRarityColor(item.rarity);
    const description = content.querySelector(".details-description");
    description.textContent = item.description;
    const durabilityDiv = content.querySelector(".details-durability");
    if (item.durability !== void 0) {
      const percentage = item.durability / item.maxDurability * 100;
      const bars = Math.round(percentage / 10);
      const filled = "‚ñà".repeat(bars);
      const empty2 = "‚ñë".repeat(10 - bars);
      durabilityDiv.style.display = "block";
      durabilityDiv.textContent = `Durability: ${filled}${empty2} ${item.durability}/${item.maxDurability}`;
    } else {
      durabilityDiv.style.display = "none";
    }
    const effectsDiv = content.querySelector(".details-effects");
    if (item.effects && Object.keys(item.effects).length > 0) {
      const effectText = Object.entries(item.effects).map(([key, value]) => {
        const prefix = value > 0 ? "+" : "";
        return `${prefix}${value} ${this.formatEffectName(key)}`;
      }).join(", ");
      effectsDiv.style.display = "block";
      effectsDiv.textContent = effectText;
    } else {
      effectsDiv.style.display = "none";
    }
    const buttons = content.querySelector(".details-buttons");
    const useBtn = buttons.children[0];
    const equipBtn = buttons.children[1];
    useBtn.style.display = item.consumable || item.usable ? "inline-block" : "none";
    equipBtn.style.display = item.equippable ? "inline-block" : "none";
  }
  /**
   * Select a slot
   */
  selectSlot(index) {
    this.selectedSlot = index;
    this.refresh();
  }
  /**
   * Drag and drop handlers
   */
  onDragStart(e, index) {
    this.draggedSlot = index;
    e.dataTransfer.effectAllowed = "move";
    e.target.classList.add("dragging");
  }
  onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }
  onDrop(e, targetIndex) {
    e.preventDefault();
    if (this.draggedSlot !== null && this.draggedSlot !== targetIndex) {
      this.inventory.swapSlots(this.draggedSlot, targetIndex);
      this.refresh();
    }
    const dragged = this.container.querySelector(".dragging");
    if (dragged) dragged.classList.remove("dragging");
    this.draggedSlot = null;
  }
  /**
   * Tooltip (simple for now, can be enhanced)
   */
  showTooltip(index) {
  }
  hideTooltip() {
  }
  /**
   * Action handlers
   */
  sortInventory() {
    this.inventory.sortInventory();
    this.refresh();
  }
  stackAll() {
    this.inventory.stackAll();
    this.refresh();
  }
  dropAll() {
    if (confirm("Drop all items? This cannot be undone!")) {
      this.inventory.slots.forEach((slot) => slot.clear());
      this.refresh();
    }
  }
  useSelectedItem() {
    if (this.selectedSlot !== null) {
      const result = this.inventory.useItem(this.selectedSlot);
      if (result) {
        console.log("Used item:", result);
      }
      this.refresh();
    }
  }
  equipSelectedItem() {
    if (this.selectedSlot !== null) {
      const slot = this.inventory.slots[this.selectedSlot];
      if (!slot.isEmpty() && slot.item.equippable) {
        const slotType = this.determineEquipmentSlot(slot.item);
        this.inventory.equip(slot.item, slotType);
        this.refresh();
      }
    }
  }
  dropSelectedItem() {
    if (this.selectedSlot !== null) {
      const slot = this.inventory.slots[this.selectedSlot];
      if (!slot.isEmpty()) {
        const item = slot.item;
        if (confirm(`Drop ${item.name}?`)) {
          this.inventory.removeItem(item.id, 1);
          this.refresh();
        }
      }
    }
  }
  /**
   * Determine which equipment slot an item goes in
   */
  determineEquipmentSlot(item) {
    if (item.type === "weapon") return "weapon";
    if (item.type === "tool") return "tool";
    if (item.type === "equipment") {
      if (item.category === "clothing") return "clothing";
      if (item.category === "backpack") return "backpack";
    }
    return null;
  }
  /**
   * Get emoji icon for item (placeholder until we have real icons)
   */
  getItemIcon(item) {
    const iconMap = {
      // Food
      coconut: "ü••",
      berries: "ü´ê",
      cooked_fish: "üçñ",
      raw_fish: "üêü",
      cooked_meat: "ü•©",
      // Water
      water_bottle: "üíß",
      dirty_water: "üí¶",
      // Medicine
      bandage: "ü©π",
      herbal_remedy: "üåø",
      // Materials
      wood: "ü™µ",
      stone: "ü™®",
      fiber: "üßµ",
      leather: "üü´",
      metal_scrap: "‚öôÔ∏è",
      // Tools
      stone_axe: "ü™ì",
      stone_pickaxe: "‚õèÔ∏è",
      knife: "üî™",
      fishing_rod: "üé£",
      // Weapons
      stone_spear: "üó°Ô∏è",
      wooden_club: "üèè",
      bow: "üèπ",
      // Equipment
      cloth_shirt: "üëï",
      leather_vest: "ü¶∫",
      leather_backpack: "üéí",
      waterskin: "ü´ô"
    };
    return iconMap[item.id] || "üì¶";
  }
  /**
   * Get color for rarity
   */
  getRarityColor(rarity) {
    const colors = {
      common: "#9e9e9e",
      uncommon: "#4caf50",
      rare: "#2196f3",
      epic: "#9c27b0",
      legendary: "#ff9800"
    };
    return colors[rarity] || colors.common;
  }
  /**
   * Format effect name for display
   */
  formatEffectName(effect) {
    const names = {
      hunger: "Hunger",
      thirst: "Thirst",
      health: "Health",
      energy: "Energy",
      damage: "Damage",
      defense: "Defense",
      woodcutting: "Woodcutting",
      mining: "Mining",
      crafting: "Crafting",
      fishing: "Fishing",
      range: "Range",
      capacity: "Capacity"
    };
    return names[effect] || effect;
  }
}
class GatheringUI {
  constructor() {
    this.container = null;
    this.isGathering = false;
    this.currentNode = null;
    this.gatheringProgress = 0;
    this.gatherStartTime = 0;
    this.animationFrame = null;
    this.createUI();
  }
  /**
   * Create UI elements
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "gathering-overlay";
    this.container.style.display = "none";
    const modal = document.createElement("div");
    modal.className = "gathering-modal";
    const info = document.createElement("div");
    info.className = "gathering-info";
    const icon = document.createElement("div");
    icon.className = "gathering-icon";
    info.appendChild(icon);
    const name = document.createElement("div");
    name.className = "gathering-name";
    info.appendChild(name);
    modal.appendChild(info);
    const progressContainer = document.createElement("div");
    progressContainer.className = "gathering-progress-container";
    const progressLabel = document.createElement("div");
    progressLabel.className = "gathering-progress-label";
    progressLabel.textContent = "Gathering...";
    progressContainer.appendChild(progressLabel);
    const progressBg = document.createElement("div");
    progressBg.className = "gathering-progress-bg";
    const progressFill = document.createElement("div");
    progressFill.className = "gathering-progress-fill";
    progressBg.appendChild(progressFill);
    progressContainer.appendChild(progressBg);
    modal.appendChild(progressContainer);
    const details = document.createElement("div");
    details.className = "gathering-details";
    modal.appendChild(details);
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "gathering-cancel";
    cancelBtn.textContent = "Cancel (ESC)";
    cancelBtn.onclick = () => this.cancel();
    modal.appendChild(cancelBtn);
    this.container.appendChild(modal);
    document.body.appendChild(this.container);
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isGathering) {
        this.cancel();
      }
    });
  }
  /**
   * Start gathering from a node
   */
  startGathering(node, player2, onComplete) {
    if (this.isGathering) return;
    this.isGathering = true;
    this.currentNode = node;
    this.gatheringProgress = 0;
    this.gatherStartTime = Date.now();
    this.onComplete = onComplete;
    const icon = this.container.querySelector(".gathering-icon");
    const name = this.container.querySelector(".gathering-name");
    const details = this.container.querySelector(".gathering-details");
    icon.textContent = node.getSprite();
    name.textContent = node.getName();
    const info = node.getInfo();
    details.innerHTML = `
      <div class="detail-row">
        <span class="detail-label">Tool Required:</span>
        <span class="detail-value">${info.requiredTool}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Energy Cost:</span>
        <span class="detail-value">${info.energyCost}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Time:</span>
        <span class="detail-value">${info.gatherTime}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Uses Remaining:</span>
        <span class="detail-value">${info.usesRemaining}</span>
      </div>
    `;
    this.container.style.display = "flex";
    this.animate();
  }
  /**
   * Animate gathering progress
   */
  animate() {
    if (!this.isGathering) return;
    const elapsed = Date.now() - this.gatherStartTime;
    const duration = this.currentNode.gatherTime;
    this.gatheringProgress = Math.min(elapsed / duration * 100, 100);
    const fill = this.container.querySelector(".gathering-progress-fill");
    fill.style.width = `${this.gatheringProgress}%`;
    if (this.gatheringProgress >= 100) {
      this.complete();
      return;
    }
    this.animationFrame = requestAnimationFrame(() => this.animate());
  }
  /**
   * Complete gathering
   */
  complete() {
    this.isGathering = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    if (this.onComplete) {
      this.onComplete();
    }
    setTimeout(() => {
      this.container.style.display = "none";
    }, 500);
  }
  /**
   * Cancel gathering
   */
  cancel() {
    this.isGathering = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.container.style.display = "none";
  }
  /**
   * Show gathering result
   */
  showResult(result) {
    if (!result.success) {
      this.showNotification("Failed", result.reason, "error");
      return;
    }
    const itemNames = result.items.map((item) => item.name).join(", ");
    let message = `Gathered: ${itemNames}`;
    if (result.xpGained) {
      message += `
+${result.xpGained} XP`;
    }
    this.showNotification("Success!", message, "success");
  }
  /**
   * Show notification popup
   */
  showNotification(title, message, type = "info") {
    const notification = document.createElement("div");
    notification.className = `gathering-notification ${type}`;
    const titleEl = document.createElement("div");
    titleEl.className = "notification-title";
    titleEl.textContent = title;
    notification.appendChild(titleEl);
    const messageEl = document.createElement("div");
    messageEl.className = "notification-message";
    messageEl.textContent = message;
    notification.appendChild(messageEl);
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.classList.add("show");
    }, 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3e3);
  }
  /**
   * Cleanup
   */
  destroy() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }
}
class Recipe {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description || "";
    this.category = data.category;
    this.ingredients = data.ingredients || [];
    this.requiredTool = data.requiredTool || null;
    this.requiredSkill = data.requiredSkill || null;
    this.minimumSkillLevel = data.minimumSkillLevel || 0;
    this.requiredStation = data.requiredStation || null;
    this.output = data.output || [];
    this.craftDuration = data.craftDuration || 60;
    this.craftTimeMs = data.craftTimeMs || 3e3;
    this.difficulty = data.difficulty || "easy";
    this.unlocked = data.unlocked !== false;
    this.unlockConditions = data.unlockConditions || null;
    this.baseXP = data.baseXP || 10;
    this.qualityEnabled = data.qualityEnabled !== false;
    this.icon = data.icon || "recipes/default.png";
  }
  /**
   * Check if player can craft this recipe
   */
  canCraft(player2) {
    if (!this.unlocked) {
      return { success: false, reason: "Recipe not unlocked" };
    }
    if (this.unlockConditions) {
      if (this.unlockConditions.skill) {
        const skillLevel = player2.getEffectiveSkill(this.unlockConditions.skill);
        if (skillLevel < this.unlockConditions.level) {
          return {
            success: false,
            reason: `Requires ${this.unlockConditions.skill} level ${this.unlockConditions.level}`
          };
        }
      }
    }
    if (this.requiredSkill && this.minimumSkillLevel > 0) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      if (skillLevel < this.minimumSkillLevel) {
        return {
          success: false,
          reason: `Requires ${this.requiredSkill} level ${this.minimumSkillLevel}`
        };
      }
    }
    for (const ingredient of this.ingredients) {
      const count = player2.inventory.getItemCount(ingredient.itemId);
      if (count < ingredient.quantity) {
        return {
          success: false,
          reason: `Need ${ingredient.quantity}x ${ingredient.itemId} (have ${count})`
        };
      }
    }
    if (this.requiredTool) {
      const hasTool = this.checkPlayerHasTool(player2, this.requiredTool);
      if (!hasTool) {
        return { success: false, reason: `Requires ${this.requiredTool}` };
      }
    }
    if (this.requiredStation) ;
    return { success: true };
  }
  /**
   * Check if player has required tool equipped
   */
  checkPlayerHasTool(player2, toolType) {
    const equipped = player2.inventory.equipment;
    const weapon = equipped.weapon;
    const tool = equipped.tool;
    if (toolType === "axe") {
      return weapon?.category === "axe" || tool?.category === "axe";
    }
    if (toolType === "pickaxe") {
      return weapon?.category === "pickaxe" || tool?.category === "pickaxe";
    }
    if (toolType === "knife") {
      return weapon?.category === "knife" || tool?.category === "knife";
    }
    if (toolType === "hammer") {
      return weapon?.category === "hammer" || tool?.category === "hammer";
    }
    return false;
  }
  /**
   * Get crafting duration in game minutes
   * Duration varies by difficulty, player skill, and tool quality
   * Range: 30 minutes to 6 hours
   */
  getCraftDuration(player2) {
    let duration = this.craftDuration;
    const difficultyBase = {
      easy: 30,
      // 30 minutes
      medium: 60,
      // 1 hour
      hard: 120,
      // 2 hours
      expert: 240
      // 4 hours
    };
    duration = difficultyBase[this.difficulty] || 60;
    if (this.requiredSkill) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      const skillReduction = Math.floor(skillLevel / 10) * 5;
      duration -= skillReduction;
    }
    if (this.requiredTool) {
      const tool = this.getEquippedTool(player2);
      if (tool && tool.rarity !== "common") {
        const rarityReduction = {
          uncommon: 5,
          // -5 minutes
          rare: 10,
          // -10 minutes
          epic: 20,
          // -20 minutes
          legendary: 30
          // -30 minutes
        };
        duration -= rarityReduction[tool.rarity] || 0;
      }
    }
    return Math.max(30, Math.ceil(duration));
  }
  /**
   * Get the equipped tool being used
   */
  getEquippedTool(player2) {
    const equipped = player2.inventory.equipment;
    if (this.requiredTool === "axe") {
      return equipped.weapon?.category === "axe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "pickaxe") {
      return equipped.weapon?.category === "pickaxe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "knife") {
      return equipped.weapon?.category === "knife" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "hammer") {
      return equipped.weapon?.category === "hammer" ? equipped.weapon : equipped.tool;
    }
    return null;
  }
  /**
   * Craft the item
   */
  craft(player2) {
    const canCraft = this.canCraft(player2);
    if (!canCraft.success) {
      return {
        success: false,
        reason: canCraft.reason
      };
    }
    for (const ingredient of this.ingredients) {
      player2.inventory.removeItem(ingredient.itemId, ingredient.quantity);
    }
    if (this.requiredTool) {
      const tool = this.getEquippedTool(player2);
      if (tool && tool.durability !== null) {
        tool.damage(2);
        if (tool.durability <= 0) {
          console.log(`${tool.name} broke while crafting!`);
        }
      }
    }
    const quality = this.qualityEnabled ? this.calculateQuality(player2) : "normal";
    const createdItems = [];
    for (const output of this.output) {
      const item = window.itemDB.get(output.itemId);
      if (item) {
        if (quality === "excellent") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 1.5);
          if (item.effects) {
            Object.keys(item.effects).forEach((key) => {
              item.effects[key] = Math.floor(item.effects[key] * 1.2);
            });
          }
        } else if (quality === "good") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 1.25);
          if (item.effects) {
            Object.keys(item.effects).forEach((key) => {
              item.effects[key] = Math.floor(item.effects[key] * 1.1);
            });
          }
        } else if (quality === "poor") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 0.75);
        }
        if (item.durability !== null) {
          item.durability = item.maxDurability;
        }
        const added = player2.inventory.addItem(item, output.quantity);
        if (added) {
          createdItems.push({ item, quantity: output.quantity, quality });
        }
      }
    }
    if (this.requiredSkill) {
      const xpBonus = quality === "excellent" ? 1.5 : quality === "good" ? 1.2 : 1;
      const xpGained = Math.floor(this.baseXP * xpBonus);
      player2.gainSkillXP(this.requiredSkill, xpGained);
    }
    return {
      success: true,
      items: createdItems,
      quality,
      xpGained: this.requiredSkill ? this.baseXP : 0
    };
  }
  /**
   * Calculate crafting quality based on skill
   */
  calculateQuality(player2) {
    if (!this.requiredSkill) return "normal";
    const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
    const roll = Math.random() * 100;
    const excellentThreshold = Math.max(0, skillLevel - 50);
    const goodThreshold = Math.max(0, skillLevel - 20);
    const poorThreshold = Math.max(0, 100 - skillLevel);
    if (roll < excellentThreshold) return "excellent";
    if (roll < goodThreshold) return "good";
    if (roll > 100 - poorThreshold && skillLevel < 30) return "poor";
    return "normal";
  }
  /**
   * Get difficulty color
   */
  getDifficultyColor() {
    const colors = {
      easy: "#4ade80",
      medium: "#fbbf24",
      hard: "#f97316",
      expert: "#dc2626"
    };
    return colors[this.difficulty] || colors.easy;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      unlocked: this.unlocked
    };
  }
}
class RecipeDatabase {
  constructor() {
    this.recipes = /* @__PURE__ */ new Map();
    this.loadRecipes();
  }
  /**
   * Load all recipe definitions
   */
  loadRecipes() {
    const recipeDefinitions = this.getRecipeDefinitions();
    recipeDefinitions.forEach((def) => {
      this.recipes.set(def.id, new Recipe(def));
    });
    console.log(`üìã Loaded ${this.recipes.size} recipes`);
  }
  /**
   * Get recipe by ID
   */
  get(recipeId) {
    return this.recipes.get(recipeId) || null;
  }
  /**
   * Get all recipes
   */
  getAll() {
    return Array.from(this.recipes.values());
  }
  /**
   * Get recipes by category
   */
  getByCategory(category) {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.category === category);
  }
  /**
   * Get craftable recipes (player can make)
   */
  getCraftable(player2) {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.canCraft(player2).success);
  }
  /**
   * Get unlocked recipes
   */
  getUnlocked() {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.unlocked);
  }
  /**
   * Recipe definitions
   */
  getRecipeDefinitions() {
    return [
      // ===== BASIC TOOLS =====
      {
        id: "stone_axe",
        name: "Stone Axe",
        description: "A crude but effective axe for chopping wood.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "stone", quantity: 2 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_axe", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 8e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "stone_pickaxe",
        name: "Stone Pickaxe",
        description: "Break rocks and mine stone.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "stone", quantity: 3 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_pickaxe", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 8e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "crude_knife",
        name: "Crude Knife",
        description: "A sharp knife for cutting and crafting.",
        category: "tools",
        ingredients: [
          { itemId: "stone", quantity: 2 },
          { itemId: "wood", quantity: 1 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [{ itemId: "knife", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12
      },
      {
        id: "fishing_rod",
        name: "Fishing Rod",
        description: "Catch fish more easily.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "fiber", quantity: 5 }
        ],
        output: [{ itemId: "fishing_rod", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 6e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 18
      },
      // ===== WEAPONS =====
      {
        id: "stone_spear",
        name: "Stone Spear",
        description: "A sharp spear for hunting and combat.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "stone", quantity: 1 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_spear", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 7e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "wooden_club",
        name: "Wooden Club",
        description: "A heavy club for bashing.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 4 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [{ itemId: "wooden_club", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12
      },
      {
        id: "bow",
        name: "Hunting Bow",
        description: "A ranged weapon for hunting.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "fiber", quantity: 8 }
        ],
        output: [{ itemId: "bow", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 15,
        craftTime: 12e3,
        energyCost: 15,
        difficulty: "medium",
        baseXP: 25
      },
      // ===== CONSUMABLES =====
      {
        id: "cook_fish",
        name: "Cook Fish",
        description: "Cook raw fish over a fire.",
        category: "consumables",
        ingredients: [
          { itemId: "raw_fish", quantity: 1 },
          { itemId: "wood", quantity: 1 }
        ],
        output: [{ itemId: "cooked_fish", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 3e3,
        energyCost: 3,
        difficulty: "easy",
        baseXP: 5,
        qualityEnabled: false
      },
      {
        id: "cook_meat",
        name: "Cook Meat",
        description: "Cook raw meat over a fire.",
        category: "consumables",
        ingredients: [
          { itemId: "raw_meat", quantity: 1 },
          { itemId: "wood", quantity: 1 }
        ],
        output: [{ itemId: "cooked_meat", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 4e3,
        energyCost: 3,
        difficulty: "easy",
        baseXP: 6,
        qualityEnabled: false
      },
      {
        id: "herbal_remedy",
        name: "Herbal Remedy",
        description: "Craft medicine from island plants.",
        category: "consumables",
        ingredients: [
          { itemId: "fiber", quantity: 5 },
          { itemId: "berries", quantity: 3 }
        ],
        output: [{ itemId: "herbal_remedy", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 10,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "medium",
        baseXP: 20
      },
      {
        id: "bandage",
        name: "Bandage",
        description: "Create bandages from cloth.",
        category: "consumables",
        ingredients: [
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "bandage", quantity: 2 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 2e3,
        energyCost: 2,
        difficulty: "easy",
        baseXP: 3,
        qualityEnabled: false
      },
      // ===== MATERIALS =====
      {
        id: "rope",
        name: "Rope",
        description: "Twist plant fibers into rope.",
        category: "materials",
        ingredients: [
          { itemId: "fiber", quantity: 10 }
        ],
        output: [{ itemId: "rope", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 5,
        difficulty: "easy",
        baseXP: 8,
        qualityEnabled: false
      },
      {
        id: "cloth",
        name: "Cloth",
        description: "Weave plant fibers into cloth.",
        category: "materials",
        ingredients: [
          { itemId: "fiber", quantity: 15 }
        ],
        output: [{ itemId: "cloth", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12,
        qualityEnabled: false
      },
      // ===== EQUIPMENT =====
      {
        id: "cloth_shirt",
        name: "Cloth Shirt",
        description: "Basic clothing for protection.",
        category: "equipment",
        ingredients: [
          { itemId: "cloth", quantity: 2 },
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "cloth_shirt", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 1e4,
        energyCost: 10,
        difficulty: "medium",
        baseXP: 18
      },
      {
        id: "leather_vest",
        name: "Leather Vest",
        description: "Sturdy leather protection.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 3 },
          { itemId: "fiber", quantity: 5 }
        ],
        output: [{ itemId: "leather_vest", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 15,
        craftTime: 15e3,
        energyCost: 15,
        difficulty: "medium",
        baseXP: 30
      },
      {
        id: "leather_backpack",
        name: "Leather Backpack",
        description: "Increases carrying capacity.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 4 },
          { itemId: "fiber", quantity: 8 },
          { itemId: "rope", quantity: 2 }
        ],
        output: [{ itemId: "leather_backpack", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 20,
        craftTime: 2e4,
        energyCost: 20,
        difficulty: "hard",
        baseXP: 50
      },
      {
        id: "waterskin",
        name: "Waterskin",
        description: "Carry water with you.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 2 },
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "waterskin", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 10,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "medium",
        baseXP: 20
      },
      // ===== TOOL REPAIR =====
      {
        id: "repair_tool",
        name: "Repair Tool",
        description: "Restore durability to damaged tools.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "stone", quantity: 1 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [],
        // Special: repairs equipped tool instead
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 10,
        qualityEnabled: false
      }
    ];
  }
}
const recipeDB = new RecipeDatabase();
class CraftingUI {
  constructor(player2, gameState2) {
    this.player = player2;
    this.gameState = gameState2;
    this.isVisible = false;
    this.selectedRecipe = null;
    this.currentCategory = "all";
    this.craftingQueue = [];
    this.isCrafting = false;
    this.container = null;
    this.init();
  }
  /**
   * Initialize the UI
   */
  init() {
    this.container = document.createElement("div");
    this.container.id = "crafting-ui";
    this.container.className = "crafting-modal hidden";
    document.body.appendChild(this.container);
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isVisible) {
        this.hide();
      }
    });
  }
  /**
   * Show the crafting UI
   */
  show() {
    this.isVisible = true;
    this.render();
    this.container.classList.remove("hidden");
    console.log("üìã Crafting menu opened");
  }
  /**
   * Hide the crafting UI
   */
  hide() {
    this.isVisible = false;
    this.container.classList.add("hidden");
  }
  /**
   * Toggle visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Render the complete UI
   */
  render() {
    const recipes = this.currentCategory === "all" ? recipeDB.getAll() : recipeDB.getByCategory(this.currentCategory);
    this.container.innerHTML = `
      <div class="crafting-overlay"></div>
      <div class="crafting-window">
        \x3C!-- Header -->
        <div class="crafting-header">
          <h2>üî® Crafting</h2>
          <button class="close-btn" onclick="window.craftingUI?.hide()">‚úï</button>
        </div>

        \x3C!-- Main Content -->
        <div class="crafting-content">
          \x3C!-- Left: Categories -->
          <div class="crafting-categories">
            <h3>Categories</h3>
            <div class="category-list">
              ${this.renderCategories()}
            </div>
            <div class="crafting-stats">
              <div class="stat-item">
                <span class="stat-label">‚ö° Energy</span>
                <span class="stat-value">${Math.floor(this.player.stats.energy)}</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">üî® Crafting</span>
                <span class="stat-value">${Math.floor(this.player.skills.crafting)}</span>
              </div>
            </div>
          </div>

          \x3C!-- Center: Recipe List -->
          <div class="crafting-recipes">
            <div class="recipes-header">
              <h3>${this.getCategoryName(this.currentCategory)}</h3>
              <span class="recipe-count">${recipes.length} recipes</span>
            </div>
            <div class="recipe-list">
              ${this.renderRecipeList(recipes)}
            </div>
          </div>

          \x3C!-- Right: Recipe Details -->
          <div class="crafting-details">
            ${this.selectedRecipe ? this.renderRecipeDetails(this.selectedRecipe) : this.renderEmptyDetails()}
          </div>
        </div>

        \x3C!-- Footer: Crafting Queue -->
        ${this.craftingQueue.length > 0 ? this.renderCraftingQueue() : ""}
      </div>
    `;
    this.attachEventListeners();
  }
  /**
   * Render category buttons
   */
  renderCategories() {
    const categories = [
      { id: "all", name: "All", icon: "üìã" },
      { id: "tools", name: "Tools", icon: "üîß" },
      { id: "weapons", name: "Weapons", icon: "‚öîÔ∏è" },
      { id: "equipment", name: "Equipment", icon: "üéΩ" },
      { id: "consumables", name: "Consumables", icon: "üçñ" },
      { id: "materials", name: "Materials", icon: "üì¶" }
    ];
    return categories.map((cat) => `
      <button 
        class="category-btn ${this.currentCategory === cat.id ? "active" : ""}"
        data-category="${cat.id}"
      >
        <span class="category-icon">${cat.icon}</span>
        <span class="category-name">${cat.name}</span>
      </button>
    `).join("");
  }
  /**
   * Get category display name
   */
  getCategoryName(categoryId) {
    const names = {
      all: "All Recipes",
      tools: "Tools",
      weapons: "Weapons",
      equipment: "Equipment",
      consumables: "Consumables",
      materials: "Materials"
    };
    return names[categoryId] || "Recipes";
  }
  /**
   * Render recipe list
   */
  renderRecipeList(recipes) {
    if (recipes.length === 0) {
      return '<div class="no-recipes">No recipes in this category</div>';
    }
    return recipes.map((recipe) => {
      const canCraft = recipe.canCraft(this.player);
      const isSelected = this.selectedRecipe?.id === recipe.id;
      return `
        <div 
          class="recipe-item ${isSelected ? "selected" : ""} ${!canCraft.success ? "disabled" : ""}"
          data-recipe-id="${recipe.id}"
        >
          <div class="recipe-icon">${this.getRecipeIcon(recipe)}</div>
          <div class="recipe-info">
            <div class="recipe-name">${recipe.name}</div>
            <div class="recipe-difficulty" style="color: ${recipe.getDifficultyColor()}">
              ${recipe.difficulty.toUpperCase()}
            </div>
          </div>
          <div class="recipe-status">
            ${canCraft.success ? '<span class="status-can-craft">‚úì</span>' : '<span class="status-cannot-craft" title="' + canCraft.reason + '">‚úï</span>'}
          </div>
        </div>
      `;
    }).join("");
  }
  /**
   * Get recipe icon
   */
  getRecipeIcon(recipe) {
    const icons = {
      tools: "üîß",
      weapons: "‚öîÔ∏è",
      equipment: "üéΩ",
      consumables: "üçñ",
      materials: "üì¶"
    };
    return icons[recipe.category] || "üìã";
  }
  /**
   * Render recipe details panel
   */
  renderRecipeDetails(recipe) {
    const canCraft = recipe.canCraft(this.player);
    return `
      <div class="details-header">
        <h3>${recipe.name}</h3>
        <div class="difficulty-badge" style="background: ${recipe.getDifficultyColor()}">
          ${recipe.difficulty}
        </div>
      </div>

      <div class="details-description">
        ${recipe.description}
      </div>

      <div class="details-section">
        <h4>Requirements</h4>
        <div class="requirements-list">
          ${recipe.energyCost > 0 ? `
            <div class="requirement">
              <span class="req-icon">‚ö°</span>
              <span class="req-label">Energy:</span>
              <span class="req-value ${this.player.stats.energy >= recipe.energyCost ? "available" : "unavailable"}">
                ${recipe.energyCost}
              </span>
            </div>
          ` : ""}
          
          ${recipe.requiredSkill ? `
            <div class="requirement">
              <span class="req-icon">üî®</span>
              <span class="req-label">${recipe.requiredSkill}:</span>
              <span class="req-value ${this.player.getEffectiveSkill(recipe.requiredSkill) >= recipe.minimumSkillLevel ? "available" : "unavailable"}">
                ${recipe.minimumSkillLevel} (${Math.floor(this.player.getEffectiveSkill(recipe.requiredSkill))})
              </span>
            </div>
          ` : ""}

          ${recipe.requiredTool ? `
            <div class="requirement">
              <span class="req-icon">üõ†Ô∏è</span>
              <span class="req-label">Tool:</span>
              <span class="req-value ${recipe.checkPlayerHasTool(this.player, recipe.requiredTool) ? "available" : "unavailable"}">
                ${recipe.requiredTool}
              </span>
            </div>
          ` : ""}
        </div>
      </div>

      <div class="details-section">
        <h4>Ingredients</h4>
        <div class="ingredients-list">
          ${recipe.ingredients.map((ing) => {
      const item = itemDB.get(ing.itemId);
      const hasCount = this.player.inventory.getItemCount(ing.itemId);
      const hasEnough = hasCount >= ing.quantity;
      return `
              <div class="ingredient ${hasEnough ? "available" : "unavailable"}">
                <span class="ingredient-name">${item?.name || ing.itemId}</span>
                <span class="ingredient-count">
                  ${hasCount}/${ing.quantity}
                </span>
              </div>
            `;
    }).join("")}
        </div>
      </div>

      <div class="details-section">
        <h4>Output</h4>
        <div class="output-list">
          ${recipe.output.map((out) => {
      const item = itemDB.get(out.itemId);
      return `
              <div class="output-item">
                <span class="output-name">${item?.name || out.itemId}</span>
                <span class="output-quantity">√ó${out.quantity}</span>
              </div>
            `;
    }).join("")}
        </div>
      </div>

      <div class="details-footer">
        <div class="craft-time">
          ‚è±Ô∏è ${recipe.getCraftDuration ? recipe.getCraftDuration(this.player) + " min" : Math.floor(recipe.craftDuration) + " min"}
        </div>
        <div class="craft-xp">
          ‚≠ê +${recipe.baseXP} XP
        </div>
      </div>

      <div class="details-actions">
        <button 
          class="craft-btn ${canCraft.success ? "" : "disabled"}"
          data-recipe-id="${recipe.id}"
          ${!canCraft.success ? "disabled" : ""}
        >
          ${canCraft.success ? "üî® Craft" : `‚úï ${canCraft.reason}`}
        </button>
      </div>
    `;
  }
  /**
   * Render empty details panel
   */
  renderEmptyDetails() {
    return `
      <div class="details-empty">
        <div class="empty-icon">üî®</div>
        <div class="empty-text">Select a recipe to view details</div>
      </div>
    `;
  }
  /**
   * Render crafting queue
   */
  renderCraftingQueue() {
    return `
      <div class="crafting-queue">
        <div class="queue-header">
          <h4>Crafting Queue</h4>
          <span class="queue-count">${this.craftingQueue.length} items</span>
        </div>
        <div class="queue-items">
          ${this.craftingQueue.map((item, index) => `
            <div class="queue-item">
              <span class="queue-recipe">${item.recipe.name}</span>
              <div class="queue-progress">
                <div class="queue-progress-bar" style="width: ${item.progress}%"></div>
              </div>
              <button class="queue-cancel" data-index="${index}">‚úï</button>
            </div>
          `).join("")}
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    this.container.querySelectorAll(".category-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        this.currentCategory = btn.dataset.category;
        this.render();
      });
    });
    this.container.querySelectorAll(".recipe-item").forEach((item) => {
      item.addEventListener("click", () => {
        const recipeId = item.dataset.recipeId;
        this.selectRecipe(recipeId);
      });
    });
    const craftBtn = this.container.querySelector(".craft-btn");
    if (craftBtn) {
      craftBtn.addEventListener("click", () => {
        const recipeId = craftBtn.dataset.recipeId;
        this.startCrafting(recipeId);
      });
    }
    this.container.querySelectorAll(".queue-cancel").forEach((btn) => {
      btn.addEventListener("click", () => {
        const index = parseInt(btn.dataset.index);
        this.cancelCrafting(index);
      });
    });
    const overlay = this.container.querySelector(".crafting-overlay");
    if (overlay) {
      overlay.addEventListener("click", () => this.hide());
    }
  }
  /**
   * Select a recipe
   */
  selectRecipe(recipeId) {
    this.selectedRecipe = recipeDB.get(recipeId);
    this.render();
  }
  /**
   * Start crafting an item
   */
  startCrafting(recipeId) {
    const recipe = recipeDB.get(recipeId);
    if (!recipe) return;
    const canCraft = recipe.canCraft(this.player);
    if (!canCraft.success) {
      this.showNotification(canCraft.reason, "error");
      return;
    }
    const queueItem = {
      recipe,
      progress: 0,
      startTime: Date.now()
    };
    this.craftingQueue.push(queueItem);
    if (!this.isCrafting) {
      this.processCraftingQueue();
    }
    this.render();
    this.showNotification(`Crafting ${recipe.name}...`, "info");
  }
  /**
   * Process crafting queue
   */
  async processCraftingQueue() {
    if (this.craftingQueue.length === 0) {
      this.isCrafting = false;
      return;
    }
    this.isCrafting = true;
    const current = this.craftingQueue[0];
    const recipe = current.recipe;
    const craftDuration = recipe.getCraftDuration ? recipe.getCraftDuration(this.player) : recipe.craftDuration;
    const craftTimeMs = recipe.craftTimeMs || 3e3;
    const startTime = Date.now();
    const updateInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      current.progress = Math.min(100, elapsed / craftTimeMs * 100);
      if (this.isVisible) {
        this.render();
      }
    }, 100);
    await new Promise((resolve) => setTimeout(resolve, craftTimeMs));
    clearInterval(updateInterval);
    const result = recipe.craft(this.player);
    if (result.success) {
      if (this.gameState && this.gameState.advanceTime) {
        this.gameState.advanceTime(craftDuration);
      }
      const itemNames = result.items.map((i) => i.item.name).join(", ");
      const qualityText = result.quality !== "normal" ? ` (${result.quality})` : "";
      this.showNotification(`‚úì Crafted ${itemNames}${qualityText}`, "success");
      if (result.xpGained > 0) {
        this.showNotification(`+${result.xpGained} ${recipe.requiredSkill} XP`, "info");
      }
    } else {
      this.showNotification(`‚úï Crafting failed: ${result.reason}`, "error");
    }
    this.craftingQueue.shift();
    if (this.craftingQueue.length > 0) {
      this.processCraftingQueue();
    } else {
      this.isCrafting = false;
      this.render();
    }
  }
  /**
   * Cancel crafting
   */
  cancelCrafting(index) {
    if (index === 0 && this.isCrafting) {
      this.showNotification("Cannot cancel item currently being crafted", "warning");
      return;
    }
    const item = this.craftingQueue[index];
    this.craftingQueue.splice(index, 1);
    this.showNotification(`Cancelled crafting ${item.recipe.name}`, "info");
    this.render();
  }
  /**
   * Show notification
   */
  showNotification(message, type = "info") {
    const notification = document.createElement("div");
    notification.className = `crafting-notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.classList.add("show");
    }, 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), 300);
    }, 3e3);
  }
  /**
   * Update (called by game loop)
   */
  update() {
    if (this.isVisible && this.isCrafting) {
      this.render();
    }
  }
}
class MapTravelUI {
  constructor(mapEngine2, travelSystem2, territoryManager2) {
    this.mapEngine = mapEngine2;
    this.travelSystem = travelSystem2;
    this.territoryManager = territoryManager2;
    this.hoveredHex = null;
    this.selectedHex = null;
    this.initialized = false;
    this.territoryLayer = null;
    this.fogLayer = null;
    this.markerLayer = null;
    this.hoverLayer = null;
  }
  /**
   * Initialize layers and event listeners (call after canvas exists)
   */
  initialize() {
    if (this.initialized) return;
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.warn("Canvas not found, deferring MapTravelUI initialization");
      return;
    }
    this.createLayers();
    this.setupEventListeners();
    this.initialized = true;
    console.log("‚úÖ MapTravelUI initialized");
  }
  /**
   * Get pixel coordinates for a hex (uses renderer)
   */
  hexToPixel(q, r) {
    const renderer = window.game.gameView?.renderer;
    if (!renderer || !renderer.hexGrid) {
      return { x: 0, y: 0 };
    }
    return renderer.hexGrid.axialToPixel(q, r);
  }
  /**
   * Get hex size
   */
  getHexSize() {
    const renderer = window.game.gameView?.renderer;
    return renderer?.hexGrid?.hexSize || 40;
  }
  /**
   * Get renderer for transformations
   */
  getRenderer() {
    return window.game.gameView?.renderer;
  }
  /**
   * Create canvas layers for territories and fog
   */
  createLayers() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.error("Canvas not found for creating layers");
      return;
    }
    this.territoryLayer = document.createElement("canvas");
    this.territoryLayer.width = canvas.width;
    this.territoryLayer.height = canvas.height;
    this.territoryLayer.style.position = "absolute";
    this.territoryLayer.style.top = "0";
    this.territoryLayer.style.left = "0";
    this.territoryLayer.style.pointerEvents = "none";
    this.territoryLayer.style.opacity = "0.3";
    canvas.parentElement.appendChild(this.territoryLayer);
    this.fogLayer = document.createElement("canvas");
    this.fogLayer.width = canvas.width;
    this.fogLayer.height = canvas.height;
    this.fogLayer.style.position = "absolute";
    this.fogLayer.style.top = "0";
    this.fogLayer.style.left = "0";
    this.fogLayer.style.pointerEvents = "none";
    canvas.parentElement.appendChild(this.fogLayer);
    this.markerLayer = document.createElement("canvas");
    this.markerLayer.width = canvas.width;
    this.markerLayer.height = canvas.height;
    this.markerLayer.style.position = "absolute";
    this.markerLayer.style.top = "0";
    this.markerLayer.style.left = "0";
    this.markerLayer.style.pointerEvents = "none";
    canvas.parentElement.appendChild(this.markerLayer);
    this.hoverLayer = document.createElement("canvas");
    this.hoverLayer.width = canvas.width;
    this.hoverLayer.height = canvas.height;
    this.hoverLayer.style.position = "absolute";
    this.hoverLayer.style.top = "0";
    this.hoverLayer.style.left = "0";
    this.hoverLayer.style.pointerEvents = "none";
    canvas.parentElement.appendChild(this.hoverLayer);
  }
  /**
   * Setup event listeners for hex interaction
   */
  setupEventListeners() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.error("Canvas not found for event listeners");
      return;
    }
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    const DRAG_THRESHOLD = 5;
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      console.log("üó∫Ô∏è MapTravelUI MOUSEDOWN at", dragStartX, dragStartY);
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const dragDistance = Math.sqrt(
          Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2)
        );
        if (dragDistance > DRAG_THRESHOLD) {
          console.log("üó∫Ô∏è MapTravelUI detected drag");
        }
      }
      const renderer = window.game.gameView?.renderer;
      if (!renderer) return;
      const hex = renderer.screenToHex(e.clientX, e.clientY);
      this.onHexHover(hex);
    });
    canvas.addEventListener("mouseup", (e) => {
      const dragDistance = Math.sqrt(
        Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2)
      );
      console.log("üó∫Ô∏è MapTravelUI MOUSEUP - drag distance:", dragDistance.toFixed(1));
      if (isDragging && dragDistance < DRAG_THRESHOLD) {
        console.log("üó∫Ô∏è MapTravelUI: CLICK detected (< threshold)");
        const renderer = window.game.gameView?.renderer;
        if (renderer) {
          const hex = renderer.screenToHex(e.clientX, e.clientY);
          this.onHexClick(hex);
        }
      } else {
        console.log("üó∫Ô∏è MapTravelUI: DRAG detected - ignoring click");
      }
      isDragging = false;
    });
    canvas.addEventListener("mouseleave", () => {
      this.onHexHover(null);
    });
  }
  /**
   * Handle hex hover
   */
  onHexHover(hex) {
    if (!hex) {
      this.hoveredHex = null;
      this.hideTooltip();
      return;
    }
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (!territory || !territory.visibleFromFog) {
      this.hoveredHex = null;
      this.hideTooltip();
      return;
    }
    this.hoveredHex = hex;
    this.showTooltip(hex, territory);
    this.render();
  }
  /**
   * Handle hex click
   */
  onHexClick(hex) {
    if (!hex) return;
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (!territory || !territory.visibleFromFog) return;
    const result = this.travelSystem.startTravel(hex.q, hex.r);
    if (result.success) {
      this.selectedHex = hex;
      this.showTravelNotification(result);
    } else {
      this.showErrorNotification(result.reason);
    }
    this.render();
  }
  /**
   * Show tooltip for hex
   */
  showTooltip(hex, territory) {
    let tooltip = document.getElementById("hex-tooltip");
    if (!tooltip) {
      tooltip = document.createElement("div");
      tooltip.id = "hex-tooltip";
      tooltip.className = "hex-tooltip";
      document.body.appendChild(tooltip);
    }
    let content = `<div class="tooltip-title">${this.getTerrainName(territory.terrain)}</div>`;
    if (territory.owner) {
      const factionName = this.getFactionName(territory.owner);
      content += `<div class="tooltip-faction" style="color: ${territory.getFactionColor()}">
        ${factionName} Territory (${territory.controlStrength}%)
      </div>`;
    } else {
      content += `<div class="tooltip-faction">Unclaimed</div>`;
    }
    const travelInfo = this.travelSystem.getTravelInfo(hex.q, hex.r);
    if (travelInfo) {
      if (travelInfo.canTravel) {
        const duration = isNaN(travelInfo.duration) ? "?" : travelInfo.duration;
        content += `<div class="tooltip-travel">
          ‚è±Ô∏è ${duration} minutes travel
        </div>`;
      } else {
        content += `<div class="tooltip-error">${travelInfo.reason}</div>`;
      }
    }
    if (territory.discovered) {
      if (territory.hasResourceNode) {
        content += `<div class="tooltip-feature">üå≥ Resources Available</div>`;
      }
      if (territory.hasNPC) {
        content += `<div class="tooltip-feature">üë§ NPC Present</div>`;
      }
      if (territory.hasEvent) {
        content += `<div class="tooltip-feature">‚ùó Event Available</div>`;
      }
    }
    tooltip.innerHTML = content;
    const canvas = document.getElementById("game-canvas");
    const pixel = this.hexToPixel(hex.q, hex.r);
    const renderer = window.game.gameView?.renderer;
    if (canvas && renderer) {
      const screenX = pixel.x * renderer.scale + renderer.offsetX;
      const screenY = pixel.y * renderer.scale + renderer.offsetY;
      tooltip.style.left = `${screenX + canvas.offsetLeft + 40}px`;
      tooltip.style.top = `${screenY + canvas.offsetTop - 20}px`;
    }
    tooltip.style.display = "block";
  }
  /**
   * Hide tooltip
   */
  hideTooltip() {
    const tooltip = document.getElementById("hex-tooltip");
    if (tooltip) {
      tooltip.style.display = "none";
    }
  }
  /**
   * Render all layers
   */
  render() {
    if (!this.initialized) {
      this.initialize();
      if (!this.initialized) return;
    }
    this.renderTerritories();
    this.renderFogOfWar();
    this.renderMarkers();
    this.renderHoverHighlight();
  }
  /**
   * Render faction territories
   */
  renderTerritories() {
    if (!this.territoryLayer) return;
    const ctx = this.territoryLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.territoryLayer.width, this.territoryLayer.height);
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      if (!territory.owner || !territory.visibleFromFog) return;
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      ctx.save();
      ctx.translate(pixel.x, pixel.y);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i - Math.PI / 6;
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      const color = territory.getFactionColor();
      const alpha = territory.controlStrength / 100 * 0.4;
      ctx.fillStyle = this.hexToRGBA(color, alpha);
      ctx.fill();
      if (territory.controlStrength > 60) {
        ctx.strokeStyle = this.hexToRGBA(color, 0.8);
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    });
    ctx.restore();
  }
  /**
   * Render fog of war - Civilization-style clouds with 2-tile sight radius
   * Player can see: current tile + adjacent tiles + 1 more layer out = 2-tile radius
   */
  renderFogOfWar() {
    if (!this.fogLayer) return;
    const ctx = this.fogLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.fogLayer.width, this.fogLayer.height);
    if (renderer.fogOfWarEnabled === false) {
      return;
    }
    const playerPos = this.travelSystem.currentPosition;
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      if (size < 3) return;
      const dq = territory.position.q - playerPos.q;
      const dr = territory.position.r - playerPos.r;
      const ds = -territory.position.q - territory.position.r - (-playerPos.q - playerPos.r);
      const distance = Math.max(Math.abs(dq), Math.abs(dr), Math.abs(ds));
      const inSightRange = distance <= 2;
      ctx.save();
      ctx.translate(pixel.x, pixel.y);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i - Math.PI / 6;
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      if (inSightRange && !territory.discovered) {
        territory.discover("player");
      }
      const isDeveloped = territory.owner === "player" && territory.controlStrength >= 60;
      const hasActiveVision = inSightRange || isDeveloped;
      if (!territory.discovered) {
        ctx.fillStyle = "#1a1a1a";
        ctx.fill();
        const gradient = ctx.createRadialGradient(
          size * 0.2,
          -size * 0.3,
          0,
          0,
          0,
          size * 1.2
        );
        gradient.addColorStop(0, "rgba(80, 80, 80, 0.9)");
        gradient.addColorStop(0.5, "rgba(60, 60, 60, 0.95)");
        gradient.addColorStop(1, "rgba(30, 30, 30, 1)");
        ctx.fillStyle = gradient;
        ctx.fill();
      } else if (territory.discovered && !territory.visited) {
        const veilGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        veilGradient.addColorStop(0, "rgba(150, 150, 150, 0.5)");
        veilGradient.addColorStop(0.6, "rgba(120, 120, 120, 0.6)");
        veilGradient.addColorStop(1, "rgba(80, 80, 80, 0.7)");
        ctx.fillStyle = veilGradient;
        ctx.fill();
      } else if (territory.visited && !hasActiveVision) {
        const dimGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        dimGradient.addColorStop(0, "rgba(100, 100, 100, 0.25)");
        dimGradient.addColorStop(0.7, "rgba(70, 70, 70, 0.35)");
        dimGradient.addColorStop(1, "rgba(40, 40, 40, 0.45)");
        ctx.fillStyle = dimGradient;
        ctx.fill();
      }
      ctx.restore();
    });
    ctx.restore();
  }
  /**
   * Render markers for resources, NPCs, events
   */
  renderMarkers() {
    if (!this.markerLayer) return;
    const ctx = this.markerLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.markerLayer.width, this.markerLayer.height);
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      if (!territory.visited) return;
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      if (territory.hasResourceNode) {
        this.drawMarker(ctx, pixel.x - size * 0.3, pixel.y - size * 0.3, "üå≥", 16);
      }
      if (territory.hasNPC) {
        this.drawMarker(ctx, pixel.x + size * 0.3, pixel.y - size * 0.3, "üë§", 16);
      }
      if (territory.hasEvent) {
        this.drawMarker(ctx, pixel.x, pixel.y + size * 0.4, "‚ùó", 16);
      }
      const currentPos = this.travelSystem.currentPosition;
      if (territory.position.q === currentPos.q && territory.position.r === currentPos.r) {
        this.drawMarker(ctx, pixel.x, pixel.y, "üìç", 24);
      }
    });
    ctx.restore();
  }
  /**
   * Draw a marker (emoji/icon)
   */
  drawMarker(ctx, x, y, icon, size) {
    ctx.save();
    ctx.font = `${size}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
    ctx.shadowBlur = 4;
    ctx.fillText(icon, x, y);
    ctx.restore();
  }
  /**
   * Render hover highlight
   */
  renderHoverHighlight() {
    if (!this.hoverLayer) return;
    const ctx = this.hoverLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.hoverLayer.width, this.hoverLayer.height);
    if (!this.hoveredHex) return;
    const territory = this.territoryManager.getTerritory(this.hoveredHex.q, this.hoveredHex.r);
    if (!territory || !territory.visibleFromFog) return;
    const pixel = this.hexToPixel(this.hoveredHex.q, this.hoveredHex.r);
    const size = this.getHexSize();
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    ctx.translate(pixel.x, pixel.y);
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 6;
      const x = size * Math.cos(angle);
      const y = size * Math.sin(angle);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  }
  /**
   * Show travel notification
   */
  showTravelNotification(result) {
    this.showNotification(
      `Traveling... (${result.duration} minutes)`,
      "info"
    );
  }
  /**
   * Show error notification
   */
  showErrorNotification(message) {
    this.showNotification(message, "error");
  }
  /**
   * Show notification
   */
  showNotification(message, type = "info") {
    let container = document.getElementById("travel-notifications");
    if (!container) {
      container = document.createElement("div");
      container.id = "travel-notifications";
      container.className = "travel-notifications";
      document.body.appendChild(container);
    }
    const notification = document.createElement("div");
    notification.className = `travel-notification travel-notification-${type}`;
    notification.textContent = message;
    container.appendChild(notification);
    setTimeout(() => notification.classList.add("show"), 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), 300);
    }, 3e3);
  }
  /**
   * Helper: Get terrain name
   */
  getTerrainName(terrain) {
    const names = {
      "deep_water": "Deep Ocean",
      "water": "Shallow Water",
      "beach": "Beach",
      "lowland": "Lowland",
      "forest": "Forest",
      "highland": "Highland",
      "mountain": "Mountain"
    };
    return names[terrain] || terrain;
  }
  /**
   * Helper: Get faction name
   */
  getFactionName(faction) {
    const names = {
      player: "Your",
      castaways: "Castaway",
      natives_clan1: "Native Clan 1",
      natives_clan2: "Native Clan 2",
      mercenaries: "Mercenary"
    };
    return names[faction] || faction;
  }
  /**
   * Helper: Convert hex color to RGBA
   */
  hexToRGBA(hex, alpha) {
    if (!hex) return `rgba(255, 255, 255, ${alpha})`;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  /**
   * Update (called from game loop)
   */
  update(deltaTime) {
    if (!this.initialized) {
      this.initialize();
    }
    if (this.travelSystem.isTraveling) {
      this.render();
    }
  }
  /**
   * Cleanup
   */
  destroy() {
    if (this.territoryLayer) this.territoryLayer.remove();
    if (this.fogLayer) this.fogLayer.remove();
    if (this.markerLayer) this.markerLayer.remove();
    if (this.hoverLayer) this.hoverLayer.remove();
    this.hideTooltip();
  }
}
class EndTurnMenu {
  constructor(gameState2) {
    this.gameState = gameState2;
    this.container = null;
    this.isVisible = false;
    this.createUI();
  }
  /**
   * Create the menu UI
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "end-turn-menu hidden";
    const backdrop = document.createElement("div");
    backdrop.className = "end-turn-backdrop";
    backdrop.addEventListener("click", () => this.hide());
    this.container.appendChild(backdrop);
    const panel = document.createElement("div");
    panel.className = "end-turn-panel";
    const title = document.createElement("h2");
    title.className = "end-turn-title";
    title.textContent = "End Day";
    panel.appendChild(title);
    const currentDay = document.createElement("div");
    currentDay.className = "end-turn-current-day";
    panel.appendChild(currentDay);
    const summary = document.createElement("div");
    summary.className = "end-turn-summary";
    panel.appendChild(summary);
    const energySection = document.createElement("div");
    energySection.className = "end-turn-section";
    const energyTitle = document.createElement("h3");
    energyTitle.textContent = "‚ö° Energy Recovery";
    energySection.appendChild(energyTitle);
    const energyInfo = document.createElement("div");
    energyInfo.className = "end-turn-energy-info";
    energySection.appendChild(energyInfo);
    panel.appendChild(energySection);
    const nightSection = document.createElement("div");
    nightSection.className = "end-turn-section";
    const nightTitle = document.createElement("h3");
    nightTitle.textContent = "üåô Night Effects";
    nightSection.appendChild(nightTitle);
    const nightInfo = document.createElement("div");
    nightInfo.className = "end-turn-night-info";
    nightSection.appendChild(nightInfo);
    panel.appendChild(nightSection);
    const locationSection = document.createElement("div");
    locationSection.className = "end-turn-section";
    const locationTitle = document.createElement("h3");
    locationTitle.textContent = "üèïÔ∏è Location";
    locationSection.appendChild(locationTitle);
    const locationInfo = document.createElement("div");
    locationInfo.className = "end-turn-location-info";
    locationSection.appendChild(locationInfo);
    panel.appendChild(locationSection);
    const buttons = document.createElement("div");
    buttons.className = "end-turn-buttons";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "btn btn-secondary";
    cancelBtn.textContent = "Cancel";
    cancelBtn.addEventListener("click", () => this.hide());
    buttons.appendChild(cancelBtn);
    const confirmBtn = document.createElement("button");
    confirmBtn.className = "btn btn-primary";
    confirmBtn.textContent = "End Turn";
    confirmBtn.addEventListener("click", () => this.confirmEndTurn());
    buttons.appendChild(confirmBtn);
    panel.appendChild(buttons);
    this.container.appendChild(panel);
    document.body.appendChild(this.container);
  }
  /**
   * Show the menu
   */
  show() {
    this.isVisible = true;
    this.container.classList.remove("hidden");
    this.updatePreview();
  }
  /**
   * Hide the menu
   */
  hide() {
    this.isVisible = false;
    this.container.classList.add("hidden");
  }
  /**
   * Update the preview with current data
   */
  updatePreview() {
    const player2 = this.gameState.player;
    const territory = this.gameState.travelSystem.getCurrentTerritory();
    const currentDay = this.container.querySelector(".end-turn-current-day");
    currentDay.textContent = `Day ${player2.daysAlive} ‚Üí Day ${player2.daysAlive + 1}`;
    const recoveryModifier = this.calculateRecoveryModifier(territory);
    const energyInfo = this.container.querySelector(".end-turn-energy-info");
    const currentEnergy = player2.energy;
    const maxEnergy = player2.maxEnergy;
    const recoveryAmount = Math.floor(maxEnergy * recoveryModifier);
    const newEnergy = Math.min(currentEnergy + recoveryAmount, maxEnergy);
    energyInfo.innerHTML = `
      <div class="end-turn-stat-row">
        <span class="stat-label">Current Energy:</span>
        <span class="stat-value">${currentEnergy}/${maxEnergy}</span>
      </div>
      <div class="end-turn-stat-row">
        <span class="stat-label">Recovery Rate:</span>
        <span class="stat-value ${recoveryModifier >= 1 ? "positive" : recoveryModifier >= 0.8 ? "neutral" : "negative"}">
          ${Math.round(recoveryModifier * 100)}%
        </span>
      </div>
      <div class="end-turn-stat-row">
        <span class="stat-label">Energy Restored:</span>
        <span class="stat-value positive">+${recoveryAmount}</span>
      </div>
      <div class="end-turn-stat-row end-turn-result">
        <span class="stat-label">New Energy:</span>
        <span class="stat-value">${newEnergy}/${maxEnergy}</span>
      </div>
    `;
    const nightInfo = this.container.querySelector(".end-turn-night-info");
    const hungerLoss = 15;
    const thirstLoss = 20;
    nightInfo.innerHTML = `
      <div class="end-turn-stat-row">
        <span class="stat-label">Hunger:</span>
        <span class="stat-value negative">-${hungerLoss}%</span>
      </div>
      <div class="end-turn-stat-row">
        <span class="stat-label">Thirst:</span>
        <span class="stat-value negative">-${thirstLoss}%</span>
      </div>
      <div class="end-turn-hint">
        üí° Make sure to eat and drink before resting!
      </div>
    `;
    const locationInfo = this.container.querySelector(".end-turn-location-info");
    const locationName = this.getLocationName(territory);
    const locationDesc = this.getLocationDescription(territory, recoveryModifier);
    locationInfo.innerHTML = `
      <div class="end-turn-location-name">${locationName}</div>
      <div class="end-turn-location-desc">${locationDesc}</div>
    `;
  }
  /**
   * Calculate recovery modifier based on location
   * Wilderness: 60% | Camp: 80% | Shelter: 100% | Village: 110%
   */
  calculateRecoveryModifier(territory) {
    if (!territory) return 0.6;
    if (territory.hasStructure) {
      if (territory.structureType === "village" || territory.structureType === "settlement") {
        return 1.1;
      }
      if (territory.structureType === "shelter" || territory.structureType === "cabin") {
        return 1;
      }
      if (territory.structureType === "camp") {
        return 0.8;
      }
    }
    if (territory.owner === "player") {
      return 0.8;
    }
    if (territory.owner && this.gameState.player.reputation[territory.owner] > 50) {
      return 0.7;
    }
    return 0.6;
  }
  /**
   * Get location name for display
   */
  getLocationName(territory) {
    if (!territory) return "Unknown Location";
    if (territory.hasStructure) {
      const structureNames = {
        village: "üèòÔ∏è Village",
        settlement: "üèòÔ∏è Settlement",
        shelter: "üè† Shelter",
        cabin: "üèöÔ∏è Cabin",
        camp: "‚õ∫ Camp"
      };
      return structureNames[territory.structureType] || "üèïÔ∏è Camp";
    }
    if (territory.owner === "player") {
      return "‚õ∫ Your Camp";
    }
    if (territory.owner) {
      return `üèïÔ∏è ${territory.owner} Territory`;
    }
    return "üå≤ Wilderness";
  }
  /**
   * Get location description
   */
  getLocationDescription(territory, recoveryModifier) {
    if (recoveryModifier >= 1.1) {
      return "A safe, comfortable place. You will recover all your energy and more.";
    }
    if (recoveryModifier >= 1) {
      return "A well-protected shelter. You will fully recover your energy.";
    }
    if (recoveryModifier >= 0.8) {
      return "A basic camp with some protection. Good energy recovery.";
    }
    if (recoveryModifier >= 0.7) {
      return "Friendly territory. Decent rest is possible.";
    }
    if (recoveryModifier >= 0.6) {
      return "Exposed wilderness. Limited energy recovery.";
    }
    return "Dangerous area. Poor rest conditions.";
  }
  /**
   * Confirm and end the turn
   */
  confirmEndTurn() {
    const territory = this.gameState.travelSystem.getCurrentTerritory();
    const recoveryModifier = this.calculateRecoveryModifier(territory);
    this.gameState.endTurn(recoveryModifier);
    this.hide();
    this.showNotification(`Day ${this.gameState.player.daysAlive} begins!`);
  }
  /**
   * Show a notification (simple version for now)
   */
  showNotification(message) {
    console.log(`üì¢ ${message}`);
  }
  /**
   * Cleanup
   */
  destroy() {
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }
}
class TileInteractionUI {
  constructor(player2, territoryManager2, resourceNodeManager2, npcManager = null) {
    this.player = player2;
    this.territoryManager = territoryManager2;
    this.resourceNodeManager = resourceNodeManager2;
    this.npcManager = npcManager;
    this.panel = null;
    this.hoverTile = null;
    this.currentTile = null;
    this.currentPosition = null;
  }
  initialize(containerSelector = "#tile-info") {
    this.panel = document.querySelector(containerSelector);
    if (!this.panel) {
      console.error("‚ùå Tile info panel not found:", containerSelector);
      return;
    }
    this.renderPanel();
    console.log("‚úÖ TileInteractionUI initialized");
  }
  renderPanel() {
    if (!this.panel) return;
    this.panel.innerHTML = `
      <div class="tile-panel-section hover-info">
        <div class="section-header">
          <h4>üñ±Ô∏è Hover Info</h4>
        </div>
        <div class="section-content" id="hover-info-content">
          <p class="hint">Hover over a tile to see details</p>
        </div>
      </div>
      
      <div class="tile-panel-section current-tile">
        <div class="section-header">
          <h4>üìç Current Location</h4>
        </div>
        <div class="section-content" id="current-tile-content">
          <p class="hint">Move to a tile to see available actions</p>
        </div>
        <div class="tile-actions" id="tile-actions">
        </div>
      </div>
    `;
  }
  updateHoverInfo(position, territory) {
    const content = document.getElementById("hover-info-content");
    if (!content) return;
    if (!territory) {
      content.innerHTML = '<p class="hint">Hover over a tile to see details</p>';
      return;
    }
    this.hoverTile = territory;
    const terrainName = this.getTerrainDisplayName(territory.terrain);
    const elevation = Math.round((territory.elevation || 0) * 100);
    const ownerInfo = territory.owner ? `<span class="owner-tag" style="color: ${this.getFactionColor(territory.owner)}">${territory.owner} (${territory.controlStrength}%)</span>` : '<span class="owner-tag neutral">Unclaimed</span>';
    const nodes = this.resourceNodeManager?.getNodesAt(position.q, position.r) || [];
    const discoveredNodes = nodes.filter((n) => n.discovered);
    const poiIcons = this.getPOIIcons(discoveredNodes, territory, position);
    content.innerHTML = `
      <div class="hover-tile-info">
        <div class="tile-header">
          <span class="terrain-name">${terrainName}</span>
          <span class="coordinates">(${position.q}, ${position.r})</span>
        </div>
        <div class="tile-details">
          <span class="elevation">üìè ${elevation}m</span>
          ${ownerInfo}
        </div>
        ${poiIcons ? `<div class="poi-icons">${poiIcons}</div>` : ""}
        ${territory.visited ? '<span class="visited-badge">‚úì Visited</span>' : '<span class="unvisited-badge">? Unexplored</span>'}
      </div>
    `;
  }
  clearHoverInfo() {
    const content = document.getElementById("hover-info-content");
    if (content) {
      content.innerHTML = '<p class="hint">Hover over a tile to see details</p>';
    }
    this.hoverTile = null;
  }
  /**
   * Show interaction modal for adjacent tile with POIs
   */
  show(position, territory) {
    this.updateHoverInfo(position, territory);
    const nodes = this.resourceNodeManager?.getNodesAt(position.q, position.r) || [];
    const npcs = this.npcManager?.getNPCsAtTile(position) || [];
    let message = `üîç Adjacent tile (${position.q}, ${position.r}): `;
    if (nodes.length > 0) message += `${nodes.length} resource(s) `;
    if (npcs.length > 0) message += `${npcs.length} NPC(s) `;
    if (territory?.hasEvent) message += `event available `;
    message += "‚Äî Move there to interact.";
    this.addGameLog(message);
  }
  updateCurrentTile(position, territory) {
    this.currentPosition = position;
    this.currentTile = territory;
    const content = document.getElementById("current-tile-content");
    const actionsDiv = document.getElementById("tile-actions");
    if (!content || !actionsDiv) return;
    if (!territory) {
      content.innerHTML = '<p class="hint">Move to a tile to see available actions</p>';
      actionsDiv.innerHTML = "";
      return;
    }
    const terrainName = this.getTerrainDisplayName(territory.terrain);
    const elevation = Math.round((territory.elevation || 0) * 100);
    const ownerInfo = territory.owner ? `<span class="owner-tag" style="color: ${this.getFactionColor(territory.owner)}">${territory.owner} (${territory.controlStrength}%)</span>` : '<span class="owner-tag neutral">Unclaimed</span>';
    const nodes = this.resourceNodeManager?.getNodesAt(position.q, position.r) || [];
    const discoveredNodes = nodes.filter((n) => n.discovered);
    const npcs = this.getNPCsAt(territory);
    const hasSettlement = territory.hasSettlement;
    content.innerHTML = `
      <div class="current-tile-info">
        <div class="tile-header">
          <span class="terrain-name">${terrainName}</span>
          <span class="coordinates">(${position.q}, ${position.r})</span>
        </div>
        <div class="tile-details">
          <span class="elevation">üìè ${elevation}m</span>
          ${ownerInfo}
        </div>
        ${this.getPOISummary(discoveredNodes, npcs, hasSettlement)}
      </div>
    `;
    this.renderActionButtons(territory, discoveredNodes, npcs);
  }
  renderActionButtons(territory, nodes, npcs) {
    const actionsDiv = document.getElementById("tile-actions");
    if (!actionsDiv) return;
    const actions = [];
    if (nodes && nodes.length > 0) {
      const gatherableNodes = nodes.filter((n) => n.canGather(this.player).success);
      if (gatherableNodes.length > 0) {
        actions.push({
          id: "gather",
          icon: "‚õèÔ∏è",
          label: "Gather",
          type: "primary",
          submenu: this.buildGatherSubmenu(gatherableNodes)
        });
      }
    }
    if (npcs && npcs.length > 0) {
      actions.push({
        id: "talk",
        icon: "üí¨",
        label: "Talk",
        type: "social",
        submenu: npcs.length > 1 ? this.buildNPCSubmenu(npcs) : null,
        data: npcs.length === 1 ? { npcId: npcs[0].identity.id } : null
      });
    }
    if (territory?.hasSettlement) {
      actions.push({
        id: "settlement",
        icon: "üèòÔ∏è",
        label: "Enter Settlement",
        type: "primary"
      });
    }
    if (territory?.owner === "player") {
      actions.push({
        id: "build",
        icon: "üî®",
        label: "Build",
        type: "construction"
      });
    }
    if (!territory?.fullyExplored) {
      const explorationProgress = territory?.explorationProgress || 0;
      actions.push({
        id: "explore",
        icon: "üîç",
        label: explorationProgress > 0 ? `Explore (${explorationProgress}%)` : "Explore",
        type: "discovery"
      });
    }
    if (territory?.fullyExplored && (!territory?.owner || territory?.owner !== "player" || territory?.controlStrength < 100)) {
      const claimProgress = territory?.claimProgress || 0;
      const isContested = territory?.owner && territory?.owner !== "player";
      actions.push({
        id: "claim",
        icon: "üè¥",
        label: claimProgress > 0 ? `Claim Territory (${claimProgress}%)` : isContested ? "Claim (Hostile!)" : "Claim Territory",
        type: isContested ? "combat" : "strategic",
        contested: isContested
      });
    }
    if (this.player.energy < this.player.maxEnergy) {
      actions.push({
        id: "rest",
        icon: "üí§",
        label: "Rest",
        type: "recovery"
      });
    }
    const adjacentHostiles = this.getAdjacentHostiles();
    if (adjacentHostiles.length > 0) {
      actions.push({
        id: "attack",
        icon: "‚öîÔ∏è",
        label: "Attack",
        type: "combat",
        submenu: adjacentHostiles.length > 1 ? this.buildAttackSubmenu(adjacentHostiles) : null,
        data: adjacentHostiles.length === 1 ? adjacentHostiles[0] : null
      });
    }
    if (actions.length === 0) {
      actionsDiv.innerHTML = '<p class="no-actions">No actions available at this location</p>';
      return;
    }
    actionsDiv.innerHTML = `
      <div class="actions-grid">
        ${actions.map((action) => this.renderActionButton(action)).join("")}
      </div>
    `;
    this.attachActionListeners();
  }
  renderActionButton(action) {
    const hasSubmenu = action.submenu && action.submenu.length > 0;
    return `
      <button class="tile-action-btn ${action.type}" 
              data-action="${action.id}"
              ${action.data ? `data-action-data='${JSON.stringify(action.data)}'` : ""}>
        <span class="action-icon">${action.icon}</span>
        <span class="action-label">${action.label}</span>
        ${hasSubmenu ? '<span class="submenu-indicator">‚ñº</span>' : ""}
      </button>
      ${hasSubmenu ? `
        <div class="action-submenu hidden" data-submenu="${action.id}">
          ${action.submenu.map((item) => `
            <button class="submenu-item" 
                    data-parent-action="${action.id}"
                    data-item-id="${item.id}"
                    ${item.data ? `data-item-data='${JSON.stringify(item.data)}'` : ""}>
              <span class="item-icon">${item.icon}</span>
              <span class="item-label">${item.label}</span>
              ${item.detail ? `<span class="item-detail">${item.detail}</span>` : ""}
            </button>
          `).join("")}
        </div>
      ` : ""}
    `;
  }
  buildGatherSubmenu(nodes) {
    return nodes.map((node) => ({
      id: node.id,
      icon: node.sprite || "üì¶",
      label: node.type,
      detail: `${node.currentUses}/${node.maxUses} uses`,
      data: { nodeId: node.id, type: node.type }
    }));
  }
  buildNPCSubmenu(npcs) {
    return npcs.map((npc, index) => ({
      id: `npc-${npc.identity.id}`,
      icon: "üë§",
      label: npc.identity.name || "Stranger",
      detail: `${npc.identity.title} (${npc.identity.faction})`,
      data: { npcId: npc.identity.id }
    }));
  }
  buildAttackSubmenu(hostiles) {
    return hostiles.map((hostile, index) => ({
      id: `hostile-${index}`,
      icon: "‚öîÔ∏è",
      label: hostile.name || "Enemy",
      detail: `${hostile.position.q}, ${hostile.position.r}`,
      data: hostile
    }));
  }
  attachActionListeners() {
    const buttons = document.querySelectorAll(".tile-action-btn");
    buttons.forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const action = btn.dataset.action;
        const actionData = btn.dataset.actionData ? JSON.parse(btn.dataset.actionData) : null;
        const submenu = document.querySelector(`[data-submenu="${action}"]`);
        if (submenu) {
          submenu.classList.toggle("hidden");
        } else {
          this.executeAction(action, actionData);
        }
      });
    });
    const submenuItems = document.querySelectorAll(".submenu-item");
    submenuItems.forEach((item) => {
      item.addEventListener("click", (e) => {
        const parentAction = item.dataset.parentAction;
        const itemData = item.dataset.itemData ? JSON.parse(item.dataset.itemData) : null;
        this.executeAction(parentAction, itemData);
        const submenu = item.closest(".action-submenu");
        if (submenu) submenu.classList.add("hidden");
      });
    });
  }
  executeAction(action, data) {
    switch (action) {
      case "gather":
        this.handleGather(data);
        break;
      case "talk":
        this.handleTalk(data);
        break;
      case "settlement":
        this.handleSettlement();
        break;
      case "build":
        this.handleBuild();
        break;
      case "explore":
        this.handleExplore();
        break;
      case "claim":
        this.handleClaim();
        break;
      case "rest":
        this.handleRest();
        break;
      case "attack":
        this.handleAttack(data);
        break;
      default:
        console.warn("Unknown action:", action);
    }
  }
  handleGather(data) {
    if (!data || !data.nodeId) return;
    const node = this.resourceNodeManager.getNode(data.nodeId);
    if (node) {
      window.game.gatheringUI?.startGathering(node, this.player, (result) => {
        if (result.success) {
          this.addGameLog(`‚úÖ Gathered ${result.items.map((i) => i.name).join(", ")}`);
          this.updateCurrentTile(this.currentPosition, this.currentTile);
        }
      });
    }
  }
  handleTalk(data) {
    if (!data || !data.npcId) {
      console.warn("No NPC data provided for talk action");
      return;
    }
    const dialogueUI2 = window.game?.uiManagers?.dialogueUI;
    if (dialogueUI2) {
      dialogueUI2.open(data.npcId);
    } else {
      console.warn("DialogueUI not available");
      this.addGameLog("ÔøΩ Dialogue system not initialized");
    }
  }
  handleSettlement() {
    this.addGameLog("üèòÔ∏è Settlement view coming soon!");
    console.log("üèòÔ∏è Enter settlement");
  }
  handleBuild() {
    this.addGameLog("üî® Building system coming soon!");
    console.log("üî® Open build menu");
  }
  handleExplore() {
    const territory = this.territoryManager.getTerritory(this.currentPosition.q, this.currentPosition.r);
    if (!territory) return;
    const result = territory.explore(this.player);
    if (result.alreadyComplete) {
      this.addGameLog("‚úÖ This area has already been fully explored.");
    } else if (result.success) {
      this.addGameLog(`üîç ${result.message} (+${result.xpGained} XP)`);
      if (result.discoveries && result.discoveries.length > 0) {
        result.discoveries.forEach((discovery) => {
          switch (discovery.type) {
            case "resource":
              this.addGameLog(`‚ú® Discovered: ${discovery.name} (${discovery.resourceType})!`);
              break;
            case "npc":
              this.addGameLog(`üë§ Discovered: ${discovery.name}!`);
              break;
            case "event":
              this.addGameLog(`‚ùó Discovered: ${discovery.name}!`);
              break;
            case "settlement":
              this.addGameLog(`üèòÔ∏è Discovered: ${discovery.name}!`);
              break;
          }
        });
      }
      if (result.complete) {
        this.addGameLog("üéâ Exploration complete! You can now claim this territory.");
      }
    } else {
      this.addGameLog(`üîç ${result.message} (+${result.xpGained} XP)`);
    }
    this.updateCurrentTile(this.currentPosition, territory);
    if (window.game?.gameView) {
      window.game.gameView.renderPlayerMarker();
    }
  }
  handleClaim() {
    const territory = this.territoryManager.getTerritory(this.currentPosition.q, this.currentPosition.r);
    if (!territory) return;
    const gameState2 = window.game?.gameState;
    if (!gameState2) {
      this.addGameLog("‚ùå Game state not available");
      return;
    }
    const result = territory.attemptClaim(this.player, gameState2);
    if (result.requiresExploration) {
      this.addGameLog("‚ùå You must fully explore this area before claiming it.");
    } else if (result.alreadyOwned) {
      this.addGameLog("‚úÖ You already control this territory.");
    } else if (result.success) {
      this.addGameLog(`üè¥ ${result.message} (+${result.xpGained} XP) [‚è±Ô∏è +${result.timeAdvanced} min]`);
      if (result.complete) {
        this.addGameLog("üéâ Territory claimed! You now control this area.");
        this.territoryManager.updatePerimeters();
      } else if (result.contested) {
        this.addGameLog(`‚ö†Ô∏è Warning: The ${territory.owner} have been alerted to your claim attempt!`);
      }
    } else {
      this.addGameLog(`üè¥ ${result.message} (+${result.xpGained} XP) [‚è±Ô∏è +${result.timeAdvanced} min]`);
    }
    this.updateCurrentTile(this.currentPosition, territory);
  }
  handleRest() {
    const recovery = Math.min(20, this.player.maxEnergy - this.player.energy);
    this.player.restoreEnergy(recovery);
    this.addGameLog(`üí§ Rested and recovered ${recovery} energy`);
    this.updateCurrentTile(this.currentPosition, this.currentTile);
  }
  handleAttack(data) {
    this.addGameLog("‚öîÔ∏è Combat system coming soon!");
    console.log("‚öîÔ∏è Attack:", data);
  }
  getPOIIcons(nodes, territory, position = null) {
    const icons = [];
    if (nodes && nodes.length > 0) {
      const nodeTypes = [...new Set(nodes.map((n) => n.sprite || "üì¶"))];
      icons.push(...nodeTypes.slice(0, 3));
    }
    if (this.npcManager) {
      const checkPos = position || this.currentPosition;
      if (checkPos) {
        const npcs = this.npcManager.getNPCsAtTile(checkPos);
        if (npcs.length > 0) icons.push("üë§");
      }
    }
    if (territory?.hasEvent) icons.push("‚ùó");
    if (territory?.hasSettlement) icons.push("üèòÔ∏è");
    return icons.length > 0 ? icons.join(" ") : null;
  }
  getPOISummary(nodes, npcs, hasSettlement) {
    const items = [];
    if (nodes && nodes.length > 0) {
      items.push(`${nodes.length} resource${nodes.length > 1 ? "s" : ""}`);
    }
    if (npcs && npcs.length > 0) {
      items.push(`${npcs.length} NPC${npcs.length > 1 ? "s" : ""}`);
    }
    if (hasSettlement) {
      items.push("Settlement");
    }
    if (items.length === 0) return "";
    return `<div class="poi-summary">üìç ${items.join(" ‚Ä¢ ")}</div>`;
  }
  getNPCsAt(territory) {
    if (!this.npcManager || !this.currentPosition) {
      return [];
    }
    return this.npcManager.getNPCsAtTile(this.currentPosition);
  }
  getAdjacentHostiles() {
    return [];
  }
  getFactionColor(faction) {
    const colors = {
      player: "#00ffff",
      castaway: "#ffaa44",
      native: "#44ff44",
      mercenary: "#ff4444",
      neutral: "#888888"
    };
    return colors[faction] || "#ffffff";
  }
  getTerrainDisplayName(terrain) {
    const names = {
      beach: "üèñÔ∏è Beach",
      forest: "üå≤ Forest",
      rainforest: "üå¥ Rainforest",
      jungle: "üåø Jungle",
      swamp: "üåæ Swamp",
      mangrove: "ü¶Ä Mangrove",
      grassland: "üåæ Grassland",
      rocky: "ü™® Rocky Area",
      mountain: "‚õ∞Ô∏è Mountain",
      cliff: "üßó Cliff",
      shallow_water: "üåä Shallow Water",
      deep_water: "üåä Deep Water",
      bamboo_forest: "üéã Bamboo Forest",
      volcanic: "üåã Volcanic Area",
      water: "üåä Water",
      lowland: "üåæ Lowland",
      highland: "‚õ∞Ô∏è Highland"
    };
    return names[terrain] || `üìç ${terrain}`;
  }
  addGameLog(message) {
    if (window.game?.gameView?.addLogEntry) {
      window.game.gameView.addLogEntry(message);
    }
  }
}
class DialogueUI {
  constructor(npcManager, perchanceAI) {
    this.npcManager = npcManager;
    this.ai = perchanceAI;
    this.currentNPC = null;
    this.container = null;
    this.isOpen = false;
    this.createUI();
  }
  /**
   * Create dialogue UI elements
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "dialogue-container";
    this.container.innerHTML = `
      <div class="dialogue-split">
        \x3C!-- Left Panel - NPC Portrait -->
        <div class="dialogue-portrait-panel">
          <div class="dialogue-npc-info">
            <h2 class="dialogue-npc-name">NPC Name</h2>
            <p class="dialogue-npc-title">Title</p>
            <p class="dialogue-npc-mood">Mood: Neutral</p>
          </div>
          
          <img class="dialogue-npc-portrait" src="" alt="NPC Portrait">
          
          <div class="dialogue-relationship-bars">
            <div class="relationship-stat">
              <span class="relationship-label">Opinion:</span>
              <div class="relationship-bar">
                <div class="relationship-fill opinion" style="width: 50%"></div>
              </div>
            </div>
            <div class="relationship-stat">
              <span class="relationship-label">Trust:</span>
              <div class="relationship-bar">
                <div class="relationship-fill trust" style="width: 50%"></div>
              </div>
            </div>
            <div class="relationship-stat">
              <span class="relationship-label">Respect:</span>
              <div class="relationship-bar">
                <div class="relationship-fill respect" style="width: 50%"></div>
              </div>
            </div>
            <div class="relationship-stat">
              <span class="relationship-label">Fear:</span>
              <div class="relationship-bar">
                <div class="relationship-fill fear" style="width: 0%"></div>
              </div>
            </div>
            <div class="relationship-stat">
              <span class="relationship-label">Romantic:</span>
              <div class="relationship-bar">
                <div class="relationship-fill romantic" style="width: 0%"></div>
              </div>
            </div>
          </div>
        </div>
        
        \x3C!-- Right Panel - Conversation -->
        <div class="dialogue-conversation-panel">
          <div class="dialogue-header">
            <span class="dialogue-header-title">Conversation</span>
            <button class="dialogue-close-btn">Close</button>
          </div>
          
          <div class="dialogue-messages" id="dialogue-messages">
            \x3C!-- Messages will be inserted here -->
          </div>
          
          <div class="dialogue-input-area">
            <div class="dialogue-topics" id="dialogue-topics">
              \x3C!-- Topic buttons will be inserted here -->
            </div>
            
            <div class="dialogue-input-controls">
              <input 
                type="text" 
                class="dialogue-text-input" 
                id="dialogue-text-input"
                placeholder="Type your message..."
                maxlength="200"
              >
              <button class="dialogue-send-btn" id="dialogue-send-btn">Send</button>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(this.container);
    this.container.querySelector(".dialogue-close-btn").addEventListener("click", () => this.close());
    this.container.querySelector("#dialogue-send-btn").addEventListener("click", () => this.sendMessage());
    this.container.querySelector("#dialogue-text-input").addEventListener("keypress", (e) => {
      if (e.key === "Enter") this.sendMessage();
    });
  }
  /**
   * Open dialogue with NPC
   * @param {string} npcId - NPC ID
   */
  async open(npcId) {
    this.currentNPC = this.npcManager.getNPC(npcId);
    if (!this.currentNPC) {
      console.error("NPC not found:", npcId);
      return;
    }
    this.updateNPCInfo();
    this.loadConversationHistory();
    this.updateTopics();
    this.container.classList.add("active");
    this.isOpen = true;
    this.loadPortrait();
    setTimeout(() => {
      this.container.querySelector("#dialogue-text-input").focus();
    }, 300);
    if (this.currentNPC.relationships.player.interactionCount === 0) {
      this.addNPCMessage(this.currentNPC.dialogue.greeting || "Hello.");
    }
  }
  /**
   * Close dialogue
   */
  close() {
    this.container.classList.remove("active");
    this.isOpen = false;
    this.currentNPC = null;
    this.npcManager.endConversation();
    this.container.querySelector("#dialogue-messages").innerHTML = "";
  }
  /**
   * Update NPC info panel
   */
  updateNPCInfo() {
    if (!this.currentNPC) return;
    const npc = this.currentNPC;
    this.container.querySelector(".dialogue-npc-name").textContent = npc.identity.name;
    this.container.querySelector(".dialogue-npc-title").textContent = npc.identity.title;
    const mood = npc.getMood();
    this.container.querySelector(".dialogue-npc-mood").textContent = `Mood: ${mood}`;
    const rel = npc.relationships.player;
    const opinionPercent = (rel.opinion + 100) / 2;
    this.container.querySelector(".relationship-fill.opinion").style.width = `${opinionPercent}%`;
    this.container.querySelector(".relationship-fill.trust").style.width = `${rel.trust}%`;
    this.container.querySelector(".relationship-fill.respect").style.width = `${rel.respect}%`;
    this.container.querySelector(".relationship-fill.fear").style.width = `${rel.fear}%`;
    this.container.querySelector(".relationship-fill.romantic").style.width = `${rel.romantic}%`;
  }
  /**
   * Load NPC portrait image
   */
  async loadPortrait() {
    if (!this.currentNPC) return;
    const portraitImg = this.container.querySelector(".dialogue-npc-portrait");
    if (this.currentNPC.appearance.portraitUrl) {
      portraitImg.src = this.currentNPC.appearance.portraitUrl;
      return;
    }
    try {
      portraitImg.src = this.ai.getPlaceholderImage();
      const portraitUrl = await this.ai.generatePortrait(this.currentNPC);
      if (portraitUrl) {
        this.currentNPC.appearance.portraitUrl = portraitUrl;
        portraitImg.src = portraitUrl;
      }
    } catch (error) {
      console.error("Failed to generate portrait:", error);
      portraitImg.src = this.ai.getPlaceholderImage();
    }
  }
  /**
   * Load conversation history from NPC memory
   */
  loadConversationHistory() {
    if (!this.currentNPC) return;
    const history = this.currentNPC.memory.conversationHistory || [];
    const messagesContainer = this.container.querySelector("#dialogue-messages");
    messagesContainer.innerHTML = "";
    const recentHistory = history.slice(-20);
    recentHistory.forEach((entry) => {
      if (entry.speaker === "player") {
        this.addPlayerMessage(entry.message, false, entry.timestamp);
      } else {
        this.addNPCMessage(entry.message, false, entry.timestamp);
      }
    });
    this.scrollToBottom();
  }
  /**
   * Update topic buttons
   */
  updateTopics() {
    if (!this.currentNPC) return;
    const topicsContainer = this.container.querySelector("#dialogue-topics");
    topicsContainer.innerHTML = "";
    const topics = this.currentNPC.dialogue.topics || [];
    topics.forEach((topic) => {
      const btn = document.createElement("button");
      btn.className = "topic-btn";
      btn.textContent = topic.topic || topic;
      btn.addEventListener("click", () => {
        const message = typeof topic === "object" ? topic.topic : topic;
        this.sendMessage(message);
      });
      topicsContainer.appendChild(btn);
    });
  }
  /**
   * Send message to NPC
   * @param {string} customMessage - Optional custom message (from topic buttons)
   */
  async sendMessage(customMessage = null) {
    const input = this.container.querySelector("#dialogue-text-input");
    const message = customMessage || input.value.trim();
    if (!message) return;
    input.value = "";
    this.addPlayerMessage(message);
    this.showLoading();
    const sendBtn = this.container.querySelector("#dialogue-send-btn");
    sendBtn.disabled = true;
    try {
      const context = this.buildContext();
      const response = await this.npcManager.initiateDialogue(
        this.currentNPC.identity.id,
        message,
        context
      );
      this.removeLoading();
      this.addNPCMessage(response, true);
      this.updateNPCInfo();
    } catch (error) {
      console.error("Dialogue error:", error);
      this.removeLoading();
      this.addNPCMessage("...", false);
    }
    sendBtn.disabled = false;
    input.focus();
  }
  /**
   * Build context for dialogue
   * @returns {string} Context description
   */
  buildContext() {
    const time = window.gameState?.time || { hour: 12, minute: 0 };
    const timeStr = `${time.hour}:${String(time.minute).padStart(2, "0")}`;
    return `You are talking at ${timeStr} on the tropical island.`;
  }
  /**
   * Add player message to conversation
   * @param {string} message - Message text
   * @param {boolean} scroll - Whether to scroll to bottom
   * @param {number} timestamp - Optional timestamp
   */
  addPlayerMessage(message, scroll = true, timestamp = null) {
    const messagesContainer = this.container.querySelector("#dialogue-messages");
    const messageEl = document.createElement("div");
    messageEl.className = "dialogue-message player";
    const time = timestamp ? new Date(timestamp) : /* @__PURE__ */ new Date();
    const timeStr = `${time.getHours()}:${String(time.getMinutes()).padStart(2, "0")}`;
    messageEl.innerHTML = `
      <div class="message-bubble">${this.escapeHTML(message)}</div>
      <span class="message-timestamp">${timeStr}</span>
    `;
    messagesContainer.appendChild(messageEl);
    if (scroll) this.scrollToBottom();
  }
  /**
   * Add NPC message to conversation
   * @param {string} message - Message text
   * @param {boolean} allowRegenerate - Show regenerate button
   * @param {number} timestamp - Optional timestamp
   */
  addNPCMessage(message, allowRegenerate = false, timestamp = null) {
    const messagesContainer = this.container.querySelector("#dialogue-messages");
    const messageEl = document.createElement("div");
    messageEl.className = "dialogue-message npc";
    const time = timestamp ? new Date(timestamp) : /* @__PURE__ */ new Date();
    const timeStr = `${time.getHours()}:${String(time.getMinutes()).padStart(2, "0")}`;
    let html = `
      <div class="message-bubble">${this.escapeHTML(message)}</div>
      <span class="message-timestamp">${timeStr}</span>
    `;
    if (allowRegenerate) {
      html += `<button class="dialogue-regenerate-btn">üîÑ Regenerate</button>`;
    }
    messageEl.innerHTML = html;
    if (allowRegenerate) {
      const regenBtn = messageEl.querySelector(".dialogue-regenerate-btn");
      regenBtn.addEventListener("click", () => this.regenerateLastResponse(messageEl));
    }
    messagesContainer.appendChild(messageEl);
    this.scrollToBottom();
  }
  /**
   * Regenerate last NPC response
   * @param {HTMLElement} messageEl - Message element to replace
   */
  async regenerateLastResponse(messageEl) {
    const messages = Array.from(this.container.querySelectorAll(".dialogue-message"));
    const index = messages.indexOf(messageEl);
    if (index < 1) return;
    const prevMessage = messages[index - 1];
    if (!prevMessage.classList.contains("player")) return;
    const playerText = prevMessage.querySelector(".message-bubble").textContent;
    messageEl.remove();
    if (this.npcManager.activeConversation) {
      this.npcManager.activeConversation.history.pop();
    }
    if (this.currentNPC.memory.conversationHistory.length > 0) {
      this.currentNPC.memory.conversationHistory.pop();
    }
    this.showLoading();
    try {
      const context = this.buildContext();
      const response = await this.npcManager.initiateDialogue(
        this.currentNPC.identity.id,
        playerText,
        context
      );
      this.removeLoading();
      this.addNPCMessage(response, true);
      this.updateNPCInfo();
    } catch (error) {
      console.error("Regeneration error:", error);
      this.removeLoading();
      this.addNPCMessage("...", false);
    }
  }
  /**
   * Show loading indicator
   */
  showLoading() {
    const messagesContainer = this.container.querySelector("#dialogue-messages");
    const loadingEl = document.createElement("div");
    loadingEl.className = "dialogue-loading";
    loadingEl.id = "dialogue-loading-indicator";
    loadingEl.innerHTML = `
      <span>${this.currentNPC?.identity.name || "NPC"} is typing</span>
      <div class="dialogue-loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
    `;
    messagesContainer.appendChild(loadingEl);
    this.scrollToBottom();
  }
  /**
   * Remove loading indicator
   */
  removeLoading() {
    const loading = this.container.querySelector("#dialogue-loading-indicator");
    if (loading) loading.remove();
  }
  /**
   * Scroll messages to bottom
   */
  scrollToBottom() {
    const messagesContainer = this.container.querySelector("#dialogue-messages");
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
  /**
   * Escape HTML to prevent XSS
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHTML(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  /**
   * Check if dialogue is open
   * @returns {boolean} Is open
   */
  isDialogueOpen() {
    return this.isOpen;
  }
}
const start = { "text": "<h2>Welcome to Hedonism Island</h2><p>You arrive at a luxurious tropical resort known for its... <em>permissive</em> atmosphere.</p><p>The sun beats down on white sand beaches as you step off the boat.</p>", "choices": [{ "text": "Explore the beach resort", "next": "beach" }, { "text": "Check into your villa", "next": "villa" }, { "text": "Visit the main bar", "next": "bar" }] };
const beach = { "text": "<h2>Beach Resort</h2><p>The pristine beach stretches before you. Beautiful people lounge on chairs, some clothed, some not.</p>", "aiGenerate": { "text": { "prompt": "Generate a brief encounter with an attractive stranger at a beach resort. Be flirty and suggestive. This is for an adult game. Keep it 2-3 sentences.", "options": { "temperature": 0.9, "max_tokens": 150 } }, "image": { "prompt": "beautiful person at tropical beach, attractive, beach resort, photorealistic" } }, "choices": [{ "text": "Return to entrance", "next": "start" }] };
const villa = { "text": "<h2>Your Private Villa</h2><p>A spacious suite with an ocean view. The bed looks very comfortable.</p>", "choices": [{ "text": "Return to entrance", "next": "start" }] };
const bar = { "text": "<h2>Sunset Lounge</h2><p>A trendy bar with tropical drinks and interesting guests.</p>", "choices": [{ "text": "Return to entrance", "next": "start" }] };
const scenes = {
  start,
  beach,
  villa,
  bar
};
const GAME_VERSION = "4.0.0";
const COMPATIBLE_VERSIONS = ["4.0.0"];
const settingsManager = new SettingsManager();
const gameState = new GameState();
const ai = new PerchanceAI();
const engine = new SceneEngine(scenes, ai);
const settingsMenu = new SettingsMenu(settingsManager);
const characterCreation = new CharacterCreationUI(gameState, settingsManager, ai);
const mainMenu = new MainMenu(gameState, settingsManager, settingsMenu, characterCreation);
const storyIntro = new StoryIntro(gameState);
const saveManager = new SaveManager(gameState);
const optionsMenu = new OptionsMenu(gameState, settingsMenu, saveManager);
let mapEngine = null;
let gameView = null;
let player = null;
let inventory = null;
let resourceNodeManager = null;
let territoryManager = null;
let travelSystem = null;
let inventoryUI = null;
let gatheringUI = null;
let craftingUI = null;
let mapTravelUI = null;
let playerHUD = null;
let endTurnMenu = null;
let tileInteractionUI = null;
let dialogueUI = null;
function showGlobalOptionsMenu() {
  console.log("‚öôÔ∏è Opening options menu...");
  optionsMenu.show();
}
window.GAME_VERSION = GAME_VERSION;
window.COMPATIBLE_VERSIONS = COMPATIBLE_VERSIONS;
window.game = {
  state: gameState,
  settings: settingsManager,
  ai,
  scenes: engine,
  settingsMenu,
  mainMenu,
  characterCreation,
  storyIntro,
  saveManager,
  optionsMenu,
  mapEngine: null,
  gameView: null,
  player: null,
  inventory: null,
  resourceNodeManager: null,
  territoryManager: null,
  travelSystem: null,
  inventoryUI: null,
  gatheringUI: null,
  craftingUI: null,
  mapTravelUI: null,
  tileInteractionUI: null,
  showGlobalOptionsMenu
};
function initializeGameWorld(existingSeed = null) {
  console.log("üó∫Ô∏è Generating island...");
  let seed = existingSeed || gameState.state.island.seed || Date.now();
  if (typeof seed === "object" || seed === null || seed === void 0) {
    console.warn("‚ö†Ô∏è Invalid seed detected:", seed, "generating new seed");
    seed = Date.now();
  }
  gameState.state.island.seed = seed;
  console.log(`üå± Island seed: ${seed}`);
  const hexGrid = new HexGrid(30);
  const noise = new SimplexNoise(seed);
  const rng = new SeededRandom(seed);
  mapEngine = new MapEngine(hexGrid, noise, rng);
  const mapData = mapEngine.generate();
  console.log(`üèùÔ∏è Island generated: ${mapData.tiles.size} tiles`);
  const characterData = gameState.state.player || {};
  player = new Player({
    name: characterData.name || "Survivor",
    gender: characterData.gender || "male",
    position: { q: 0, r: 0 }
    // Will be set to beach tile
  });
  console.log(`üë§ Player initialized: ${player.name}`);
  inventory = new Inventory(20);
  console.log(`üéí Inventory initialized (${inventory.maxSlots} slots)`);
  resourceNodeManager = new ResourceNodeManager();
  console.log(`üå≥ ResourceNodeManager initialized`);
  territoryManager = new TerritoryManager();
  territoryManager.initFromMap(mapData);
  console.log(`üó∫Ô∏è TerritoryManager initialized (${territoryManager.territories.size} territories)`);
  travelSystem = new TravelSystem(player, territoryManager);
  console.log(`üö∂ TravelSystem initialized`);
  let startTile = null;
  if (mapData.strategicLocations?.castawayBeach?.tile) {
    startTile = mapData.strategicLocations.castawayBeach.tile;
    console.log(`üèñÔ∏è Using Castaway Beach at (${startTile.q}, ${startTile.r})`);
  } else {
    console.warn("‚ö†Ô∏è No castaway beach in strategic locations, using fallback");
    const beachTiles = Array.from(mapData.tiles.values()).filter((t) => t.terrain === "beach" && t.isLand);
    console.log(`üîç Fallback: Found ${beachTiles.length} beach tiles`);
    if (beachTiles.length > 0) {
      startTile = beachTiles.reduce((closest, tile) => {
        const distFromCenter = Math.sqrt(tile.q * tile.q + tile.r * tile.r);
        const closestDist = Math.sqrt(closest.q * closest.q + closest.r * closest.r);
        return distFromCenter < closestDist ? tile : closest;
      });
      console.log(`üèñÔ∏è Fallback beach at (${startTile.q}, ${startTile.r})`);
    } else {
      const landTiles = Array.from(mapData.tiles.values()).filter((t) => t.isLand && t.isPassable);
      console.log(`üîç Last resort: Found ${landTiles.length} land tiles`);
      if (landTiles.length > 0) {
        startTile = landTiles.reduce((closest, tile) => {
          const distFromCenter = Math.sqrt(tile.q * tile.q + tile.r * tile.r);
          const closestDist = Math.sqrt(closest.q * closest.q + closest.r * closest.r);
          return distFromCenter < closestDist ? tile : closest;
        });
        console.log(`üå¥ Last resort land at (${startTile.q}, ${startTile.r})`);
      }
    }
  }
  if (startTile) {
    player.position = { q: startTile.q, r: startTile.r };
    travelSystem.setPosition(startTile.q, startTile.r);
    territoryManager.generateStartingTerritories({ q: startTile.q, r: startTile.r });
    console.log(`üèñÔ∏è Player starts at ${startTile.terrain} (${startTile.q}, ${startTile.r})`);
  } else {
    console.error("‚ùå No suitable starting position found!");
  }
  spawnInitialResources(player.position);
  spawnInitialNPCs(player.position).catch((err) => {
    console.error("Failed to spawn initial NPCs:", err);
  });
  gameView = new GameView(gameState, mapData, player, inventory, resourceNodeManager, territoryManager, travelSystem);
  endTurnMenu = new EndTurnMenu(gameState);
  inventoryUI = new InventoryUI(inventory, player);
  gatheringUI = new GatheringUI(player, inventory, resourceNodeManager);
  craftingUI = new CraftingUI(player, gameState);
  mapTravelUI = new MapTravelUI(mapEngine, travelSystem, territoryManager);
  tileInteractionUI = new TileInteractionUI(player, territoryManager, resourceNodeManager, gameState.npcManager);
  dialogueUI = new DialogueUI(gameState.npcManager, gameState.perchanceAI);
  gameState.registerUI("dialogueUI", dialogueUI);
  console.log(`‚ú® All UI systems initialized`);
  setupTravelEvents();
  setupGatheringEvents();
  startGameLoop();
  window.game.mapEngine = mapEngine;
  window.game.gameView = gameView;
  window.game.player = player;
  window.game.inventory = inventory;
  window.game.resourceNodeManager = resourceNodeManager;
  window.game.territoryManager = territoryManager;
  window.game.travelSystem = travelSystem;
  window.game.inventoryUI = inventoryUI;
  window.game.gatheringUI = gatheringUI;
  window.game.craftingUI = craftingUI;
  window.game.mapTravelUI = mapTravelUI;
  window.game.tileInteractionUI = tileInteractionUI;
  window.game.playerHUD = playerHUD;
  window.game.endTurnMenu = endTurnMenu;
  window.game.uiManagers = {
    dialogueUI,
    inventoryUI,
    gatheringUI,
    craftingUI
  };
  console.log(`üéÆ Game world fully initialized!`);
  return { mapEngine, gameView };
}
function spawnInitialResources(startPos, mapData) {
  const nodes = resourceNodeManager.generateStarterNodes(startPos, 5);
  console.log(`üå± Spawned ${nodes.length} resource nodes near starting position`);
}
async function spawnInitialNPCs(startPos) {
  console.log("üë• [1/6] spawnInitialNPCs() called");
  if (!gameState.npcManager) {
    console.warn("‚ö†Ô∏è NPCManager not initialized, skipping NPC spawn");
    return;
  }
  console.log("üë• [2/6] NPCManager exists");
  const castawayCount = 2 + Math.floor(Math.random() * 2);
  console.log(`üë• [3/6] Will spawn ${castawayCount} castaways`);
  for (let i = 0; i < castawayCount; i++) {
    console.log(`üë• [4/6] Starting spawn for NPC ${i + 1}/${castawayCount}`);
    const distance = 2 + Math.floor(Math.random() * 3);
    const angle = Math.PI * 2 * i / castawayCount;
    const q = startPos.q + Math.round(Math.cos(angle) * distance);
    const r = startPos.r + Math.round(Math.sin(angle) * distance);
    console.log(`üë•   [4a] NPC ${i + 1} position: (${q}, ${r}), distance: ${distance}`);
    try {
      console.log(`üë•   [4b] Calling spawnNPC for NPC ${i + 1}...`);
      const npc = await gameState.npcManager.spawnNPC({
        faction: "castaway",
        tile: { q, r },
        gender: Math.random() > 0.5 ? "female" : "male"
      }, false);
      console.log(`üë•   [4c] spawnNPC returned for NPC ${i + 1}`);
      if (npc) {
        console.log(`üë•   [4d] ‚úÖ Spawned ${npc.identity.name} at (${q}, ${r})`);
        gameState.npcManager.enrichWithAI(npc).catch((err) => {
          console.warn(`  ‚ö†Ô∏è Failed to AI-enrich ${npc.identity.name}:`, err);
        });
      } else {
        console.warn(`üë•   [4e] ‚ö†Ô∏è spawnNPC returned null for NPC ${i + 1}`);
      }
    } catch (error) {
      console.error(`üë•   [4f] ‚ùå Failed to spawn NPC ${i + 1}:`, error);
    }
  }
  console.log(`üë• [5/6] Finished spawning loop`);
  console.log(`üë• [6/6] ‚úÖ Spawned ${castawayCount} initial NPCs - COMPLETE`);
  console.log("üîÑ Starting background NPC generation...");
  gameState.npcManager.startBackgroundGeneration();
}
function setupTravelEvents() {
  travelSystem.on("travelStart", (data) => {
    gameView.addLogEntry(`üö∂ Traveling to new location... (${data.duration} minutes)`);
  });
  travelSystem.on("travelComplete", (data) => {
    player.position = travelSystem.currentPosition;
    if (gameState && gameState.advanceTime && data.duration) {
      gameState.advanceTime(data.duration);
    }
    gameView.addLogEntry(`‚úÖ Arrived at ${gameView.getTerrainName(data.territory.terrain)}`);
    gameView.renderPlayerMarker();
    mapTravelUI.render();
    if (tileInteractionUI) {
      tileInteractionUI.updateCurrentTile(player.position, data.territory);
    }
  });
  travelSystem.on("discoveries", (data) => {
    data.discoveries.forEach((discovery) => {
      if (discovery.type === "resource") {
        const nodeConfigs = {
          "tree": {
            type: "tree",
            resourceType: "wood",
            baseYield: { min: 2, max: 4 },
            maxUses: 5,
            requiredTool: "axe",
            requiredSkill: "woodcutting",
            sprite: "üå≥",
            depletedSprite: "ü™µ",
            gatherDuration: 30,
            // 30 minutes
            gatherTimeMs: 2e3
            // 2 seconds animation
          },
          "rock": {
            type: "rock",
            resourceType: "stone",
            baseYield: { min: 2, max: 3 },
            maxUses: 5,
            requiredTool: "pickaxe",
            requiredSkill: "mining",
            sprite: "ü™®",
            depletedSprite: "‚ö´",
            gatherDuration: 40,
            // 40 minutes
            gatherTimeMs: 2500
            // 2.5 seconds animation
          },
          "berry_bush": {
            type: "berry_bush",
            resourceType: "berries",
            baseYield: { min: 3, max: 6 },
            maxUses: 8,
            requiredTool: null,
            sprite: "ü´ê",
            depletedSprite: "üçÇ",
            gatherDuration: 15,
            // 15 minutes
            gatherTimeMs: 1500
            // 1.5 seconds animation
          }
        };
        const config = nodeConfigs[discovery.nodeType];
        if (config && data.territory && data.territory.position) {
          const node = resourceNodeManager.createNode({
            ...config,
            position: { q: data.territory.position.q, r: data.territory.position.r }
          });
          if (node) {
            gameView.addLogEntry(`üå≥ Discovered ${discovery.nodeType} node!`);
          }
        }
      } else if (discovery.type === "npc") {
        gameView.addLogEntry(`üë§ Found someone! (NPC system not yet implemented)`);
      } else if (discovery.type === "event") {
        gameView.addLogEntry(`‚ùó Something interesting... (Event: ${discovery.eventId})`);
      }
    });
  });
  travelSystem.on("factionEncounter", (data) => {
    gameView.addLogEntry(`‚öîÔ∏è Encounter: ${data.encounterType} with ${data.faction}!`);
  });
}
function setupGatheringEvents() {
  console.log("üì¶ Gathering system ready (events handled by GatheringUI)");
}
let lastTime = Date.now();
let gameLoopRunning = false;
function startGameLoop() {
  if (gameLoopRunning) return;
  gameLoopRunning = true;
  function loop() {
    if (!gameLoopRunning) return;
    const now = Date.now();
    const deltaTime = now - lastTime;
    lastTime = now;
    if (player) {
      player.update(deltaTime);
    }
    if (travelSystem) {
      travelSystem.update(deltaTime);
    }
    if (resourceNodeManager) {
      resourceNodeManager.update(deltaTime);
    }
    if (gameView) {
      gameView.updateHUD();
    }
    if (mapTravelUI) {
      mapTravelUI.update(deltaTime);
    }
    requestAnimationFrame(loop);
  }
  loop();
  console.log("üîÑ Game loop started");
}
function loadGameWorld(savedState) {
  console.log("üíæ Loading saved game...");
  try {
    if (!savedState) {
      throw new Error("No save data provided");
    }
    gameState.loadState(savedState);
    const seed = savedState.state?.island?.seed || savedState.island?.seed;
    if (!seed) {
      throw new Error("No island seed found in save data");
    }
    const { mapEngine: map, gameView: view } = initializeGameWorld(seed);
    const playerPos = savedState.player?.position || savedState.state?.player?.position;
    if (playerPos) {
      player.position = playerPos;
      travelSystem.setPosition(playerPos.q, playerPos.r);
      view.renderPlayerMarker();
    }
    view.show();
    const playerName = savedState.player?.name || savedState.state?.player?.name || "Survivor";
    const day = savedState.state?.time?.day || savedState.time?.day || 1;
    console.log(`‚úÖ Game loaded: Day ${day}, ${playerName}`);
    return { mapEngine: map, gameView: view };
  } catch (error) {
    console.error("‚ùå Failed to load game:", error);
    alert(`Failed to load game: ${error.message}

The save file may be corrupted or from an incompatible version. Starting a new game instead.`);
    const { mapEngine: map, gameView: view } = initializeGameWorld();
    view.show();
    return { mapEngine: map, gameView: view };
  }
}
function initGame() {
  console.log("üèùÔ∏è Hedonism Island - Initializing...");
  try {
    console.log("üéØ Initializing main menu...");
    mainMenu.init();
    gameState.on("characterCreated", (character) => {
      console.log("‚úÖ Character created:", character.name);
      gameState.state.player = {
        ...gameState.state.player,
        ...character
      };
      characterCreation.hide();
      console.log("üìñ Starting story intro...");
      storyIntro.show();
    });
    gameState.on("introComplete", () => {
      console.log("‚úÖ Story intro complete");
      const mapSeed = gameState.state.player?.mapSeed || void 0;
      const { mapEngine: map, gameView: view } = initializeGameWorld(mapSeed);
      console.log("üéÆ Starting gameplay...");
      view.show();
      gameState.emit("gameStarted");
    });
    gameState.on("loadGame", (saveState) => {
      console.log("üíæ Loading game from save...");
      const { mapEngine: map, gameView: view } = loadGameWorld(saveState);
      gameState.emit("gameStarted");
    });
    gameState.on("gameStarted", () => {
      console.log("üéÆ Game started!");
    });
    console.log("‚úÖ Game initialized!");
    console.log('üí° Open dev console and type "game" to access game systems');
  } catch (error) {
    console.error("‚ùå Error during initialization:", error);
  }
}
if (document.readyState === "loading") {
  console.log("‚è≥ Waiting for DOMContentLoaded...");
  document.addEventListener("DOMContentLoaded", initGame);
} else {
  console.log("‚úÖ DOM already loaded, initializing immediately");
  initGame();
}</script>
  <style rel="stylesheet" crossorigin>* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Mobile-first touch optimizations */
* {
  -webkit-tap-highlight-color: rgba(74, 222, 128, 0.2);
  touch-action: manipulation; /* Prevents double-tap zoom */
}

/* Allow scrolling where needed */
.modal-body,
.inventory-grid,
.crafting-grid,
.save-list {
  touch-action: pan-y; /* Allow vertical scrolling */
}

/* Global smooth transitions */
* {
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}

/* Prevent transitions on page load */
.preload * {
  transition: none !important;
}

.hidden {
  display: none !important;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  line-height: 1.6;
  color: #333;
  background: #1a1a1a url('https://user.uploads.dev/file/f2298da58835e5109933fa05e8e40561.png') center/contain no-repeat fixed;
  min-height: 100vh;
  overflow-x: hidden;
}

#app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  display: grid;
  grid-template-columns: 1fr 300px;
  gap: 20px;
  max-height: 100vh;
  overflow-y: auto;
}

header {
  grid-column: 1 / -1;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

header h1 {
  font-size: 2.5rem;
  color: #fff;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

#connection-status {
  font-weight: bold;
  padding: 8px 16px;
  border-radius: 6px;
  display: inline-block;
  background: #f0f0f0;
}

#connection-status.connected {
  background: #d4edda;
  color: #155724;
}

#connection-status.disconnected {
  background: #f8d7da;
  color: #721c24;
}

main {
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 30px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  color: #fff;
  max-height: 80vh;
  overflow-y: auto;
}

/* Custom scrollbar for main content */
main::-webkit-scrollbar {
  width: 10px;
}

main::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 5px;
}

main::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 5px;
}

main::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

#scene-container {
  margin-bottom: 30px;
  font-size: 1.1rem;
}

#choices-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Touch-friendly button sizing (minimum 44x44px) */
button,
.choice-button,
.btn,
input[type="button"],
input[type="submit"] {
  min-height: 44px;
  min-width: 44px;
}

.choice-button {
  padding: 15px 25px;
  font-size: 1rem;
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
  text-align: left;
}

.choice-button:hover {
  transform: translateY(-2px);
  background: #3a3a3a;
  border-color: #666;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.choice-button:active {
  transform: translateY(0);
}

aside {
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  color: #fff;
  max-height: 80vh;
  overflow-y: auto;
}

/* Custom scrollbar for aside */
aside::-webkit-scrollbar {
  width: 8px;
}

aside::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

aside::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 4px;
}

aside::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

@media (max-width: 768px) {
  #app {
    grid-template-columns: 1fr;
    padding: 10px;
  }
  
  header h1 {
    font-size: 1.8rem;
  }
  
  main, aside {
    max-height: none;
    padding: 20px;
  }
  
  /* Larger touch targets on tablets */
  button,
  .choice-button,
  .btn {
    min-height: 48px;
    padding: 12px 20px;
  }
  
  /* More spacing between interactive elements */
  #choices-container {
    gap: 16px;
  }
}

@media (max-width: 480px) {
  #app {
    padding: 5px;
  }
  
  header {
    padding: 15px;
  }
  
  header h1 {
    font-size: 1.5rem;
  }
  
  main, aside {
    padding: 15px;
  }
  
  /* Even larger touch targets on phones */
  button,
  .choice-button,
  .btn {
    min-height: 52px;
    padding: 15px 25px;
    font-size: 1rem;
  }
  
  .choice-button {
    padding: 15px 20px;
    font-size: 0.95rem;
  }
  
  /* Extra spacing for fat fingers */
  #choices-container {
    gap: 20px;
  }
}
/* Main Menu Styles */

.main-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  padding-left: 15%;
  z-index: 1000;
  opacity: 1;
  transition: opacity 0.4s ease-in-out;
}

.main-menu.hidden {
  opacity: 0;
  pointer-events: none;
}

.menu-container {
  background: rgba(0, 0, 0, 0.05);
  backdrop-filter: blur(1px);
  padding: 40px 50px;
  border-radius: 20px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
  text-align: left;
  border: 2px solid rgba(255, 255, 255, 0.1);
  animation: menuSlideIn 0.5s ease;
  max-width: 400px;
  width: 100%;
}

@keyframes menuSlideIn {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.game-title {
  font-size: 3.5rem;
  font-weight: 900;
  color: #fff;
  margin: 0 0 10px 0;
  text-shadow: 
    0 0 20px rgba(255, 255, 255, 0.5),
    0 0 40px rgba(255, 100, 100, 0.3),
    3px 3px 6px rgba(0, 0, 0, 0.8);
  letter-spacing: 3px;
}

.game-subtitle {
  font-size: 1.2rem;
  color: #aaa;
  margin: 0 0 40px 0;
  font-weight: 300;
  letter-spacing: 2px;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 30px;
}

.menu-btn {
  padding: 12px 30px;
  font-size: 1.1rem;
  font-weight: 600;
  color: #fff;
  background: rgba(185, 185, 185, 0.8);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  width: 100%;
  text-align: left;
}

.menu-btn:hover {
  background: rgba(60, 60, 60, 0.9);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-3px);
  box-shadow: 
    0 8px 20px rgba(0, 0, 0, 0.6),
    0 0 20px rgba(255, 255, 255, 0.1);
}

.menu-btn:active {
  transform: translateY(-1px);
}

.menu-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

.version-info {
  font-size: 0.9rem;
  color: #666;
  margin: 0;
  font-style: italic;
}

/* Discord Logo Link */
.discord-logo-link {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 120px;
  height: 120px;
  z-index: 1001;
  transition: all 0.3s ease;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
  background: rgba(11, 12, 13, 0.9);
  padding: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.discord-logo-link:hover {
  transform: scale(1.1) translateY(-5px);
  box-shadow: 
    0 8px 25px rgba(0, 0, 0, 0.7),
    0 0 30px rgba(180, 122, 60, 0.4);
  background: rgba(11, 12, 13, 1);
}

.discord-logo-link:active {
  transform: scale(1.05) translateY(-3px);
}

.menu-logo {
  width: 100%;
  height: 100%;
  object-fit: contain;
  filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.3));
  transition: filter 0.3s ease;
}

.discord-logo-link:hover .menu-logo {
  filter: 
    drop-shadow(0 4px 10px rgba(0, 0, 0, 0.5))
    brightness(1.2);
}

/* Game View */
.game-view {
  width: 100%;
  height: 100%;
}

.game-view.hidden {
  display: none;
}

/* Load Game Modal */
.load-game-modal {
  max-width: 800px;
}

.save-list {
  max-height: 400px;
  overflow-y: auto;
  margin: 20px 0;
}

.save-item {
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.save-item:hover {
  border-color: #555;
  background: #fff;
  transform: translateX(5px);
}

.save-info {
  flex: 1;
}

.save-info h4 {
  margin: 0 0 5px 0;
  color: #333;
  font-size: 1.1rem;
}

.save-info p {
  margin: 0;
  font-size: 0.9rem;
  color: #666;
}

.save-actions {
  display: flex;
  gap: 10px;
}

.save-actions button {
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s;
}

.btn-load {
  background: #2a2a2a;
  color: white;
}

.btn-load:hover {
  background: #3a3a3a;
}

.btn-delete {
  background: #dc3545;
  color: white;
}

.btn-delete:hover {
  background: #c82333;
}

.no-saves {
  text-align: center;
  padding: 40px;
  color: #666;
  font-style: italic;
}

/* Credits Modal */
.credits-content {
  text-align: center;
  padding: 20px;
}

.credits-content h3 {
  margin-top: 0;
  color: #333;
}

.credits-content p {
  color: #666;
  line-height: 1.8;
  margin: 10px 0;
}

.credits-content .credit-section {
  margin: 20px 0;
}

.credits-content .credit-section h4 {
  color: #555;
  margin-bottom: 10px;
}

/* Responsive */
@media (max-width: 768px) {
  .main-menu {
    justify-content: center;
    padding-left: 0;
  }

  .menu-container {
    padding: 40px 30px;
    text-align: center;
    max-width: 90%;
  }

  .game-title {
    font-size: 2.5rem;
  }

  .game-subtitle {
    font-size: 1rem;
  }

  .menu-btn {
    font-size: 1rem;
    padding: 12px 25px;
    text-align: center;
  }
  
  .discord-logo-link {
    width: 80px;
    height: 80px;
    bottom: 15px;
    right: 15px;
    border-radius: 15px;
    padding: 8px;
  }
}
/* Settings Menu Styles */

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease;
}

.modal-content {
  background: white;
  border-radius: 16px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
  max-width: 90vw;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  animation: slideIn 0.3s ease;
  overflow: hidden;
}

.settings-modal {
  width: 900px;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from {
    transform: translateY(-30px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.modal-header {
  padding: 20px 30px;
  border-bottom: 2px solid #f0f0f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.modal-header h2 {
  margin: 0;
  color: #333;
  font-size: 1.8rem;
}

.close-btn {
  background: none;
  border: none;
  font-size: 2rem;
  color: #999;
  cursor: pointer;
  padding: 0;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  transition: all 0.2s;
}

.close-btn:hover {
  background: #f0f0f0;
  color: #333;
}

.modal-body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 0;
  min-height: 0;
}

/* Custom scrollbar for modal body */
.modal-body::-webkit-scrollbar {
  width: 10px;
}

.modal-body::-webkit-scrollbar-track {
  background: #f0f0f0;
}

.modal-body::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 5px;
}

.modal-body::-webkit-scrollbar-thumb:hover {
  background: #999;
}

.settings-body {
  display: flex;
  flex: 1;
  overflow: hidden;
}

.settings-tabs {
  width: 200px;
  background: #f8f9fa;
  border-right: 2px solid #e0e0e0;
  display: flex;
  flex-direction: column;
  padding: 10px 0;
  overflow-y: auto;
}

.tab-btn {
  background: none;
  border: none;
  padding: 15px 20px;
  text-align: left;
  cursor: pointer;
  font-size: 0.9rem;
  color: #666;
  transition: all 0.2s;
  border-left: 3px solid transparent;
}

.tab-btn:hover {
  background: rgba(100, 100, 100, 0.1);
  color: #333;
}

.tab-btn.active {
  background: rgba(100, 100, 100, 0.15);
  color: #333;
  font-weight: 600;
  border-left-color: #555;
}

.settings-content {
  flex: 1;
  padding: 30px;
  overflow-y: auto;
}

.tab-content {
  animation: contentFade 0.2s ease;
}

@keyframes contentFade {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

.tab-content h3 {
  margin-top: 0;
  color: #333;
  font-size: 1.5rem;
  margin-bottom: 15px;
}

.help-text {
  color: #666;
  font-size: 0.9rem;
  margin-bottom: 20px;
  line-height: 1.5;
}

.help-text.warning {
  background: #fff3cd;
  border-left: 4px solid #ffc107;
  padding: 10px 15px;
  border-radius: 4px;
}

/* Slider Controls */
.slider-control {
  margin-bottom: 25px;
}

.slider-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.slider-control.wide {
  margin-bottom: 30px;
}

.slider-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: #666;
  margin-bottom: 5px;
}

.slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #e0e0e0;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #444;
  border: 2px solid #666;
  cursor: pointer;
  transition: transform 0.2s;
}

.slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #444;
  border: 2px solid #666;
  cursor: pointer;
  transition: transform 0.2s;
}

.slider::-moz-range-thumb:hover {
  transform: scale(1.2);
}

.slider-value {
  display: inline-block;
  margin-left: 15px;
  font-weight: 600;
  color: #666;
  min-width: 50px;
}

.slider-control.disabled {
  opacity: 0.5;
  pointer-events: none;
}

/* Faction Sections */
.faction-section {
  margin-bottom: 30px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.faction-section h4 {
  margin-top: 0;
  margin-bottom: 15px;
  color: #333;
  font-size: 1.1rem;
}

/* Toggle Controls */
.toggle-control {
  margin-bottom: 15px;
}

.toggle-control label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

.toggle-control input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  cursor: pointer;
  accent-color: #555;
}

.toggle-control span {
  color: #333;
  font-size: 1rem;
}

/* Select Controls */
.select-control {
  margin-bottom: 20px;
}

.select-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.select-control select,
.difficulty-section select {
  width: 100%;
  padding: 10px 15px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: border-color 0.2s;
}

.select-control select:hover,
.difficulty-section select:hover {
  border-color: #555;
}

.select-control select:focus,
.difficulty-section select:focus {
  outline: none;
  border-color: #555;
  box-shadow: 0 0 0 3px rgba(100, 100, 100, 0.1);
}

/* Difficulty Sections */
.difficulty-section {
  margin-bottom: 25px;
}

.difficulty-section h4 {
  margin-bottom: 10px;
  color: #333;
  font-size: 1.1rem;
}

/* Style Selector (Radio Cards) */
.style-selector {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.radio-card {
  position: relative;
  cursor: pointer;
}

.radio-card input[type="radio"] {
  position: absolute;
  opacity: 0;
}

.radio-card span {
  display: block;
  padding: 15px;
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  text-align: center;
  transition: all 0.2s;
  font-size: 0.9rem;
}

.radio-card:hover span {
  border-color: #555;
  background: rgba(100, 100, 100, 0.05);
}

.radio-card input[type="radio"]:checked + span {
  background: #2a2a2a;
  color: white;
  border-color: #444;
  font-weight: 600;
}

/* Custom Style Input */
.custom-style {
  margin-top: 20px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
  transition: all 0.3s;
}

.custom-style.hidden {
  display: none;
}

.custom-style label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.custom-style input[type="text"] {
  width: 100%;
  padding: 12px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.custom-style input[type="text"]:focus {
  outline: none;
  border-color: #555;
  box-shadow: 0 0 0 3px rgba(100, 100, 100, 0.1);
}

/* Kink Grid */
.kink-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 15px;
}

.kink-card {
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 15px;
  transition: all 0.2s;
}

.kink-card:hover {
  border-color: #555;
  background: rgba(100, 100, 100, 0.05);
}

.kink-card label {
  display: flex;
  align-items: flex-start;
  cursor: pointer;
  user-select: none;
}

.kink-card input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  margin-top: 2px;
  cursor: pointer;
  accent-color: #555;
  flex-shrink: 0;
}

.kink-label {
  display: flex;
  flex-direction: column;
}

.kink-label strong {
  color: #333;
  margin-bottom: 4px;
}

.kink-desc {
  font-size: 0.85rem;
  color: #666;
  line-height: 1.4;
}

/* Modal Footer */
.modal-footer {
  padding: 20px 30px;
  border-top: 2px solid #f0f0f0;
  display: flex;
  gap: 10px;
  align-items: center;
  flex-shrink: 0;
}

.modal-footer .spacer {
  flex: 1;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-primary {
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
}

.btn-primary:hover {
  transform: translateY(-2px);
  background: #3a3a3a;
  border-color: #666;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
}

.btn-secondary {
  background: #e0e0e0;
  color: #333;
}

.btn-secondary:hover {
  background: #d0d0d0;
}

/* Notification Toast */
.notification-toast {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
  padding: 15px 25px;
  border-radius: 8px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
  z-index: 10000;
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.3s;
}

.notification-toast.show {
  opacity: 1;
  transform: translateY(0);
}

/* Responsive */
@media (max-width: 768px) {
  .modal-content {
    max-width: 95vw;
    max-height: 95vh;
  }
  
  .settings-modal {
    width: 95vw;
    max-height: 95vh;
  }
  
  .modal-header {
    padding: 15px 20px;
  }
  
  .modal-header h2 {
    font-size: 1.5rem;
  }
  
  .modal-footer {
    padding: 15px 20px;
  }

  .settings-body {
    flex-direction: column;
  }

  .settings-tabs {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
    border-right: none;
    border-bottom: 2px solid #e0e0e0;
  }

  .tab-btn {
    white-space: nowrap;
    border-left: none;
    border-bottom: 3px solid transparent;
  }

  .tab-btn.active {
    border-left: none;
    border-bottom-color: #667eea;
  }

  .kink-grid {
    grid-template-columns: 1fr;
  }

  .style-selector {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .modal-content {
    max-width: 98vw;
    max-height: 98vh;
    border-radius: 8px;
  }
  
  .modal-header {
    padding: 12px 15px;
  }
  
  .modal-header h2 {
    font-size: 1.3rem;
  }
  
  .modal-footer {
    padding: 12px 15px;
    flex-direction: column;
  }
  
  .modal-footer .btn {
    width: 100%;
  }
  
  .style-selector {
    grid-template-columns: 1fr;
  }
}
/* Character Creation Styles */

#character-creation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  z-index: 2000;
  display: none;
  overflow-y: auto;
  padding: 15px;
  
  /* Background image */
  background-image: url('https://user.uploads.dev/file/b3d30050f83a4679a35851bdcf2da206.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: fixed;
  
  /* Smooth transitions */
  opacity: 0;
  transition: opacity 0.4s ease-in-out;
}

#character-creation::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.05); /* Dark overlay to ensure text readability */
  backdrop-filter: blur(1px);
  z-index: -1;
}

#character-creation.active {
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
}

/* Wrapper for container + preview panel */
.char-creation-wrapper {
  display: flex;
  gap: 15px;
  max-width: 1400px;
  width: 100%;
  height: 92vh;
  animation: fadeInUp 0.5s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.char-creation-container {
  flex: 1;
  max-height: 92vh;
  background: rgba(20, 20, 30, 0.85);
  backdrop-filter: blur(15px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.15);
  padding: 20px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: transform 0.3s ease;
}

/* Preview Panel */
.char-preview-panel {
  width: 280px;
  background: rgba(20, 20, 30, 0.85);
  backdrop-filter: blur(15px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.15);
  padding: 15px;
  overflow-y: auto;
  flex-shrink: 0;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
  transition: transform 0.3s ease;
}

.char-preview-panel h3 {
  color: #4CAF50;
  margin: 0 0 15px 0;
  font-size: 1.1rem;
  text-align: center;
  border-bottom: 2px solid rgba(76, 175, 80, 0.3);
  padding-bottom: 8px;
}

.preview-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.preview-field {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  padding: 6px 8px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.9rem;
}

.preview-label {
  color: #aaa;
  font-weight: 600;
  flex-shrink: 0;
}

.preview-value {
  color: #fff;
  text-align: right;
  flex: 1;
}

.preview-missing {
  color: #ff5555;
  font-style: italic;
}

.preview-section {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.preview-section h4 {
  color: #8BC34A;
  margin: 0 0 10px 0;
  font-size: 1.1rem;
}

.preview-skill {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  color: #fff;
  font-size: 0.9rem;
}

.skill-dots {
  color: #4CAF50;
  letter-spacing: 2px;
  font-family: monospace;
}

.preview-traits {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.trait-badge {
  background: rgba(76, 175, 80, 0.2);
  color: #4CAF50;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.85rem;
  border: 1px solid rgba(76, 175, 80, 0.3);
}

/* Header */
.char-creation-header {
  text-align: center;
  margin-bottom: 15px;
  flex-shrink: 0;
  position: relative;
}

.char-creation-header h1 {
  font-size: 1.7rem;
  margin-bottom: 10px;
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.btn-randomize {
  position: absolute;
  top: 0;
  right: 0;
  background: rgba(139, 195, 74, 0.2);
  color: #8BC34A;
  border: 2px solid #8BC34A;
  padding: 6px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.btn-randomize:hover {
  background: rgba(139, 195, 74, 0.3);
  transform: scale(1.05);
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 8px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  transition: width 0.3s ease;
}

.step-indicator {
  color: #aaa;
  font-size: 0.85rem;
}

/* Content */
.char-creation-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: 15px;
  padding-right: 8px;
  min-height: 0;
}

/* Custom scrollbar for content */
.char-creation-content::-webkit-scrollbar {
  width: 8px;
}

.char-creation-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.char-creation-content::-webkit-scrollbar-thumb {
  background: rgba(76, 175, 80, 0.5);
  border-radius: 4px;
}

.char-creation-content::-webkit-scrollbar-thumb:hover {
  background: rgba(76, 175, 80, 0.7);
}

.step-content {
  animation: fadeIn 0.4s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.step-content h2 {
  font-size: 1.4rem;
  margin-bottom: 8px;
  color: #fff;
}

.step-description {
  color: #ccc;
  margin-bottom: 20px;
  font-size: 0.95rem;
}

/* Gender Selection */
.gender-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.gender-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 20px 15px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.gender-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-5px);
}

.gender-card.selected {
  background: rgba(76, 175, 80, 0.2);
  border-color: #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.gender-symbol {
  font-size: 3rem;
  margin-bottom: 8px;
}

.gender-label {
  font-size: 1rem;
  font-weight: 600;
  color: #fff;
  margin-bottom: 4px;
}

.gender-description {
  font-size: 0.8rem;
  color: #aaa;
  line-height: 1.3;
  margin-top: 8px;
}

/* Preset Selection */
.creation-method-options {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin: 30px 0;
}

.method-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.method-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
}

.method-card.selected {
  background: rgba(76, 175, 80, 0.2);
  border-color: #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.method-card h3 {
  font-size: 1.2rem;
  margin-bottom: 8px;
  color: #fff;
}

.method-card p {
  color: #ccc;
  line-height: 1.4;
  font-size: 0.9rem;
}

.preset-selection {
  margin-top: 20px;
}

.preset-selection h3 {
  font-size: 1.1rem;
  margin-bottom: 12px;
  color: #fff;
}

.preset-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
}

.preset-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.preset-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-3px);
}

.preset-card h4 {
  font-size: 1rem;
  margin-bottom: 6px;
  color: #fff;
}

.preset-card p {
  color: #aaa;
  font-size: 0.85rem;
  line-height: 1.3;
}

/* Appearance Customization */
.appearance-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 18px;
}

.appearance-section {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 15px;
}

.appearance-section h3 {
  font-size: 1.1rem;
  margin-bottom: 12px;
  color: #fff;
  border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 8px;
}

.explicit-section {
  border: 2px solid rgba(255, 100, 100, 0.3);
  background: rgba(100, 0, 0, 0.1);
}

.genital-subsection {
  margin-top: 12px;
}

.genital-subsection h4 {
  font-size: 0.95rem;
  color: #faa;
  margin-bottom: 8px;
}

.form-group {
  margin-bottom: 12px;
}

.form-group label {
  display: block;
  margin-bottom: 4px;
  color: #ddd;
  font-weight: 500;
  font-size: 0.9rem;
}

.char-select,
.text-input {
  width: 100%;
  padding: 8px;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  color: #fff !important;
  font-size: 0.9rem;
  font-family: inherit;
}

.char-select option {
  background: #2a2a2a;
  color: #fff;
}

.char-select:focus,
.text-input:focus {
  outline: none;
  border-color: #4CAF50;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
}

/* Custom text input styling */
.custom-text-input {
  width: 100%;
  margin-top: 8px;
  padding: 10px;
  background: rgba(139, 195, 74, 0.05);
  border: 1px solid rgba(139, 195, 74, 0.4);
  border-radius: 6px;
  color: #fff !important;
  font-size: 1rem;
  font-family: inherit;
}

.custom-text-input:focus {
  outline: none;
  border-color: #8BC34A;
  box-shadow: 0 0 8px rgba(139, 195, 74, 0.3);
}

.custom-text-input::placeholder {
  color: rgba(255, 255, 255, 0.4);
  font-style: italic;
}

/* Ensure dropdown text is always white */
.appearance-step select,
.personality-step select,
.background-step select,
.char-creation-content select {
  color: #fff !important;
}

.appearance-step select option,
.personality-step select option,
.background-step select option,
.char-creation-content select option {
  background: #2a2a2a;
  color: #fff;
}

.checkbox-group {
  margin: 10px 0;
}

.checkbox-group label {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #ddd;
  cursor: pointer;
}

.char-checkbox {
  width: 20px;
  height: 20px;
  cursor: pointer;
}

/* Personality Sliders */
.personality-sliders {
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.slider-group {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.slider-group label {
  display: block;
  font-size: 1.2rem;
  font-weight: 600;
  margin-bottom: 10px;
  color: #fff;
}

.slider-labels {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  color: #aaa;
  font-size: 0.9rem;
}

.char-slider {
  width: 100%;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  outline: none;
  cursor: pointer;
}

.char-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #4CAF50;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.char-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #4CAF50;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.slider-value {
  text-align: center;
  margin-top: 8px;
  font-size: 1.3rem;
  font-weight: 600;
  color: #4CAF50;
}

/* Skills Allocation */
.skills-allocation {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
  margin-top: 20px;
}

.skills-allocation h3 {
  font-size: 1.3rem;
  margin-bottom: 10px;
  color: #fff;
}

.skills-info {
  color: #aaa;
  margin-bottom: 15px;
}

.skills-info-text {
  font-size: 1.1rem;
  margin-bottom: 15px;
  color: #fff;
  text-align: center;
}

.skills-info-text strong {
  color: #4CAF50;
}

.skills-remaining {
  font-size: 1.2rem;
  margin-bottom: 15px;
  color: #fff;
}

.skills-remaining strong {
  color: #4CAF50;
  font-size: 1.5rem;
}

.skills-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
}

.skill-item {
  background: rgba(0, 0, 0, 0.4);
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.skill-item label {
  display: block;
  font-weight: 600;
  margin-bottom: 5px;
  color: #ddd;
}

.skill-breakdown {
  min-height: 20px;
  margin-bottom: 8px;
}

.skill-bonus {
  font-size: 0.85rem;
  color: #4CAF50;
  font-style: italic;
}

.skill-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.skill-btn {
  width: 30px;
  height: 30px;
  background: rgba(76, 175, 80, 0.3);
  border: 1px solid #4CAF50;
  border-radius: 50%;
  color: #fff !important;
  font-size: 1.2rem;
  cursor: pointer;
  transition: all 0.2s;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.skill-btn:hover {
  background: rgba(76, 175, 80, 0.5);
  transform: scale(1.1);
  color: #fff !important;
}

.skill-btn:active {
  transform: scale(0.95);
}

.skill-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.skill-value {
  font-size: 1.5rem;
  font-weight: 600;
  color: #4CAF50;
  min-width: 30px;
}

.skill-value-display {
  font-size: 2rem;
  font-weight: 700;
  color: #4CAF50;
  text-align: center;
  margin-top: 10px;
}

.background-description {
  margin-top: 10px;
  padding: 10px;
  background: rgba(76, 175, 80, 0.1);
  border-left: 3px solid #4CAF50;
  color: #ccc;
  font-style: italic;
}

/* Portrait Step */
.portrait-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 30px;
  margin-bottom: 30px;
}

.portrait-preview {
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 3/4;
  display: flex;
  align-items: center;
  justify-content: center;
}

.portrait-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.portrait-placeholder {
  text-align: center;
  color: #666;
}

.placeholder-icon {
  font-size: 5rem;
  margin-bottom: 10px;
}

.portrait-controls {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.portrait-controls .btn-primary {
  padding: 15px 30px;
  font-size: 1.2rem;
  background: #4CAF50;
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s;
}

.portrait-controls .btn-primary:hover {
  background: #45a049;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.portrait-controls .btn-primary:disabled {
  background: #666;
  cursor: not-allowed;
  transform: none;
}

.portrait-info {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.portrait-info h4 {
  font-size: 1.2rem;
  margin-bottom: 10px;
  color: #fff;
}

.character-description {
  color: #ddd;
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: 15px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  border-left: 3px solid #4CAF50;
}

.prompt-details {
  margin-top: 15px;
}

.prompt-details summary {
  color: #8BC34A;
  cursor: pointer;
  font-size: 0.9rem;
  padding: 8px;
  border-radius: 4px;
  transition: background 0.2s;
}

.prompt-details summary:hover {
  background: rgba(139, 195, 74, 0.1);
}

.prompt-details[open] summary {
  margin-bottom: 10px;
}

.prompt-preview {
  color: #aaa;
  font-size: 0.85rem;
  line-height: 1.5;
  padding: 10px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.success-msg {
  color: #4CAF50;
  font-weight: 600;
  margin-top: 10px;
}

/* Character Summary */
.character-summary {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.character-summary h3 {
  font-size: 1.5rem;
  margin-bottom: 15px;
  color: #fff;
}

.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.summary-item {
  color: #ddd;
  line-height: 1.8;
}

.summary-item strong {
  color: #4CAF50;
}

/* Footer */
.char-creation-footer {
  display: flex;
  justify-content: space-between;
  gap: 15px;
  padding-top: 20px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
  flex-shrink: 0;
}

.char-creation-footer button {
  padding: 10px 24px;
  font-size: 0.95rem;
  cursor: pointer;
  border-radius: 8px;
  font-weight: 600;
  transition: all 0.2s;
  border: none;
}

.char-creation-footer .btn-primary {
  background: #4CAF50;
  color: #fff;
}

.char-creation-footer .btn-primary:hover {
  background: #45a049;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.char-creation-footer .btn-secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.char-creation-footer .btn-secondary:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
}

/* Responsive */
@media (max-width: 1200px) {
  .char-creation-wrapper {
    flex-direction: column;
    height: auto;
    max-height: none;
  }
  
  .char-preview-panel {
    width: 100%;
    max-height: 300px;
  }
  
  .char-creation-container {
    max-height: 600px;
  }
}

@media (max-width: 768px) {
  #character-creation {
    padding: 10px;
  }
  
  .char-creation-wrapper {
    gap: 10px;
  }
  
  .char-creation-container {
    padding: 20px;
    max-height: 500px;
  }
  
  .char-preview-panel {
    padding: 15px;
    max-height: 250px;
  }
  
  .char-creation-header h1 {
    font-size: 1.8rem;
  }
  
  .btn-randomize {
    position: static;
    margin-top: 10px;
    width: 100%;
  }
  
  .appearance-sections {
    grid-template-columns: 1fr;
  }
  
  .portrait-container {
    grid-template-columns: 1fr;
  }
  
  .creation-method-options {
    grid-template-columns: 1fr;
  }
  
  .gender-options {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .char-creation-footer {
    flex-direction: column;
  }
  
  .char-creation-footer button {
    width: 100%;
  }
}

@media (max-width: 480px) {
  .char-creation-container {
    padding: 15px;
  }
  
  .char-creation-header h1 {
    font-size: 1.5rem;
  }
  
  .gender-options {
    grid-template-columns: 1fr;
  }
  
  .step-content h2 {
    font-size: 1.5rem;
  }
}
/**
 * Story Intro Styles - Visual Novel
 * Text box at bottom, click to advance
 */

#story-intro {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 200;
  opacity: 1;
  transition: opacity 0.5s ease;
}

#story-intro.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Visual Novel Container */
.vn-container {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

/* Background */
.vn-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  transition: background-color 1s ease, opacity 0.5s ease;
}

/* Text Box at Bottom */
.vn-textbox {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.95) 20%, rgba(0, 0, 0, 0.98) 100%);
  padding: 60px 80px 40px 80px;
  min-height: 200px;
  cursor: pointer;
  transition: background 0.2s ease;
  border-top: 2px solid rgba(74, 222, 128, 0.3);
}

.vn-textbox:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.98) 20%, rgba(0, 0, 0, 1) 100%);
}

/* Text */
.vn-text {
  font-size: 1.6rem;
  line-height: 1.8;
  color: #fff;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
  min-height: 80px;
  display: flex;
  align-items: center;
  transition: opacity 0.3s ease;
}

/* Continue Indicator */
.vn-continue {
  position: absolute;
  bottom: 20px;
  right: 60px;
  font-size: 1.2rem;
  color: #4ade80;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; transform: translateY(0); }
  50% { opacity: 1; transform: translateY(-5px); }
}

/* Skip Button */
.vn-skip {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(15, 23, 42, 0.8);
  border: 2px solid rgba(74, 222, 128, 0.3);
  color: #e2e8f0;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  z-index: 10;
}

.vn-skip:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

/* Responsive */
@media (max-width: 768px) {
  .vn-textbox {
    padding: 40px 40px 30px 40px;
    min-height: 160px;
  }
  
  .vn-text {
    font-size: 1.3rem;
    min-height: 60px;
  }
  
  .vn-continue {
    bottom: 15px;
    right: 30px;
    font-size: 1rem;
  }
  
  .vn-skip {
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .vn-textbox {
    padding: 30px 20px 20px 20px;
    min-height: 140px;
  }
  
  .vn-text {
    font-size: 1.1rem;
    line-height: 1.6;
  }
}
/**
 * Game View Styles
 * Main gameplay interface
 */

#game-view {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #0a0a0a;
  z-index: 100;
  opacity: 1;
  transition: opacity 0.4s ease;
}

#game-view.hidden {
  opacity: 0;
  pointer-events: none;
}

.game-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* Top HUD - Optimized Layout */
.game-hud {
  background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
  border-bottom: 2px solid rgba(74, 222, 128, 0.3);
  padding: 10px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 30px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 10;
}

/* Left: Profile & Stats Grid */
.hud-left {
  display: flex;
  gap: 15px;
  align-items: center;
}

.player-profile {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.player-portrait {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid #4ade80;
  box-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
}

.player-portrait img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.portrait-placeholder {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
}

.player-name {
  font-size: 13px;
  font-weight: 700;
  color: #4ade80;
  text-align: center;
  max-width: 80px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 2x2 Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
}

.stat-cell {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  background: rgba(30, 41, 59, 0.6);
  border: 1px solid rgba(74, 222, 128, 0.2);
  border-radius: 6px;
  min-width: 120px;
}

.stat-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.stat-bar-mini {
  flex: 1;
  height: 12px;
  background: rgba(15, 23, 42, 0.8);
  border-radius: 6px;
  overflow: hidden;
  position: relative;
}

.stat-bar-fill {
  height: 100%;
  transition: width 0.5s ease;
  border-radius: 6px;
  box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.2);
}

.stat-bar-fill.health {
  background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
}

.stat-bar-fill.hunger {
  background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
}

.stat-bar-fill.thirst {
  background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
}

.stat-bar-fill.happiness {
  background: linear-gradient(90deg, #ec4899 0%, #f472b6 100%);
}

.stat-num {
  font-size: 11px;
  font-weight: 700;
  color: #e2e8f0;
  min-width: 25px;
  text-align: right;
}

/* Center: Action Grid */
.hud-center {
  flex: 0 0 auto;
}

.action-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
}

.action-btn {
  width: 48px;
  height: 48px;
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
  border: 2px solid rgba(74, 222, 128, 0.3);
  color: #e2e8f0;
  border-radius: 8px;
  cursor: pointer;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.action-btn:hover {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.15) 100%);
  border-color: #4ade80;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

/* Right: Time Controls */
.hud-right {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
}

.time-display {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  background: rgba(30, 41, 59, 0.6);
  border: 1px solid rgba(74, 222, 128, 0.2);
  border-radius: 8px;
}

.time-icon {
  font-size: 24px;
}

.time-info {
  display: flex;
  flex-direction: column;
}

.time-string {
  font-size: 14px;
  font-weight: 700;
  color: #4ade80;
  line-height: 1.2;
}

.time-controls {
  display: flex;
  gap: 4px;
}

.time-btn {
  width: 40px;
  height: 32px;
  background: rgba(30, 41, 59, 0.6);
  border: 1px solid rgba(74, 222, 128, 0.2);
  color: #cbd5e1;
  border-radius: 6px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.time-btn:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  color: #fff;
}

.time-btn.active {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.3) 0%, rgba(34, 197, 94, 0.2) 100%);
  border-color: #4ade80;
  color: #fff;
  box-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
}

/* Remove old styles that are no longer used */
.player-info,
.player-details,
.stat-bar,
.stat-label,
.stat-value,
.hud-btn {
  display: none;
}

/* Map Display */
.map-display {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: #000;
}

#game-canvas {
  width: 100%;
  height: 100%;
  display: block;
  cursor: grab;
}

#game-canvas:active {
  cursor: grabbing;
}

/* Map Controls */
.map-controls {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 5;
}

.map-control-btn {
  width: 44px;
  height: 44px;
  background: rgba(15, 23, 42, 0.9);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 8px;
  color: #e2e8f0;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.map-control-btn:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
}

/* Tile Info */
.tile-info {
  position: absolute;
  bottom: 120px;
  left: 20px;
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 12px;
  padding: 16px;
  min-width: 220px;
  max-width: 300px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 5;
}

.tile-info-content h4 {
  margin: 0 0 8px 0;
  font-size: 16px;
  color: #4ade80;
}

.tile-info-content p {
  margin: 4px 0;
  font-size: 13px;
  color: #cbd5e1;
}

.tile-info-content strong {
  color: #e2e8f0;
}

/* Tutorial Hint */
.tutorial-hint {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 12px;
  padding: 12px 20px;
  display: flex;
  gap: 20px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  animation: slideDown 0.5s ease, fadeOutSlow 1s ease 8s forwards;
  z-index: 5;
}

.tutorial-hint p {
  margin: 0;
  font-size: 14px;
  color: #e2e8f0;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

@keyframes fadeOutSlow {
  to {
    opacity: 0;
    pointer-events: none;
  }
}

/* Action Log Container - Button that transforms into panel */
.action-log-container {
  position: absolute;
  top: calc(20px + 5 * (44px + 8px)); /* Below map controls: 20px top + 5 buttons √ó (44px height + 8px gap) */
  right: 20px;
  width: 44px;
  height: 44px;
  background: rgba(15, 23, 42, 0.9);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 8px;
  overflow: hidden;
  transition: all 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
  z-index: 5;
}

/* When expanded - grow downward, intelligently sizing to screen */
.action-log-container:not(.collapsed) {
  width: min(350px, calc(100vw - 60px)); /* 350px or screen width minus margins */
  height: min(400px, calc(100vh - 20px - 5 * (44px + 8px) - 60px)); /* Max height to bottom of screen */
  max-height: calc(100vh - 20px - 5 * (44px + 8px) - 60px); /* Ensure it never extends past viewport */
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

/* The button itself (visible when collapsed) */
.action-log-button {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #e2e8f0;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2;
}

.action-log-button:hover {
  background: rgba(74, 222, 128, 0.2);
  transform: scale(1.05);
}

.action-log-container:hover {
  border-color: #4ade80;
  box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
}

/* The expanded panel content (hidden when collapsed) */
.action-log-expanded {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease 0.1s;
}

.action-log-container:not(.collapsed) .action-log-button {
  opacity: 0;
  pointer-events: none;
}

.action-log-container:not(.collapsed) .action-log-expanded {
  opacity: 1;
  pointer-events: all;
  transition: opacity 0.3s ease 0.2s;
}

/* Action Log Header */
.action-log-header {
  padding: 12px 16px;
  background: rgba(74, 222, 128, 0.1);
  border-bottom: 1px solid rgba(74, 222, 128, 0.2);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background 0.2s ease;
  flex-shrink: 0;
}

.action-log-header:hover {
  background: rgba(74, 222, 128, 0.15);
}

.action-log-header h4 {
  margin: 0;
  font-size: 14px;
  color: #4ade80;
  display: flex;
  align-items: center;
  gap: 6px;
}

.collapse-hint {
  font-size: 11px;
  color: #94a3b8;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.action-log-header:hover .collapse-hint {
  opacity: 1;
}

/* Log Content Area */
.action-log-container .log-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  font-size: 13px;
  line-height: 1.6;
  padding: 12px 16px;
}

.action-log-container .log-entry {
  margin: 2px 0;
  color: #cbd5e1;
  padding: 4px 0;
  animation: fadeIn 0.3s ease;
}

.action-log-container .log-entry:last-child {
  color: #e2e8f0;
  font-weight: 500;
}

/* Scrollbar for action log */
.action-log-container .log-content::-webkit-scrollbar {
  width: 8px;
}

.action-log-container .log-content::-webkit-scrollbar-track {
  background: rgba(30, 41, 59, 0.5);
  border-radius: 4px;
}

.action-log-container .log-content::-webkit-scrollbar-thumb {
  background: rgba(74, 222, 128, 0.3);
  border-radius: 4px;
}

.action-log-container .log-content::-webkit-scrollbar-thumb:hover {
  background: rgba(74, 222, 128, 0.5);
}

/* Remove old action-log styles */
.action-log {
  display: none;
}

.action-log-panel {
  display: none;
}

/* Responsive */
@media (max-width: 1200px) {
  .hud-btn span {
    display: none;
  }
  
  .hud-btn {
    padding: 10px;
  }
  
  .stat-label {
    min-width: 70px;
    font-size: 13px;
  }
}

@media (max-width: 768px) {
  /* Compact HUD for mobile */
  .game-hud {
    padding: 6px 10px;
    gap: 12px;
  }
  
  /* Smaller profile and stats */
  .player-portrait {
    width: 36px;
    height: 36px;
  }
  
  .player-name {
    font-size: 11px;
    max-width: 60px;
  }
  
  .portrait-placeholder {
    font-size: 20px;
  }
  
  .stats-grid {
    gap: 6px;
  }
  
  .stat-cell {
    font-size: 10px;
    padding: 4px 6px;
  }
  
  .stat-icon {
    font-size: 12px;
  }
  
  .stat-value {
    font-size: 12px;
  }
  
  /* Smaller action buttons */
  .action-grid {
    gap: 4px;
  }
  
  .action-btn {
    width: 36px;
    height: 36px;
    font-size: 14px;
  }
  
  /* Compact time display */
  .time-display {
    gap: 4px;
  }
  
  .time-value {
    font-size: 13px;
  }
  
  .time-label {
    font-size: 9px;
  }
  
  .time-controls {
    gap: 3px;
  }
  
  .time-speed-btn {
    width: 32px;
    height: 32px;
    font-size: 10px;
  }
  
  /* Smaller map controls */
  .map-control-btn {
    width: 36px;
    height: 36px;
    font-size: 14px;
  }
  
  .map-controls {
    top: 8px;
    right: 8px;
    gap: 5px;
  }
  
  /* Compact action log */
  .action-log-container {
    top: calc(8px + 5 * (36px + 5px));
    right: 8px;
    width: 36px;
    height: 36px;
  }
  
  .action-log-button {
    width: 36px;
    height: 36px;
    font-size: 14px;
  }
  
  .action-log-container:not(.collapsed) {
    width: min(280px, calc(100vw - 20px));
    height: min(220px, calc(100vh - 8px - 5 * (36px + 5px) - 30px));
    max-height: calc(100vh - 8px - 5 * (36px + 5px) - 30px);
  }
  
  .action-log-header {
    padding: 8px 12px;
  }
  
  .action-log-header h4 {
    font-size: 12px;
  }
  
  .action-log-container .log-content {
    font-size: 11px;
    padding: 8px 12px;
  }
  
  /* Smaller tile info */
  .tile-info {
    bottom: 80px;
    left: 8px;
    padding: 10px;
    min-width: 160px;
    max-width: 220px;
  }
  
  .tile-info-content h4 {
    font-size: 13px;
    margin-bottom: 6px;
  }
  
  .tile-info-content p {
    font-size: 11px;
    margin: 3px 0;
  }
  
  /* Compact tutorial hint */
  .tutorial-hint {
    padding: 8px 12px;
    gap: 6px;
  }
  
  .tutorial-hint p {
    font-size: 12px;
  }
}

/* Extra small screens (portrait phones) */
@media (max-width: 480px) {
  /* Ultra-compact HUD */
  .game-hud {
    padding: 4px 6px;
    gap: 8px;
  }
  
  .player-portrait {
    width: 32px;
    height: 32px;
  }
  
  .player-name {
    font-size: 10px;
    max-width: 50px;
  }
  
  .portrait-placeholder {
    font-size: 18px;
  }
  
  .stats-grid {
    gap: 4px;
  }
  
  .stat-cell {
    font-size: 9px;
    padding: 3px 5px;
  }
  
  .stat-icon {
    font-size: 10px;
  }
  
  .stat-value {
    font-size: 10px;
  }
  
  /* Tiny action buttons */
  .action-grid {
    gap: 3px;
  }
  
  .action-btn {
    width: 32px;
    height: 32px;
    font-size: 13px;
  }
  
  /* Compact time display */
  .time-display {
    gap: 3px;
  }
  
  .time-value {
    font-size: 12px;
  }
  
  .time-label {
    font-size: 8px;
  }
  
  .time-controls {
    gap: 2px;
  }
  
  .time-speed-btn {
    width: 28px;
    height: 28px;
    font-size: 9px;
  }
  
  /* Tiny map controls */
  .map-control-btn {
    width: 32px;
    height: 32px;
    font-size: 13px;
  }
  
  .map-controls {
    top: 6px;
    right: 6px;
    gap: 4px;
  }
  
  /* Ultra-compact action log */
  .action-log-container {
    top: calc(6px + 5 * (32px + 4px));
    right: 6px;
    width: 32px;
    height: 32px;
  }
  
  .action-log-button {
    width: 32px;
    height: 32px;
    font-size: 13px;
  }
  
  .action-log-container:not(.collapsed) {
    width: calc(100vw - 16px);
    height: min(180px, calc(100vh - 6px - 5 * (32px + 4px) - 20px));
    max-height: calc(100vh - 6px - 5 * (32px + 4px) - 20px);
  }
  
  .action-log-header {
    padding: 6px 10px;
  }
  
  .action-log-header h4 {
    font-size: 11px;
  }
  
  .collapse-hint {
    font-size: 9px;
  }
  
  .action-log-container .log-content {
    font-size: 10px;
    padding: 6px 10px;
    line-height: 1.4;
  }
  
  /* Tiny tile info */
  .tile-info {
    bottom: 60px;
    left: 6px;
    padding: 8px;
    min-width: 140px;
    max-width: 200px;
  }
  
  .tile-info-content h4 {
    font-size: 12px;
    margin-bottom: 4px;
  }
  
  .tile-info-content p {
    font-size: 10px;
    margin: 2px 0;
  }
  
  /* Compact tutorial hint */
  .tutorial-hint {
    padding: 6px 10px;
    gap: 4px;
  }
  
  .tutorial-hint p {
    font-size: 11px;
  }
}
/**
 * Save Manager UI - Comprehensive Save/Load System
 * Modern list-based interface with inline editing and no popups
 */

/* Save Manager Modal */
.save-manager-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  padding: 20px;
  animation: fadeIn 0.2s ease;
}

.save-manager-container {
  width: 100%;
  max-width: 1200px;
  max-height: 90vh;
  background: rgba(11, 15, 20, 0.95);
  border: 1px solid #1c2738;
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header */
.save-manager-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, rgba(20, 32, 53, 0.8), rgba(14, 22, 35, 0.8));
  border-bottom: 1px solid #1c2738;
}

.save-manager-title {
  display: flex;
  align-items: center;
  gap: 12px;
}

.save-manager-logo {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: linear-gradient(160deg, #3dd6ed, #8b5cf6);
  box-shadow: 0 2px 12px rgba(61, 214, 237, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

.save-manager-title h2 {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
  color: #e8f0f7;
}

.save-manager-subtitle {
  font-size: 12px;
  color: #8aa1b4;
  margin-top: 2px;
}

.save-manager-close {
  background: transparent;
  border: 1px solid #1c2738;
  color: #8aa1b4;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
  transition: all 0.2s ease;
}

.save-manager-close:hover {
  background: rgba(255, 93, 122, 0.1);
  border-color: #ff5d7a;
  color: #ff5d7a;
}

/* Top Actions */
.save-manager-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 16px 20px;
  background: rgba(15, 22, 35, 0.5);
  border-bottom: 1px solid #1c2738;
}

.sm-btn {
  padding: 10px 16px;
  border: 1px solid #1c2738;
  background: linear-gradient(180deg, #142035, #0e1623);
  color: #e8f0f7;
  border-radius: 10px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 6px;
}

.sm-btn:hover {
  transform: translateY(-1px);
  border-color: #2a3a53;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.sm-btn.primary {
  background: linear-gradient(180deg, #1a2b43, #15243a);
  border-color: #284162;
}

.sm-btn.accent {
  background: linear-gradient(180deg, #0bbbd1, #0aa1b5);
  border-color: #0b8ea0;
  color: #001318;
  font-weight: 700;
}

.sm-btn.success {
  background: linear-gradient(180deg, #20d2a0, #10b37f);
  border-color: #0f9e70;
  color: #05231b;
  font-weight: 700;
}

.sm-btn.danger {
  background: linear-gradient(180deg, #ff7a92, #ff5d7a);
  border-color: #f54e69;
  color: #4a0713;
  font-weight: 700;
}

.sm-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

/* Toolbar */
.save-manager-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  background: rgba(14, 21, 34, 0.8);
  border-bottom: 1px solid #1c2738;
  gap: 12px;
  flex-wrap: wrap;
}

.save-tab-group {
  display: inline-flex;
  border: 1px solid #1c2738;
  border-radius: 10px;
  overflow: hidden;
  background: #0f1623;
}

.save-tab {
  padding: 8px 16px;
  background: transparent;
  border: none;
  color: #8aa1b4;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
}

.save-tab.active {
  background: linear-gradient(180deg, #1a2a3f, #122136);
  color: #dff7ff;
}

.save-search-box {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #0f1623;
  border: 1px solid #1c2738;
  border-radius: 10px;
  padding: 8px 12px;
  flex: 1;
  min-width: 200px;
  max-width: 400px;
}

.save-search-icon {
  color: #8aa1b4;
  font-size: 14px;
}

.save-search-box input {
  background: transparent;
  border: none;
  outline: none;
  color: #e8f0f7;
  width: 100%;
  font-size: 13px;
}

.save-search-box input::placeholder {
  color: #8aa1b4;
}

/* Save List Table */
.save-list-container {
  flex: 1;
  overflow-y: auto;
  overflow-x: auto;
}

.save-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  min-width: 900px;
}

.save-table thead {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #0e1522;
}

.save-table th {
  padding: 12px 12px;
  text-align: left;
  font-size: 12px;
  font-weight: 600;
  color: #8aa1b4;
  border-bottom: 1px solid #1c2738;
  white-space: nowrap;
}

.save-table th.sortable {
  cursor: pointer;
  user-select: none;
}

.save-table th.sortable:hover {
  color: #dff7ff;
}

.sort-arrow {
  display: inline-block;
  margin-left: 4px;
  opacity: 0.4;
  font-size: 10px;
}

.save-table th.sorted .sort-arrow {
  opacity: 1;
  color: #3dd6ed;
}

.save-table tbody tr {
  background: #0f1623;
  transition: all 0.15s ease;
}

.save-table tbody tr:nth-child(2n) {
  background: #121b2b;
}

.save-table tbody tr:hover {
  background: rgba(61, 214, 237, 0.05);
}

.save-table tbody tr.selected {
  outline: 2px solid #3dd6ed;
  outline-offset: -2px;
  background: rgba(61, 214, 237, 0.08);
}

.save-table tbody tr.create-row {
  background: linear-gradient(90deg, rgba(61, 214, 237, 0.06), transparent);
  cursor: pointer;
}

.save-table tbody tr.create-row:hover {
  background: linear-gradient(90deg, rgba(61, 214, 237, 0.12), transparent);
}

.save-table td {
  padding: 12px;
  border-bottom: 1px solid #1c2738;
  font-size: 13px;
  color: #e8f0f7;
  vertical-align: middle;
}

.save-table td.meta {
  color: #8aa1b4;
  font-size: 12px;
}

.save-name-cell {
  display: flex;
  align-items: center;
  gap: 8px;
}

.save-name-input {
  background: rgba(15, 22, 35, 0.8);
  border: 1px solid #1c2738;
  color: #e8f0f7;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 13px;
  flex: 1;
  min-width: 120px;
}

.save-name-input:focus {
  outline: none;
  border-color: #3dd6ed;
  background: rgba(61, 214, 237, 0.05);
}

.save-tag {
  display: inline-block;
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 500;
  border: 1px solid #1c2738;
  background: #101a2a;
  color: #bcd2e6;
}

.save-tag.auto {
  background: #0e1c2e;
  border-color: #1f2b46;
  color: #b9c9ff;
}

.save-tag.quick {
  background: #0e2e1c;
  border-color: #1f462b;
  color: #b9ffc9;
}

.create-save-link {
  color: #3dd6ed;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
}

.create-save-link:hover {
  color: #5ee5f5;
}

/* Action buttons in table */
.save-row-actions {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
}

.save-action-btn {
  padding: 6px 12px;
  border: 1px solid #1c2738;
  background: linear-gradient(180deg, #142035, #0e1623);
  color: #e8f0f7;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.15s ease;
}

.save-action-btn:hover {
  border-color: #2a3a53;
  transform: translateY(-1px);
}

.save-action-btn.load {
  background: linear-gradient(180deg, #20d2a0, #10b37f);
  border-color: #0f9e70;
  color: #05231b;
  font-weight: 600;
}

.save-action-btn.delete {
  background: linear-gradient(180deg, #ff7a92, #ff5d7a);
  border-color: #f54e69;
  color: #fff;
  font-weight: 600;
  width: 32px;
  padding: 6px;
}

.save-action-btn.export {
  background: linear-gradient(180deg, #0bbbd1, #0aa1b5);
  border-color: #0b8ea0;
  color: #001318;
  font-weight: 600;
}

/* Footer */
.save-manager-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: rgba(14, 21, 34, 0.8);
  border-top: 1px solid #1c2738;
  font-size: 12px;
  color: #8aa1b4;
  flex-wrap: wrap;
  gap: 12px;
}

.save-footer-hint {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.kbd {
  padding: 2px 6px;
  border: 1px solid #334155;
  border-bottom-width: 2px;
  border-radius: 4px;
  background: #0c1421;
  color: #cfe5ff;
  font-size: 11px;
  font-family: monospace;
}

.save-count {
  color: #8aa1b4;
}

/* Empty state */
.save-list-empty {
  text-align: center;
  padding: 60px 20px;
  color: #8aa1b4;
}

.save-list-empty-icon {
  font-size: 48px;
  opacity: 0.3;
  margin-bottom: 16px;
}

.save-list-empty-text {
  font-size: 16px;
  margin-bottom: 8px;
}

.save-list-empty-hint {
  font-size: 13px;
  opacity: 0.7;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .save-manager-container {
    max-width: 100%;
    max-height: 100vh;
    border-radius: 0;
  }

  .save-manager-actions {
    padding: 12px;
  }

  .sm-btn {
    padding: 8px 12px;
    font-size: 12px;
  }

  .save-table {
    font-size: 12px;
  }

  .save-table th,
  .save-table td {
    padding: 8px;
  }

  .save-row-actions {
    flex-direction: column;
  }

  .save-search-box {
    min-width: 150px;
  }

  .save-footer-hint {
    display: none;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/**
 * Options Menu Styles
 * Quick access overlay menu
 */

.options-menu-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9998;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease;
}

.options-menu-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.options-menu-container {
  background: linear-gradient(135deg, rgba(17, 24, 38, 0.98), rgba(11, 15, 20, 0.98));
  border: 2px solid #1c2738;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
  padding: 32px;
  max-width: 600px;
  width: 100%;
  animation: slideUp 0.3s ease;
}

.options-menu-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 28px;
  padding-bottom: 20px;
  border-bottom: 1px solid #1c2738;
}

.options-menu-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: #e8f0f7;
  display: flex;
  align-items: center;
  gap: 12px;
}

.options-close-btn {
  background: rgba(15, 22, 35, 0.8);
  border: 1px solid #1c2738;
  color: #8aa1b4;
  width: 36px;
  height: 36px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 20px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.options-close-btn:hover {
  background: rgba(255, 93, 122, 0.1);
  border-color: #ff5d7a;
  color: #ff5d7a;
  transform: scale(1.05);
}

/* Options Grid */
.options-menu-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.option-card {
  background: linear-gradient(135deg, rgba(20, 32, 53, 0.6), rgba(14, 22, 35, 0.6));
  border: 2px solid #1c2738;
  border-radius: 16px;
  padding: 24px 20px;
  cursor: pointer;
  transition: all 0.25s ease;
  text-align: center;
  position: relative;
  overflow: hidden;
}

.option-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(61, 214, 237, 0.05), rgba(139, 92, 246, 0.05));
  opacity: 0;
  transition: opacity 0.25s ease;
}

.option-card:hover::before {
  opacity: 1;
}

.option-card:hover {
  border-color: #3dd6ed;
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(61, 214, 237, 0.2);
}

.option-card:active {
  transform: translateY(-2px);
}

.option-icon {
  font-size: 48px;
  margin-bottom: 12px;
  filter: drop-shadow(0 2px 8px rgba(61, 214, 237, 0.3));
}

.option-title {
  font-size: 16px;
  font-weight: 600;
  color: #e8f0f7;
  margin-bottom: 6px;
}

.option-desc {
  font-size: 12px;
  color: #8aa1b4;
  line-height: 1.4;
}

/* Specific card hover effects */
.option-card:nth-child(1):hover {
  border-color: #3dd6ed;
  box-shadow: 0 8px 24px rgba(61, 214, 237, 0.25);
}

.option-card:nth-child(2):hover {
  border-color: #8b5cf6;
  box-shadow: 0 8px 24px rgba(139, 92, 246, 0.25);
}

.option-card:nth-child(3):hover {
  border-color: #ff5d7a;
  box-shadow: 0 8px 24px rgba(255, 93, 122, 0.25);
}

.option-card:nth-child(4):hover {
  border-color: #1bc97c;
  box-shadow: 0 8px 24px rgba(27, 201, 124, 0.25);
}

/* Mobile responsiveness */
@media (max-width: 640px) {
  .options-menu-container {
    padding: 24px;
    max-width: 100%;
  }

  .options-menu-grid {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .option-card {
    padding: 20px 16px;
  }

  .option-icon {
    font-size: 40px;
  }

  .option-title {
    font-size: 15px;
  }

  .option-desc {
    font-size: 11px;
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* ============================================
   INVENTORY UI - ELEGANT MULTI-PANEL DESIGN
   ============================================ */

/* Overlay */
.inventory-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(4px);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Main Modal */
.inventory-modal {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #0f3460;
  border-radius: 12px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  color: #e0e0e0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateY(-50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Header */
.inventory-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 25px;
  border-bottom: 2px solid #0f3460;
  background: linear-gradient(to right, #1a1a2e, #0f3460);
}

.inventory-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  letter-spacing: 2px;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

.inventory-close {
  background: none;
  border: none;
  font-size: 36px;
  color: #e0e0e0;
  cursor: pointer;
  padding: 0;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.2s;
}

.inventory-close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #ff6b6b;
  transform: rotate(90deg);
}

/* Content Area */
.inventory-content {
  display: flex;
  padding: 20px;
  gap: 20px;
  flex: 1;
  overflow: hidden;
}

/* ============================================
   EQUIPMENT PANEL (LEFT)
   ============================================ */

.equipment-panel {
  flex: 0 0 200px;
  background: rgba(15, 52, 96, 0.3);
  border: 1px solid #0f3460;
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.equipment-panel h3 {
  margin: 0 0 10px 0;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 1px;
  color: #4dd0e1;
  text-align: center;
  border-bottom: 1px solid #0f3460;
  padding-bottom: 10px;
}

.equipment-slot-container {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.equipment-label {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  color: #9e9e9e;
  text-transform: uppercase;
}

.equipment-slot {
  width: 100%;
  height: 80px;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #0f3460;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}

.equipment-slot:hover {
  border-color: #4dd0e1;
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.3);
  transform: translateY(-2px);
}

.equipment-placeholder {
  font-size: 36px;
  opacity: 0.3;
  filter: grayscale(100%);
}

.equipment-icon {
  font-size: 48px;
  animation: equipPop 0.3s ease-out;
}

@keyframes equipPop {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}

.equipment-border {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 3px solid;
  border-radius: 6px;
  pointer-events: none;
  box-shadow: inset 0 0 10px currentColor;
}

/* ============================================
   GRID PANEL (CENTER)
   ============================================ */

.grid-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 8px;
  flex: 1;
}

.inventory-slot {
  aspect-ratio: 1;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #0f3460;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}

.inventory-slot:hover {
  border-color: #4dd0e1;
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.3);
  transform: scale(1.05);
}

.inventory-slot.selected {
  border-color: #ffd700;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
  background: rgba(255, 215, 0, 0.1);
}

.inventory-slot.dragging {
  opacity: 0.5;
}

.slot-icon {
  font-size: 42px;
  display: none;
  pointer-events: none;
}

.slot-count {
  position: absolute;
  bottom: 4px;
  right: 6px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 3px;
  display: none;
  pointer-events: none;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.slot-border {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 3px solid;
  border-radius: 6px;
  pointer-events: none;
  display: none;
  box-shadow: inset 0 0 10px currentColor;
}

/* Weight Bar */
.weight-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.weight-label {
  font-size: 14px;
  font-weight: 600;
  color: #e0e0e0;
  text-align: center;
}

.weight-bar-bg {
  width: 100%;
  height: 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid #0f3460;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.weight-bar-fill {
  height: 100%;
  background: #2ecc71;
  transition: width 0.3s ease, background-color 0.3s ease;
  border-radius: 10px;
  box-shadow: 0 0 10px currentColor;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
}

.inventory-button {
  padding: 10px 20px;
  background: linear-gradient(135deg, #0f3460, #1a1a2e);
  border: 1px solid #4dd0e1;
  border-radius: 6px;
  color: #e0e0e0;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.inventory-button:hover {
  background: linear-gradient(135deg, #4dd0e1, #0f3460);
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.5);
  transform: translateY(-2px);
}

.inventory-button:active {
  transform: translateY(0);
}

/* ============================================
   DETAILS PANEL (BOTTOM)
   ============================================ */

.details-panel {
  border-top: 2px solid #0f3460;
  padding: 20px 25px;
  background: rgba(15, 52, 96, 0.2);
  min-height: 140px;
  display: flex;
  align-items: center;
}

.details-empty {
  width: 100%;
  text-align: center;
  color: #9e9e9e;
  font-style: italic;
  font-size: 16px;
}

.details-content {
  width: 100%;
  display: none;
  gap: 20px;
  align-items: flex-start;
}

.details-icon {
  font-size: 64px;
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 3px solid;
  border-radius: 8px;
  flex-shrink: 0;
  box-shadow: inset 0 0 15px currentColor;
}

.details-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.details-name {
  font-size: 22px;
  font-weight: 700;
  letter-spacing: 1px;
  text-shadow: 0 0 10px currentColor;
}

.details-description {
  font-size: 14px;
  color: #b0b0b0;
  line-height: 1.5;
}

.details-durability {
  font-size: 13px;
  font-family: 'Courier New', monospace;
  color: #4dd0e1;
  letter-spacing: 1px;
}

.details-effects {
  font-size: 14px;
  color: #ffd700;
  font-weight: 600;
}

.details-buttons {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0;
}

.details-buttons .inventory-button {
  min-width: 120px;
}

/* ============================================
   RESPONSIVE DESIGN
   ============================================ */

@media (max-width: 768px) {
  .inventory-modal {
    width: 95%;
    max-height: 95vh;
  }

  .inventory-content {
    flex-direction: column;
    overflow-y: auto;
  }

  .equipment-panel {
    flex: 0 0 auto;
    flex-direction: row;
    flex-wrap: wrap;
  }

  .equipment-slot-container {
    flex: 1;
    min-width: 100px;
  }

  .inventory-grid {
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
  }

  .details-content {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .details-buttons {
    flex-direction: row;
    width: 100%;
  }

  .details-buttons .inventory-button {
    flex: 1;
  }
}

/* ============================================
   ANIMATIONS & EFFECTS
   ============================================ */

@keyframes itemAdd {
  0% {
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
  50% {
    transform: scale(1.3) rotate(-10deg);
  }
  100% {
    transform: scale(1) rotate(0);
    opacity: 1;
  }
}

@keyframes itemRemove {
  0% {
    transform: scale(1) rotate(0);
    opacity: 1;
  }
  100% {
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
}

/* Glow effect for rare items */
@keyframes rarityGlow {
  0%, 100% {
    box-shadow: 0 0 5px currentColor;
  }
  50% {
    box-shadow: 0 0 20px currentColor;
  }
}

.slot-border,
.equipment-border {
  animation: rarityGlow 2s ease-in-out infinite;
}

/* ============================================
   SCROLLBAR STYLING
   ============================================ */

.inventory-content::-webkit-scrollbar {
  width: 8px;
}

.inventory-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.inventory-content::-webkit-scrollbar-thumb {
  background: #0f3460;
  border-radius: 4px;
}

.inventory-content::-webkit-scrollbar-thumb:hover {
  background: #4dd0e1;
}
/* ============================================
   RESOURCE GATHERING UI
   ============================================ */

/* Gathering Overlay */
.gathering-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1100;
  animation: fadeIn 0.2s ease-out;
}

/* Gathering Modal */
.gathering-modal {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #0f3460;
  border-radius: 16px;
  padding: 30px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    transform: translateY(30px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Resource Info */
.gathering-info {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-bottom: 25px;
  padding-bottom: 20px;
  border-bottom: 2px solid rgba(77, 208, 225, 0.3);
}

.gathering-icon {
  font-size: 64px;
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 3px solid #4dd0e1;
  border-radius: 12px;
  box-shadow: 0 0 20px rgba(77, 208, 225, 0.3);
}

.gathering-name {
  flex: 1;
  font-size: 28px;
  font-weight: 700;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

/* Progress Bar */
.gathering-progress-container {
  margin-bottom: 20px;
}

.gathering-progress-label {
  font-size: 14px;
  font-weight: 600;
  color: #e0e0e0;
  margin-bottom: 10px;
  text-align: center;
  letter-spacing: 1px;
  text-transform: uppercase;
}

.gathering-progress-bg {
  width: 100%;
  height: 30px;
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid #0f3460;
  border-radius: 15px;
  overflow: hidden;
  position: relative;
}

.gathering-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #26c6da 100%);
  border-radius: 15px;
  transition: width 0.1s linear;
  box-shadow: 0 0 20px rgba(77, 208, 225, 0.5);
  position: relative;
  overflow: hidden;
}

/* Progress shimmer effect */
.gathering-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.5),
    transparent
  );
  animation: progressShimmer 1.5s infinite;
}

@keyframes progressShimmer {
  0% {
    left: -100%;
  }
  100% {
    left: 100%;
  }
}

/* Details */
.gathering-details {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
}

.detail-label {
  color: #9e9e9e;
  font-weight: 600;
}

.detail-value {
  color: #4dd0e1;
  font-weight: 700;
}

/* Cancel Button */
.gathering-cancel {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  border: 2px solid #e74c3c;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.gathering-cancel:hover {
  background: linear-gradient(135deg, #c0392b, #a93226);
  box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
  transform: translateY(-2px);
}

/* ============================================
   NODE INSPECTOR (Near Node Info)
   ============================================ */

.node-inspector {
  position: fixed;
  bottom: 150px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(26, 26, 46, 0.98) 0%, rgba(15, 52, 96, 0.98) 100%);
  border: 2px solid rgba(77, 208, 225, 0.6);
  border-radius: 12px;
  padding: 20px;
  min-width: 350px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 800;
  animation: inspectorSlideUp 0.3s ease-out;
}

@keyframes inspectorSlideUp {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* Inspector Header */
.inspector-header {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 15px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(77, 208, 225, 0.3);
}

.inspector-icon {
  font-size: 48px;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
}

.inspector-name {
  flex: 1;
  font-size: 20px;
  font-weight: 700;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

.inspector-quality {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.inspector-quality.poor {
  background: rgba(158, 158, 158, 0.3);
  color: #9e9e9e;
}

.inspector-quality.normal {
  background: rgba(46, 204, 113, 0.3);
  color: #2ecc71;
}

.inspector-quality.rich {
  background: rgba(52, 152, 219, 0.3);
  color: #3498db;
}

.inspector-quality.abundant {
  background: rgba(155, 89, 182, 0.3);
  color: #9b59b6;
}

/* Inspector State */
.inspector-state {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.state-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 1px;
}

.state-badge.full {
  background: rgba(46, 204, 113, 0.3);
  color: #2ecc71;
}

.state-badge.depleted {
  background: rgba(231, 76, 60, 0.3);
  color: #e74c3c;
}

.state-badge.regenerating {
  background: rgba(241, 196, 15, 0.3);
  color: #f1c40f;
}

.regen-progress {
  font-size: 12px;
  color: #f1c40f;
  font-weight: 600;
}

/* Inspector Details */
.inspector-details {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 15px;
}

.inspector-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  padding: 6px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
}

.inspector-label {
  color: #9e9e9e;
  font-weight: 600;
}

.inspector-value {
  color: #e0e0e0;
  font-weight: 700;
}

/* Inspector Action */
.inspector-action {
  margin-top: 15px;
}

.inspector-button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #4dd0e1, #26c6da);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
  animation: buttonPulse 2s ease-in-out infinite;
}

@keyframes buttonPulse {
  0%, 100% {
    box-shadow: 0 0 10px rgba(77, 208, 225, 0.3);
  }
  50% {
    box-shadow: 0 0 25px rgba(77, 208, 225, 0.6);
  }
}

.inspector-button:hover {
  background: linear-gradient(135deg, #26c6da, #00acc1);
  transform: translateY(-2px);
  box-shadow: 0 0 30px rgba(77, 208, 225, 0.8);
}

.inspector-error {
  text-align: center;
  padding: 12px;
  background: rgba(231, 76, 60, 0.2);
  border: 1px solid #e74c3c;
  border-radius: 8px;
  color: #e74c3c;
  font-size: 14px;
  font-weight: 600;
}

/* ============================================
   GATHERING NOTIFICATIONS
   ============================================ */

.gathering-notification {
  position: fixed;
  top: 100px;
  right: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid;
  border-radius: 12px;
  padding: 20px 25px;
  min-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  z-index: 1200;
  transform: translateX(400px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

.gathering-notification.show {
  transform: translateX(0);
  opacity: 1;
}

.gathering-notification.success {
  border-color: #2ecc71;
  box-shadow: 0 8px 32px rgba(46, 204, 113, 0.4);
}

.gathering-notification.error {
  border-color: #e74c3c;
  box-shadow: 0 8px 32px rgba(231, 76, 60, 0.4);
}

.gathering-notification.info {
  border-color: #3498db;
  box-shadow: 0 8px 32px rgba(52, 152, 219, 0.4);
}

.notification-title {
  font-size: 18px;
  font-weight: 700;
  color: #4dd0e1;
  margin-bottom: 8px;
  letter-spacing: 1px;
}

.notification-message {
  font-size: 14px;
  color: #e0e0e0;
  line-height: 1.5;
  white-space: pre-line;
}

/* ============================================
   MOBILE RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
  .gathering-modal {
    min-width: 90vw;
    padding: 20px;
  }

  .gathering-icon {
    font-size: 48px;
    width: 60px;
    height: 60px;
  }

  .gathering-name {
    font-size: 22px;
  }

  .node-inspector {
    bottom: 100px;
    min-width: 90vw;
    padding: 15px;
  }

  .gathering-notification {
    right: 10px;
    left: 10px;
    min-width: auto;
  }
}
/**
 * Crafting UI Styles
 * Beautiful dark-themed crafting interface with smooth animations
 */

/* Modal Overlay */
.crafting-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10000;
  display: flex;
  justify-content: center;
  align-items: center;
  animation: fadeIn 0.3s ease;
}

.crafting-modal.hidden {
  display: none;
}

.crafting-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
}

/* Main Window */
.crafting-window {
  position: relative;
  width: 90%;
  max-width: 1200px;
  height: 85vh;
  max-height: 800px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: slideUp 0.3s ease;
}

/* Header */
.crafting-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  background: linear-gradient(135deg, #0f3460 0%, #1a1a2e 100%);
  border-bottom: 2px solid #4dd0e1;
}

.crafting-header h2 {
  margin: 0;
  color: #4dd0e1;
  font-size: 24px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 2px 8px rgba(77, 208, 225, 0.3);
}

.close-btn {
  background: transparent;
  border: 2px solid #4dd0e1;
  color: #4dd0e1;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.close-btn:hover {
  background: #4dd0e1;
  color: #1a1a2e;
  transform: rotate(90deg);
}

/* Content Area */
.crafting-content {
  display: grid;
  grid-template-columns: 200px 1fr 350px;
  gap: 20px;
  padding: 20px;
  flex: 1;
  overflow: hidden;
}

/* Categories Panel */
.crafting-categories {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.crafting-categories h3 {
  color: #4dd0e1;
  font-size: 16px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin: 0 0 10px 0;
}

.category-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.category-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: rgba(77, 208, 225, 0.1);
  border: 1px solid rgba(77, 208, 225, 0.3);
  border-radius: 8px;
  color: #e0e0e0;
  cursor: pointer;
  transition: all 0.3s;
  font-size: 14px;
}

.category-btn:hover {
  background: rgba(77, 208, 225, 0.2);
  border-color: #4dd0e1;
  transform: translateX(5px);
}

.category-btn.active {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-color: #667eea;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.category-icon {
  font-size: 20px;
}

.category-name {
  flex: 1;
  text-align: left;
}

.crafting-stats {
  margin-top: auto;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border: 1px solid rgba(77, 208, 225, 0.2);
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
}

.stat-item:last-child {
  margin-bottom: 0;
}

.stat-label {
  color: #b0b0b0;
}

.stat-value {
  color: #4dd0e1;
  font-weight: 600;
}

/* Recipe List Panel */
.crafting-recipes {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.recipes-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.recipes-header h3 {
  color: #4dd0e1;
  font-size: 18px;
  margin: 0;
}

.recipe-count {
  color: #b0b0b0;
  font-size: 13px;
}

.recipe-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-right: 10px;
}

/* Custom Scrollbar */
.recipe-list::-webkit-scrollbar,
.details-section::-webkit-scrollbar {
  width: 8px;
}

.recipe-list::-webkit-scrollbar-track,
.details-section::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.recipe-list::-webkit-scrollbar-thumb,
.details-section::-webkit-scrollbar-thumb {
  background: #4dd0e1;
  border-radius: 4px;
}

.recipe-list::-webkit-scrollbar-thumb:hover,
.details-section::-webkit-scrollbar-thumb:hover {
  background: #667eea;
}

/* Recipe Item */
.recipe-item {
  display: grid;
  grid-template-columns: 40px 1fr 30px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  background: rgba(77, 208, 225, 0.05);
  border: 1px solid rgba(77, 208, 225, 0.2);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s;
}

.recipe-item:hover {
  background: rgba(77, 208, 225, 0.1);
  border-color: #4dd0e1;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(77, 208, 225, 0.2);
}

.recipe-item.selected {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
  border-color: #667eea;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.recipe-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.recipe-item.disabled:hover {
  transform: none;
  box-shadow: none;
}

.recipe-icon {
  font-size: 28px;
  text-align: center;
}

.recipe-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.recipe-name {
  color: #e0e0e0;
  font-size: 14px;
  font-weight: 600;
}

.recipe-difficulty {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.recipe-status {
  text-align: center;
  font-size: 18px;
}

.status-can-craft {
  color: #4ade80;
}

.status-cannot-craft {
  color: #f87171;
}

.no-recipes {
  padding: 40px;
  text-align: center;
  color: #b0b0b0;
  font-size: 14px;
}

/* Details Panel */
.crafting-details {
  display: flex;
  flex-direction: column;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(77, 208, 225, 0.2);
  border-radius: 8px;
  padding: 20px;
  overflow-y: auto;
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 15px;
}

.details-header h3 {
  color: #4dd0e1;
  font-size: 20px;
  margin: 0;
  flex: 1;
}

.difficulty-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  color: #000;
}

.details-description {
  color: #b0b0b0;
  font-size: 14px;
  line-height: 1.6;
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(77, 208, 225, 0.2);
}

.details-section {
  margin-bottom: 20px;
}

.details-section h4 {
  color: #4dd0e1;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin: 0 0 12px 0;
}

/* Requirements */
.requirements-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.requirement {
  display: grid;
  grid-template-columns: 30px 1fr auto;
  gap: 8px;
  align-items: center;
  padding: 8px;
  background: rgba(77, 208, 225, 0.05);
  border-radius: 6px;
  font-size: 13px;
}

.req-icon {
  text-align: center;
  font-size: 16px;
}

.req-label {
  color: #b0b0b0;
}

.req-value {
  font-weight: 600;
  text-align: right;
}

.req-value.available {
  color: #4ade80;
}

.req-value.unavailable {
  color: #f87171;
}

/* Ingredients */
.ingredients-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ingredient {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(77, 208, 225, 0.05);
  border-radius: 6px;
  border-left: 3px solid transparent;
  font-size: 13px;
}

.ingredient.available {
  border-left-color: #4ade80;
}

.ingredient.unavailable {
  border-left-color: #f87171;
}

.ingredient-name {
  color: #e0e0e0;
}

.ingredient-count {
  font-weight: 600;
}

.ingredient.available .ingredient-count {
  color: #4ade80;
}

.ingredient.unavailable .ingredient-count {
  color: #f87171;
}

/* Output */
.output-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.output-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(77, 208, 225, 0.1);
  border-radius: 6px;
  border-left: 3px solid #4dd0e1;
  font-size: 13px;
}

.output-name {
  color: #e0e0e0;
  font-weight: 600;
}

.output-quantity {
  color: #4dd0e1;
  font-weight: 600;
}

/* Details Footer */
.details-footer {
  display: flex;
  justify-content: space-around;
  padding: 15px 0;
  margin: 20px 0;
  border-top: 1px solid rgba(77, 208, 225, 0.2);
  border-bottom: 1px solid rgba(77, 208, 225, 0.2);
}

.craft-time,
.craft-xp {
  font-size: 14px;
  color: #b0b0b0;
  font-weight: 600;
}

/* Actions */
.details-actions {
  margin-top: auto;
}

.craft-btn {
  width: 100%;
  padding: 15px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  border-radius: 8px;
  color: white;
  font-size: 16px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s;
}

.craft-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.craft-btn:active {
  transform: translateY(0);
}

.craft-btn.disabled {
  background: rgba(180, 180, 180, 0.2);
  color: #999;
  cursor: not-allowed;
  box-shadow: none;
}

.craft-btn.disabled:hover {
  transform: none;
}

/* Empty State */
.details-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 20px;
}

.empty-icon {
  font-size: 64px;
  opacity: 0.3;
}

.empty-text {
  color: #b0b0b0;
  font-size: 16px;
}

/* Crafting Queue */
.crafting-queue {
  padding: 15px 20px;
  background: rgba(0, 0, 0, 0.3);
  border-top: 2px solid #4dd0e1;
}

.queue-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.queue-header h4 {
  color: #4dd0e1;
  font-size: 14px;
  text-transform: uppercase;
  margin: 0;
}

.queue-count {
  color: #b0b0b0;
  font-size: 12px;
}

.queue-items {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.queue-item {
  display: grid;
  grid-template-columns: 1fr auto 30px;
  gap: 15px;
  align-items: center;
  padding: 10px;
  background: rgba(77, 208, 225, 0.1);
  border-radius: 6px;
}

.queue-recipe {
  color: #e0e0e0;
  font-size: 13px;
  font-weight: 600;
}

.queue-progress {
  width: 200px;
  height: 6px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 3px;
  overflow: hidden;
}

.queue-progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #667eea 100%);
  transition: width 0.1s linear;
  position: relative;
  overflow: hidden;
}

.queue-progress-bar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.3) 50%,
    transparent 100%
  );
  animation: shimmer 2s infinite;
}

.queue-cancel {
  background: transparent;
  border: 1px solid #f87171;
  color: #f87171;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.queue-cancel:hover {
  background: #f87171;
  color: #fff;
}

/* Notifications */
.crafting-notification {
  position: fixed;
  top: 80px;
  right: -400px;
  padding: 15px 20px;
  background: rgba(26, 26, 46, 0.95);
  border-left: 4px solid #4dd0e1;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  color: #e0e0e0;
  font-size: 14px;
  z-index: 10001;
  transition: right 0.3s ease;
  max-width: 350px;
}

.crafting-notification.show {
  right: 20px;
}

.crafting-notification.success {
  border-left-color: #4ade80;
}

.crafting-notification.error {
  border-left-color: #f87171;
}

.crafting-notification.warning {
  border-left-color: #fbbf24;
}

.crafting-notification.info {
  border-left-color: #60a5fa;
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

/* Responsive */
@media (max-width: 1024px) {
  .crafting-content {
    grid-template-columns: 180px 1fr 300px;
  }
}

@media (max-width: 768px) {
  .crafting-window {
    width: 100%;
    height: 100vh;
    max-height: 100vh;
    border-radius: 0;
  }

  .crafting-content {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr;
  }

  .crafting-categories {
    flex-direction: row;
    overflow-x: auto;
  }

  .category-list {
    flex-direction: row;
  }

  .category-btn {
    flex-shrink: 0;
  }

  .crafting-stats {
    display: none;
  }

  .crafting-details {
    grid-row: 3;
  }
}
/**
 * Map Travel UI Styles
 * Beautiful travel interface with tooltips, notifications, and territory colors
 */

/* Hex Tooltip */
.hex-tooltip {
  position: absolute;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 12px;
  min-width: 200px;
  max-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  z-index: 10000;
  pointer-events: none;
  display: none;
  animation: tooltipFadeIn 0.2s ease-out;
  backdrop-filter: blur(10px);
}

@keyframes tooltipFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.tooltip-title {
  font-size: 16px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.tooltip-faction {
  font-size: 13px;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.tooltip-travel {
  font-size: 12px;
  color: #b0b0b0;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(77, 208, 225, 0.2);
  display: flex;
  gap: 12px;
}

.tooltip-error {
  font-size: 12px;
  color: #ff6b6b;
  margin-top: 8px;
  padding: 6px 8px;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 4px;
  border-left: 3px solid #ff6b6b;
}

.tooltip-feature {
  font-size: 12px;
  color: #4ade80;
  margin-top: 4px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* Travel Notifications */
.travel-notifications {
  position: fixed;
  top: 80px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.travel-notification {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 12px 20px;
  min-width: 250px;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  transform: translateX(450px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  font-size: 14px;
  color: #e0e0e0;
}

.travel-notification.show {
  transform: translateX(0);
  opacity: 1;
}

.travel-notification-info {
  border-color: #4dd0e1;
  color: #4dd0e1;
}

.travel-notification-success {
  border-color: #4ade80;
  color: #4ade80;
}

.travel-notification-warning {
  border-color: #fbbf24;
  color: #fbbf24;
}

.travel-notification-error {
  border-color: #ff6b6b;
  color: #ff6b6b;
}

/* Territory Legend (optional overlay) */
.territory-legend {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  padding: 16px;
  min-width: 200px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9998;
}

.territory-legend-title {
  font-size: 14px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.territory-legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
  font-size: 13px;
  color: #e0e0e0;
}

.territory-legend-color {
  width: 20px;
  height: 20px;
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Travel Progress Bar */
.travel-progress {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 25px;
  padding: 12px 24px;
  min-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9999;
  display: none;
}

.travel-progress.active {
  display: block;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.travel-progress-text {
  font-size: 13px;
  color: #4dd0e1;
  margin-bottom: 8px;
  text-align: center;
  font-weight: bold;
}

.travel-progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(77, 208, 225, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.travel-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #00bcd4 100%);
  border-radius: 4px;
  transition: width 0.1s linear;
  box-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

/* Travel Stats Panel */
.travel-stats {
  position: fixed;
  top: 80px;
  left: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  padding: 16px;
  min-width: 220px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9998;
}

.travel-stats-title {
  font-size: 14px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.travel-stat {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
  color: #e0e0e0;
}

.travel-stat-label {
  color: #b0b0b0;
}

.travel-stat-value {
  color: #4dd0e1;
  font-weight: bold;
}

/* Territory Control Indicator */
.territory-control {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 4px;
}

.territory-control-bar {
  flex: 1;
  height: 6px;
  background: rgba(77, 208, 225, 0.2);
  border-radius: 3px;
  overflow: hidden;
}

.territory-control-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s ease;
}

.territory-control-text {
  font-size: 11px;
  color: #b0b0b0;
  min-width: 40px;
  text-align: right;
}

/* Faction Encounter Modal */
.faction-encounter {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.faction-encounter.active {
  opacity: 1;
  pointer-events: all;
}

.faction-encounter-content {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 3px solid #4dd0e1;
  border-radius: 16px;
  padding: 32px;
  max-width: 600px;
  width: 90%;
  box-shadow: 0 16px 64px rgba(0, 0, 0, 0.9);
  transform: scale(0.9);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.faction-encounter.active .faction-encounter-content {
  transform: scale(1);
}

.faction-encounter-title {
  font-size: 24px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 16px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.faction-encounter-text {
  font-size: 16px;
  color: #e0e0e0;
  line-height: 1.6;
  margin-bottom: 24px;
  text-align: center;
}

.faction-encounter-choices {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.faction-encounter-choice {
  background: rgba(77, 208, 225, 0.1);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  color: #e0e0e0;
  text-align: left;
}

.faction-encounter-choice:hover {
  background: rgba(77, 208, 225, 0.2);
  transform: translateX(8px);
  box-shadow: 0 4px 16px rgba(77, 208, 225, 0.3);
}

.faction-encounter-choice-title {
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 4px;
}

.faction-encounter-choice-description {
  font-size: 12px;
  color: #b0b0b0;
}

/* Discovery Animation */
.discovery-flash {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle, rgba(77, 208, 225, 0.3) 0%, transparent 70%);
  pointer-events: none;
  z-index: 9997;
  opacity: 0;
  animation: discoveryFlash 1s ease-out;
}

@keyframes discoveryFlash {
  0% {
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
  .hex-tooltip {
    min-width: 150px;
    max-width: 200px;
    padding: 8px;
  }

  .tooltip-title {
    font-size: 14px;
  }

  .travel-notifications {
    top: 60px;
    right: 10px;
    left: 10px;
  }

  .travel-notification {
    min-width: auto;
    max-width: none;
  }

  .territory-legend {
    bottom: 10px;
    right: 10px;
    padding: 12px;
    min-width: 150px;
  }

  .travel-stats {
    top: 60px;
    left: 10px;
    padding: 12px;
    min-width: 180px;
  }

  .faction-encounter-content {
    padding: 24px;
    width: 95%;
  }

  .faction-encounter-title {
    font-size: 20px;
  }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: light) {
  .hex-tooltip,
  .travel-notification,
  .territory-legend,
  .travel-stats,
  .faction-encounter-content {
    background: linear-gradient(135deg, #f0f0f5 0%, #e8e8f0 100%);
    color: #1a1a2e;
  }

  .tooltip-title,
  .territory-legend-title,
  .travel-stats-title,
  .faction-encounter-title {
    color: #0891b2;
  }

  .tooltip-travel,
  .travel-stat,
  .faction-encounter-text {
    color: #4a4a4a;
  }
}
/* ============================================
   PLAYER HUD - ELEGANT CORNER OVERLAY
   ============================================ */

.player-hud {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 900;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* Compact View (always visible) */
.hud-compact {
  background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(15, 52, 96, 0.95) 100%);
  border: 2px solid rgba(77, 208, 225, 0.5);
  border-radius: 12px;
  padding: 15px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(10px);
  min-width: 250px;
  transition: all 0.3s ease;
}

.player-hud:hover .hud-compact {
  border-color: rgba(77, 208, 225, 0.8);
  box-shadow: 0 8px 32px rgba(77, 208, 225, 0.3);
}

/* Header */
.hud-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 15px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(77, 208, 225, 0.3);
}

.hud-avatar {
  font-size: 32px;
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(77, 208, 225, 0.5);
  border-radius: 50%;
}

.hud-name {
  flex: 1;
  font-size: 18px;
  font-weight: 700;
  color: #4dd0e1;
  letter-spacing: 1px;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

/* Stat Bars (Compact) */
.stat-bar.compact {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.stat-bar.compact:last-child {
  margin-bottom: 0;
}

.stat-icon {
  font-size: 20px;
  width: 24px;
  text-align: center;
  flex-shrink: 0;
}

.stat-bar-bg {
  flex: 1;
  height: 14px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(77, 208, 225, 0.3);
  border-radius: 7px;
  overflow: hidden;
  position: relative;
}

.stat-bar-fill {
  height: 100%;
  background: #2ecc71;
  transition: width 0.3s ease, background-color 0.5s ease;
  border-radius: 7px;
  box-shadow: 0 0 10px currentColor;
  position: relative;
  overflow: hidden;
}

/* Shimmer effect on bars */
.stat-bar-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  animation: shimmer 3s infinite;
}

@keyframes shimmer {
  0%, 100% {
    left: -100%;
  }
  50% {
    left: 100%;
  }
}

/* Critical pulse animation */
.stat-bar-fill.critical {
  animation: criticalPulse 1s ease-in-out infinite;
}

@keyframes criticalPulse {
  0%, 100% {
    box-shadow: 0 0 5px currentColor;
  }
  50% {
    box-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
  }
}

/* Expanded View */
.hud-expanded {
  position: absolute;
  top: 0;
  left: 100%;
  margin-left: 15px;
  background: linear-gradient(135deg, rgba(26, 26, 46, 0.98) 0%, rgba(15, 52, 96, 0.98) 100%);
  border: 2px solid rgba(77, 208, 225, 0.5);
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(10px);
  min-width: 300px;
  opacity: 0;
  pointer-events: none;
  transform: translateX(-20px);
  transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

.player-hud.expanded .hud-expanded {
  opacity: 1;
  pointer-events: all;
  transform: translateX(0);
}

/* Sections */
.hud-section {
  margin-bottom: 20px;
}

.hud-section:last-child {
  margin-bottom: 0;
}

.hud-section h3 {
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 2px;
  color: #4dd0e1;
  margin-bottom: 12px;
  text-transform: uppercase;
  border-bottom: 1px solid rgba(77, 208, 225, 0.3);
  padding-bottom: 6px;
}

/* Stat Rows (Expanded) */
.stat-row {
  display: grid;
  grid-template-columns: 80px 1fr 60px;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}

.stat-row:last-child {
  margin-bottom: 0;
}

.stat-label {
  font-size: 13px;
  font-weight: 600;
  color: #e0e0e0;
}

.stat-bar-container {
  flex: 1;
}

.stat-value {
  font-size: 13px;
  font-weight: 700;
  color: #4dd0e1;
  text-align: right;
  font-family: 'Courier New', monospace;
}

/* Status Effects */
.effects-list,
.bonuses-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.effects-empty,
.bonuses-empty {
  font-size: 12px;
  color: #9e9e9e;
  font-style: italic;
  text-align: center;
  padding: 8px;
}

.effect-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border-left: 3px solid;
  border-radius: 4px;
  font-size: 13px;
  transition: all 0.2s;
}

.effect-item:hover {
  background: rgba(0, 0, 0, 0.5);
  transform: translateX(3px);
}

.effect-item.buff {
  border-color: #2ecc71;
}

.effect-item.debuff {
  border-color: #e74c3c;
}

.effect-item.neutral {
  border-color: #3498db;
}

.effect-icon {
  font-size: 16px;
}

.effect-name {
  flex: 1;
  color: #e0e0e0;
  font-weight: 600;
}

.effect-duration {
  color: #9e9e9e;
  font-size: 11px;
  font-family: 'Courier New', monospace;
}

/* Bonuses */
.bonus-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 12px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 13px;
}

.bonus-name {
  color: #e0e0e0;
  font-weight: 600;
}

.bonus-value {
  font-weight: 700;
  font-family: 'Courier New', monospace;
}

.bonus-value.positive {
  color: #2ecc71;
}

.bonus-value.negative {
  color: #e74c3c;
}

/* Survival Time */
.hud-time {
  text-align: center;
  padding: 15px;
  background: rgba(77, 208, 225, 0.1);
  border: 1px solid rgba(77, 208, 225, 0.3);
  border-radius: 8px;
}

.time-label {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  color: #9e9e9e;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.time-value {
  font-size: 24px;
  font-weight: 700;
  color: #4dd0e1;
  font-family: 'Courier New', monospace;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .player-hud {
    top: 10px;
    left: 10px;
  }

  .hud-compact {
    min-width: 200px;
    padding: 12px;
  }

  .hud-expanded {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    margin: 0;
    max-width: 90vw;
    max-height: 80vh;
    overflow-y: auto;
  }

  .player-hud.expanded .hud-expanded {
    transform: translate(-50%, -50%);
  }
}

/* Animations */
@keyframes hudAppear {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.player-hud {
  animation: hudAppear 0.5s ease-out;
}

/* Scrollbar for expanded view */
.hud-expanded::-webkit-scrollbar {
  width: 6px;
}

.hud-expanded::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 3px;
}

.hud-expanded::-webkit-scrollbar-thumb {
  background: rgba(77, 208, 225, 0.5);
  border-radius: 3px;
}

.hud-expanded::-webkit-scrollbar-thumb:hover {
  background: rgba(77, 208, 225, 0.8);
}

/* End Turn Button */
.end-turn-button {
  width: 100%;
  margin-top: 12px;
  padding: 10px 16px;
  background: linear-gradient(135deg, #3bbfce 0%, #0f4c75 100%);
  border: none;
  border-radius: 8px;
  color: #fff;
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 3px 8px rgba(59, 191, 206, 0.3);
}

.end-turn-button:hover {
  box-shadow: 0 4px 12px rgba(59, 191, 206, 0.5);
  transform: translateY(-1px);
}

.end-turn-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(59, 191, 206, 0.4);
}

.end-turn-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Energy Display Styles */
.hud-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.hud-day {
  font-size: 12px;
  color: #3bbfce;
  font-weight: 600;
}

.energy-display {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  margin-top: 8px;
}

.energy-icon {
  font-size: 18px;
}

.energy-value {
  font-size: 14px;
  font-weight: 600;
  color: #2ecc71;
}
/**
 * End Turn Menu Styles
 */

.end-turn-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease-out;
}

.end-turn-menu.hidden {
  display: none;
}

.end-turn-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
}

.end-turn-panel {
  position: relative;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #0f4c75;
  border-radius: 16px;
  padding: 30px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 
    0 10px 40px rgba(0, 0, 0, 0.5),
    0 0 0 1px rgba(255, 255, 255, 0.1) inset;
  animation: slideUp 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.end-turn-title {
  font-size: 28px;
  font-weight: bold;
  color: #3bbfce;
  text-align: center;
  margin: 0 0 10px 0;
  text-shadow: 0 2px 8px rgba(59, 191, 206, 0.3);
}

.end-turn-current-day {
  text-align: center;
  font-size: 16px;
  color: #bbb;
  margin-bottom: 25px;
  padding: 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  font-weight: 600;
}

.end-turn-summary {
  margin-bottom: 20px;
}

.end-turn-section {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 15px;
}

.end-turn-section h3 {
  margin: 0 0 15px 0;
  font-size: 18px;
  color: #3bbfce;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
}

.end-turn-energy-info,
.end-turn-night-info,
.end-turn-location-info {
  font-size: 14px;
}

.end-turn-stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.end-turn-stat-row:last-child {
  border-bottom: none;
}

.end-turn-stat-row.end-turn-result {
  margin-top: 10px;
  padding-top: 15px;
  border-top: 2px solid rgba(59, 191, 206, 0.3);
  font-weight: 600;
  font-size: 15px;
}

.stat-label {
  color: #aaa;
  font-weight: 500;
}

.stat-value {
  font-weight: 600;
  color: #fff;
}

.stat-value.positive {
  color: #2ecc71;
}

.stat-value.negative {
  color: #e74c3c;
}

.stat-value.neutral {
  color: #f39c12;
}

.end-turn-hint {
  margin-top: 12px;
  padding: 10px;
  background: rgba(241, 196, 15, 0.1);
  border-left: 3px solid #f1c40f;
  border-radius: 4px;
  font-size: 13px;
  color: #f1c40f;
  font-style: italic;
}

.end-turn-location-name {
  font-size: 16px;
  font-weight: 600;
  color: #3bbfce;
  margin-bottom: 8px;
}

.end-turn-location-desc {
  font-size: 13px;
  color: #bbb;
  line-height: 1.5;
}

.end-turn-buttons {
  display: flex;
  gap: 12px;
  margin-top: 25px;
}

.end-turn-buttons .btn {
  flex: 1;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.btn-secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #ccc;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.btn-secondary:hover {
  background: rgba(255, 255, 255, 0.15);
  color: #fff;
  transform: translateY(-1px);
}

.btn-primary {
  background: linear-gradient(135deg, #3bbfce 0%, #0f4c75 100%);
  color: #fff;
  box-shadow: 0 4px 12px rgba(59, 191, 206, 0.3);
}

.btn-primary:hover {
  box-shadow: 0 6px 16px rgba(59, 191, 206, 0.4);
  transform: translateY(-2px);
}

.btn-primary:active {
  transform: translateY(0);
}

/* Scrollbar styling */
.end-turn-panel::-webkit-scrollbar {
  width: 8px;
}

.end-turn-panel::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.end-turn-panel::-webkit-scrollbar-thumb {
  background: rgba(59, 191, 206, 0.3);
  border-radius: 4px;
}

.end-turn-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(59, 191, 206, 0.5);
}

/* Mobile responsive */
@media (max-width: 600px) {
  .end-turn-panel {
    padding: 20px;
    max-width: 95%;
  }

  .end-turn-title {
    font-size: 24px;
  }

  .end-turn-section {
    padding: 15px;
  }

  .end-turn-buttons {
    flex-direction: column;
  }
}
/**
 * Tile Interaction UI Styles
 * Two-part panel design for hover info and current tile actions
 */

/* Panel Sections */
.tile-panel-section {
  background: rgba(20, 20, 30, 0.9);
  border: 1px solid rgba(76, 175, 80, 0.3);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
}

.tile-panel-section .section-header {
  border-bottom: 1px solid rgba(76, 175, 80, 0.3);
  padding-bottom: 6px;
  margin-bottom: 10px;
}

.tile-panel-section .section-header h4 {
  margin: 0;
  font-size: 0.9rem;
  color: #4ade80;
  font-weight: 600;
}

.tile-panel-section .section-content {
  font-size: 0.85rem;
  color: #cbd5e1;
}

/* Hover Info (Top Panel) */
.hover-info {
  border-color: rgba(59, 130, 246, 0.4);
}

.hover-info .section-header h4 {
  color: #60a5fa;
}

.hover-tile-info .tile-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.hover-tile-info .terrain-name {
  font-weight: 600;
  color: #e2e8f0;
  font-size: 0.9rem;
}

.hover-tile-info .coordinates {
  font-size: 0.75rem;
  color: #94a3b8;
  font-family: monospace;
}

.hover-tile-info .tile-details {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

.hover-tile-info .elevation {
  font-size: 0.8rem;
  color: #94a3b8;
}

.hover-tile-info .owner-tag {
  font-size: 0.8rem;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.3);
}

.hover-tile-info .owner-tag.neutral {
  color: #94a3b8;
}

.hover-tile-info .poi-icons {
  font-size: 1rem;
  margin-top: 4px;
}

.hover-tile-info .visited-badge,
.hover-tile-info .unvisited-badge {
  display: inline-block;
  font-size: 0.75rem;
  padding: 2px 8px;
  border-radius: 10px;
  margin-top: 4px;
}

.hover-tile-info .visited-badge {
  background: rgba(74, 222, 128, 0.2);
  color: #4ade80;
}

.hover-tile-info .unvisited-badge {
  background: rgba(100, 116, 139, 0.2);
  color: #94a3b8;
}

/* Current Tile (Bottom Panel) */
.current-tile {
  border-color: rgba(76, 175, 80, 0.4);
}

.current-tile .section-header h4 {
  color: #4ade80;
}

.current-tile-info .tile-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.current-tile-info .terrain-name {
  font-weight: 600;
  color: #e2e8f0;
  font-size: 0.9rem;
}

.current-tile-info .coordinates {
  font-size: 0.75rem;
  color: #94a3b8;
  font-family: monospace;
}

.current-tile-info .tile-details {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

.current-tile-info .elevation {
  font-size: 0.8rem;
  color: #94a3b8;
}

.current-tile-info .owner-tag {
  font-size: 0.8rem;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.3);
}

.current-tile-info .owner-tag.neutral {
  color: #94a3b8;
}

.current-tile-info .poi-summary {
  font-size: 0.8rem;
  color: #cbd5e1;
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

/* Action Buttons */
.tile-actions {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(76, 175, 80, 0.2);
}

.actions-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
}

.tile-action-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 10px;
  background: rgba(76, 175, 80, 0.15);
  border: 1px solid rgba(76, 175, 80, 0.4);
  border-radius: 6px;
  color: #4ade80;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.tile-action-btn:hover {
  background: rgba(76, 175, 80, 0.25);
  border-color: rgba(76, 175, 80, 0.6);
  transform: translateY(-1px);
}

.tile-action-btn .action-icon {
  font-size: 1.1rem;
  line-height: 1;
}

.tile-action-btn .action-label {
  flex: 1;
  text-align: left;
}

.tile-action-btn .submenu-indicator {
  font-size: 0.7rem;
  opacity: 0.7;
}

/* Action Type Variants */
.tile-action-btn.primary {
  border-color: rgba(76, 175, 80, 0.5);
  background: rgba(76, 175, 80, 0.15);
  color: #4ade80;
}

.tile-action-btn.social {
  border-color: rgba(59, 130, 246, 0.5);
  background: rgba(59, 130, 246, 0.15);
  color: #60a5fa;
}

.tile-action-btn.construction {
  border-color: rgba(251, 191, 36, 0.5);
  background: rgba(251, 191, 36, 0.15);
  color: #fbbf24;
}

.tile-action-btn.discovery {
  border-color: rgba(139, 92, 246, 0.5);
  background: rgba(139, 92, 246, 0.15);
  color: #a78bfa;
}

.tile-action-btn.strategic {
  border-color: rgba(34, 197, 94, 0.5);
  background: rgba(34, 197, 94, 0.15);
  color: #22c55e;
}

.tile-action-btn.recovery {
  border-color: rgba(96, 165, 250, 0.5);
  background: rgba(96, 165, 250, 0.15);
  color: #60a5fa;
}

.tile-action-btn.combat {
  border-color: rgba(239, 68, 68, 0.5);
  background: rgba(239, 68, 68, 0.15);
  color: #ef4444;
}

/* Action Submenu */
.action-submenu {
  grid-column: 1 / -1;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(76, 175, 80, 0.3);
  border-radius: 6px;
  padding: 4px;
  margin-top: -2px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  max-height: 200px;
  overflow-y: auto;
}

.action-submenu.hidden {
  display: none;
}

.submenu-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  background: rgba(255, 255, 255, 0.05);
  border: none;
  border-radius: 4px;
  color: #cbd5e1;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s ease;
  text-align: left;
}

.submenu-item:hover {
  background: rgba(76, 175, 80, 0.2);
  color: #4ade80;
}

.submenu-item .item-icon {
  font-size: 1rem;
  flex-shrink: 0;
}

.submenu-item .item-label {
  flex: 1;
  font-weight: 500;
}

.submenu-item .item-detail {
  font-size: 0.75rem;
  color: #94a3b8;
}

/* No Actions State */
.no-actions {
  text-align: center;
  padding: 15px;
  color: #64748b;
  font-size: 0.85rem;
  font-style: italic;
}

/* Hint Text */
.hint {
  text-align: center;
  padding: 10px;
  color: #64748b;
  font-size: 0.8rem;
  font-style: italic;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .actions-grid {
    grid-template-columns: 1fr;
  }
  
  .tile-action-btn {
    font-size: 0.8rem;
    padding: 7px 9px;
  }
  
  .tile-action-btn .action-icon {
    font-size: 1rem;
  }
}

@media (max-width: 480px) {
  .tile-panel-section {
    padding: 10px;
  }
  
  .tile-action-btn {
    padding: 6px 8px;
    font-size: 0.75rem;
  }
  
  .hover-tile-info .terrain-name,
  .current-tile-info .terrain-name {
    font-size: 0.85rem;
  }
}
/* Dialogue UI Styles - Full Screen Conversation Interface */

/* Main dialogue container - fullscreen overlay */
.dialogue-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 30, 0.95));
  z-index: 9000;
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.dialogue-container.active {
  display: flex;
  opacity: 1;
}

/* Split layout container */
.dialogue-split {
  display: flex;
  width: 100%;
  height: 100%;
  flex-direction: row;
  gap: 0;
}

/* Left side - NPC Portrait (40% width on desktop, asymmetric) */
.dialogue-portrait-panel {
  flex: 0 0 40%;
  background: linear-gradient(180deg, rgba(30, 30, 40, 0.8), rgba(10, 10, 20, 0.9));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  border-right: 2px solid rgba(139, 69, 19, 0.6);
  position: relative;
  overflow: hidden;
}

/* NPC full body portrait */
.dialogue-npc-portrait {
  width: 100%;
  max-width: 400px;
  height: auto;
  max-height: 80vh;
  object-fit: contain;
  object-position: center bottom;
  filter: drop-shadow(0 0 20px rgba(139, 69, 19, 0.5));
  transition: filter 0.3s ease;
}

.dialogue-npc-portrait:hover {
  filter: drop-shadow(0 0 30px rgba(139, 69, 19, 0.8));
}

/* NPC info overlay on portrait panel */
.dialogue-npc-info {
  position: absolute;
  top: 20px;
  left: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 15px;
  border-radius: 8px;
  border: 1px solid rgba(139, 69, 19, 0.4);
}

.dialogue-npc-name {
  font-size: 1.8em;
  font-weight: bold;
  color: #d4a574;
  margin: 0 0 5px 0;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.dialogue-npc-title {
  font-size: 1.1em;
  color: #a0a0a0;
  margin: 0 0 10px 0;
  font-style: italic;
}

.dialogue-npc-mood {
  font-size: 0.9em;
  color: #8b9dc3;
  margin: 0;
}

/* Relationship indicators */
.dialogue-relationship-bars {
  position: absolute;
  bottom: 20px;
  left: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(139, 69, 19, 0.4);
}

.relationship-stat {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.relationship-stat:last-child {
  margin-bottom: 0;
}

.relationship-label {
  flex: 0 0 80px;
  font-size: 0.85em;
  color: #a0a0a0;
}

.relationship-bar {
  flex: 1;
  height: 8px;
  background: rgba(50, 50, 50, 0.8);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.relationship-fill {
  height: 100%;
  transition: width 0.5s ease;
  border-radius: 4px;
}

.relationship-fill.opinion { background: linear-gradient(90deg, #c44, #4c4); }
.relationship-fill.trust { background: linear-gradient(90deg, #44c, #4cc); }
.relationship-fill.respect { background: linear-gradient(90deg, #c4c, #cc4); }
.relationship-fill.fear { background: linear-gradient(90deg, #888, #f80); }
.relationship-fill.romantic { background: linear-gradient(90deg, #c48, #f4c); }

/* Right side - Conversation Panel (60% width on desktop) */
.dialogue-conversation-panel {
  flex: 0 0 60%;
  background: rgba(15, 15, 25, 0.9);
  display: flex;
  flex-direction: column;
  padding: 0;
  position: relative;
}

/* Header with close button */
.dialogue-header {
  flex: 0 0 auto;
  padding: 15px 20px;
  background: rgba(20, 20, 30, 0.95);
  border-bottom: 2px solid rgba(139, 69, 19, 0.5);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dialogue-header-title {
  font-size: 1.2em;
  color: #d4a574;
  font-weight: bold;
}

.dialogue-close-btn {
  background: rgba(139, 69, 19, 0.3);
  border: 2px solid rgba(139, 69, 19, 0.6);
  color: #d4a574;
  padding: 8px 20px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 1em;
  transition: all 0.2s ease;
}

.dialogue-close-btn:hover {
  background: rgba(139, 69, 19, 0.5);
  border-color: rgba(139, 69, 19, 0.9);
  transform: translateY(-2px);
}

/* Message history area - scrollable */
.dialogue-messages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

/* Individual message bubble */
.dialogue-message {
  display: flex;
  flex-direction: column;
  max-width: 80%;
  animation: messageSlideIn 0.3s ease;
}

@keyframes messageSlideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.dialogue-message.player {
  align-self: flex-end;
  align-items: flex-end;
}

.dialogue-message.npc {
  align-self: flex-start;
  align-items: flex-start;
}

.message-bubble {
  padding: 12px 18px;
  border-radius: 18px;
  font-size: 1em;
  line-height: 1.5;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  word-wrap: break-word;
}

.dialogue-message.player .message-bubble {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.8), rgba(37, 99, 235, 0.9));
  color: #fff;
  border-bottom-right-radius: 4px;
}

.dialogue-message.npc .message-bubble {
  background: linear-gradient(135deg, rgba(139, 69, 19, 0.6), rgba(101, 50, 14, 0.8));
  color: #f0e6d2;
  border-bottom-left-radius: 4px;
  border: 1px solid rgba(139, 69, 19, 0.4);
}

.message-timestamp {
  font-size: 0.7em;
  color: #888;
  margin-top: 4px;
  padding: 0 8px;
}

/* Input area at bottom */
.dialogue-input-area {
  flex: 0 0 auto;
  padding: 20px;
  background: rgba(20, 20, 30, 0.95);
  border-top: 2px solid rgba(139, 69, 19, 0.5);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Quick topic buttons */
.dialogue-topics {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.topic-btn {
  background: rgba(139, 69, 19, 0.3);
  border: 1px solid rgba(139, 69, 19, 0.5);
  color: #d4a574;
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9em;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.topic-btn:hover {
  background: rgba(139, 69, 19, 0.5);
  border-color: rgba(139, 69, 19, 0.8);
  transform: translateY(-2px);
}

.topic-btn:active {
  transform: translateY(0);
}

/* Text input and send button */
.dialogue-input-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}

.dialogue-text-input {
  flex: 1;
  background: rgba(30, 30, 40, 0.9);
  border: 2px solid rgba(139, 69, 19, 0.4);
  color: #f0e6d2;
  padding: 12px 16px;
  border-radius: 25px;
  font-size: 1em;
  outline: none;
  transition: border-color 0.2s ease;
}

.dialogue-text-input:focus {
  border-color: rgba(139, 69, 19, 0.8);
}

.dialogue-text-input::placeholder {
  color: #666;
}

.dialogue-send-btn {
  flex: 0 0 auto;
  background: linear-gradient(135deg, rgba(139, 69, 19, 0.6), rgba(101, 50, 14, 0.8));
  border: 2px solid rgba(139, 69, 19, 0.8);
  color: #d4a574;
  padding: 12px 24px;
  border-radius: 25px;
  cursor: pointer;
  font-size: 1em;
  font-weight: bold;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.dialogue-send-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, rgba(139, 69, 19, 0.8), rgba(101, 50, 14, 1));
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139, 69, 19, 0.5);
}

.dialogue-send-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Response regeneration button */
.dialogue-regenerate-btn {
  background: rgba(100, 100, 120, 0.3);
  border: 1px solid rgba(100, 100, 120, 0.5);
  color: #a0a0d0;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85em;
  margin-top: 5px;
  transition: all 0.2s ease;
}

.dialogue-regenerate-btn:hover {
  background: rgba(100, 100, 120, 0.5);
  border-color: rgba(100, 100, 120, 0.8);
}

/* Loading indicator */
.dialogue-loading {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 18px;
  color: #888;
  font-style: italic;
}

.dialogue-loading-dots {
  display: flex;
  gap: 4px;
}

.loading-dot {
  width: 8px;
  height: 8px;
  background: #666;
  border-radius: 50%;
  animation: loadingPulse 1.4s infinite;
}

.loading-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.loading-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes loadingPulse {
  0%, 80%, 100% {
    opacity: 0.3;
    transform: scale(0.8);
  }
  40% {
    opacity: 1;
    transform: scale(1);
  }
}

/* Mobile landscape optimization (height < 600px) */
@media (max-height: 600px) {
  .dialogue-npc-info {
    padding: 10px;
    top: 10px;
    left: 10px;
    right: 10px;
  }
  
  .dialogue-npc-name {
    font-size: 1.4em;
  }
  
  .dialogue-npc-title {
    font-size: 0.95em;
  }
  
  .dialogue-relationship-bars {
    padding: 8px;
    bottom: 10px;
    left: 10px;
    right: 10px;
  }
  
  .relationship-stat {
    margin-bottom: 4px;
  }
  
  .dialogue-messages {
    padding: 15px;
    gap: 10px;
  }
  
  .dialogue-input-area {
    padding: 12px;
    gap: 8px;
  }
  
  .message-bubble {
    padding: 10px 14px;
    font-size: 0.95em;
  }
}

/* Mobile portrait - stack vertically */
@media (max-width: 768px) and (orientation: portrait) {
  .dialogue-split {
    flex-direction: column;
  }
  
  .dialogue-portrait-panel {
    flex: 0 0 35%;
    border-right: none;
    border-bottom: 2px solid rgba(139, 69, 19, 0.6);
    padding: 10px;
  }
  
  .dialogue-npc-portrait {
    max-height: 30vh;
  }
  
  .dialogue-conversation-panel {
    flex: 0 0 65%;
  }
  
  .dialogue-npc-info {
    position: relative;
    top: auto;
    left: auto;
    right: auto;
    margin-bottom: 10px;
  }
  
  .dialogue-relationship-bars {
    position: relative;
    bottom: auto;
    left: auto;
    right: auto;
    margin-top: 10px;
  }
}

/* Very small screens - minimize portrait */
@media (max-width: 480px) {
  .dialogue-portrait-panel {
    flex: 0 0 25%;
  }
  
  .dialogue-conversation-panel {
    flex: 0 0 75%;
  }
  
  .dialogue-npc-portrait {
    max-height: 20vh;
  }
  
  .dialogue-topics {
    display: none; /* Hide topics on very small screens */
  }
  
  .message-bubble {
    font-size: 0.9em;
    max-width: 90%;
  }
}

/* Scrollbar styling */
.dialogue-messages::-webkit-scrollbar {
  width: 8px;
}

.dialogue-messages::-webkit-scrollbar-track {
  background: rgba(30, 30, 40, 0.5);
}

.dialogue-messages::-webkit-scrollbar-thumb {
  background: rgba(139, 69, 19, 0.5);
  border-radius: 4px;
}

.dialogue-messages::-webkit-scrollbar-thumb:hover {
  background: rgba(139, 69, 19, 0.7);
}</style>
</head>
<body>
  <div id="app">
    <!-- Main Menu (shown on startup) -->
    <div id="main-menu" class="main-menu">
      <div class="menu-container">
        <h1 class="game-title">HEDONISM ISLAND</h1>
        <p class="game-subtitle">Survival ‚Ä¢ Romance ‚Ä¢ Degeneracy</p>
        
        <div class="menu-buttons">
          <button class="menu-btn" id="btn-continue">Continue</button>
          <button class="menu-btn" id="btn-new-game">New Game</button>
          <button class="menu-btn" id="btn-load">Load Game</button>
          <button class="menu-btn secondary" id="btn-clear-saves">üóëÔ∏è Clear Old Saves</button>
          <button class="menu-btn" id="btn-settings">Settings</button>
          <button class="menu-btn" id="btn-credits">Credits</button>
        </div>
        
        <p class="version-info">v3.0.0 - Turn-Based Update</p>
      </div>
      
      <!-- Discord Link Logo -->
      <a href="https://discord.com/invite/E6N9WKpGPA" target="_blank" rel="noopener noreferrer" class="discord-logo-link" title="Join our Discord community!">
        <img src="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20width='4096'%20height='4096'%20viewBox='0%200%204096%204096'%3e%3crect%20x='0'%20y='0'%20width='4096'%20height='4096'%20fill='%230b0c0d'%20/%3e%3cg%20fill='%23b47a3c'%20fill-rule='evenodd'%20stroke='none'%3e%3cpath%20d='M%201686%203585%20L%201646%203585%20L%201646%203592%20L%201650%203596%20L%201650%203608%20L%201624%203660%20L%201613%203660%20L%201611%203657%20L%201610%203641%20L%201605%203617%20L%201605%203601%20L%201615%203592%20L%201615%203585%20L%201563%203585%20L%201563%203593%20L%201571%203604%20L%201577%203626%20L%201591%203697%20L%201591%203713%20L%201574%203744%20L%201560%203762%20L%201549%203762%20L%201543%203758%20L%201534%203758%20L%201530%203761%20L%201528%203765%20L%201528%203776%20L%201532%203781%20L%201536%203783%20L%201550%203783%20L%201566%203774%20L%201578%203762%20L%201600%203730%20L%201623%203688%20L%201667%203615%20L%201678%203600%20L%201686%203593%20Z%20M%202575%203563%20L%202563%203565%20L%202547%203571%20L%202536%203578%20L%202522%203591%20L%202513%203604%20L%202505%203624%20L%202503%203649%20L%202505%203664%20L%202510%203678%20L%202521%203695%20L%202531%203705%20L%202543%203713%20L%202562%203720%20L%202585%203721%20L%202616%203712%20L%202626%203707%20L%202641%203697%20L%202642%203687%20L%202632%203687%20L%202621%203693%20L%202602%203700%20L%202577%203701%20L%202571%203699%20L%202560%203692%20L%202549%203678%20L%202544%203662%20L%202544%203646%20L%202549%203642%20L%202639%203641%20L%202642%203640%20L%202646%203634%20L%202646%203617%20L%202638%203593%20L%202632%203584%20L%202624%203576%20L%202615%203570%20L%202602%203565%20L%202592%203563%20Z%20M%202604%203588%20L%202604%203589%20L%202606%203592%20L%202606%203594%20L%202607%203595%20L%202607%203613%20L%202606%203614%20L%202606%203615%20L%202605%203616%20L%202605%203617%20L%202599%203623%20L%202598%203623%20L%202597%203624%20L%202595%203624%20L%202594%203625%20L%202551%203625%20L%202550%203624%20L%202548%203624%20L%202545%203621%20L%202545%203610%20L%202546%203609%20L%202546%203606%20L%202548%203603%20L%202548%203601%20L%202550%203599%20L%202550%203598%20L%202551%203597%20L%202551%203596%20L%202553%203594%20L%202553%203593%20L%202557%203589%20L%202557%203588%20L%202560%203585%20L%202561%203585%20L%202564%203582%20L%202565%203582%20L%202568%203580%20L%202570%203580%20L%202571%203579%20L%202574%203579%20L%202575%203578%20L%202588%203578%20L%202589%203579%20L%202592%203579%20L%202593%203580%20L%202594%203580%20L%202595%203581%20L%202596%203581%20L%202597%203582%20L%202598%203582%20Z%20M%202383%203562%20L%202382%203563%20L%202371%203564%20L%202355%203569%20L%202342%203576%20L%202325%203591%20L%202317%203602%20L%202309%203620%20L%202306%203633%20L%202306%203650%20L%202312%203672%20L%202317%203682%20L%202325%203693%20L%202336%203704%20L%202351%203713%20L%202359%203715%20L%202369%203720%20L%202380%203722%20L%202392%203722%20L%202393%203721%20L%202405%203720%20L%202417%203715%20L%202427%203713%20L%202435%203709%20L%202442%203704%20L%202457%203689%20L%202465%203677%20L%202470%203665%20L%202473%203653%20L%202474%203632%20L%202472%203622%20L%202465%203604%20L%202458%203593%20L%202446%203581%20L%202436%203574%20L%202415%203565%20L%202398%203563%20L%202397%203562%20Z%20M%202379%203579%20L%202396%203579%20L%202397%203580%20L%202400%203580%20L%202403%203582%20L%202405%203582%20L%202412%203586%20L%202422%203596%20L%202422%203597%20L%202426%203602%20L%202430%203610%20L%202430%203612%20L%202432%203615%20L%202432%203618%20L%202433%203619%20L%202433%203629%20L%202434%203630%20L%202434%203662%20L%202433%203663%20L%202433%203671%20L%202432%203672%20L%202431%203677%20L%202423%203690%20L%202414%203699%20L%202405%203704%20L%202402%203704%20L%202401%203705%20L%202381%203705%20L%202380%203704%20L%202377%203704%20L%202369%203700%20L%202358%203689%20L%202358%203688%20L%202356%203686%20L%202351%203676%20L%202351%203674%20L%202348%203667%20L%202347%203660%20L%202346%203659%20L%202346%203651%20L%202345%203650%20L%202345%203626%20L%202346%203625%20L%202347%203614%20L%202348%203613%20L%202350%203605%20L%202352%203602%20L%202352%203600%20L%202357%203592%20L%202361%203588%20L%202362%203588%20L%202365%203585%20Z%20M%201996%203578%20L%201996%203585%20L%202014%203599%20L%202017%203607%20L%202017%203691%20L%202009%203703%20L%202000%203707%20L%202002%203715%20L%202070%203714%20L%202070%203707%20L%202059%203701%20L%202053%203693%20L%202051%203621%20L%202057%203605%20L%202070%203592%20L%202087%203585%20L%202106%203588%20L%202116%203601%20L%202119%203617%20L%202119%203690%20L%202115%203699%20L%202102%203707%20L%202102%203714%20L%202172%203714%20L%202172%203707%20L%202159%203698%20L%202155%203686%20L%202155%203614%20L%202168%203596%20L%202189%203585%20L%202209%203588%20L%202217%203597%20L%202221%203610%20L%202222%203687%20L%202218%203699%20L%202205%203707%20L%202205%203715%20L%202276%203714%20L%202276%203707%20L%202266%203703%20L%202258%203690%20L%202258%203618%20L%202255%203599%20L%202248%203582%20L%202232%203567%20L%202214%203562%20L%202197%203564%20L%202176%203573%20L%202159%203586%20L%202148%203586%20L%202134%203569%20L%202115%203562%20L%202085%203567%20L%202063%203580%20L%202052%203580%20L%202047%203565%20L%202037%203565%20Z%20M%201456%203506%20L%201422%203510%20L%201416%203513%20L%201416%203521%20L%201422%203523%20L%201426%203527%20L%201426%203544%20L%201411%203617%20L%201408%203646%20L%201402%203666%20L%201401%203681%20L%201398%203690%20L%201398%203699%20L%201400%203703%20L%201409%203711%20L%201432%203719%20L%201449%203719%20L%201460%203715%20L%201468%203714%20L%201483%203707%20L%201494%203699%20L%201506%203687%20L%201519%203668%20L%201526%203651%20L%201529%203637%20L%201529%203617%20L%201526%203606%20L%201518%203593%20L%201511%203587%20L%201494%203581%20L%201480%203581%20L%201462%203588%20L%201450%203587%20L%201450%203570%20L%201459%203520%20L%201459%203509%20Z%20M%201483%203599%20L%201484%203600%20L%201487%203601%20L%201494%203608%20L%201494%203609%20L%201496%203612%20L%201496%203614%20L%201497%203615%20L%201497%203620%20L%201498%203621%20L%201498%203637%20L%201497%203638%20L%201497%203645%20L%201496%203646%20L%201496%203650%20L%201495%203651%20L%201495%203653%20L%201494%203654%20L%201494%203657%20L%201493%203658%20L%201492%203663%20L%201490%203666%20L%201490%203668%20L%201489%203669%20L%201486%203676%20L%201484%203678%20L%201483%203681%20L%201480%203684%20L%201480%203685%20L%201475%203690%20L%201475%203691%20L%201466%203699%20L%201465%203699%20L%201458%203703%20L%201456%203703%20L%201455%203704%20L%201441%203704%20L%201440%203703%20L%201438%203703%20L%201432%203698%20L%201432%203697%20L%201430%203694%20L%201430%203681%20L%201431%203680%20L%201431%203676%20L%201432%203675%20L%201432%203671%20L%201433%203670%20L%201433%203666%20L%201434%203665%20L%201434%203659%20L%201435%203658%20L%201435%203653%20L%201436%203652%20L%201436%203649%20L%201437%203648%20L%201437%203643%20L%201438%203642%20L%201438%203636%20L%201439%203635%20L%201439%203631%20L%201440%203630%20L%201440%203628%20L%201441%203627%20L%201442%203622%20L%201445%203618%20L%201445%203617%20L%201457%203605%20L%201458%203605%20L%201460%203603%20L%201461%203603%20L%201464%203601%20L%201469%203600%20L%201470%203599%20Z%20M%201941%203506%20L%201919%203494%20L%201893%203488%20L%201873%203486%20L%201788%203488%20L%201788%203495%20L%201798%203501%20L%201805%203508%20L%201809%203523%20L%201809%203686%20L%201806%203696%20L%201800%203702%20L%201789%203707%20L%201789%203715%20L%201871%203714%20L%201871%203707%20L%201861%203702%20L%201854%203695%20L%201851%203688%20L%201851%203631%20L%201858%203626%20L%201887%203626%20L%201908%203622%20L%201922%203617%20L%201940%203606%20L%201954%203592%20L%201964%203572%20L%201966%203548%20L%201959%203527%20L%201953%203518%20Z%20M%201859%203503%20L%201879%203503%20L%201880%203504%20L%201884%203504%20L%201885%203505%20L%201888%203505%20L%201889%203506%20L%201891%203506%20L%201892%203507%20L%201894%203507%20L%201896%203508%20L%201898%203510%20L%201901%203511%20L%201904%203514%20L%201905%203514%20L%201912%203521%20L%201912%203522%20L%201916%203527%20L%201920%203535%20L%201920%203538%20L%201921%203539%20L%201921%203545%20L%201922%203546%20L%201922%203568%20L%201921%203569%20L%201921%203576%20L%201920%203577%20L%201920%203580%20L%201918%203584%20L%201916%203586%20L%201916%203587%20L%201913%203590%20L%201913%203591%20L%201905%203599%20L%201904%203599%20L%201901%203602%20L%201893%203606%20L%201891%203606%20L%201887%203608%20L%201883%203608%20L%201882%203609%20L%201858%203609%20L%201857%203608%20L%201855%203608%20L%201851%203604%20L%201851%203602%20L%201850%203601%20L%201850%203513%20L%201851%203512%20L%201851%203510%20L%201852%203508%20L%201855%203505%20Z%20M%201953%203017%20L%201935%203039%20L%201931%203051%20L%201931%203068%20L%201938%203088%20L%201956%203110%20L%201956%203122%20L%201925%203147%20L%201910%203168%20L%201901%203190%20L%201901%203227%20L%201913%203255%20L%201935%203275%20L%201955%203284%20L%201978%203288%20L%202008%203286%20L%202027%203279%20L%202053%203263%20L%202072%203246%20L%202083%203246%20L%202108%203273%20L%202119%203279%20L%202134%203282%20L%202181%203282%20L%202182%203273%20L%202168%203263%20L%202114%203205%20L%202114%203193%20L%202156%203135%20L%202177%203119%20L%202177%203111%20L%202093%203111%20L%202093%203119%20L%202108%203126%20L%202115%203133%20L%202117%203151%20L%202100%203179%20L%202088%203179%20L%202024%203116%20L%202024%203104%20L%202047%203088%20L%202069%203061%20L%202074%203046%20L%202074%203034%20L%202065%203015%20L%202040%203000%20L%202007%202997%20L%201980%203003%20Z%20M%201972%203140%20L%201985%203140%20L%201987%203141%20L%202032%203185%20L%202032%203186%20L%202041%203195%20L%202041%203196%20L%202056%203211%20L%202056%203212%20L%202060%203216%20L%202060%203228%20L%202053%203235%20L%202052%203235%20L%202043%203242%20L%202031%203248%20L%202029%203248%20L%202028%203249%20L%202026%203249%20L%202019%203252%20L%202015%203252%20L%202014%203253%20L%201992%203253%20L%201991%203252%20L%201980%203249%20L%201974%203246%20L%201972%203244%20L%201971%203244%20L%201960%203233%20L%201960%203232%20L%201957%203229%20L%201952%203219%20L%201952%203217%20L%201950%203213%20L%201950%203209%20L%201949%203208%20L%201949%203202%20L%201948%203201%20L%201948%203188%20L%201949%203187%20L%201949%203181%20L%201950%203180%20L%201951%203173%20L%201954%203167%20L%201954%203165%20L%201963%203150%20Z%20M%202019%203017%20L%202020%203018%20L%202022%203018%20L%202023%203019%20L%202024%203019%20L%202026%203021%20L%202027%203021%20L%202035%203029%20L%202035%203030%20L%202037%203032%20L%202037%203033%20L%202038%203034%20L%202038%203036%20L%202040%203039%20L%202040%203055%20L%202039%203056%20L%202039%203058%20L%202038%203059%20L%202038%203061%20L%202037%203062%20L%202037%203063%20L%202036%203064%20L%202036%203065%20L%202035%203066%20L%202035%203067%20L%202034%203068%20L%202033%203071%20L%202031%203073%20L%202031%203074%20L%202027%203078%20L%202027%203079%20L%202017%203089%20L%202016%203089%20L%202013%203092%20L%202012%203092%20L%202009%203094%20L%201998%203094%20L%201997%203093%20L%201996%203093%20L%201987%203084%20L%201987%203083%20L%201984%203080%20L%201984%203079%20L%201982%203077%20L%201981%203074%20L%201979%203072%20L%201979%203070%20L%201977%203067%20L%201977%203065%20L%201976%203064%20L%201976%203062%20L%201975%203061%20L%201975%203058%20L%201974%203057%20L%201974%203045%20L%201975%203044%20L%201975%203041%20L%201976%203040%20L%201976%203038%20L%201978%203035%20L%201978%203033%20L%201980%203031%20L%201980%203030%20L%201982%203028%20L%201982%203027%20L%201985%203024%20L%201986%203024%20L%201991%203020%20L%201992%203020%20L%201993%203019%20L%201995%203019%20L%201996%203018%20L%201999%203018%20L%202000%203017%20Z%20M%202644%202977%20L%202644%202985%20L%202661%202995%20L%202669%203003%20L%202673%203014%20L%202673%203243%20L%202669%203256%20L%202644%203275%20L%202644%203282%20L%202650%203285%20L%202750%203285%20L%202757%203282%20L%202757%203275%20L%202738%203264%20L%202729%203248%20L%202729%203160%20L%202735%203151%20L%202749%203151%20L%202761%203160%20L%202814%203243%20L%202839%203273%20L%202866%203286%20L%202909%203288%20L%202922%203285%20L%202924%203276%20L%202900%203261%20L%202883%203245%20L%202814%203149%20L%202814%203138%20L%202853%203109%20L%202866%203091%20L%202873%203074%20L%202874%203039%20L%202860%203010%20L%202833%202988%20L%202799%202977%20Z%20M%202736%203003%20L%202738%203003%20L%202739%203002%20L%202744%203002%20L%202745%203001%20L%202761%203001%20L%202762%203002%20L%202771%203002%20L%202772%203003%20L%202775%203003%20L%202776%203004%20L%202781%203005%20L%202790%203010%20L%202800%203019%20L%202800%203020%20L%202805%203026%20L%202809%203034%20L%202809%203036%20L%202811%203039%20L%202812%203044%20L%202814%203047%20L%202814%203049%20L%202816%203053%20L%202816%203057%20L%202817%203058%20L%202817%203071%20L%202816%203072%20L%202816%203077%20L%202815%203078%20L%202811%203092%20L%202809%203095%20L%202809%203097%20L%202804%203106%20L%202794%203116%20L%202785%203121%20L%202783%203121%20L%202779%203123%20L%202776%203123%20L%202775%203124%20L%202771%203124%20L%202770%203125%20L%202760%203125%20L%202759%203126%20L%202741%203126%20L%202740%203125%20L%202736%203125%20L%202734%203124%20L%202729%203119%20L%202729%203116%20L%202728%203115%20L%202728%203033%20L%202729%203032%20L%202729%203012%20L%202730%203011%20L%202730%203009%20Z%20M%203521%202976%20L%203522%202985%20L%203544%203001%20L%203549%203028%20L%203548%203246%20L%203542%203259%20L%203523%203274%20L%203523%203282%20L%203733%203284%20L%203739%203281%20L%203750%203235%20L%203750%203215%20L%203742%203215%20L%203706%203252%20L%203695%203257%20L%203616%203257%20L%203606%203247%20L%203606%203143%20L%203610%203137%20L%203671%203137%20L%203684%203143%20L%203699%203159%20L%203706%203159%20L%203708%203155%20L%203708%203093%20L%203705%203087%20L%203698%203087%20L%203684%203101%20L%203668%203108%20L%203614%203109%20L%203607%203104%20L%203607%203007%20L%203620%203001%20L%203694%203002%20L%203707%203011%20L%203720%203037%20L%203730%203040%20L%203733%203035%20L%203731%202977%20L%203726%202974%20Z%20M%203148%202975%20L%203148%202984%20L%203175%203006%20L%203181%203020%20L%203181%203240%20L%203174%203256%20L%203153%203272%20L%203152%203282%20L%203158%203285%20L%203243%203282%20L%203243%203274%20L%203222%203258%20L%203217%203247%20L%203216%203081%20L%203217%203068%20L%203230%203067%20L%203410%203278%20L%203423%203289%20L%203435%203288%20L%203438%203013%20L%203443%203002%20L%203463%202983%20L%203463%202976%20L%203370%202976%20L%203370%202983%20L%203395%203002%20L%203401%203015%20L%203403%203164%20L%203390%203166%20L%203229%202977%20Z%20M%202980%202974%20L%202975%202977%20L%202975%202985%20L%202995%202999%20L%203001%203013%20L%203001%203247%20L%202994%203261%20L%202973%203275%20L%202973%203282%20L%202976%203284%20L%203081%203285%20L%203085%203283%20L%203085%203275%20L%203069%203266%20L%203061%203258%20L%203057%203246%20L%203057%203012%20L%203063%202998%20L%203080%202984%20L%203080%202976%20L%203076%202974%20Z%20M%202525%202989%20L%202499%202978%20L%202473%202973%20L%202343%202974%20L%202339%202976%20L%202339%202984%20L%202354%202993%20L%202363%203002%20L%202368%203015%20L%202368%203243%20L%202362%203256%20L%202340%203274%20L%202342%203283%20L%202471%203284%20L%202500%203281%20L%202521%203275%20L%202543%203264%20L%202562%203248%20L%202575%203231%20L%202585%203197%20L%202584%203179%20L%202580%203164%20L%202570%203146%20L%202556%203131%20L%202527%203114%20L%202527%203103%20L%202547%203084%20L%202556%203068%20L%202560%203051%20L%202558%203030%20L%202544%203005%20Z%20M%202427%203135%20L%202432%203133%20L%202447%203133%20L%202448%203134%20L%202478%203134%20L%202479%203135%20L%202483%203135%20L%202491%203138%20L%202494%203138%20L%202502%203142%20L%202516%203155%20L%202521%203163%20L%202521%203165%20L%202523%203168%20L%202523%203170%20L%202525%203174%20L%202525%203177%20L%202526%203178%20L%202526%203183%20L%202527%203184%20L%202527%203201%20L%202526%203202%20L%202525%203213%20L%202518%203229%20L%202515%203233%20L%202503%203244%20L%202494%203249%20L%202492%203249%20L%202486%203252%20L%202478%203253%20L%202477%203254%20L%202472%203254%20L%202471%203255%20L%202465%203255%20L%202464%203256%20L%202444%203256%20L%202443%203255%20L%202437%203255%20L%202436%203254%20L%202430%203253%20L%202425%203248%20L%202423%203243%20L%202423%203140%20Z%20M%202431%203001%20L%202433%203001%20L%202437%202999%20L%202442%202999%20L%202443%202998%20L%202455%202998%20L%202456%202999%20L%202466%203000%20L%202467%203001%20L%202475%203003%20L%202479%203005%20L%202481%203007%20L%202484%203008%20L%202487%203011%20L%202488%203011%20L%202496%203020%20L%202500%203028%20L%202500%203030%20L%202501%203031%20L%202501%203033%20L%202503%203037%20L%202503%203040%20L%202504%203041%20L%202504%203063%20L%202503%203064%20L%202502%203071%20L%202501%203072%20L%202499%203080%20L%202495%203087%20L%202492%203090%20L%202492%203091%20L%202483%203099%20L%202475%203103%20L%202469%203104%20L%202468%203105%20L%202463%203105%20L%202462%203106%20L%202435%203106%20L%202434%203105%20L%202430%203105%20L%202428%203104%20L%202424%203100%20L%202423%203098%20L%202423%203010%20L%202425%203006%20Z%20M%20423%202972%20L%20423%202981%20L%20452%203009%20L%20449%203132%20L%20438%203248%20L%20407%203274%20L%20408%203282%20L%20502%203282%20L%20502%203273%20L%20482%203259%20L%20475%203245%20L%20483%203078%20L%20495%203079%20L%20588%203283%20L%20602%203288%20L%20629%203239%20L%20700%203074%20L%20713%203078%20L%20724%203250%20L%20698%203274%20L%20698%203282%20L%20809%203281%20L%20809%203274%20L%20789%203262%20L%20780%203247%20L%20770%203126%20L%20766%203012%20L%20771%202999%20L%20794%202982%20L%20793%202973%20L%20707%202975%20L%20616%203187%20L%20605%203187%20L%20506%202972%20Z%20M%201704%202974%20L%201673%202978%20L%201642%202969%20L%201603%202970%20L%201566%202987%20L%201542%203014%20L%201531%203047%20L%201531%203065%20L%201541%203097%20L%201553%203113%20L%201573%203130%20L%201630%203159%20L%201654%203175%20L%201672%203197%20L%201675%203222%20L%201667%203245%20L%201654%203257%20L%201637%203265%20L%201606%203265%20L%201569%203247%20L%201551%203228%20L%201536%203203%20L%201527%203202%20L%201525%203234%20L%201528%203269%20L%201534%203282%20L%201565%203279%20L%201603%203291%20L%201647%203290%20L%201672%203282%20L%201689%203272%20L%201717%203240%20L%201726%203216%20L%201728%203187%20L%201722%203163%20L%201713%203147%20L%201682%203119%20L%201606%203080%20L%201590%203064%20L%201582%203044%20L%201583%203026%20L%201594%203007%20L%201613%202996%20L%201640%202995%20L%201657%203000%20L%201675%203011%20L%201689%203028%20L%201699%203048%20L%201710%203051%20L%201709%202984%20Z%20M%201427%202974%20L%201398%202979%20L%201364%202969%20L%201322%202971%20L%201286%202989%20L%201264%203015%20L%201255%203038%20L%201253%203065%20L%201265%203100%20L%201293%203129%20L%201377%203175%20L%201396%203199%20L%201399%203223%20L%201394%203241%20L%201376%203259%20L%201363%203265%20L%201329%203265%20L%201291%203244%20L%201274%203225%20L%201259%203202%20L%201252%203202%20L%201250%203224%20L%201253%203266%20L%201260%203282%20L%201289%203279%20L%201330%203292%20L%201378%203289%20L%201408%203276%20L%201429%203258%20L%201439%203244%20L%201450%203216%20L%201451%203182%20L%201445%203161%20L%201437%203148%20L%201405%203119%20L%201327%203080%20L%201312%203065%20L%201305%203048%20L%201306%203025%20L%201317%203007%20L%201341%202995%20L%201363%202995%20L%201398%203011%20L%201409%203023%20L%201422%203048%20L%201432%203051%20L%201433%202992%20Z%20M%201065%202973%20L%201037%202969%20L%201001%202970%20L%20971%202976%20L%20929%202994%20L%20904%203012%20L%20882%203035%20L%20869%203055%20L%20859%203077%20L%20853%203099%20L%20850%203138%20L%20854%203164%20L%20862%203190%20L%20881%203224%20L%20902%203248%20L%20922%203263%20L%20956%203280%20L%20997%203289%20L%201035%203289%20L%201061%203284%20L%201092%203273%20L%201127%203252%20L%201151%203230%20L%201169%203205%20L%201181%203179%20L%201189%203146%20L%201190%203117%20L%201185%203087%20L%201169%203049%20L%201150%203023%20L%201126%203001%20L%201093%202982%20Z%20M%20999%202998%20L%201032%202998%20L%201041%203000%20L%201063%203008%20L%201081%203019%20L%201099%203038%20L%201111%203059%20L%201117%203075%20L%201125%203115%20L%201125%203152%20L%201121%203177%20L%201115%203197%20L%201103%203221%20L%201085%203241%20L%201075%203248%20L%201058%203256%20L%201030%203264%20L%201014%203264%20L%20980%203254%20L%20962%203244%20L%20944%203226%20L%20933%203209%20L%20924%203188%20L%20915%203144%20L%20915%203114%20L%20918%203088%20L%20926%203062%20L%20935%203043%20L%20946%203028%20L%20964%203011%20L%20978%203004%20Z%20M%201873%202470%20L%201873%202479%20L%201881%202489%20L%201937%202527%20L%201980%202546%20L%202013%202554%20L%202034%202556%20L%202084%202554%20L%202127%202543%20L%202173%202521%20L%202216%202492%20L%202228%202479%20L%202226%202468%20L%202214%202456%20L%202191%202440%20L%202166%202426%20L%202125%202408%20L%202100%202401%20L%202073%202397%20L%202027%202397%20L%202002%202401%20L%201967%202411%20L%201944%202421%20L%201909%202440%20L%201882%202459%20Z%20M%203100%201715%20L%203089%201716%20L%203075%201728%20L%202999%201772%20L%202999%201780%20L%203025%201811%20L%203048%201851%20L%203057%201882%20L%203059%201928%20L%203056%201947%20L%203048%201972%20L%203037%201994%20L%203025%202011%20L%203001%202033%20L%202978%202047%20L%202949%202055%20L%202932%202057%20L%202932%202065%20L%202938%202071%20L%202958%202082%20L%202979%202087%20L%203013%202086%20L%203044%202077%20L%203077%202059%20L%203097%202043%20L%203125%202012%20L%203144%201981%20L%203154%201959%20L%203162%201932%20L%203167%201901%20L%203167%201860%20L%203162%201827%20L%203155%201803%20L%203135%201759%20L%203119%201736%20Z%20M%20998%201714%20L%20974%201741%20L%20956%201772%20L%20945%201797%20L%20934%201837%20L%20931%201890%20L%20937%201931%20L%20945%201958%20L%20964%201997%20L%20979%202018%20L%201001%202042%20L%201031%202065%20L%201057%202078%20L%201085%202086%20L%201119%202087%20L%201143%202081%20L%201162%202070%20L%201167%202065%20L%201167%202057%20L%201124%202048%20L%201089%202026%20L%201072%202008%20L%201059%201988%20L%201048%201963%20L%201042%201940%20L%201041%201892%20L%201050%201855%20L%201071%201815%20L%201100%201781%20L%201100%201772%20L%201048%201743%20L%201007%201714%20Z%20M%201298%201439%20L%201281%201550%20L%201339%201659%20L%201382%201474%20L%201458%201467%20L%201526%201534%20L%201414%201665%20L%201336%201846%20L%201251%202384%20L%201523%202598%20L%201795%202734%20L%201475%202454%20L%201354%202226%20L%201362%202072%20L%201432%201933%20L%201422%202123%20L%201486%202273%20L%201532%202170%20L%201582%202335%20L%201722%202445%20L%201730%202169%20L%201814%201900%20L%201726%201885%20L%201669%201797%20L%201614%201784%20L%201683%201746%20L%201844%201757%20L%201912%201808%20L%201801%202187%20L%201822%202419%20L%202002%202311%20L%201999%202216%20L%201904%202204%20L%201883%202132%20L%201927%202066%20L%202042%202041%20L%202175%202067%20L%202217%202130%20L%202199%202202%20L%202099%202218%20L%202100%202316%20L%202292%202408%20L%202298%202182%20L%202187%201821%20L%202223%201769%20L%202387%201743%20L%202485%201771%20L%202369%201886%20L%202284%201900%20L%202369%202165%20L%202377%202444%20L%202517%202336%20L%202564%202168%20L%202612%202276%20L%202642%202244%20L%202677%201927%20L%202752%202143%20L%202717%202321%20L%202579%202503%20L%202304%202732%20L%202612%202575%20L%202847%202390%20L%202770%201868%20L%202686%201668%20L%202574%201533%20L%202640%201467%20L%202718%201476%20L%202760%201660%20L%202818%201483%20L%202744%201381%20L%202606%201364%20L%202474%201467%20L%202133%201405%20L%201886%201410%20L%201627%201467%20L%201539%201383%20L%201429%201357%20Z%20M%202903%20807%20L%202826%20814%20L%202771%20842%20L%202735%20883%20L%202709%20961%20L%202713%201031%20L%202744%201101%20L%202790%201153%20L%202913%201247%20L%202960%201292%20L%203009%201373%20L%203013%201438%20L%202993%201498%20L%202953%201540%20L%202869%201587%20L%202844%201649%20L%202809%201704%20L%202813%201715%20L%202846%201720%20L%202903%201717%20L%202967%201701%20L%203022%201677%20L%203073%201642%20L%203108%201606%20L%203137%201561%20L%203158%201509%20L%203168%201448%20L%203155%201349%20L%203133%201296%20L%203102%201247%20L%203019%201165%20L%202870%201065%20L%202835%201018%20L%202829%20968%20L%202840%20929%20L%202865%20903%20L%202907%20893%20L%202961%20900%20L%203012%20936%20L%203029%20978%20L%203014%201044%20L%203032%201046%20L%203054%201037%20L%203081%20998%20L%203081%20935%20L%203051%20880%20L%203023%20853%20L%202973%20824%20Z%20M%201209%20806%20L%201133%20821%20L%201064%20863%20L%201019%20930%20L%201017%20995%20L%201045%201037%20L%201067%201046%20L%201086%201044%20L%201070%20983%20L%201087%20936%20L%201139%20899%20L%201204%20894%20L%201239%20906%20L%201263%20936%20L%201271%20987%20L%201262%201023%20L%201228%201065%20L%201074%201169%20L%201003%201239%20L%20969%201290%20L%20946%201343%20L%20933%201400%20L%20932%201451%20L%20954%201544%20L%20983%201596%20L%201019%201637%20L%201118%201696%20L%201195%201717%20L%201250%201720%20L%201284%201715%20L%201288%201704%20L%201254%201648%20L%201234%201595%20L%201222%201581%20L%201146%201540%20L%201115%201511%20L%201090%201463%20L%201086%201389%20L%201103%201341%20L%201135%201295%20L%201189%201244%20L%201301%201159%20L%201344%201113%20L%201381%201042%20L%201390%20973%20L%201373%20902%20L%201330%20845%20L%201271%20813%20Z%20M%201205%201414%20L%201209%201468%20L%201225%201485%20L%201250%201409%20L%201305%201342%20L%201401%201294%20L%201511%201293%20L%201590%201228%20L%201639%201144%20L%201652%201148%20L%201639%201227%20L%201564%201326%20L%201631%201383%20L%201733%201332%20L%201788%201216%20L%201801%201219%20L%201805%201265%20L%201776%201365%20L%201822%201370%20L%201891%201342%20L%201975%201243%20L%202037%201213%20L%202110%201231%20L%202203%201337%20L%202276%201370%20L%202324%201365%20L%202294%201271%20L%202297%201220%20L%202310%201216%20L%202365%201330%20L%202468%201383%20L%202536%201326%20L%202464%201232%20L%202449%201147%20L%202462%201145%20L%202503%201218%20L%202599%201297%20L%202681%201290%20L%202760%201318%20L%202837%201387%20L%202875%201484%20L%202894%201452%20L%202888%201390%20L%202846%201315%20L%202766%201250%20L%202607%201176%20L%202555%201107%20L%202541%20991%20L%202582%20700%20L%202559%20598%20L%202509%20503%20L%202427%20413%20L%202321%20342%20L%202202%20297%20L%202070%20279%20L%201943%20289%20L%201807%20331%20L%201684%20406%20L%201597%20497%20L%201549%20583%20L%201521%20685%20L%201522%20796%20L%201559%201001%20L%201540%201118%20L%201477%201187%20L%201285%201284%20L%201232%201344%20Z%20M%202458%20905%20L%202458%20916%20L%202453%20921%20L%202429%20934%20L%202420%20941%20L%202417%20948%20L%202416%20977%20L%202405%201014%20L%202392%201037%20L%202373%201055%20L%202362%201061%20L%202342%201068%20L%202318%201073%20L%202304%201074%20L%202270%201073%20L%202251%201068%20L%202230%201059%20L%202218%201059%20L%202207%201069%20L%202197%201083%20L%202185%201082%20L%202187%201057%20L%202195%201033%20L%202206%201012%20L%202229%20981%20L%202241%20969%20L%202266%20950%20L%202293%20937%20L%202335%20925%20L%202440%20903%20L%202455%20903%20Z%20M%201642%20904%20L%201659%20903%20L%201676%20906%20L%201705%20914%20L%201768%20927%20L%201808%20939%20L%201836%20954%20L%201850%20964%20L%201869%20982%20L%201893%201013%20L%201909%201048%20L%201913%201062%20L%201914%201083%20L%201902%201084%20L%201890%201067%20L%201881%201059%20L%201870%201059%20L%201848%201068%20L%201828%201073%20L%201795%201074%20L%201781%201073%20L%201753%201067%20L%201724%201054%20L%201706%201036%20L%201693%201011%20L%201686%20986%20L%201682%20961%20L%201682%20947%20L%201680%20942%20L%201670%20934%20L%201645%20919%20L%201642%20916%20Z'%20/%3e%3c/g%3e%3c/svg%3e" alt="Moss and Brine Logo" class="menu-logo" />
      </a>
    </div>
    
    <!-- Character Creation (shown after New Game) -->
    <div id="character-creation"></div>
    
    <!-- Story Intro (shown after character creation) -->
    <div id="story-intro" class="hidden"></div>
    
    <!-- Game View (shown after intro) -->
    <div id="game-view" class="hidden"></div>
  </div>
  
</body>
</html>
