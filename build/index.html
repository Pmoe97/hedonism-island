<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hedonism Island</title>
  
  <!-- Perchance Bridge Script - Exposes Perchance functions to our bundled module -->
  <script>
    // When loaded in Perchance, these functions are available in the global scope
    // We expose them on window so our ES module can access them
    (function() {
      // Wait for Perchance plugins to be available
      const waitForPerchance = setInterval(() => {
        // Check if Perchance functions exist in global scope
        if (typeof generateImage === 'function') {
          window.generateImage = generateImage;
          console.log('‚úÖ Perchance generateImage exposed to window');
        }
        if (typeof generateText === 'function') {
          window.generateText = generateText;
          console.log('‚úÖ Perchance generateText exposed to window');
        }
        if (typeof kv !== 'undefined') {
          window.kv = kv;
          console.log('‚úÖ Perchance kv exposed to window');
        }
        
        // Stop checking once all are found
        if (window.generateImage && window.generateText && window.kv) {
          clearInterval(waitForPerchance);
          console.log('üéâ All Perchance plugins ready!');
        }
      }, 100);
      
      // Stop checking after 5 seconds if not found
      setTimeout(() => {
        clearInterval(waitForPerchance);
        if (!window.generateImage) {
          console.warn('‚ö†Ô∏è Perchance plugins not detected - running in standalone mode');
        }
      }, 5000);
    })();
  </script>
  <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
class PerchanceAI {
  constructor() {
    this.isReady = true;
    console.log("‚úÖ Perchance AI Ready");
    this.debugPerchanceAvailability();
  }
  /**
   * Debug helper to check what Perchance functions are available
   */
  debugPerchanceAvailability() {
    const checks = {
      "window.generateImage": typeof window.generateImage,
      "window.generateText": typeof window.generateText,
      "window.kv": typeof window.kv,
      "globalThis.generateImage": typeof globalThis.generateImage,
      "globalThis.generateText": typeof globalThis.generateText
    };
    console.group("üîç Perchance Availability Check");
    for (const [key, type] of Object.entries(checks)) {
      const icon = type === "function" || type === "object" ? "‚úÖ" : "‚ùå";
      console.log(`${icon} ${key}: ${type}`);
    }
    const generateProps = Object.keys(window).filter((k) => k.toLowerCase().includes("generate"));
    if (generateProps.length > 0) {
      console.log('üìã Window properties containing "generate":', generateProps);
    }
    console.groupEnd();
  }
  /**
   * Generate text using ai-text-plugin
   * @param {string} prompt - The instruction for text generation
   * @param {object} options - Optional parameters (temperature, max_tokens, etc.)
   * @returns {Promise<string>} Generated text
   */
  async generateText(prompt2, options = {}) {
    try {
      const result = await window.generateText(prompt2, options);
      return result;
    } catch (error) {
      console.error("Text generation failed:", error);
      throw new Error(`Failed to generate text: ${error.message}`);
    }
  }
  /**
   * Generate image using text-to-image-plugin
   * @param {string|object} promptInput - The image description (string) or prompt object
   * @returns {Promise<string>} Image URL or data URI
   */
  async generateImage(promptInput) {
    try {
      const generateImageFn = window.generateImage;
      if (typeof generateImageFn !== "function") {
        console.warn("‚ùå Perchance generateImage not found on window");
        console.warn(
          'üìã Available window properties with "generate":',
          Object.keys(window).filter((k) => k.toLowerCase().includes("generate"))
        );
        return this.getPlaceholderImage();
      }
      console.log(
        "‚úÖ Calling window.generateImage with:",
        typeof promptInput === "object" ? promptInput.prompt?.slice(0, 60) : String(promptInput).slice(0, 60)
      );
      const result = await generateImageFn(promptInput);
      const imageUrl = result?.dataUrl || result?.toString() || result;
      console.log("‚úÖ Image generated:", imageUrl ? String(imageUrl).slice(0, 60) + "..." : "null");
      return imageUrl;
    } catch (error) {
      console.error("‚ùå Image generation error:", error);
      console.warn("Falling back to placeholder");
      return this.getPlaceholderImage();
    }
  }
  /**
   * Generate placeholder image when Perchance is unavailable
   * @returns {string} Data URI for placeholder SVG
   */
  getPlaceholderImage() {
    const svg = `<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
          <stop offset="100%" style="stop-color:#2196F3;stop-opacity:1" />
        </linearGradient>
      </defs>
      <circle cx="200" cy="200" r="180" fill="url(#grad)" opacity="0.3"/>
      <text x="200" y="180" font-family="Arial, sans-serif" font-size="120" fill="#4CAF50" text-anchor="middle" font-weight="bold">?</text>
      <text x="200" y="250" font-family="Arial, sans-serif" font-size="24" fill="#fff" text-anchor="middle">Portrait Coming Soon</text>
    </svg>`;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  /**
   * Save data persistently using kv-plugin
   * @param {string} key - Storage key
   * @param {any} value - Value to store
   */
  async saveData(key, value) {
    try {
      await window.kv.set(key, value);
      return true;
    } catch (error) {
      console.error("Save failed:", error);
      return false;
    }
  }
  /**
   * Load data from kv-plugin
   * @param {string} key - Storage key
   * @returns {Promise<any>} Stored value
   */
  async loadData(key) {
    try {
      return await window.kv.get(key);
    } catch (error) {
      console.error("Load failed:", error);
      return null;
    }
  }
  /**
   * Generate character profile with AI
   * @param {string} faction - castaway, islander, mercenary, tourist
   * @param {string} gender - Gender from settings
   * @returns {Promise<object>} Character profile
   */
  async generateCharacter(faction, gender) {
    const genderLabel = {
      female: "woman",
      male: "man",
      futanari: "futanari",
      transWoman: "trans woman",
      transMale: "trans man"
    }[gender] || "person";
    const factionDesc = {
      castaway: "a fellow castaway who washed up on the island",
      islander: "a native islander, initially cautious of outsiders",
      mercenary: "a mercenary, hostile and dangerous",
      tourist: "a tourist visiting the island resort"
    }[faction] || "a person";
    const prompt2 = `Generate a detailed character profile for ${genderLabel} who is ${factionDesc}. Include:
- Name (first and last)
- Age (18-45)
- Physical description (2-3 sentences, be explicit and detailed)
- Personality traits (3-4 traits)
- Background story (2-3 sentences)
- Sexual preferences/kinks (2-3, be explicit)
- Skills (2-3 relevant skills)

Format as JSON with keys: name, age, description, personality, background, kinks, skills (array).`;
    try {
      const response = await this.generateText(prompt2, {
        temperature: 0.9,
        max_tokens: 500
      });
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("Failed to parse character data");
      }
    } catch (error) {
      console.error("Character generation failed:", error);
      return {
        name: `${gender} ${faction}`,
        age: 25,
        description: "A mysterious person.",
        personality: ["friendly", "adventurous"],
        background: "Their past is unknown.",
        kinks: ["vanilla"],
        skills: ["survival"]
      };
    }
  }
  /**
   * Apply consistent art style to image prompts
   * Based on user's settings preference
   * @param {string} basePrompt - Base image description
   * @returns {object} Prompt object for generateImage
   */
  applyImageStyle(basePrompt) {
    const selectedStyle = window.gameState?.settings?.imageStyle || "photorealistic";
    const styleDirectives = {
      photorealistic: "photorealistic, highly detailed, 8k quality, professional photography, natural lighting, sharp focus, realistic textures",
      anime: "anime style, manga aesthetic, cel shaded, vibrant colors, clean lines, Japanese animation style, expressive features",
      artistic: "artistic style, painterly aesthetic, impressionist, brush strokes, artistic interpretation, creative composition, gallery quality",
      cartoon: "cartoon style, comic book aesthetic, bold outlines, simplified shapes, bright colors, animated style, character illustration",
      cinematic: "cinematic lighting, movie scene, dramatic composition, film quality, depth of field, atmospheric, professional cinematography"
    };
    const directive = styleDirectives[selectedStyle] || styleDirectives.photorealistic;
    const hasStyle = basePrompt.toLowerCase().includes(selectedStyle.toLowerCase());
    const styledPrompt = hasStyle ? basePrompt : `${basePrompt}, ${directive}`;
    console.log(`[Image Style] Selected: ${selectedStyle}`);
    return { prompt: styledPrompt };
  }
  /**
   * Generate character portrait image
   * @param {object} character - Character object
   * @param {string} styleOverride - Optional style override
   * @returns {Promise<string>} Portrait URL
   */
  async generatePortrait(character, styleOverride = null) {
    const appearance = character.appearance || {};
    const body = appearance.body || {};
    const face = appearance.face || {};
    const hair = appearance.hair || {};
    const genderDesc = {
      female: "woman",
      male: "man",
      futanari: "futanari",
      Cuntboy: "Cuntboy",
      other: "person"
    }[character.gender] || "person";
    const buildDesc = {
      petite: "petite, slender build",
      slim: "slim, athletic build",
      average: "average build",
      athletic: "athletic, toned build",
      curvy: "curvy, voluptuous build",
      muscular: "muscular, powerful build",
      heavyset: "heavyset, robust build"
    }[body.build] || "average build";
    const skinDesc = body.skinTone || "fair skin";
    const hairDesc = `${hair.length || "medium"} ${hair.color || "brown"} hair${hair.style ? ", " + hair.style : ""}`;
    const eyeDesc = `${face.eyeColor || "brown"} eyes`;
    const ageDesc = character.age ? `${character.age} years old` : "young adult";
    const heightDesc = body.height ? `, ${body.height}cm tall` : "";
    const basePrompt = `Portrait of a ${genderDesc}, ${ageDesc}, ${buildDesc}, ${skinDesc}, ${hairDesc}, ${eyeDesc}${heightDesc}, attractive face, confident expression, tropical island vacation attire, isolated on transparent background, profile portrait, studio lighting`;
    const styledPrompt = this.applyImageStyle(basePrompt);
    console.log("[Portrait] Generating with prompt:", styledPrompt.prompt.slice(0, 100) + "...");
    return await this.generateImage(styledPrompt);
  }
  // Generate image from custom prompt (used by character creator)
  async generateImageFromPrompt(prompt2, styleOverride = null) {
    const styledPrompt = this.applyImageStyle(prompt2);
    console.log("[Custom Portrait] Generating with prompt:", styledPrompt.prompt.slice(0, 150) + "...");
    return await this.generateImage(styledPrompt);
  }
}
class SceneEngine {
  constructor(scenes2, aiProvider) {
    this.scenes = scenes2;
    this.ai = aiProvider;
    this.currentScene = "start";
    this.state = {
      variables: {},
      inventory: [],
      characters: {}
    };
  }
  start() {
    this.renderScene(this.currentScene);
  }
  renderScene(sceneId) {
    const scene = this.scenes[sceneId];
    if (!scene) {
      console.error(`Scene "${sceneId}" not found`);
      return;
    }
    const sceneContainer = document.getElementById("scene-container");
    const choicesContainer = document.getElementById("choices-container");
    sceneContainer.innerHTML = "";
    choicesContainer.innerHTML = "";
    const textEl = document.createElement("div");
    textEl.innerHTML = this.processText(scene.text);
    sceneContainer.appendChild(textEl);
    if (scene.image) {
      this.renderImage(sceneContainer, scene.image);
    }
    if (scene.choices) {
      scene.choices.forEach((choice, index) => {
        const button = document.createElement("button");
        button.className = "choice-button";
        button.textContent = choice.text;
        button.onclick = () => this.makeChoice(choice);
        choicesContainer.appendChild(button);
      });
    }
    if (scene.aiGenerate) {
      this.addAIButtons(choicesContainer, scene.aiGenerate);
    }
  }
  processText(text) {
    return text.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return this.state.variables[varName] || match;
    });
  }
  renderImage(container, imageConfig) {
    const imgEl = document.createElement("img");
    imgEl.src = imageConfig.url || imageConfig;
    imgEl.alt = imageConfig.alt || "Scene image";
    imgEl.style.maxWidth = "100%";
    imgEl.style.borderRadius = "8px";
    imgEl.style.marginTop = "20px";
    container.appendChild(imgEl);
  }
  addAIButtons(container, config) {
    if (config.text) {
      const btn = document.createElement("button");
      btn.className = "choice-button";
      btn.textContent = "‚ú® Generate Text";
      btn.onclick = async () => {
        btn.textContent = "‚è≥ Generating...";
        btn.disabled = true;
        try {
          const result = await this.ai.generateText(config.text.prompt, config.text.options);
          alert(result);
        } catch (e) {
          alert("Error: " + e);
        }
        btn.disabled = false;
        btn.textContent = "‚ú® Generate Text";
      };
      container.appendChild(btn);
    }
    if (config.image) {
      const btn = document.createElement("button");
      btn.className = "choice-button";
      btn.textContent = "üé® Generate Image";
      btn.onclick = async () => {
        btn.textContent = "‚è≥ Generating...";
        btn.disabled = true;
        try {
          const imageUrl = await this.ai.generateImage(config.image.prompt);
          const img = document.createElement("img");
          img.src = imageUrl;
          img.style.maxWidth = "100%";
          img.style.borderRadius = "8px";
          img.style.marginTop = "20px";
          document.getElementById("scene-container").appendChild(img);
        } catch (e) {
          alert("Error: " + e);
        }
        btn.disabled = false;
        btn.textContent = "üé® Generate Image";
      };
      container.appendChild(btn);
    }
  }
  makeChoice(choice) {
    if (choice.action) {
      this.executeAction(choice.action);
    }
    if (choice.next) {
      this.currentScene = choice.next;
      this.renderScene(choice.next);
    }
  }
  executeAction(action) {
    if (action.setVariable) {
      Object.assign(this.state.variables, action.setVariable);
    }
    if (action.addItem) {
      this.state.inventory.push(action.addItem);
    }
  }
}
class InventorySlot {
  constructor() {
    this.item = null;
    this.quantity = 0;
  }
  /**
   * Add items to this slot
   * @returns {number} Number of items that couldn't be added
   */
  add(item, quantity = 1) {
    if (!this.item) {
      this.item = item;
      this.quantity = quantity;
      return 0;
    }
    if (this.item.canStack(item)) {
      const space = this.item.maxStack - this.quantity;
      const toAdd = Math.min(space, quantity);
      this.quantity += toAdd;
      return quantity - toAdd;
    }
    return quantity;
  }
  /**
   * Remove items from this slot
   * @returns {number} Number of items actually removed
   */
  remove(quantity = 1) {
    const removed = Math.min(this.quantity, quantity);
    this.quantity -= removed;
    if (this.quantity <= 0) {
      this.item = null;
      this.quantity = 0;
    }
    return removed;
  }
  /**
   * Check if slot is empty
   */
  isEmpty() {
    return this.item === null || this.quantity <= 0;
  }
  /**
   * Check if slot is full
   */
  isFull() {
    if (!this.item) return false;
    return this.quantity >= this.item.maxStack;
  }
  /**
   * Get available space in slot
   */
  getAvailableSpace() {
    if (!this.item) return Infinity;
    return this.item.maxStack - this.quantity;
  }
  /**
   * Clear the slot
   */
  clear() {
    this.item = null;
    this.quantity = 0;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    if (this.isEmpty()) return null;
    return {
      itemId: this.item.id,
      quantity: this.quantity,
      durability: this.item.durability
    };
  }
}
class Inventory {
  constructor(capacity = 20, maxWeight = 100) {
    this.capacity = capacity;
    this.maxWeight = maxWeight;
    this.slots = [];
    for (let i = 0; i < capacity; i++) {
      this.slots.push(new InventorySlot());
    }
    this.equipment = {
      weapon: null,
      tool: null,
      clothing: null,
      backpack: null
    };
  }
  /**
   * Add item to inventory
   */
  addItem(item, quantity = 1) {
    if (quantity <= 0) return false;
    let remaining = quantity;
    if (item.stackable) {
      for (let slot of this.slots) {
        if (slot.item && slot.item.canStack(item) && !slot.isFull()) {
          remaining = slot.add(item, remaining);
          if (remaining === 0) return true;
        }
      }
    }
    while (remaining > 0) {
      const emptySlot = this.slots.find((s) => s.isEmpty());
      if (!emptySlot) {
        console.warn("Inventory full! Could not add all items.");
        return false;
      }
      const toAdd = item.stackable ? Math.min(remaining, item.maxStack) : 1;
      emptySlot.add(item.clone(), toAdd);
      remaining -= toAdd;
    }
    return true;
  }
  /**
   * Remove item from inventory
   */
  removeItem(itemId, quantity = 1) {
    let remaining = quantity;
    for (let slot of this.slots) {
      if (slot.item && slot.item.id === itemId) {
        const removed = slot.remove(remaining);
        remaining -= removed;
        if (remaining === 0) return true;
      }
    }
    return remaining < quantity;
  }
  /**
   * Check if inventory has item
   */
  hasItem(itemId, quantity = 1) {
    return this.getItemCount(itemId) >= quantity;
  }
  /**
   * Get total count of an item
   */
  getItemCount(itemId) {
    return this.slots.filter((s) => s.item && s.item.id === itemId).reduce((sum, s) => sum + s.quantity, 0);
  }
  /**
   * Get first slot containing item
   */
  findItem(itemId) {
    return this.slots.findIndex((s) => s.item && s.item.id === itemId);
  }
  /**
   * Get all slots containing item
   */
  findAllItems(itemId) {
    return this.slots.map((slot, index) => ({ slot, index })).filter(({ slot }) => slot.item && slot.item.id === itemId);
  }
  /**
   * Calculate total weight
   */
  getTotalWeight() {
    let weight = this.slots.filter((s) => !s.isEmpty()).reduce((sum, s) => sum + s.item.weight * s.quantity, 0);
    Object.values(this.equipment).forEach((item) => {
      if (item) weight += item.weight;
    });
    return weight;
  }
  /**
   * Check if inventory is full
   */
  isFull() {
    return this.slots.every((s) => !s.isEmpty());
  }
  /**
   * Check if inventory has space for item
   */
  hasSpaceFor(item, quantity = 1) {
    if (this.isFull() && !item.stackable) return false;
    if (item.stackable) {
      let availableSpace = 0;
      for (let slot of this.slots) {
        if (slot.isEmpty()) {
          availableSpace += item.maxStack;
        } else if (slot.item && slot.item.canStack(item)) {
          availableSpace += slot.getAvailableSpace();
        }
      }
      return availableSpace >= quantity;
    }
    const emptySlots = this.slots.filter((s) => s.isEmpty()).length;
    return emptySlots >= quantity;
  }
  /**
   * Equip an item
   */
  equip(item, slotType) {
    if (!item.equippable) {
      console.warn(`${item.name} cannot be equipped`);
      return false;
    }
    if (this.equipment[slotType]) {
      const unequipped = this.equipment[slotType];
      if (!this.addItem(unequipped)) {
        console.warn("Inventory full, cannot unequip item");
        return false;
      }
    }
    this.equipment[slotType] = item;
    this.removeItem(item.id, 1);
    console.log(`Equipped ${item.name} in ${slotType} slot`);
    return true;
  }
  /**
   * Unequip an item
   */
  unequip(slotType) {
    const item = this.equipment[slotType];
    if (!item) return false;
    if (!this.addItem(item)) {
      console.warn("Inventory full, cannot unequip item");
      return false;
    }
    this.equipment[slotType] = null;
    console.log(`Unequipped ${item.name} from ${slotType} slot`);
    return true;
  }
  /**
   * Get equipped item in slot
   */
  getEquipped(slotType) {
    return this.equipment[slotType];
  }
  /**
   * Use item from inventory
   */
  useItem(slotIndex, player2) {
    const slot = this.slots[slotIndex];
    if (slot.isEmpty()) return false;
    const item = slot.item;
    const wasUsed = item.use(player2);
    if (wasUsed && item.consumable) {
      slot.remove(1);
    }
    return wasUsed;
  }
  /**
   * Drop item from inventory
   */
  dropItem(slotIndex, quantity = 1) {
    const slot = this.slots[slotIndex];
    if (slot.isEmpty()) return null;
    const item = slot.item.clone();
    const dropped = slot.remove(quantity);
    return { item, quantity: dropped };
  }
  /**
   * Swap two inventory slots
   */
  swapSlots(index1, index2) {
    const temp = this.slots[index1];
    this.slots[index1] = this.slots[index2];
    this.slots[index2] = temp;
  }
  /**
   * Sort inventory by type/name
   */
  sortInventory(sortBy = "type") {
    const nonEmptySlots = this.slots.filter((s) => !s.isEmpty());
    const emptySlots = this.slots.filter((s) => s.isEmpty());
    if (sortBy === "type") {
      nonEmptySlots.sort((a, b) => {
        if (a.item.type !== b.item.type) {
          return a.item.type.localeCompare(b.item.type);
        }
        return a.item.name.localeCompare(b.item.name);
      });
    } else if (sortBy === "name") {
      nonEmptySlots.sort((a, b) => a.item.name.localeCompare(b.item.name));
    } else if (sortBy === "value") {
      nonEmptySlots.sort((a, b) => b.item.value - a.item.value);
    }
    this.slots = [...nonEmptySlots, ...emptySlots];
  }
  /**
   * Stack all stackable items
   */
  stackAll() {
    const itemMap = /* @__PURE__ */ new Map();
    this.slots.forEach((slot) => {
      if (slot.isEmpty()) return;
      const id = slot.item.id;
      if (!itemMap.has(id)) {
        itemMap.set(id, []);
      }
      itemMap.get(id).push(slot);
    });
    itemMap.forEach((slots) => {
      if (slots.length <= 1) return;
      const item = slots[0].item;
      if (!item.stackable) return;
      let totalQuantity = slots.reduce((sum, s) => sum + s.quantity, 0);
      slots.forEach((s) => s.clear());
      let slotIndex = 0;
      while (totalQuantity > 0 && slotIndex < slots.length) {
        const toAdd = Math.min(totalQuantity, item.maxStack);
        slots[slotIndex].add(item.clone(), toAdd);
        totalQuantity -= toAdd;
        slotIndex++;
      }
    });
  }
  /**
   * Get number of empty slots
   */
  getEmptySlotCount() {
    return this.slots.filter((s) => s.isEmpty()).length;
  }
  /**
   * Clear entire inventory
   */
  clear() {
    this.slots.forEach((s) => s.clear());
    Object.keys(this.equipment).forEach((key) => {
      this.equipment[key] = null;
    });
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      capacity: this.capacity,
      maxWeight: this.maxWeight,
      slots: this.slots.map((s) => s.toJSON()),
      equipment: {
        weapon: this.equipment.weapon?.toJSON() || null,
        tool: this.equipment.tool?.toJSON() || null,
        clothing: this.equipment.clothing?.toJSON() || null,
        backpack: this.equipment.backpack?.toJSON() || null
      }
    };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data, itemDatabase) {
    const inventory2 = new Inventory(data.capacity, data.maxWeight);
    data.slots.forEach((slotData, index) => {
      if (slotData) {
        const item = itemDatabase.get(slotData.itemId);
        if (item) {
          item.durability = slotData.durability ?? item.durability;
          inventory2.slots[index].add(item, slotData.quantity);
        }
      }
    });
    Object.entries(data.equipment).forEach(([slot, itemData]) => {
      if (itemData) {
        const item = itemDatabase.get(itemData.id);
        if (item) {
          item.durability = itemData.durability ?? item.durability;
          inventory2.equipment[slot] = item;
        }
      }
    });
    return inventory2;
  }
}
class Player {
  constructor(config = {}) {
    this.name = config.name || "Survivor";
    this.gender = config.gender || "male";
    this.stats = {
      health: 100,
      maxHealth: 100,
      hunger: 100,
      // 100 = full, 0 = starving
      thirst: 100,
      // 100 = hydrated, 0 = dehydrated
      energy: 100,
      // 100 = well-rested, 0 = exhausted
      sanity: 100
      // 100 = stable, 0 = broken
    };
    this.statusEffects = [];
    this.skills = {
      woodcutting: 0,
      mining: 0,
      fishing: 0,
      crafting: 0,
      combat: 0,
      diplomacy: 0,
      survival: 0
    };
    this.inventory = new Inventory();
    this.position = config.position || { q: 0, r: 0 };
    this.daysAlive = 0;
    this.hoursAlive = 0;
    this.reputation = {
      castaways: 0,
      // -100 to +100
      nativesClan1: 0,
      nativesClan2: 0,
      mercenaries: 0,
      island: 0
      // The island's will itself
    };
    this.moralBackbone = {
      claim: 0,
      // Colonial democracy path
      respect: 0,
      // Native integration path
      exploit: 0,
      // Mercenary domination path
      leave: 0
      // Escape path
    };
    this.perks = [];
    this.isAlive = true;
    this.isConscious = true;
    this.isMoving = false;
    this.lastUpdateTime = Date.now();
    this.updateInterval = 1e3;
  }
  /**
   * Update player stats based on time passed
   * Called by game loop
   */
  update(deltaTime) {
    if (!this.isAlive) return;
    this.hoursAlive += deltaTime / (60 * 60 * 1e3);
    if (this.hoursAlive >= 24) {
      this.daysAlive += Math.floor(this.hoursAlive / 24);
      this.hoursAlive %= 24;
    }
    this.applyStatDegradation(deltaTime);
    this.updateStatusEffects(deltaTime);
    this.checkCriticalStates();
    this.applyStatInteractions();
    this.clampStats();
  }
  /**
   * Natural stat degradation over time
   */
  applyStatDegradation(deltaTime) {
    const hours = deltaTime / (60 * 60 * 1e3);
    const hungerRate = this.isMoving ? 2.5 : 1.5;
    this.stats.hunger -= hungerRate * hours;
    const thirstRate = this.isMoving ? 4 : 2.5;
    this.stats.thirst -= thirstRate * hours;
    if (this.isMoving) {
      this.stats.energy -= 3 * hours;
    } else if (this.stats.energy < 100) {
      const regenRate = this.stats.hunger > 50 ? 10 : 5;
      this.stats.energy += regenRate * hours;
    }
    if (this.stats.health < this.stats.maxHealth && this.stats.hunger > 60 && this.stats.energy > 70) {
      this.stats.health += 2 * hours;
    }
    if (this.stats.hunger < 20 || this.stats.thirst < 20) {
      this.stats.sanity -= 1 * hours;
    }
    if (this.stats.energy < 20) {
      this.stats.sanity -= 0.5 * hours;
    }
  }
  /**
   * Status effects system
   */
  updateStatusEffects(deltaTime) {
    this.statusEffects = this.statusEffects.filter((effect) => {
      effect.duration -= deltaTime;
      if (effect.duration <= 0) {
        this.onEffectExpire(effect);
        return false;
      }
      this.applyEffectTick(effect, deltaTime);
      return true;
    });
  }
  /**
   * Add a status effect
   */
  addStatusEffect(effect) {
    const existing = this.statusEffects.find((e) => e.id === effect.id);
    if (existing) {
      if (effect.stackable) {
        existing.intensity = (existing.intensity || 1) + (effect.intensity || 1);
        existing.duration = Math.max(existing.duration, effect.duration);
      } else {
        existing.duration = effect.duration;
      }
    } else {
      this.statusEffects.push({
        id: effect.id,
        name: effect.name,
        type: effect.type,
        // 'buff', 'debuff', 'neutral'
        duration: effect.duration,
        intensity: effect.intensity || 1,
        stackable: effect.stackable || false,
        effects: effect.effects,
        icon: effect.icon
      });
      this.onEffectApply(effect);
    }
  }
  /**
   * Remove a status effect
   */
  removeStatusEffect(effectId) {
    const index = this.statusEffects.findIndex((e) => e.id === effectId);
    if (index !== -1) {
      const effect = this.statusEffects[index];
      this.onEffectExpire(effect);
      this.statusEffects.splice(index, 1);
    }
  }
  /**
   * Called when effect is first applied
   */
  onEffectApply(effect) {
    console.log(`Status effect applied: ${effect.name}`);
  }
  /**
   * Called every tick while effect is active
   */
  applyEffectTick(effect, deltaTime) {
    const hours = deltaTime / (60 * 60 * 1e3);
    const intensity = effect.intensity || 1;
    if (effect.effects) {
      Object.entries(effect.effects).forEach(([stat, value]) => {
        if (this.stats[stat] !== void 0) {
          this.stats[stat] += value * intensity * hours;
        }
      });
    }
  }
  /**
   * Called when effect expires
   */
  onEffectExpire(effect) {
    console.log(`Status effect expired: ${effect.name}`);
  }
  /**
   * Stats influence each other
   */
  applyStatInteractions() {
    if (this.stats.hunger < 30) {
      const maxEnergyPenalty = (30 - this.stats.hunger) * 2;
      if (this.stats.energy > 100 - maxEnergyPenalty) {
        this.stats.energy = 100 - maxEnergyPenalty;
      }
    }
    if (this.stats.thirst < 10) {
      this.stats.health -= 0.5;
    }
    if (this.stats.hunger <= 0) {
      this.stats.health -= 1;
    }
    if (this.stats.sanity < 20) {
      const penalty = (20 - this.stats.sanity) * 0.1;
      this.stats.energy -= penalty;
    }
  }
  /**
   * Check for critical states (unconscious, death)
   */
  checkCriticalStates() {
    if (this.stats.health <= 0) {
      this.die();
      return;
    }
    if (this.stats.energy <= 0 || this.stats.health <= 10) {
      if (this.isConscious) {
        this.becomeUnconscious();
      }
    } else if (!this.isConscious && this.stats.energy > 20 && this.stats.health > 20) {
      this.regainConsciousness();
    }
  }
  /**
   * Player becomes unconscious
   */
  becomeUnconscious() {
    this.isConscious = false;
    this.isMoving = false;
    console.log("Player has become unconscious!");
  }
  /**
   * Player regains consciousness
   */
  regainConsciousness() {
    this.isConscious = true;
    console.log("Player has regained consciousness!");
  }
  /**
   * Player death
   */
  die() {
    this.isAlive = false;
    this.isConscious = false;
    this.isMoving = false;
    console.log("Player has died!");
  }
  /**
   * Consume an item (food, water, medicine)
   */
  consumeItem(item) {
    if (!item.consumable) {
      console.warn("Item is not consumable:", item.name);
      return false;
    }
    if (item.effects) {
      Object.entries(item.effects).forEach(([stat, value]) => {
        if (this.stats[stat] !== void 0) {
          this.stats[stat] += value;
          console.log(`${stat}: ${value > 0 ? "+" : ""}${value}`);
        }
      });
    }
    if (item.statusEffect) {
      this.addStatusEffect(item.statusEffect);
    }
    this.clampStats();
    return true;
  }
  /**
   * Equip an item
   */
  equipItem(item, slot) {
    const result = this.inventory.equip(item, slot);
    if (result) {
      console.log(`Equipped ${item.name} to ${slot} slot`);
    }
    return result;
  }
  /**
   * Unequip an item
   */
  unequipItem(slot) {
    const result = this.inventory.unequip(slot);
    if (result) {
      console.log(`Unequipped ${slot} slot`);
    }
    return result;
  }
  /**
   * Get total bonuses from equipment and status effects
   */
  getTotalBonuses() {
    const bonuses = {
      damage: 0,
      defense: 0,
      woodcutting: 0,
      mining: 0,
      fishing: 0,
      crafting: 0,
      capacity: 0,
      speed: 0
    };
    Object.values(this.inventory.equipment).forEach((item) => {
      if (item && item.effects) {
        Object.entries(item.effects).forEach(([key, value]) => {
          if (bonuses[key] !== void 0) {
            bonuses[key] += value;
          }
        });
      }
    });
    this.statusEffects.forEach((effect) => {
      if (effect.effects) {
        Object.entries(effect.effects).forEach(([key, value]) => {
          if (bonuses[key] !== void 0) {
            bonuses[key] += value * (effect.intensity || 1);
          }
        });
      }
    });
    return bonuses;
  }
  /**
   * Get effective skill level (base + bonuses)
   */
  getEffectiveSkill(skillName) {
    const base = this.skills[skillName] || 0;
    const bonuses = this.getTotalBonuses();
    const bonus = bonuses[skillName] || 0;
    let penalty = 0;
    if (this.stats.energy < 30) {
      penalty = (30 - this.stats.energy) * 0.5;
    }
    if (this.stats.hunger < 30) {
      penalty += (30 - this.stats.hunger) * 0.3;
    }
    return Math.max(0, base + bonus - penalty);
  }
  /**
   * Gain skill experience
   */
  gainSkillXP(skillName, amount) {
    if (this.skills[skillName] !== void 0) {
      this.skills[skillName] += amount;
      console.log(`${skillName} skill increased: +${amount}`);
    }
  }
  /**
   * Adjust reputation with a faction
   */
  adjustReputation(faction, amount) {
    if (this.reputation[faction] !== void 0) {
      this.reputation[faction] += amount;
      this.reputation[faction] = Math.max(-100, Math.min(100, this.reputation[faction]));
      console.log(`Reputation with ${faction}: ${amount > 0 ? "+" : ""}${amount}`);
    }
  }
  /**
   * Adjust moral backbone
   */
  adjustMoralBackbone(path, amount) {
    if (this.moralBackbone[path] !== void 0) {
      this.moralBackbone[path] += amount;
      console.log(`Moral backbone - ${path}: ${amount > 0 ? "+" : ""}${amount}`);
    }
  }
  /**
   * Get dominant moral path
   */
  getDominantPath() {
    let maxPath = null;
    let maxValue = -Infinity;
    Object.entries(this.moralBackbone).forEach(([path, value]) => {
      if (value > maxValue) {
        maxValue = value;
        maxPath = path;
      }
    });
    return { path: maxPath, value: maxValue };
  }
  /**
   * Perform an action that costs energy
   */
  performAction(energyCost, onSuccess, onFailure) {
    if (this.stats.energy < energyCost) {
      console.warn("Not enough energy to perform action");
      if (onFailure) onFailure();
      return false;
    }
    this.stats.energy -= energyCost;
    if (onSuccess) onSuccess();
    return true;
  }
  /**
   * Move to a new position
   */
  moveTo(q, r) {
    const distance = Math.abs(q - this.position.q) + Math.abs(r - this.position.r);
    const energyCost = distance * 2;
    return this.performAction(energyCost, () => {
      this.position = { q, r };
      console.log(`Moved to (${q}, ${r})`);
    }, () => {
      console.log("Too exhausted to move");
    });
  }
  /**
   * Rest to recover energy
   */
  rest(hours) {
    const energyRecovered = hours * 15;
    this.stats.energy = Math.min(100, this.stats.energy + energyRecovered);
    console.log(`Rested for ${hours} hours. Energy: +${energyRecovered}`);
    if (this.stats.sanity < 100) {
      const sanityRecovered = hours * 5;
      this.stats.sanity = Math.min(100, this.stats.sanity + sanityRecovered);
    }
  }
  /**
   * Get current state description (for UI/narrative)
   */
  getStateDescription() {
    const descriptions = [];
    if (this.stats.health < 20) descriptions.push("critically wounded");
    else if (this.stats.health < 50) descriptions.push("injured");
    else if (this.stats.health < 80) descriptions.push("somewhat hurt");
    if (this.stats.hunger < 20) descriptions.push("starving");
    else if (this.stats.hunger < 50) descriptions.push("hungry");
    if (this.stats.thirst < 20) descriptions.push("severely dehydrated");
    else if (this.stats.thirst < 50) descriptions.push("thirsty");
    if (this.stats.energy < 20) descriptions.push("exhausted");
    else if (this.stats.energy < 50) descriptions.push("tired");
    if (this.stats.sanity < 20) descriptions.push("mentally broken");
    else if (this.stats.sanity < 50) descriptions.push("stressed");
    return descriptions.length > 0 ? descriptions.join(", ") : "in good condition";
  }
  /**
   * Clamp all stats to valid ranges
   */
  clampStats() {
    this.stats.health = Math.max(0, Math.min(this.stats.maxHealth, this.stats.health));
    this.stats.hunger = Math.max(0, Math.min(100, this.stats.hunger));
    this.stats.thirst = Math.max(0, Math.min(100, this.stats.thirst));
    this.stats.energy = Math.max(0, Math.min(100, this.stats.energy));
    this.stats.sanity = Math.max(0, Math.min(100, this.stats.sanity));
  }
  /**
   * Serialize player state for saving
   */
  toJSON() {
    return {
      name: this.name,
      gender: this.gender,
      stats: { ...this.stats },
      statusEffects: [...this.statusEffects],
      skills: { ...this.skills },
      inventory: this.inventory.toJSON(),
      position: { ...this.position },
      daysAlive: this.daysAlive,
      hoursAlive: this.hoursAlive,
      reputation: { ...this.reputation },
      moralBackbone: { ...this.moralBackbone },
      perks: [...this.perks],
      isAlive: this.isAlive,
      isConscious: this.isConscious
    };
  }
  /**
   * Deserialize player state from save
   */
  static fromJSON(data) {
    const player2 = new Player({ name: data.name, gender: data.gender });
    Object.assign(player2.stats, data.stats);
    player2.statusEffects = data.statusEffects || [];
    Object.assign(player2.skills, data.skills);
    player2.inventory = Inventory.fromJSON(data.inventory);
    player2.position = data.position;
    player2.daysAlive = data.daysAlive;
    player2.hoursAlive = data.hoursAlive;
    Object.assign(player2.reputation, data.reputation);
    Object.assign(player2.moralBackbone, data.moralBackbone);
    player2.perks = data.perks || [];
    player2.isAlive = data.isAlive;
    player2.isConscious = data.isConscious;
    return player2;
  }
}
class Item {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description || "";
    this.type = data.type;
    this.category = data.category;
    this.icon = data.icon || "items/default.png";
    this.sprite = data.sprite || null;
    this.stackable = data.stackable ?? false;
    this.maxStack = data.maxStack || 1;
    this.weight = data.weight || 1;
    this.consumable = data.consumable ?? false;
    this.equippable = data.equippable ?? false;
    this.usable = data.usable ?? false;
    this.effects = data.effects || {};
    this.durability = data.durability ?? null;
    this.maxDurability = data.maxDurability ?? null;
    this.value = data.value || 0;
    this.rarity = data.rarity || "common";
    this.requirements = data.requirements || {};
  }
  /**
   * Use the item (consume, activate, etc.)
   */
  use(player2) {
    if (!this.usable && !this.consumable) {
      console.warn(`${this.name} cannot be used`);
      return false;
    }
    if (this.consumable) {
      return this.consume(player2);
    }
    if (this.usable) {
      return this.activate(player2);
    }
    return false;
  }
  /**
   * Consume the item (food, water, medicine)
   */
  consume(player2) {
    Object.entries(this.effects).forEach(([stat, value]) => {
      player2.modifyStat(stat, value);
    });
    console.log(`${player2.name} consumed ${this.name}`);
    return true;
  }
  /**
   * Activate special item behavior
   */
  activate(player2) {
    console.log(`${this.name} was activated`);
    return false;
  }
  /**
   * Check if this item can stack with another
   */
  canStack(otherItem) {
    if (!this.stackable || !otherItem.stackable) return false;
    if (this.id !== otherItem.id) return false;
    if (this.durability !== null && this.durability !== otherItem.durability) {
      return false;
    }
    return true;
  }
  /**
   * Create a copy of this item
   */
  clone() {
    return new Item({
      id: this.id,
      name: this.name,
      description: this.description,
      type: this.type,
      category: this.category,
      icon: this.icon,
      sprite: this.sprite,
      stackable: this.stackable,
      maxStack: this.maxStack,
      weight: this.weight,
      consumable: this.consumable,
      equippable: this.equippable,
      usable: this.usable,
      effects: { ...this.effects },
      durability: this.durability,
      maxDurability: this.maxDurability,
      value: this.value,
      rarity: this.rarity,
      requirements: { ...this.requirements }
    });
  }
  /**
   * Get rarity color for UI
   */
  getRarityColor() {
    const colors = {
      common: "#ffffff",
      uncommon: "#00ff00",
      rare: "#0099ff",
      legendary: "#ff9900"
    };
    return colors[this.rarity] || colors.common;
  }
  /**
   * Get durability percentage
   */
  getDurabilityPercent() {
    if (this.durability === null) return 100;
    return this.durability / this.maxDurability * 100;
  }
  /**
   * Damage the item (tools/weapons)
   */
  damage(amount = 1) {
    if (this.durability === null) return false;
    this.durability = Math.max(0, this.durability - amount);
    return this.durability <= 0;
  }
  /**
   * Repair the item
   */
  repair(amount) {
    if (this.durability === null) return;
    this.durability = Math.min(this.maxDurability, this.durability + amount);
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      durability: this.durability
      // Other dynamic properties only
    };
  }
  /**
   * Get display name with quantity/durability
   */
  getDisplayName(quantity = 1) {
    let name = this.name;
    if (quantity > 1) {
      name += ` (${quantity})`;
    }
    if (this.durability !== null) {
      const percent = this.getDurabilityPercent();
      if (percent < 25) name += " [!]";
      else if (percent < 50) name += " [*]";
    }
    return name;
  }
}
class ItemDatabase {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.loadItems();
  }
  /**
   * Load all item definitions
   */
  loadItems() {
    const itemDefinitions = this.getItemDefinitions();
    itemDefinitions.forEach((def) => {
      this.items.set(def.id, def);
    });
    console.log(`Loaded ${this.items.size} items`);
  }
  /**
   * Get item by ID (returns a new instance)
   */
  get(itemId) {
    const def = this.items.get(itemId);
    if (!def) {
      console.error(`Item not found: ${itemId}`);
      return null;
    }
    return new Item(def);
  }
  /**
   * Check if item exists
   */
  has(itemId) {
    return this.items.has(itemId);
  }
  /**
   * Get all items of a type
   */
  getByType(type) {
    return Array.from(this.items.values()).filter((item) => item.type === type).map((def) => new Item(def));
  }
  /**
   * Get all items of a category
   */
  getByCategory(category) {
    return Array.from(this.items.values()).filter((item) => item.category === category).map((def) => new Item(def));
  }
  /**
   * Item definitions (will move to JSON file later)
   */
  getItemDefinitions() {
    return [
      // ===== CONSUMABLES - FOOD =====
      {
        id: "coconut",
        name: "Coconut",
        description: "A fresh coconut. Sweet meat and refreshing water.",
        type: "consumable",
        category: "food",
        icon: "items/coconut.png",
        stackable: true,
        maxStack: 10,
        weight: 2,
        consumable: true,
        effects: { hunger: 15, thirst: 10 },
        value: 2,
        rarity: "common"
      },
      {
        id: "berries",
        name: "Berries",
        description: "Sweet wild berries. A quick snack.",
        type: "consumable",
        category: "food",
        icon: "items/berries.png",
        stackable: true,
        maxStack: 20,
        weight: 0.1,
        consumable: true,
        effects: { hunger: 5 },
        value: 1,
        rarity: "common"
      },
      {
        id: "cooked_fish",
        name: "Cooked Fish",
        description: "Freshly cooked fish. Delicious and nutritious.",
        type: "consumable",
        category: "food",
        icon: "items/cooked_fish.png",
        stackable: true,
        maxStack: 10,
        weight: 1,
        consumable: true,
        effects: { hunger: 35, health: 5 },
        value: 5,
        rarity: "common"
      },
      {
        id: "raw_fish",
        name: "Raw Fish",
        description: "Uncooked fish. Should be cooked before eating.",
        type: "consumable",
        category: "food",
        icon: "items/raw_fish.png",
        stackable: true,
        maxStack: 10,
        weight: 1,
        consumable: true,
        effects: { hunger: 10, health: -5 },
        value: 2,
        rarity: "common"
      },
      {
        id: "cooked_meat",
        name: "Cooked Meat",
        description: "Properly cooked meat. Very filling.",
        type: "consumable",
        category: "food",
        icon: "items/cooked_meat.png",
        stackable: true,
        maxStack: 10,
        weight: 1.5,
        consumable: true,
        effects: { hunger: 45, health: 10 },
        value: 8,
        rarity: "common"
      },
      // ===== CONSUMABLES - WATER =====
      {
        id: "water_bottle",
        name: "Water Bottle",
        description: "Clean drinking water.",
        type: "consumable",
        category: "water",
        icon: "items/water.png",
        stackable: true,
        maxStack: 5,
        weight: 1,
        consumable: true,
        effects: { thirst: 30 },
        value: 3,
        rarity: "common"
      },
      {
        id: "dirty_water",
        name: "Dirty Water",
        description: "Unfiltered water. Might make you sick.",
        type: "consumable",
        category: "water",
        icon: "items/dirty_water.png",
        stackable: true,
        maxStack: 5,
        weight: 1,
        consumable: true,
        effects: { thirst: 15, health: -10 },
        value: 1,
        rarity: "common"
      },
      // ===== CONSUMABLES - MEDICINE =====
      {
        id: "bandage",
        name: "Bandage",
        description: "Stops bleeding and speeds healing.",
        type: "consumable",
        category: "medicine",
        icon: "items/bandage.png",
        stackable: true,
        maxStack: 10,
        weight: 0.1,
        consumable: true,
        effects: { health: 20 },
        value: 10,
        rarity: "common"
      },
      {
        id: "herbal_remedy",
        name: "Herbal Remedy",
        description: "Native medicine made from island plants.",
        type: "consumable",
        category: "medicine",
        icon: "items/herbs.png",
        stackable: true,
        maxStack: 5,
        weight: 0.2,
        consumable: true,
        effects: { health: 40, energy: 10 },
        value: 20,
        rarity: "uncommon"
      },
      // ===== MATERIALS =====
      {
        id: "wood",
        name: "Wood",
        description: "Sturdy wood for building and crafting.",
        type: "material",
        category: "wood",
        icon: "items/wood.png",
        stackable: true,
        maxStack: 50,
        weight: 0.5,
        value: 1,
        rarity: "common"
      },
      {
        id: "stone",
        name: "Stone",
        description: "Hard stone for tools and construction.",
        type: "material",
        category: "stone",
        icon: "items/stone.png",
        stackable: true,
        maxStack: 50,
        weight: 1,
        value: 1,
        rarity: "common"
      },
      {
        id: "fiber",
        name: "Plant Fiber",
        description: "Strong plant fibers for rope and cloth.",
        type: "material",
        category: "fiber",
        icon: "items/fiber.png",
        stackable: true,
        maxStack: 50,
        weight: 0.2,
        value: 1,
        rarity: "common"
      },
      {
        id: "leather",
        name: "Leather",
        description: "Tanned animal hide. Useful for crafting.",
        type: "material",
        category: "leather",
        icon: "items/leather.png",
        stackable: true,
        maxStack: 20,
        weight: 0.8,
        value: 5,
        rarity: "uncommon"
      },
      {
        id: "metal_scrap",
        name: "Metal Scrap",
        description: "Salvaged metal. Can be worked into tools.",
        type: "material",
        category: "metal",
        icon: "items/metal.png",
        stackable: true,
        maxStack: 20,
        weight: 2,
        value: 10,
        rarity: "uncommon"
      },
      {
        id: "rope",
        name: "Rope",
        description: "Strong rope made from plant fibers.",
        type: "material",
        category: "rope",
        icon: "items/rope.png",
        stackable: true,
        maxStack: 20,
        weight: 0.5,
        value: 3,
        rarity: "common"
      },
      {
        id: "cloth",
        name: "Cloth",
        description: "Woven plant fiber cloth.",
        type: "material",
        category: "cloth",
        icon: "items/cloth.png",
        stackable: true,
        maxStack: 20,
        weight: 0.3,
        value: 4,
        rarity: "common"
      },
      {
        id: "raw_meat",
        name: "Raw Meat",
        description: "Uncooked meat. Should be cooked before eating.",
        type: "consumable",
        category: "food",
        icon: "items/raw_meat.png",
        stackable: true,
        maxStack: 10,
        weight: 1.5,
        consumable: true,
        effects: { hunger: 15, health: -8 },
        value: 3,
        rarity: "common"
      },
      // ===== TOOLS =====
      {
        id: "stone_axe",
        name: "Stone Axe",
        description: "A crude but effective axe for chopping wood.",
        type: "tool",
        category: "axe",
        icon: "items/stone_axe.png",
        stackable: false,
        weight: 3,
        equippable: true,
        durability: 100,
        maxDurability: 100,
        effects: { woodcutting: 2, damage: 5 },
        value: 10,
        rarity: "common"
      },
      {
        id: "stone_pickaxe",
        name: "Stone Pickaxe",
        description: "Break rocks and mine stone.",
        type: "tool",
        category: "pickaxe",
        icon: "items/stone_pickaxe.png",
        stackable: false,
        weight: 4,
        equippable: true,
        durability: 80,
        maxDurability: 80,
        effects: { mining: 2, damage: 4 },
        value: 12,
        rarity: "common"
      },
      {
        id: "knife",
        name: "Knife",
        description: "A sharp knife for cutting and crafting.",
        type: "tool",
        category: "knife",
        icon: "items/knife.png",
        stackable: false,
        weight: 0.5,
        equippable: true,
        durability: 150,
        maxDurability: 150,
        effects: { crafting: 1, damage: 6 },
        value: 15,
        rarity: "common"
      },
      {
        id: "fishing_rod",
        name: "Fishing Rod",
        description: "Catch fish more easily.",
        type: "tool",
        category: "fishing",
        icon: "items/fishing_rod.png",
        stackable: false,
        weight: 1,
        equippable: true,
        durability: 50,
        maxDurability: 50,
        effects: { fishing: 3 },
        value: 20,
        rarity: "common"
      },
      // ===== WEAPONS =====
      {
        id: "stone_spear",
        name: "Stone Spear",
        description: "A sharp spear for hunting and combat.",
        type: "weapon",
        category: "spear",
        icon: "items/stone_spear.png",
        stackable: false,
        weight: 2,
        equippable: true,
        durability: 50,
        maxDurability: 50,
        effects: { damage: 10 },
        value: 15,
        rarity: "common"
      },
      {
        id: "wooden_club",
        name: "Wooden Club",
        description: "A heavy club for bashing.",
        type: "weapon",
        category: "club",
        icon: "items/club.png",
        stackable: false,
        weight: 3,
        equippable: true,
        durability: 60,
        maxDurability: 60,
        effects: { damage: 8 },
        value: 8,
        rarity: "common"
      },
      {
        id: "bow",
        name: "Hunting Bow",
        description: "A ranged weapon for hunting.",
        type: "weapon",
        category: "bow",
        icon: "items/bow.png",
        stackable: false,
        weight: 1.5,
        equippable: true,
        durability: 100,
        maxDurability: 100,
        effects: { damage: 12, range: 10 },
        value: 30,
        rarity: "uncommon"
      },
      // ===== EQUIPMENT =====
      {
        id: "cloth_shirt",
        name: "Cloth Shirt",
        description: "Basic clothing. Provides minimal protection.",
        type: "equipment",
        category: "clothing",
        icon: "items/cloth_shirt.png",
        stackable: false,
        weight: 0.5,
        equippable: true,
        effects: { defense: 1 },
        value: 5,
        rarity: "common"
      },
      {
        id: "leather_vest",
        name: "Leather Vest",
        description: "Sturdy leather protection.",
        type: "equipment",
        category: "clothing",
        icon: "items/leather_vest.png",
        stackable: false,
        weight: 2,
        equippable: true,
        effects: { defense: 5 },
        value: 25,
        rarity: "uncommon"
      },
      {
        id: "leather_backpack",
        name: "Leather Backpack",
        description: "Increases carrying capacity by 10 slots.",
        type: "equipment",
        category: "backpack",
        icon: "items/backpack.png",
        stackable: false,
        weight: 2,
        equippable: true,
        effects: { capacity: 10 },
        value: 50,
        rarity: "uncommon"
      },
      {
        id: "waterskin",
        name: "Waterskin",
        description: "Carry water with you.",
        type: "equipment",
        category: "container",
        icon: "items/waterskin.png",
        stackable: false,
        weight: 0.5,
        equippable: false,
        usable: true,
        value: 15,
        rarity: "common"
      }
    ];
  }
}
const itemDB = new ItemDatabase();
class ResourceNode {
  constructor(config) {
    this.id = config.id;
    this.type = config.type;
    this.position = config.position;
    this.resourceType = config.resourceType;
    this.baseYield = config.baseYield || { min: 1, max: 3 };
    this.currentUses = config.maxUses || 5;
    this.maxUses = config.maxUses || 5;
    this.requiredTool = config.requiredTool || null;
    this.requiredSkill = config.requiredSkill || null;
    this.minimumSkillLevel = config.minimumSkillLevel || 0;
    this.regenerationTime = config.regenerationTime || 3e5;
    this.regenerationProgress = 0;
    this.isRegenerating = false;
    this.lastGatherTime = null;
    this.state = "full";
    this.discovered = config.discovered || false;
    this.sprite = config.sprite || "üå≥";
    this.depletedSprite = config.depletedSprite || "ü™µ";
    this.size = config.size || "medium";
    this.gatherTime = config.gatherTime || 3e3;
    this.energyCost = config.energyCost || 5;
    this.isRespawnable = config.isRespawnable !== false;
    this.quality = config.quality || "normal";
    this.onGather = config.onGather || null;
    this.onDeplete = config.onDeplete || null;
    this.onRegenerate = config.onRegenerate || null;
  }
  /**
   * Check if player can gather from this node
   */
  canGather(player2) {
    if (this.state === "depleted" && !this.isRegenerating) {
      return { success: false, reason: "Node is depleted" };
    }
    if (!player2.isAlive || !player2.isConscious) {
      return { success: false, reason: "You are not in condition to gather" };
    }
    if (player2.stats.energy < this.energyCost) {
      return { success: false, reason: "Not enough energy" };
    }
    if (this.requiredTool) {
      const hasTool = this.checkPlayerHasTool(player2, this.requiredTool);
      if (!hasTool) {
        return { success: false, reason: `Requires ${this.requiredTool}` };
      }
    }
    if (this.requiredSkill && this.minimumSkillLevel > 0) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      if (skillLevel < this.minimumSkillLevel) {
        return { success: false, reason: `Requires ${this.requiredSkill} level ${this.minimumSkillLevel}` };
      }
    }
    return { success: true };
  }
  /**
   * Check if player has required tool equipped
   */
  checkPlayerHasTool(player2, toolType) {
    const equipped = player2.inventory.equipment;
    const weapon = equipped.weapon;
    const tool = equipped.tool;
    if (toolType === "axe") {
      return weapon?.category === "axe" || tool?.category === "axe";
    }
    if (toolType === "pickaxe") {
      return weapon?.category === "pickaxe" || tool?.category === "pickaxe";
    }
    if (toolType === "knife") {
      return weapon?.category === "knife" || tool?.category === "knife";
    }
    if (toolType === "fishing_rod") {
      return tool?.category === "fishing";
    }
    return false;
  }
  /**
   * Get the equipped tool being used
   */
  getEquippedTool(player2) {
    const equipped = player2.inventory.equipment;
    if (this.requiredTool === "axe") {
      return equipped.weapon?.category === "axe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "pickaxe") {
      return equipped.weapon?.category === "pickaxe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "knife") {
      return equipped.weapon?.category === "knife" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "fishing_rod") {
      return equipped.tool;
    }
    return null;
  }
  /**
   * Attempt to gather resources
   */
  gather(player2) {
    const canGather = this.canGather(player2);
    if (!canGather.success) {
      return {
        success: false,
        reason: canGather.reason
      };
    }
    const baseYield = this.calculateYield(player2);
    const items = this.generateItems(baseYield);
    player2.stats.energy -= this.energyCost;
    const tool = this.getEquippedTool(player2);
    if (tool && tool.durability !== void 0) {
      tool.damage(1);
      if (tool.durability <= 0) {
        console.log(`${tool.name} broke!`);
      }
    }
    if (this.requiredSkill) {
      const xpGain = this.calculateSkillXP();
      player2.gainSkillXP(this.requiredSkill, xpGain);
    }
    this.currentUses--;
    this.lastGatherTime = Date.now();
    if (this.currentUses <= 0) {
      this.depleteNode();
    }
    if (this.onGather) {
      this.onGather(player2, items);
    }
    return {
      success: true,
      items,
      xpGained: this.requiredSkill ? this.calculateSkillXP() : 0,
      usesRemaining: this.currentUses
    };
  }
  /**
   * Calculate yield based on player skill and quality
   */
  calculateYield(player2) {
    let yield_amount = Math.floor(
      Math.random() * (this.baseYield.max - this.baseYield.min + 1) + this.baseYield.min
    );
    if (this.requiredSkill) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      const skillBonus = Math.floor(skillLevel / 20);
      yield_amount += skillBonus;
    }
    const qualityMultipliers = {
      poor: 0.5,
      normal: 1,
      rich: 1.5,
      abundant: 2
    };
    yield_amount = Math.floor(yield_amount * qualityMultipliers[this.quality]);
    const tool = this.getEquippedTool(player2);
    if (tool && tool.rarity !== "common") {
      const rarityBonus = {
        uncommon: 1.1,
        rare: 1.25,
        epic: 1.5,
        legendary: 2
      };
      yield_amount = Math.floor(yield_amount * (rarityBonus[tool.rarity] || 1));
    }
    return Math.max(1, yield_amount);
  }
  /**
   * Generate item instances
   */
  generateItems(quantity) {
    const items = [];
    for (let i = 0; i < quantity; i++) {
      items.push(itemDB.get(this.resourceType));
    }
    return items;
  }
  /**
   * Calculate skill XP gain
   */
  calculateSkillXP() {
    const baseXP = 5;
    const qualityXP = {
      poor: 0.5,
      normal: 1,
      rich: 1.5,
      abundant: 2
    };
    return Math.floor(baseXP * qualityXP[this.quality]);
  }
  /**
   * Deplete the node
   */
  depleteNode() {
    this.state = "depleted";
    this.currentUses = 0;
    if (this.isRespawnable) {
      this.startRegeneration();
    }
    if (this.onDeplete) {
      this.onDeplete();
    }
  }
  /**
   * Start regeneration process
   */
  startRegeneration() {
    this.isRegenerating = true;
    this.regenerationProgress = 0;
  }
  /**
   * Update node state (called by game loop)
   */
  update(deltaTime) {
    if (this.isRegenerating) {
      this.regenerationProgress += deltaTime;
      if (this.regenerationProgress >= this.regenerationTime) {
        this.regenerateNode();
      }
    }
  }
  /**
   * Regenerate the node
   */
  regenerateNode() {
    this.state = "full";
    this.currentUses = this.maxUses;
    this.isRegenerating = false;
    this.regenerationProgress = 0;
    if (this.onRegenerate) {
      this.onRegenerate();
    }
  }
  /**
   * Get regeneration progress percentage
   */
  getRegenerationProgress() {
    if (!this.isRegenerating) return 0;
    return this.regenerationProgress / this.regenerationTime * 100;
  }
  /**
   * Get visual representation
   */
  getSprite() {
    if (this.state === "depleted") {
      return this.depletedSprite;
    }
    return this.sprite;
  }
  /**
   * Get node info for UI
   */
  getInfo() {
    return {
      name: this.getName(),
      type: this.type,
      state: this.state,
      usesRemaining: `${this.currentUses}/${this.maxUses}`,
      requiredTool: this.requiredTool || "Bare hands",
      requiredSkill: this.requiredSkill ? `${this.requiredSkill} (${this.minimumSkillLevel})` : "None",
      gatherTime: `${this.gatherTime / 1e3}s`,
      energyCost: this.energyCost,
      quality: this.quality,
      regenerationProgress: this.isRegenerating ? `${Math.floor(this.getRegenerationProgress())}%` : "N/A"
    };
  }
  /**
   * Get display name
   */
  getName() {
    const names = {
      tree: "Tree",
      rock: "Rock Formation",
      berry_bush: "Berry Bush",
      fishing_spot: "Fishing Spot",
      coconut_tree: "Coconut Tree",
      iron_deposit: "Iron Deposit",
      herb_patch: "Herb Patch",
      stone_outcrop: "Stone Outcrop"
    };
    return names[this.type] || this.type;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      position: this.position,
      currentUses: this.currentUses,
      state: this.state,
      regenerationProgress: this.regenerationProgress,
      isRegenerating: this.isRegenerating,
      discovered: this.discovered,
      lastGatherTime: this.lastGatherTime
    };
  }
  /**
   * Deserialize from save
   */
  static fromJSON(data, config) {
    const node = new ResourceNode({ ...config, ...data });
    node.state = data.state;
    node.currentUses = data.currentUses;
    node.regenerationProgress = data.regenerationProgress;
    node.isRegenerating = data.isRegenerating;
    node.discovered = data.discovered;
    node.lastGatherTime = data.lastGatherTime;
    return node;
  }
}
class ResourceNodeManager {
  constructor() {
    this.nodes = /* @__PURE__ */ new Map();
    this.nodesByPosition = /* @__PURE__ */ new Map();
    this.nextNodeId = 1;
  }
  /**
   * Create a new resource node
   */
  createNode(config) {
    const node = new ResourceNode({
      ...config,
      id: config.id || `node_${this.nextNodeId++}`
    });
    this.nodes.set(node.id, node);
    const posKey = `${node.position.q},${node.position.r}`;
    if (!this.nodesByPosition.has(posKey)) {
      this.nodesByPosition.set(posKey, []);
    }
    this.nodesByPosition.get(posKey).push(node);
    return node;
  }
  /**
   * Get node by ID
   */
  getNode(id) {
    return this.nodes.get(id);
  }
  /**
   * Get nodes at position
   */
  getNodesAt(q, r) {
    const posKey = `${q},${r}`;
    return this.nodesByPosition.get(posKey) || [];
  }
  /**
   * Get all nodes of a type
   */
  getNodesByType(type) {
    return Array.from(this.nodes.values()).filter((node) => node.type === type);
  }
  /**
   * Get all gatherable nodes (not depleted)
   */
  getGatherableNodes() {
    return Array.from(this.nodes.values()).filter((node) => node.state !== "depleted");
  }
  /**
   * Remove a node
   */
  removeNode(id) {
    const node = this.nodes.get(id);
    if (!node) return;
    const posKey = `${node.position.q},${node.position.r}`;
    const nodesAtPos = this.nodesByPosition.get(posKey);
    if (nodesAtPos) {
      const index = nodesAtPos.indexOf(node);
      if (index !== -1) {
        nodesAtPos.splice(index, 1);
      }
    }
    this.nodes.delete(id);
  }
  /**
   * Update all nodes (called by game loop)
   */
  update(deltaTime) {
    this.nodes.forEach((node) => {
      node.update(deltaTime);
    });
  }
  /**
   * Generate starter resource nodes near player spawn
   */
  generateStarterNodes(spawnPosition, radius = 3) {
    const nodes = [];
    for (let i = 0; i < 5; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "tree",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "wood",
        baseYield: { min: 2, max: 4 },
        maxUses: 5,
        requiredTool: "axe",
        requiredSkill: "woodcutting",
        sprite: "üå≥",
        depletedSprite: "ü™µ",
        gatherTime: 3e3,
        energyCost: 5
      }));
    }
    for (let i = 0; i < 4; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "rock",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "stone",
        baseYield: { min: 2, max: 3 },
        maxUses: 5,
        requiredTool: "pickaxe",
        requiredSkill: "mining",
        sprite: "ü™®",
        depletedSprite: "‚ö´",
        gatherTime: 4e3,
        energyCost: 7
      }));
    }
    for (let i = 0; i < 3; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "berry_bush",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "berries",
        baseYield: { min: 3, max: 6 },
        maxUses: 8,
        requiredTool: null,
        sprite: "ü´ê",
        depletedSprite: "üçÇ",
        gatherTime: 2e3,
        energyCost: 2
      }));
    }
    for (let i = 0; i < 2; i++) {
      const offset = this.getRandomOffset(radius);
      nodes.push(this.createNode({
        type: "coconut_tree",
        position: { q: spawnPosition.q + offset.q, r: spawnPosition.r + offset.r },
        resourceType: "coconut",
        baseYield: { min: 1, max: 2 },
        maxUses: 3,
        requiredTool: null,
        sprite: "üå¥",
        depletedSprite: "üå¥",
        gatherTime: 2500,
        energyCost: 3
      }));
    }
    return nodes;
  }
  /**
   * Get random hex offset within radius
   */
  getRandomOffset(radius) {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.floor(Math.random() * radius) + 1;
    return {
      q: Math.round(Math.cos(angle) * distance),
      r: Math.round(Math.sin(angle) * distance)
    };
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    const nodesArray = Array.from(this.nodes.values()).map((node) => node.toJSON());
    return {
      nodes: nodesArray,
      nextNodeId: this.nextNodeId
    };
  }
  /**
   * Deserialize from save
   */
  static fromJSON(data, nodeConfigs) {
    const manager = new ResourceNodeManager();
    manager.nextNodeId = data.nextNodeId;
    data.nodes.forEach((nodeData) => {
      const config = nodeConfigs[nodeData.type] || {};
      const node = ResourceNode.fromJSON(nodeData, config);
      manager.nodes.set(node.id, node);
      const posKey = `${node.position.q},${node.position.r}`;
      if (!manager.nodesByPosition.has(posKey)) {
        manager.nodesByPosition.set(posKey, []);
      }
      manager.nodesByPosition.get(posKey).push(node);
    });
    return manager;
  }
}
class GameState {
  constructor() {
    this.version = "2.0.0";
    this.listeners = /* @__PURE__ */ new Map();
    this.player = null;
    this.resourceManager = null;
    this.uiManagers = {
      playerHUD: null,
      inventoryUI: null,
      gatheringUI: null,
      nodeInspector: null
    };
    this.state = {
      meta: {
        version: this.version,
        saveDate: null,
        saveName: "Autosave",
        playTime: 0,
        // seconds
        lastTick: Date.now()
      },
      island: {
        seed: null,
        mapRadius: 8,
        discoveredTiles: [],
        controlledZones: []
      },
      characters: [],
      // NPCs
      time: {
        day: 1,
        hour: 8,
        // 0-23
        minute: 0,
        season: "summer",
        timeScale: 60
        // 60 game minutes per real second (adjustable)
      },
      flags: {
        phase: 1,
        // 1-4 (story phases)
        tutorialComplete: false,
        firstCastawayFound: false,
        mercLeaderDefeated: false,
        islanderAlliance: null,
        // null, 'ally', 'enslaved'
        completedQuests: []
      },
      buildings: [],
      economy: {
        money: 0,
        income: 0,
        expenses: 0
      }
    };
    this.gameLoopInterval = null;
    this.isPaused = false;
  }
  /**
   * Initialize game state (new game or load)
   */
  init(config = {}) {
    const {
      playerName = "Survivor",
      playerGender = "male",
      savedState = null,
      spawnPosition = { q: 0, r: 0 }
    } = config;
    if (savedState) {
      this.loadState(savedState);
    } else {
      this.state.island.seed = this.generateSeed();
      this.player = new Player({
        name: playerName,
        gender: playerGender,
        position: spawnPosition
      });
      this.resourceManager = new ResourceNodeManager();
      this.resourceManager.generateStarterNodes(spawnPosition, 3);
    }
    this.startGameLoop();
    this.emit("stateInitialized", {
      player: this.player,
      resourceManager: this.resourceManager,
      state: this.state
    });
  }
  /**
   * Register UI managers (called by UI initialization)
   */
  registerUI(name, uiInstance) {
    this.uiManagers[name] = uiInstance;
    console.log(`Registered UI: ${name}`);
  }
  /**
   * Get UI manager
   */
  getUI(name) {
    return this.uiManagers[name];
  }
  /**
   * Generate random seed for island generation
   */
  generateSeed() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  /**
   * Game loop - updates time, stats, and all systems
   */
  startGameLoop() {
    this.gameLoopInterval = setInterval(() => {
      if (this.isPaused) return;
      const now = Date.now();
      const deltaTime = now - this.state.meta.lastTick;
      this.state.meta.lastTick = now;
      this.state.meta.playTime += deltaTime / 1e3;
      this.advanceTime(deltaTime);
      if (this.player) {
        this.player.update(deltaTime);
      }
      if (this.resourceManager) {
        this.resourceManager.update(deltaTime);
      }
      if (Math.floor(this.state.meta.playTime / 300) > Math.floor((this.state.meta.playTime - deltaTime / 1e3) / 300)) {
        this.autoSave();
      }
      this.emit("gameLoopTick", { deltaTime, playTime: this.state.meta.playTime });
    }, 100);
  }
  /**
   * Pause/resume game
   */
  pause() {
    this.isPaused = true;
    this.emit("gamePaused");
  }
  resume() {
    this.isPaused = false;
    this.state.meta.lastTick = Date.now();
    this.emit("gameResumed");
  }
  togglePause() {
    if (this.isPaused) {
      this.resume();
    } else {
      this.pause();
    }
  }
  /**
   * Advance in-game time
   */
  advanceTime(deltaMs) {
    const gameMinutes = deltaMs / 1e3 * (this.state.time.timeScale / 60);
    this.state.time.minute += gameMinutes;
    if (this.state.time.minute >= 60) {
      const hoursToAdd = Math.floor(this.state.time.minute / 60);
      this.state.time.minute = this.state.time.minute % 60;
      this.state.time.hour += hoursToAdd;
      if (this.state.time.hour >= 24) {
        const daysToAdd = Math.floor(this.state.time.hour / 24);
        this.state.time.hour = this.state.time.hour % 24;
        this.state.time.day += daysToAdd;
        this.emit("newDay", { day: this.state.time.day });
      }
      this.emit("newHour", { hour: this.state.time.hour, day: this.state.time.day });
    }
    this.emit("timeAdvanced", this.state.time);
  }
  /**
   * Set time scale (how fast time passes)
   */
  setTimeScale(scale) {
    this.state.time.timeScale = scale;
    this.emit("timeScaleChanged", { timeScale: scale });
  }
  /**
   * Get formatted time string
   */
  getTimeString() {
    const hour = Math.floor(this.state.time.hour);
    const minute = Math.floor(this.state.time.minute);
    const ampm = hour >= 12 ? "PM" : "AM";
    const displayHour = hour % 12 || 12;
    return `Day ${this.state.time.day}, ${displayHour}:${minute.toString().padStart(2, "0")} ${ampm}`;
  }
  /**
   * Player actions - Consume item
   */
  consumeItem(itemId) {
    if (!this.player) return false;
    const item = itemDB.get(itemId);
    if (!item || !item.consumable) {
      console.warn("Item cannot be consumed:", itemId);
      return false;
    }
    const hasItem = this.player.inventory.hasItem(itemId);
    if (!hasItem) {
      console.warn("Player does not have item:", itemId);
      return false;
    }
    const success = this.player.consumeItem(item);
    if (success) {
      this.player.inventory.removeItem(itemId, 1);
      this.emit("itemConsumed", { itemId, item, effects: item.effects });
      return true;
    }
    return false;
  }
  /**
   * Player actions - Gather from resource node
   */
  gatherFromNode(nodeId, onProgress = null) {
    if (!this.player || !this.resourceManager) return null;
    const node = this.resourceManager.getNode(nodeId);
    if (!node) {
      console.warn("Node not found:", nodeId);
      return null;
    }
    const canGather = node.canGather(this.player);
    if (!canGather.success) {
      this.emit("gatherFailed", { nodeId, reason: canGather.reason });
      return { success: false, reason: canGather.reason };
    }
    const gatherTime = node.gatherTime;
    const startTime = Date.now();
    const progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / gatherTime * 100, 100);
      if (onProgress) onProgress(progress);
      if (progress >= 100) {
        clearInterval(progressInterval);
        const result = node.gather(this.player);
        if (result.success) {
          result.items.forEach((item) => {
            this.player.inventory.addItem(item);
          });
          this.emit("gatherComplete", { nodeId, result });
        }
        return result;
      }
    }, 100);
    return { success: true, gathering: true };
  }
  /**
   * Player actions - Equip item
   */
  equipItem(itemId, slot) {
    if (!this.player) return false;
    const item = this.player.inventory.slots.find((s) => !s.isEmpty() && s.item.id === itemId)?.item;
    if (!item) {
      console.warn("Item not in inventory:", itemId);
      return false;
    }
    const success = this.player.equipItem(item, slot);
    if (success) {
      this.emit("itemEquipped", { itemId, slot });
    }
    return success;
  }
  /**
   * Player actions - Move to position
   */
  movePlayer(q, r) {
    if (!this.player) return false;
    const success = this.player.moveTo(q, r);
    if (success) {
      this.emit("playerMoved", { position: { q, r } });
    }
    return success;
  }
  /**
   * Add character to the game
   */
  addCharacter(character) {
    this.state.characters.push(character);
    this.emit("characterAdded", character);
  }
  /**
   * Update character relationship
   */
  updateRelationship(characterId, delta) {
    const character = this.state.characters.find((c) => c.id === characterId);
    if (character) {
      character.relationship = Math.max(0, Math.min(100, character.relationship + delta));
      this.emit("relationshipChanged", { characterId, relationship: character.relationship, delta });
    }
  }
  /**
   * Add item to player inventory (legacy support + new system)
   */
  addItem(itemId, quantity = 1) {
    if (!this.player) return false;
    for (let i = 0; i < quantity; i++) {
      const item = itemDB.get(itemId);
      if (item) {
        this.player.inventory.addItem(item);
      }
    }
    this.emit("inventoryUpdated", this.player.inventory);
    return true;
  }
  /**
   * Remove item from inventory (legacy support + new system)
   */
  removeItem(itemId, quantity = 1) {
    if (!this.player) return false;
    const removed = this.player.inventory.removeItem(itemId, quantity);
    if (removed) {
      this.emit("inventoryUpdated", this.player.inventory);
    }
    return removed;
  }
  /**
   * Get player inventory (for UI/external access)
   */
  getInventory() {
    return this.player?.inventory || null;
  }
  /**
   * Save game state to localStorage
   */
  save(slotName = "autosave") {
    const saveData = {
      version: this.version,
      meta: {
        ...this.state.meta,
        saveDate: (/* @__PURE__ */ new Date()).toISOString(),
        saveName: slotName
      },
      player: this.player ? this.player.toJSON() : null,
      resourceManager: this.resourceManager ? this.resourceManager.toJSON() : null,
      state: {
        ...this.state,
        meta: void 0
        // Don't duplicate meta
      }
    };
    try {
      localStorage.setItem(`hedonism_save_${slotName}`, JSON.stringify(saveData));
      this.emit("gameSaved", { slotName, saveData });
      console.log(`‚úÖ Game saved: ${slotName}`);
      return true;
    } catch (e) {
      console.error("Failed to save game:", e);
      this.emit("saveFailed", { error: e.message });
      return false;
    }
  }
  /**
   * Auto-save
   */
  autoSave() {
    this.save("autosave");
  }
  /**
   * Load game state from localStorage
   */
  load(slotName = "autosave") {
    try {
      const savedData = localStorage.getItem(`hedonism_save_${slotName}`);
      if (!savedData) {
        console.warn(`No save found: ${slotName}`);
        return false;
      }
      const data = JSON.parse(savedData);
      if (!data.version || data.version === "1.0.0") {
        console.log("‚ö†Ô∏è Loading legacy v1.0.0 save - migrating to v2.0.0");
        this.migrateLegacySave(data);
      } else {
        this.loadState(data);
      }
      this.emit("gameLoaded", { slotName, data });
      console.log(`‚úÖ Game loaded: ${slotName} (v${data.version || "1.0.0"})`);
      return true;
    } catch (e) {
      console.error("Failed to load game:", e);
      this.emit("loadFailed", { error: e.message });
      return false;
    }
  }
  /**
   * Load state object into current state
   */
  loadState(data) {
    if (data.state) {
      this.state = { ...this.state, ...data.state };
    }
    if (data.meta) {
      this.state.meta = { ...data.meta, lastTick: Date.now() };
    }
    if (data.player) {
      this.player = Player.fromJSON(data.player);
    }
    if (data.resourceManager) {
      const nodeConfigs = {
        "tree": {
          resourceType: "wood",
          baseYield: { min: 2, max: 4 },
          requiredTool: "axe",
          requiredSkill: "woodcutting",
          sprite: "üå≥",
          depletedSprite: "ü™µ",
          gatherTime: 3e3,
          energyCost: 5
        },
        "rock": {
          resourceType: "stone",
          baseYield: { min: 2, max: 3 },
          requiredTool: "pickaxe",
          requiredSkill: "mining",
          sprite: "ü™®",
          depletedSprite: "‚ö´",
          gatherTime: 4e3,
          energyCost: 7
        },
        "berry_bush": {
          resourceType: "berries",
          baseYield: { min: 3, max: 6 },
          requiredTool: null,
          sprite: "ü´ê",
          depletedSprite: "üçÇ",
          gatherTime: 2e3,
          energyCost: 2
        },
        "coconut_tree": {
          resourceType: "coconut",
          baseYield: { min: 1, max: 2 },
          requiredTool: null,
          sprite: "üå¥",
          depletedSprite: "üå¥",
          gatherTime: 2500,
          energyCost: 3
        }
      };
      this.resourceManager = ResourceNodeManager.fromJSON(data.resourceManager, nodeConfigs);
    }
    this.emit("stateLoaded", { version: data.version || "2.0.0" });
  }
  /**
   * Migrate legacy v1.0.0 save to v2.0.0 format
   */
  migrateLegacySave(legacyData) {
    this.state = { ...legacyData };
    this.state.meta.lastTick = Date.now();
    const oldPlayer = legacyData.player || {};
    this.player = new Player({
      name: oldPlayer.name || "Survivor",
      gender: oldPlayer.gender || "neutral"
    });
    if (oldPlayer.health !== void 0) this.player.stats.health.current = oldPlayer.health;
    if (oldPlayer.hunger !== void 0) this.player.stats.hunger.current = oldPlayer.hunger;
    if (oldPlayer.thirst !== void 0) this.player.stats.thirst.current = oldPlayer.thirst;
    if (oldPlayer.energy !== void 0) this.player.stats.energy.current = oldPlayer.energy;
    if (oldPlayer.position) {
      this.player.position = { ...oldPlayer.position };
    }
    if (legacyData.inventory) {
      Object.entries(legacyData.inventory).forEach(([itemId, quantity]) => {
        const item = itemDB.get(itemId);
        if (item) {
          this.player.inventory.addItem(item, quantity);
        }
      });
    }
    this.resourceManager = new ResourceNodeManager();
    this.resourceManager.generateStarterNodes(this.player.position);
    console.log("‚úÖ Legacy save migrated to v2.0.0");
  }
  /**
   * Export save to JSON file
   */
  exportSave() {
    const saveData = {
      version: this.version,
      meta: {
        ...this.state.meta,
        saveDate: (/* @__PURE__ */ new Date()).toISOString()
      },
      player: this.player ? this.player.toJSON() : null,
      resourceManager: this.resourceManager ? this.resourceManager.toJSON() : null,
      state: {
        ...this.state,
        meta: void 0
        // Don't duplicate meta
      }
    };
    const dataStr = JSON.stringify(saveData, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `hedonism_island_day${this.state.time.day}_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    this.emit("saveExported", { filename: a.download });
  }
  /**
   * Import save from JSON file
   */
  importSave(fileContent) {
    try {
      const loadedState = JSON.parse(fileContent);
      this.loadState(loadedState);
      this.save("imported");
      return true;
    } catch (e) {
      console.error("Failed to import save:", e);
      return false;
    }
  }
  /**
   * List all available saves
   */
  listSaves() {
    const saves = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.startsWith("hedonism_save_")) {
        const slotName = key.replace("hedonism_save_", "");
        try {
          const data = JSON.parse(localStorage.getItem(key));
          const version = data.version || "1.0.0";
          let saveInfo = {
            slotName,
            version,
            saveDate: data.meta?.saveDate || "Unknown"
          };
          if (version === "2.0.0") {
            saveInfo.playerName = data.player?.name || "Survivor";
            saveInfo.day = data.state?.time?.day || 0;
            saveInfo.playTime = data.meta?.playTime || 0;
            saveInfo.health = data.player?.stats?.health?.current || 100;
            saveInfo.characterCount = data.state?.characters?.length || 0;
          } else {
            saveInfo.playerName = data.player?.name || "Survivor";
            saveInfo.day = data.time?.day || 0;
            saveInfo.playTime = data.meta?.playTime || 0;
            saveInfo.health = data.player?.health || 100;
            saveInfo.characterCount = data.characters?.length || 0;
          }
          saves.push(saveInfo);
        } catch (e) {
          console.error(`Failed to parse save ${slotName}:`, e);
        }
      }
    }
    return saves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
  }
  /**
   * Delete save
   */
  deleteSave(slotName) {
    localStorage.removeItem(`hedonism_save_${slotName}`);
    this.emit("saveDeleted", { slotName });
  }
  /**
   * Event bus - subscribe to state changes
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }
  /**
   * Event bus - subscribe once (auto-removes after first call)
   */
  once(event, callback) {
    const wrapper = (data) => {
      callback(data);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }
  /**
   * Event bus - unsubscribe from event
   */
  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
  /**
   * Event bus - emit event
   */
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach((callback) => callback(data));
    }
  }
  /**
   * Stop game loop (cleanup)
   */
  destroy() {
    if (this.gameLoopInterval) {
      clearInterval(this.gameLoopInterval);
    }
  }
  /**
   * Get current state (read-only)
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Set flag
   */
  setFlag(flagName, value) {
    this.state.flags[flagName] = value;
    this.emit("flagChanged", { flagName, value });
  }
  /**
   * Check flag
   */
  hasFlag(flagName) {
    return !!this.state.flags[flagName];
  }
}
class SettingsManager {
  constructor() {
    this.settings = {
      // Gender distribution per faction (percentages, must sum to 100)
      genderDistribution: {
        castaways: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        islanders: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        mercenaries: {
          female: 20,
          male: 60,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        },
        tourists: {
          female: 50,
          male: 30,
          futanari: 10,
          transWoman: 5,
          transMale: 5
        }
      },
      // NPC disposition sliders (0-100)
      npcDisposition: {
        friendliness: 50,
        // 0=hostile, 100=friendly
        romanceInterest: 70,
        // 0=not interested, 100=very interested
        sexualOpenness: 80,
        // 0=prude, 100=complete horndog
        hostility: 20,
        // 0=peaceful, 100=aggressive
        submissiveness: 50
        // 0=dominant, 100=submissive
      },
      // AI Image generation style
      aiImageStyle: {
        preset: "photo-realistic",
        // or 'anime', 'painterly', etc.
        custom: ""
        // Custom style keywords if preset is 'custom'
      },
      // Available presets
      aiImageStylePresets: [
        "photo-realistic",
        "anime",
        "manga",
        "painterly",
        "watercolor",
        "cartoon",
        "comic-book",
        "cinematic",
        "professional-studio",
        "fantasy-art",
        "pixel-art",
        "3d-render",
        "custom"
      ],
      // Difficulty settings
      difficulty: {
        survival: "normal",
        // easy, normal, hard, hardcore
        combat: "normal",
        // easy, normal, hard, permadeath
        economy: "normal"
        // generous, normal, challenging
      },
      // Gameplay toggles
      gameplay: {
        permadeath: false,
        autosaveFrequency: 5,
        // minutes
        tutorialEnabled: true,
        explicitContent: "full",
        // full, fade-to-black, off
        bloodViolence: "full",
        // full, reduced, off
        eventPacing: "normal"
        // slow, normal, fast
      },
      // Cheat panel
      cheats: {
        godMode: false,
        infiniteHealth: false,
        infiniteEnergy: false,
        infiniteResources: false,
        noHungerThirst: false,
        relationshipMultiplier: 1,
        // 0.1 - 10.0
        resourceMultiplier: 1
        // 0.5 - 10.0
      },
      // Content preferences (kinks)
      contentPreferences: {
        vanillaRomance: true,
        bdsm: false,
        submission: false,
        groupScenes: false,
        publicExhibition: false,
        voyeurism: false,
        breedingPregnancy: false,
        nonConDubCon: false,
        furryMonster: false,
        feet: false,
        lactation: false,
        ageGap: false,
        interracial: true,
        surpriseMe: false
        // Random kink inclusion
      },
      // Accessibility
      accessibility: {
        textSize: "medium",
        // small, medium, large, extra-large
        colorblindMode: "none",
        // none, protanopia, deuteranopia, tritanopia
        screenReader: false,
        animations: "full",
        // full, reduced, off
        autoAdvanceText: false,
        autoAdvanceSpeed: 3
        // 1-5 seconds
      }
    };
    this.load();
  }
  /**
   * Save settings to localStorage
   */
  save() {
    try {
      localStorage.setItem("hedonism_settings", JSON.stringify(this.settings));
      return true;
    } catch (e) {
      console.error("Failed to save settings:", e);
      return false;
    }
  }
  /**
   * Load settings from localStorage
   */
  load() {
    try {
      const saved = localStorage.getItem("hedonism_settings");
      if (saved) {
        const loadedSettings = JSON.parse(saved);
        this.settings = this.deepMerge(this.settings, loadedSettings);
      }
      return true;
    } catch (e) {
      console.error("Failed to load settings:", e);
      return false;
    }
  }
  /**
   * Deep merge two objects
   */
  deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }
  /**
   * Get specific setting
   */
  get(path) {
    const keys = path.split(".");
    let value = this.settings;
    for (const key of keys) {
      value = value[key];
      if (value === void 0) return null;
    }
    return value;
  }
  /**
   * Set specific setting
   */
  set(path, value) {
    const keys = path.split(".");
    let obj = this.settings;
    for (let i = 0; i < keys.length - 1; i++) {
      obj = obj[keys[i]];
    }
    obj[keys[keys.length - 1]] = value;
    this.save();
  }
  /**
   * Get gender for random NPC generation
   */
  getRandomGender(faction = "castaways") {
    const distribution = this.settings.genderDistribution[faction];
    const rand = Math.random() * 100;
    let cumulative = 0;
    for (const [gender, percentage] of Object.entries(distribution)) {
      cumulative += percentage;
      if (rand <= cumulative) {
        return gender;
      }
    }
    return "female";
  }
  /**
   * Get AI image style string for prompt
   */
  getAIImageStyle() {
    const style = this.settings.aiImageStyle;
    if (style.preset === "custom") {
      return style.custom;
    }
    const styleMap = {
      "photo-realistic": "photorealistic, professional photography, high quality",
      "anime": "anime style, manga art, japanese animation",
      "manga": "manga style, black and white, detailed lineart",
      "painterly": "oil painting, painterly style, artistic",
      "watercolor": "watercolor painting, soft colors, artistic",
      "cartoon": "cartoon style, animated, colorful",
      "comic-book": "comic book style, bold lines, pop art",
      "cinematic": "cinematic, film still, dramatic lighting",
      "professional-studio": "professional studio photography, high end, glamorous",
      "fantasy-art": "fantasy art, epic, detailed illustration",
      "pixel-art": "pixel art, retro, 8-bit style",
      "3d-render": "3d render, cgi, digital art"
    };
    return styleMap[style.preset] || styleMap["photo-realistic"];
  }
  /**
   * Check if specific kink is enabled
   */
  isKinkEnabled(kinkName) {
    return this.settings.contentPreferences[kinkName] || false;
  }
  /**
   * Get active kinks list
   */
  getActiveKinks() {
    return Object.entries(this.settings.contentPreferences).filter(([key, value]) => value && key !== "surpriseMe").map(([key]) => key);
  }
  /**
   * Apply difficulty modifiers
   */
  getDifficultyMultipliers() {
    const survival = this.settings.difficulty.survival;
    const combat = this.settings.difficulty.combat;
    const multipliers = {
      hungerDrain: 1,
      thirstDrain: 1,
      energyDrain: 1,
      resourceYield: 1,
      enemyStrength: 1,
      deathRisk: 0.01
      // 1% base death chance in combat
    };
    switch (survival) {
      case "easy":
        multipliers.hungerDrain = 0.5;
        multipliers.thirstDrain = 0.5;
        multipliers.energyDrain = 0.5;
        multipliers.resourceYield = 1.5;
        break;
      case "hard":
        multipliers.hungerDrain = 1.5;
        multipliers.thirstDrain = 1.5;
        multipliers.energyDrain = 1.5;
        multipliers.resourceYield = 0.7;
        break;
      case "hardcore":
        multipliers.hungerDrain = 2;
        multipliers.thirstDrain = 2;
        multipliers.energyDrain = 2;
        multipliers.resourceYield = 0.5;
        break;
    }
    switch (combat) {
      case "easy":
        multipliers.enemyStrength = 0.7;
        multipliers.deathRisk = 1e-3;
        break;
      case "hard":
        multipliers.enemyStrength = 1.3;
        multipliers.deathRisk = 0.05;
        break;
      case "permadeath":
        multipliers.enemyStrength = 1.5;
        multipliers.deathRisk = 0.1;
        break;
    }
    if (this.settings.cheats.resourceMultiplier !== 1) {
      multipliers.resourceYield *= this.settings.cheats.resourceMultiplier;
    }
    return multipliers;
  }
  /**
   * Reset settings to defaults
   */
  reset() {
    localStorage.removeItem("hedonism_settings");
    this.settings = this.constructor.prototype.settings;
    return true;
  }
  /**
   * Export settings to JSON
   */
  export() {
    const dataStr = JSON.stringify(this.settings, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "hedonism_settings.json";
    a.click();
    URL.revokeObjectURL(url);
  }
  /**
   * Import settings from JSON
   */
  import(fileContent) {
    try {
      const imported = JSON.parse(fileContent);
      this.settings = this.deepMerge(this.settings, imported);
      this.save();
      return true;
    } catch (e) {
      console.error("Failed to import settings:", e);
      return false;
    }
  }
}
class SettingsMenu {
  constructor(settingsManager2) {
    this.settings = settingsManager2;
    this.currentTab = "gender";
    this.isOpen = false;
  }
  /**
   * Open settings menu
   */
  open() {
    this.isOpen = true;
    this.render();
  }
  /**
   * Close settings menu
   */
  close() {
    this.isOpen = false;
    const menu = document.getElementById("settings-menu");
    if (menu) {
      menu.remove();
    }
  }
  /**
   * Render settings menu
   */
  render() {
    const existing = document.getElementById("settings-menu");
    if (existing) existing.remove();
    const menu = document.createElement("div");
    menu.id = "settings-menu";
    menu.className = "modal-overlay";
    menu.innerHTML = `
      <div class="modal-content settings-modal">
        <div class="modal-header">
          <h2>‚öôÔ∏è Settings</h2>
          <button class="close-btn" id="close-settings">‚úï</button>
        </div>
        
        <div class="settings-body">
          <div class="settings-tabs">
            <button class="tab-btn ${this.currentTab === "gender" ? "active" : ""}" data-tab="gender">
              Gender Distribution
            </button>
            <button class="tab-btn ${this.currentTab === "disposition" ? "active" : ""}" data-tab="disposition">
              NPC Disposition
            </button>
            <button class="tab-btn ${this.currentTab === "ai-style" ? "active" : ""}" data-tab="ai-style">
              AI Style
            </button>
            <button class="tab-btn ${this.currentTab === "difficulty" ? "active" : ""}" data-tab="difficulty">
              Difficulty
            </button>
            <button class="tab-btn ${this.currentTab === "gameplay" ? "active" : ""}" data-tab="gameplay">
              Gameplay
            </button>
            <button class="tab-btn ${this.currentTab === "cheats" ? "active" : ""}" data-tab="cheats">
              Cheats
            </button>
            <button class="tab-btn ${this.currentTab === "content" ? "active" : ""}" data-tab="content">
              Content/Kinks
            </button>
            <button class="tab-btn ${this.currentTab === "accessibility" ? "active" : ""}" data-tab="accessibility">
              Accessibility
            </button>
          </div>
          
          <div class="settings-content">
            ${this.renderCurrentTab()}
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn btn-secondary" id="reset-settings">Reset to Defaults</button>
          <button class="btn btn-secondary" id="export-settings">Export Settings</button>
          <div class="spacer"></div>
          <button class="btn btn-secondary" id="cancel-settings">Cancel</button>
          <button class="btn btn-primary" id="save-settings">Save & Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(menu);
    this.attachEventListeners();
  }
  /**
   * Render current tab content
   */
  renderCurrentTab() {
    switch (this.currentTab) {
      case "gender":
        return this.renderGenderTab();
      case "disposition":
        return this.renderDispositionTab();
      case "ai-style":
        return this.renderAIStyleTab();
      case "difficulty":
        return this.renderDifficultyTab();
      case "gameplay":
        return this.renderGameplayTab();
      case "cheats":
        return this.renderCheatsTab();
      case "content":
        return this.renderContentTab();
      case "accessibility":
        return this.renderAccessibilityTab();
      default:
        return "<p>Select a tab</p>";
    }
  }
  /**
   * Render Gender Distribution tab
   */
  renderGenderTab() {
    const factions = ["castaways", "islanders", "mercenaries", "tourists"];
    const genders = ["female", "male", "futanari", "transWoman", "transMale"];
    const genderLabels = {
      female: "Female",
      male: "Male",
      futanari: "Futanari",
      transWoman: "Trans Woman",
      transMale: "Trans Man"
    };
    let html = '<div class="tab-content"><h3>Gender Distribution by Faction</h3>';
    html += '<p class="help-text">Adjust the likelihood of each gender appearing in procedurally generated characters. Percentages must total 100% per faction.</p>';
    for (const faction of factions) {
      html += `<div class="faction-section">
        <h4>${faction.charAt(0).toUpperCase() + faction.slice(1)}</h4>`;
      for (const gender of genders) {
        const value = this.settings.get(`genderDistribution.${faction}.${gender}`);
        html += `
          <div class="slider-control">
            <label>${genderLabels[gender]}</label>
            <input type="range" min="0" max="100" value="${value}" 
                   data-setting="genderDistribution.${faction}.${gender}"
                   class="slider">
            <span class="slider-value">${value}%</span>
          </div>
        `;
      }
      html += "</div>";
    }
    html += "</div>";
    return html;
  }
  /**
   * Render NPC Disposition tab
   */
  renderDispositionTab() {
    const dispositions = {
      friendliness: { label: "Friendliness", min: "Hostile", max: "Friendly" },
      romanceInterest: { label: "Romance Interest", min: "Not Interested", max: "Very Interested" },
      sexualOpenness: { label: "Sexual Openness", min: "Prude", max: "Complete Horndog" },
      hostility: { label: "Hostility", min: "Peaceful", max: "Aggressive" },
      submissiveness: { label: "Submissiveness", min: "Dominant", max: "Submissive" }
    };
    let html = '<div class="tab-content"><h3>NPC Disposition</h3>';
    html += '<p class="help-text">These sliders affect the baseline personality traits of generated NPCs.</p>';
    for (const [key, config] of Object.entries(dispositions)) {
      const value = this.settings.get(`npcDisposition.${key}`);
      html += `
        <div class="slider-control wide">
          <label>${config.label}</label>
          <div class="slider-labels">
            <span>${config.min}</span>
            <span>${config.max}</span>
          </div>
          <input type="range" min="0" max="100" value="${value}"
                 data-setting="npcDisposition.${key}"
                 class="slider">
          <span class="slider-value">${value}</span>
        </div>
      `;
    }
    html += "</div>";
    return html;
  }
  /**
   * Render AI Style tab
   */
  renderAIStyleTab() {
    const currentPreset = this.settings.get("aiImageStyle.preset");
    const customValue = this.settings.get("aiImageStyle.custom");
    const presets = this.settings.settings.aiImageStylePresets;
    let html = '<div class="tab-content"><h3>AI Image Generation Style</h3>';
    html += '<p class="help-text">Choose how AI-generated character portraits and scenes should look.</p>';
    html += '<div class="style-selector">';
    for (const preset of presets) {
      const label = preset.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
      html += `
        <label class="radio-card">
          <input type="radio" name="ai-style" value="${preset}" 
                 ${currentPreset === preset ? "checked" : ""}>
          <span>${label}</span>
        </label>
      `;
    }
    html += "</div>";
    html += `
      <div class="custom-style ${currentPreset === "custom" ? "" : "hidden"}" id="custom-style-input">
        <label>Custom Style Keywords</label>
        <input type="text" value="${customValue}" 
               data-setting="aiImageStyle.custom"
               placeholder="e.g., vintage photograph, sepia tone, 1920s">
        <p class="help-text">Enter Perchance-compatible style keywords.</p>
      </div>
    `;
    html += "</div>";
    return html;
  }
  /**
   * Render Difficulty tab
   */
  renderDifficultyTab() {
    const survival = this.settings.get("difficulty.survival");
    const combat = this.settings.get("difficulty.combat");
    const economy = this.settings.get("difficulty.economy");
    return `
      <div class="tab-content">
        <h3>Difficulty Settings</h3>
        
        <div class="difficulty-section">
          <h4>Survival Difficulty</h4>
          <select data-setting="difficulty.survival">
            <option value="easy" ${survival === "easy" ? "selected" : ""}>Easy - Slow hunger/thirst drain, abundant resources</option>
            <option value="normal" ${survival === "normal" ? "selected" : ""}>Normal - Balanced survival challenge</option>
            <option value="hard" ${survival === "hard" ? "selected" : ""}>Hard - Fast stat drain, scarce resources</option>
            <option value="hardcore" ${survival === "hardcore" ? "selected" : ""}>Hardcore - Extreme challenge, for masochists</option>
          </select>
        </div>
        
        <div class="difficulty-section">
          <h4>Combat Difficulty</h4>
          <select data-setting="difficulty.combat">
            <option value="easy" ${combat === "easy" ? "selected" : ""}>Easy - Weak enemies, very rare deaths</option>
            <option value="normal" ${combat === "normal" ? "selected" : ""}>Normal - Balanced combat, injury common</option>
            <option value="hard" ${combat === "hard" ? "selected" : ""}>Hard - Strong enemies, death possible</option>
            <option value="permadeath" ${combat === "permadeath" ? "selected" : ""}>Permadeath - Death is permanent. Good luck.</option>
          </select>
        </div>
        
        <div class="difficulty-section">
          <h4>Economy Difficulty (Phase 4)</h4>
          <select data-setting="difficulty.economy">
            <option value="generous" ${economy === "generous" ? "selected" : ""}>Generous - Money flows freely</option>
            <option value="normal" ${economy === "normal" ? "selected" : ""}>Normal - Balanced economy</option>
            <option value="challenging" ${economy === "challenging" ? "selected" : ""}>Challenging - Every coin counts</option>
          </select>
        </div>
      </div>
    `;
  }
  /**
   * Render Gameplay tab
   */
  renderGameplayTab() {
    const gameplay = this.settings.settings.gameplay;
    return `
      <div class="tab-content">
        <h3>Gameplay Options</h3>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="gameplay.permadeath" ${gameplay.permadeath ? "checked" : ""}>
            <span>Permadeath - Characters can die permanently</span>
          </label>
        </div>
        
        <div class="slider-control">
          <label>Autosave Frequency (minutes)</label>
          <input type="range" min="1" max="30" value="${gameplay.autosaveFrequency}"
                 data-setting="gameplay.autosaveFrequency" class="slider">
          <span class="slider-value">${gameplay.autosaveFrequency}</span>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="gameplay.tutorialEnabled" ${gameplay.tutorialEnabled ? "checked" : ""}>
            <span>Tutorial Hints Enabled</span>
          </label>
        </div>
        
        <div class="select-control">
          <label>Explicit Content Display</label>
          <select data-setting="gameplay.explicitContent">
            <option value="full" ${gameplay.explicitContent === "full" ? "selected" : ""}>Full - Show everything (recommended)</option>
            <option value="fade-to-black" ${gameplay.explicitContent === "fade-to-black" ? "selected" : ""}>Fade to Black - Implied only (for cowards)</option>
            <option value="off" ${gameplay.explicitContent === "off" ? "selected" : ""}>Off - No sexual content (why are you here?)</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Blood & Violence</label>
          <select data-setting="gameplay.bloodViolence">
            <option value="full" ${gameplay.bloodViolence === "full" ? "selected" : ""}>Full - Realistic violence</option>
            <option value="reduced" ${gameplay.bloodViolence === "reduced" ? "selected" : ""}>Reduced - Minimal gore</option>
            <option value="off" ${gameplay.bloodViolence === "off" ? "selected" : ""}>Off - Cartoon violence</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Event Pacing</label>
          <select data-setting="gameplay.eventPacing">
            <option value="slow" ${gameplay.eventPacing === "slow" ? "selected" : ""}>Slow - Take your time</option>
            <option value="normal" ${gameplay.eventPacing === "normal" ? "selected" : ""}>Normal - Balanced</option>
            <option value="fast" ${gameplay.eventPacing === "fast" ? "selected" : ""}>Fast - Quick progression</option>
          </select>
        </div>
      </div>
    `;
  }
  /**
   * Render Cheats tab
   */
  renderCheatsTab() {
    const cheats = this.settings.settings.cheats;
    return `
      <div class="tab-content">
        <h3>Cheat Panel</h3>
        <p class="help-text warning">‚ö†Ô∏è Using cheats may affect achievements (if we add them later)</p>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.godMode" ${cheats.godMode ? "checked" : ""}>
            <span>God Mode - All cheats enabled</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteHealth" ${cheats.infiniteHealth ? "checked" : ""}>
            <span>Infinite Health</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteEnergy" ${cheats.infiniteEnergy ? "checked" : ""}>
            <span>Infinite Energy</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.infiniteResources" ${cheats.infiniteResources ? "checked" : ""}>
            <span>Infinite Resources</span>
          </label>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="cheats.noHungerThirst" ${cheats.noHungerThirst ? "checked" : ""}>
            <span>No Hunger/Thirst</span>
          </label>
        </div>
        
        <div class="slider-control">
          <label>Relationship Gain Multiplier</label>
          <input type="range" min="0.1" max="10" step="0.1" value="${cheats.relationshipMultiplier}"
                 data-setting="cheats.relationshipMultiplier" class="slider">
          <span class="slider-value">${cheats.relationshipMultiplier}x</span>
        </div>
        
        <div class="slider-control">
          <label>Resource Gather Multiplier</label>
          <input type="range" min="0.5" max="10" step="0.1" value="${cheats.resourceMultiplier}"
                 data-setting="cheats.resourceMultiplier" class="slider">
          <span class="slider-value">${cheats.resourceMultiplier}x</span>
        </div>
      </div>
    `;
  }
  /**
   * Render Content/Kinks tab
   */
  renderContentTab() {
    const prefs = this.settings.settings.contentPreferences;
    const kinks = [
      { key: "vanillaRomance", label: "Vanilla Romance", desc: "Standard romantic content" },
      { key: "bdsm", label: "BDSM/Dominance", desc: "Bondage, discipline, dominance scenes" },
      { key: "submission", label: "Submission/Slavery", desc: "Submissive dynamics, slavery content" },
      { key: "groupScenes", label: "Group Scenes", desc: "Threesomes, orgies, multiple partners" },
      { key: "publicExhibition", label: "Public/Exhibition", desc: "Public sex, being watched" },
      { key: "voyeurism", label: "Voyeurism", desc: "Watching others" },
      { key: "breedingPregnancy", label: "Breeding/Pregnancy", desc: "Impregnation, pregnancy content" },
      { key: "nonConDubCon", label: "Non-Con/Dubious Consent", desc: "Forced or questionable consent scenarios" },
      { key: "furryMonster", label: "Furry/Monster", desc: "Non-human characters" },
      { key: "feet", label: "Feet", desc: "Foot fetish content" },
      { key: "lactation", label: "Lactation", desc: "Breastfeeding, milk" },
      { key: "ageGap", label: "Age Gap (18+)", desc: "Significant age differences, all 18+" },
      { key: "interracial", label: "Interracial", desc: "Diverse ethnic pairings" },
      { key: "surpriseMe", label: "Surprise Me!", desc: "Random kink inclusion" }
    ];
    let html = '<div class="tab-content"><h3>Content Preferences / Kinks</h3>';
    html += '<p class="help-text">Enable the types of sexual content you want to encounter. Disabled content will be filtered out.</p>';
    html += '<div class="kink-grid">';
    for (const kink of kinks) {
      html += `
        <div class="kink-card">
          <label>
            <input type="checkbox" data-setting="contentPreferences.${kink.key}" ${prefs[kink.key] ? "checked" : ""}>
            <div class="kink-label">
              <strong>${kink.label}</strong>
              <span class="kink-desc">${kink.desc}</span>
            </div>
          </label>
        </div>
      `;
    }
    html += "</div></div>";
    return html;
  }
  /**
   * Render Accessibility tab
   */
  renderAccessibilityTab() {
    const acc = this.settings.settings.accessibility;
    return `
      <div class="tab-content">
        <h3>Accessibility Options</h3>
        
        <div class="select-control">
          <label>Text Size</label>
          <select data-setting="accessibility.textSize">
            <option value="small" ${acc.textSize === "small" ? "selected" : ""}>Small</option>
            <option value="medium" ${acc.textSize === "medium" ? "selected" : ""}>Medium</option>
            <option value="large" ${acc.textSize === "large" ? "selected" : ""}>Large</option>
            <option value="extra-large" ${acc.textSize === "extra-large" ? "selected" : ""}>Extra Large</option>
          </select>
        </div>
        
        <div class="select-control">
          <label>Colorblind Mode</label>
          <select data-setting="accessibility.colorblindMode">
            <option value="none" ${acc.colorblindMode === "none" ? "selected" : ""}>None</option>
            <option value="protanopia" ${acc.colorblindMode === "protanopia" ? "selected" : ""}>Protanopia (Red-Green)</option>
            <option value="deuteranopia" ${acc.colorblindMode === "deuteranopia" ? "selected" : ""}>Deuteranopia (Red-Green)</option>
            <option value="tritanopia" ${acc.colorblindMode === "tritanopia" ? "selected" : ""}>Tritanopia (Blue-Yellow)</option>
          </select>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="accessibility.screenReader" ${acc.screenReader ? "checked" : ""}>
            <span>Screen Reader Support</span>
          </label>
        </div>
        
        <div class="select-control">
          <label>Animations</label>
          <select data-setting="accessibility.animations">
            <option value="full" ${acc.animations === "full" ? "selected" : ""}>Full</option>
            <option value="reduced" ${acc.animations === "reduced" ? "selected" : ""}>Reduced</option>
            <option value="off" ${acc.animations === "off" ? "selected" : ""}>Off</option>
          </select>
        </div>
        
        <div class="toggle-control">
          <label>
            <input type="checkbox" data-setting="accessibility.autoAdvanceText" ${acc.autoAdvanceText ? "checked" : ""}>
            <span>Auto-Advance Text</span>
          </label>
        </div>
        
        <div class="slider-control ${acc.autoAdvanceText ? "" : "disabled"}">
          <label>Auto-Advance Speed (seconds)</label>
          <input type="range" min="1" max="10" value="${acc.autoAdvanceSpeed}"
                 data-setting="accessibility.autoAdvanceSpeed" class="slider"
                 ${acc.autoAdvanceText ? "" : "disabled"}>
          <span class="slider-value">${acc.autoAdvanceSpeed}s</span>
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    document.getElementById("close-settings").onclick = () => this.close();
    document.getElementById("cancel-settings").onclick = () => this.close();
    document.querySelectorAll(".tab-btn").forEach((btn) => {
      btn.onclick = () => {
        this.currentTab = btn.dataset.tab;
        this.render();
      };
    });
    document.querySelectorAll('input[type="range"]').forEach((slider) => {
      slider.oninput = (e) => {
        const valueDisplay = e.target.nextElementSibling;
        if (valueDisplay && valueDisplay.classList.contains("slider-value")) {
          const setting = e.target.dataset.setting;
          if (setting && setting.includes("genderDistribution")) {
            valueDisplay.textContent = `${e.target.value}%`;
          } else if (setting && setting.includes("Multiplier")) {
            valueDisplay.textContent = `${e.target.value}x`;
          } else if (setting === "accessibility.autoAdvanceSpeed") {
            valueDisplay.textContent = `${e.target.value}s`;
          } else {
            valueDisplay.textContent = e.target.value;
          }
        }
      };
    });
    document.querySelectorAll('input[name="ai-style"]').forEach((radio) => {
      radio.onchange = (e) => {
        this.settings.set("aiImageStyle.preset", e.target.value);
        const customInput = document.getElementById("custom-style-input");
        if (customInput) {
          if (e.target.value === "custom") {
            customInput.classList.remove("hidden");
          } else {
            customInput.classList.add("hidden");
          }
        }
      };
    });
    document.getElementById("save-settings").onclick = () => this.saveSettings();
    document.getElementById("reset-settings").onclick = () => {
      if (confirm("Reset all settings to defaults? This cannot be undone.")) {
        this.settings.reset();
        this.render();
      }
    };
    document.getElementById("export-settings").onclick = () => this.settings.export();
  }
  /**
   * Save all settings
   */
  saveSettings() {
    document.querySelectorAll("[data-setting]").forEach((input) => {
      const setting = input.dataset.setting;
      let value;
      if (input.type === "checkbox") {
        value = input.checked;
      } else if (input.type === "range") {
        value = parseFloat(input.value);
      } else {
        value = input.value;
      }
      this.settings.set(setting, value);
    });
    this.settings.save();
    this.close();
    this.showNotification("Settings saved successfully!");
  }
  /**
   * Show notification toast
   */
  showNotification(message) {
    const toast = document.createElement("div");
    toast.className = "notification-toast";
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.classList.add("show"), 10);
    setTimeout(() => {
      toast.classList.remove("show");
      setTimeout(() => toast.remove(), 300);
    }, 3e3);
  }
}
class MainMenu {
  constructor(gameState2, settingsManager2, settingsMenu2, characterCreation2) {
    this.gameState = gameState2;
    this.settings = settingsManager2;
    this.settingsMenu = settingsMenu2;
    this.characterCreation = characterCreation2;
    console.log("üéØ MainMenu initialized with:", {
      gameState: !!gameState2,
      settingsManager: !!settingsManager2,
      settingsMenu: !!settingsMenu2,
      characterCreation: !!characterCreation2
    });
  }
  /**
   * Initialize main menu
   */
  init() {
    console.log("üìã MainMenu.init() called");
    this.attachEventListeners();
    this.checkContinueButton();
    console.log("‚úÖ MainMenu.init() complete");
  }
  /**
   * Attach event listeners to menu buttons
   */
  attachEventListeners() {
    const continueBtn = document.getElementById("btn-continue");
    const newGameBtn = document.getElementById("btn-new-game");
    const loadBtn = document.getElementById("btn-load");
    const settingsBtn = document.getElementById("btn-settings");
    const creditsBtn = document.getElementById("btn-credits");
    console.log("üîó Attaching event listeners:", {
      continueBtn: !!continueBtn,
      newGameBtn: !!newGameBtn,
      loadBtn: !!loadBtn,
      settingsBtn: !!settingsBtn,
      creditsBtn: !!creditsBtn
    });
    if (continueBtn) {
      continueBtn.onclick = () => this.continueGame();
    }
    if (newGameBtn) {
      newGameBtn.onclick = () => {
        console.log("üéÆ New Game button clicked!");
        this.newGame();
      };
    }
    if (loadBtn) {
      loadBtn.onclick = () => this.showLoadMenu();
    }
    if (settingsBtn) {
      settingsBtn.onclick = () => this.settingsMenu.open();
    }
    if (creditsBtn) {
      creditsBtn.onclick = () => this.showCredits();
    }
  }
  /**
   * Check if there's a save to continue from
   */
  checkContinueButton() {
    const continueBtn = document.getElementById("btn-continue");
    if (!continueBtn) return;
    const hasSave = localStorage.getItem("hedonism_save_autosave");
    if (hasSave) {
      continueBtn.disabled = false;
    } else {
      continueBtn.disabled = true;
    }
  }
  /**
   * Continue from last save
   */
  continueGame() {
    const savedData = localStorage.getItem("hedonism_save_autosave");
    if (savedData) {
      try {
        const saveState = JSON.parse(savedData);
        this.gameState.emit("loadGame", saveState);
        const menu = document.getElementById("main-menu");
        if (menu) menu.classList.add("hidden");
      } catch (e) {
        console.error("Failed to continue game:", e);
        const menu = document.getElementById("main-menu");
        if (menu) menu.classList.remove("hidden");
        const startNew = confirm("Failed to load save game. Would you like to start a new game instead?");
        if (startNew) {
          this.newGame();
        }
      }
    } else {
      const startNew = confirm("No save game found. Would you like to start a new game?");
      if (startNew) {
        this.newGame();
      }
    }
  }
  /**
   * Start new game
   */
  newGame() {
    console.log("üéÆ New Game clicked");
    const hasSave = localStorage.getItem("hedonism_save_autosave");
    if (hasSave) {
      const confirmed = confirm("Starting a new game will overwrite your current progress. Continue?");
      if (!confirmed) return;
    }
    console.log("üìù Initializing game state...");
    this.gameState.init();
    console.log("üé® Showing character creation...");
    this.characterCreation.show();
    this.gameState.once("characterCreated", () => {
      console.log("‚úÖ Character created, starting game...");
      this.startGame();
    });
  }
  /**
   * Show load game menu
   */
  showLoadMenu() {
    if (window.game && window.game.saveManager) {
      window.game.saveManager.show();
      return;
    }
    const saves = this.gameState.listSaves();
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "load-menu";
    let savesHTML = "";
    if (saves.length === 0) {
      savesHTML = '<div class="no-saves">No saved games found.</div>';
    } else {
      savesHTML = '<div class="save-list">';
      saves.forEach((save) => {
        const date = new Date(save.saveDate).toLocaleString();
        savesHTML += `
          <div class="save-item" data-slot="${save.slotName}">
            <div class="save-info">
              <h4>${save.slotName}</h4>
              <p>Day ${save.day} ‚Ä¢ ${save.characterCount} characters ‚Ä¢ ${this.formatPlayTime(save.playTime)}</p>
              <p class="save-date">${date}</p>
            </div>
            <div class="save-actions">
              <button class="btn-load" data-slot="${save.slotName}">Load</button>
              <button class="btn-delete" data-slot="${save.slotName}">Delete</button>
            </div>
          </div>
        `;
      });
      savesHTML += "</div>";
    }
    modal.innerHTML = `
      <div class="modal-content load-game-modal">
        <div class="modal-header">
          <h2>Load Game</h2>
          <button class="close-btn" id="close-load-menu">‚úï</button>
        </div>
        <div class="modal-body">
          ${savesHTML}
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="cancel-load">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-load-menu").onclick = () => modal.remove();
    document.getElementById("cancel-load").onclick = () => modal.remove();
    modal.querySelectorAll(".btn-load").forEach((btn) => {
      btn.onclick = (e) => {
        const slot = e.target.dataset.slot;
        const savedData = localStorage.getItem(`hedonism_save_${slot}`);
        if (savedData) {
          try {
            const saveState = JSON.parse(savedData);
            modal.remove();
            const menu = document.getElementById("main-menu");
            if (menu) menu.classList.add("hidden");
            this.gameState.emit("loadGame", saveState);
          } catch (e2) {
            console.error("Failed to load game:", e2);
            alert("Failed to load save game.");
          }
        } else {
          alert("Save file not found.");
        }
      };
    });
    modal.querySelectorAll(".btn-delete").forEach((btn) => {
      btn.onclick = (e) => {
        const slot = e.target.dataset.slot;
        if (confirm(`Delete save "${slot}"?`)) {
          this.gameState.deleteSave(slot);
          modal.remove();
          this.showLoadMenu();
        }
      };
    });
  }
  /**
   * Show credits
   */
  showCredits() {
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "credits-menu";
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h2>Credits</h2>
          <button class="close-btn" id="close-credits">‚úï</button>
        </div>
        <div class="modal-body credits-content">
          <h3>Hedonism Island</h3>
          <p>A survival/management/dating sim where morality is optional</p>
          
          <div class="credit-section">
            <h4>Development</h4>
            <p>Built with Vite, vanilla JavaScript, and pure degeneracy</p>
          </div>
          
          <div class="credit-section">
            <h4>AI Generation</h4>
            <p>Powered by Perchance AI</p>
            <p>Text-to-Image Plugin ‚Ä¢ AI Text Plugin</p>
          </div>
          
          <div class="credit-section">
            <h4>Special Thanks</h4>
            <p>To everyone who said "you can't make that"</p>
            <p>We fucking did it anyway</p>
          </div>
          
          <div class="credit-section">
            <h4>Content Warning</h4>
            <p>This game contains explicit sexual content,</p>
            <p>player-choice morality including slavery and violence,</p>
            <p>and themes that would give your grandmother a heart attack.</p>
            <p><strong>18+ ONLY</strong></p>
          </div>
          
          <p style="margin-top: 30px; font-style: italic; color: #999;">
            "Survival is optional. Pleasure is mandatory."
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="close-credits-btn">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-credits").onclick = () => modal.remove();
    document.getElementById("close-credits-btn").onclick = () => modal.remove();
  }
  /**
   * Start the game (deprecated - now handled by story intro ‚Üí game view flow)
   */
  startGame() {
    console.warn("MainMenu.startGame() is deprecated. Game flow is now: Character Creation ‚Üí Story Intro ‚Üí Game View");
  }
  /**
   * Show main menu (hide game view)
   */
  showMenu() {
    const menu = document.getElementById("main-menu");
    const gameView2 = document.getElementById("game-view");
    if (menu) menu.classList.remove("hidden");
    if (gameView2) gameView2.classList.add("hidden");
    this.checkContinueButton();
  }
  /**
   * Format play time in human-readable format
   */
  formatPlayTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else {
      return `${minutes}m`;
    }
  }
}
class CharacterCreator {
  constructor() {
    this.currentCharacter = this.getDefaultCharacter();
    this.presets = this.loadPresets();
    this.backgroundBonuses = {};
    this.manualSkillPoints = {
      survival: 0,
      combat: 0,
      charisma: 0,
      crafting: 0,
      medical: 0,
      leadership: 0
    };
  }
  getDefaultCharacter() {
    return {
      // Basic Info
      name: "",
      age: 25,
      gender: "female",
      // female, male, futanari, Cuntboy, other
      // Physical Appearance
      body: {
        height: "average",
        // petite, short, average, tall, very-tall, custom
        heightCustom: "",
        build: "average",
        // skinny, slim, average, athletic, curvy, muscular, heavyset, custom
        buildCustom: "",
        skinTone: "tan",
        // pale, fair, tan, olive, brown, dark, custom
        skinToneCustom: "",
        // Face
        faceShape: "oval",
        // oval, round, square, heart, diamond, custom
        faceShapeCustom: "",
        eyeColor: "brown",
        // brown, blue, green, hazel, gray, amber, heterochromia, custom
        eyeColorCustom: "",
        eyeShape: "almond",
        // almond, round, hooded, upturned, downturned, custom
        eyeShapeCustom: "",
        hairColor: "brown",
        // black, brown, blonde, red, auburn, gray, white, unusual, custom
        hairColorCustom: "",
        hairLength: "shoulder",
        // buzzed, short, shoulder, long, very-long, custom
        hairLengthCustom: "",
        hairStyle: "straight",
        // straight, wavy, curly, kinky, braided, tied-up, custom
        hairStyleCustom: "",
        // Body Features
        breastSize: "medium",
        // flat, small, medium, large, very-large, huge, custom
        breastSizeCustom: "",
        buttSize: "medium",
        // small, medium, large, very-large, custom
        buttSizeCustom: "",
        muscleTone: "average",
        // soft, toned, average, muscular, very-muscular, custom
        muscleToneCustom: "",
        // Distinctive Features
        scars: "none",
        // none, few, many, prominent, custom
        scarsCustom: "",
        scarLocation: null,
        // face, chest, back, arms, legs, custom
        scarLocationCustom: "",
        birthmarks: false,
        birthmarksCustom: "",
        // Custom description if birthmarks = true
        freckles: "none",
        // none, light, moderate, heavy, custom
        frecklesCustom: "",
        beautyMark: false,
        beautyMarkCustom: "",
        // Custom description if beautyMark = true
        distinctiveFeaturesCustom: "",
        // General custom distinctive features
        // Genitals (explicit customization)
        primaryGenitals: "vagina",
        // penis, vagina, both
        secondaryGenitals: null,
        // null, penis, vagina (for futanari/andromorph)
        // Penis details (if applicable)
        penisSize: "average",
        // small, average, large, very-large, huge, custom
        penisSizeCustom: "",
        penisGirth: "average",
        // thin, average, thick, very-thick, custom
        penisGirthCustom: "",
        circumcised: false,
        // Vagina details (if applicable)
        vaginaTightness: "average",
        // tight, average, loose, custom
        vaginaTightnessCustom: "",
        vaginaDepth: "average",
        // shallow, average, deep, custom
        vaginaDepthCustom: "",
        // Other
        pubicHair: "trimmed",
        // none, trimmed, natural, styled, custom
        pubicHairCustom: "",
        bodyHair: "minimal",
        // none, minimal, average, hairy, custom
        bodyHairCustom: "",
        tattoos: "none",
        // none, few, many, custom
        tattoosCustom: "",
        piercings: "none",
        // none, ears, face, body, nipples, genital, multiple, custom
        piercingsCustom: ""
      },
      // Personality Traits (developed through gameplay, start neutral)
      personality: {
        dominance: 50,
        // 0-100 (submissive to dominant)
        openness: 50,
        // 0-100 (reserved to promiscuous)
        morality: 50,
        // 0-100 (cruel to kind)
        confidence: 50,
        // 0-100 (shy to confident)
        intelligence: 50,
        // 0-100 (simple to clever)
        aggression: 50
        // 0-100 (passive to aggressive)
      },
      // Background & Skills
      background: "tourist",
      // tourist, sailor, scientist, criminal, drifter, pilot
      traits: [],
      // Special traits from background and achievements
      skills: {
        survival: 0,
        combat: 0,
        charisma: 0,
        crafting: 0,
        medical: 0,
        leadership: 0
      },
      // Sexual Preferences & Experience
      sexualProfile: {
        experience: "experienced",
        // virgin, inexperienced, experienced, veteran
        preferredRole: "versatile",
        // dominant, submissive, versatile, switch
        virginityStatus: {
          vaginal: false,
          // Only applies if has vagina
          anal: false,
          oral: false
        },
        kinks: [],
        // Will be populated from settings
        turnOns: [],
        // Specific preferences
        limits: []
        // Hard no's
      },
      // Generated Portrait
      portraitUrl: null,
      portraitPrompt: ""
    };
  }
  loadPresets() {
    return {
      female: [
        {
          name: "Beach Babe",
          description: "Curvy, confident surfer girl with sun-kissed skin",
          character: {
            age: 23,
            gender: "female",
            body: {
              height: "average",
              build: "curvy",
              skinTone: "tan",
              faceShape: "heart",
              eyeColor: "blue",
              eyeShape: "almond",
              hairColor: "blonde",
              hairLength: "long",
              hairStyle: "wavy",
              breastSize: "large",
              buttSize: "large",
              muscleTone: "toned",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "average",
              pubicHair: "trimmed",
              bodyHair: "none",
              tattoos: "few",
              piercings: "ears"
            },
            personality: {
              dominance: 60,
              openness: 70,
              morality: 50,
              confidence: 75,
              intelligence: 50,
              aggression: 40
            },
            background: "tourist",
            skills: { survival: 1, charisma: 3, crafting: 1 }
          }
        },
        {
          name: "Jungle Explorer",
          description: "Athletic researcher with a curious mind",
          character: {
            age: 28,
            gender: "female",
            body: {
              height: "tall",
              build: "athletic",
              skinTone: "olive",
              faceShape: "oval",
              eyeColor: "green",
              eyeShape: "upturned",
              hairColor: "brown",
              hairLength: "shoulder",
              hairStyle: "tied-up",
              breastSize: "medium",
              buttSize: "medium",
              muscleTone: "muscular",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "tight",
              vaginaDepth: "average",
              pubicHair: "natural",
              bodyHair: "minimal",
              tattoos: "none",
              piercings: "none"
            },
            personality: {
              dominance: 55,
              openness: 50,
              morality: 65,
              confidence: 70,
              intelligence: 80,
              aggression: 45
            },
            background: "scientist",
            skills: { survival: 3, medical: 2, crafting: 2 }
          }
        },
        {
          name: "Island Siren",
          description: "Seductive beauty with dangerous charm",
          character: {
            age: 26,
            gender: "female",
            body: {
              height: "average",
              build: "slim",
              skinTone: "fair",
              faceShape: "diamond",
              eyeColor: "hazel",
              eyeShape: "hooded",
              hairColor: "red",
              hairLength: "very-long",
              hairStyle: "straight",
              breastSize: "medium",
              buttSize: "medium",
              muscleTone: "soft",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "deep",
              pubicHair: "none",
              bodyHair: "none",
              tattoos: "many",
              piercings: "multiple"
            },
            personality: {
              dominance: 70,
              openness: 85,
              morality: 30,
              confidence: 85,
              intelligence: 65,
              aggression: 55
            },
            background: "criminal",
            skills: { charisma: 4, combat: 2, survival: 1 }
          }
        }
      ],
      male: [
        {
          name: "Rugged Survivor",
          description: "Strong, capable man built for the wilderness",
          character: {
            age: 32,
            gender: "male",
            body: {
              height: "tall",
              build: "muscular",
              skinTone: "tan",
              faceShape: "square",
              eyeColor: "brown",
              eyeShape: "almond",
              hairColor: "brown",
              hairLength: "short",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "large",
              penisGirth: "thick",
              circumcised: true,
              pubicHair: "trimmed",
              bodyHair: "average",
              tattoos: "few",
              piercings: "none"
            },
            personality: {
              dominance: 70,
              openness: 50,
              morality: 60,
              confidence: 75,
              intelligence: 55,
              aggression: 65
            },
            background: "sailor",
            skills: { survival: 3, combat: 3, crafting: 2 }
          }
        },
        {
          name: "Smooth Talker",
          description: "Charismatic and charming ladies man",
          character: {
            age: 27,
            gender: "male",
            body: {
              height: "average",
              build: "athletic",
              skinTone: "olive",
              faceShape: "oval",
              eyeColor: "blue",
              eyeShape: "upturned",
              hairColor: "black",
              hairLength: "short",
              hairStyle: "styled",
              breastSize: "flat",
              buttSize: "small",
              muscleTone: "toned",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "average",
              penisGirth: "average",
              circumcised: false,
              pubicHair: "trimmed",
              bodyHair: "minimal",
              tattoos: "none",
              piercings: "ears"
            },
            personality: {
              dominance: 50,
              openness: 75,
              morality: 50,
              confidence: 80,
              intelligence: 70,
              aggression: 35
            },
            background: "tourist",
            skills: { charisma: 4, survival: 1, medical: 1 }
          }
        },
        {
          name: "Brutal Fighter",
          description: "Aggressive warrior with no mercy",
          character: {
            age: 35,
            gender: "male",
            body: {
              height: "very-tall",
              build: "muscular",
              skinTone: "brown",
              faceShape: "square",
              eyeColor: "gray",
              eyeShape: "downturned",
              hairColor: "black",
              hairLength: "buzzed",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "penis",
              secondaryGenitals: null,
              penisSize: "very-large",
              penisGirth: "very-thick",
              circumcised: true,
              pubicHair: "natural",
              bodyHair: "hairy",
              tattoos: "many",
              piercings: "body"
            },
            personality: {
              dominance: 90,
              openness: 60,
              morality: 20,
              confidence: 85,
              intelligence: 40,
              aggression: 90
            },
            background: "criminal",
            skills: { combat: 4, survival: 2, leadership: 1 }
          }
        }
      ],
      futanari: [
        {
          name: "Exotic Beauty",
          description: "Stunning futanari with feminine grace and masculine power",
          character: {
            age: 24,
            gender: "futanari",
            body: {
              height: "tall",
              build: "curvy",
              skinTone: "tan",
              faceShape: "heart",
              eyeColor: "amber",
              eyeShape: "almond",
              hairColor: "unusual",
              hairLength: "long",
              hairStyle: "straight",
              breastSize: "large",
              buttSize: "large",
              muscleTone: "toned",
              primaryGenitals: "both",
              secondaryGenitals: null,
              penisSize: "large",
              penisGirth: "thick",
              circumcised: false,
              vaginaTightness: "tight",
              vaginaDepth: "average",
              pubicHair: "trimmed",
              bodyHair: "none",
              tattoos: "few",
              piercings: "multiple"
            },
            personality: {
              dominance: 75,
              openness: 80,
              morality: 50,
              confidence: 80,
              intelligence: 60,
              aggression: 50
            },
            background: "tourist",
            skills: { charisma: 3, survival: 1, combat: 2 }
          }
        }
      ],
      Cuntboy: [
        {
          name: "Tough Guy",
          description: "Masculine build with unexpected anatomy",
          character: {
            age: 29,
            gender: "Cuntboy",
            body: {
              height: "tall",
              build: "muscular",
              skinTone: "fair",
              faceShape: "square",
              eyeColor: "blue",
              eyeShape: "almond",
              hairColor: "blonde",
              hairLength: "short",
              hairStyle: "straight",
              breastSize: "flat",
              buttSize: "medium",
              muscleTone: "very-muscular",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "tight",
              vaginaDepth: "shallow",
              pubicHair: "trimmed",
              bodyHair: "average",
              tattoos: "few",
              piercings: "none"
            },
            personality: {
              dominance: 65,
              openness: 55,
              morality: 55,
              confidence: 70,
              intelligence: 50,
              aggression: 70
            },
            background: "sailor",
            skills: { combat: 3, survival: 2, crafting: 2 }
          }
        }
      ],
      other: [
        {
          name: "Mysterious Stranger",
          description: "Androgynous beauty defying categorization",
          character: {
            age: 25,
            gender: "other",
            body: {
              height: "average",
              build: "slim",
              skinTone: "pale",
              faceShape: "oval",
              eyeColor: "heterochromia",
              eyeShape: "round",
              hairColor: "unusual",
              hairLength: "shoulder",
              hairStyle: "wavy",
              breastSize: "small",
              buttSize: "small",
              muscleTone: "soft",
              primaryGenitals: "vagina",
              secondaryGenitals: null,
              vaginaTightness: "average",
              vaginaDepth: "average",
              pubicHair: "styled",
              bodyHair: "none",
              tattoos: "many",
              piercings: "multiple"
            },
            personality: {
              dominance: 50,
              openness: 70,
              morality: 60,
              confidence: 60,
              intelligence: 75,
              aggression: 40
            },
            background: "scientist",
            skills: { medical: 2, crafting: 2, charisma: 2 }
          }
        }
      ]
    };
  }
  getPresetsForGender(gender) {
    return this.presets[gender] || [];
  }
  applyPreset(gender, presetIndex) {
    const presets = this.getPresetsForGender(gender);
    if (presets[presetIndex]) {
      const preset = JSON.parse(JSON.stringify(presets[presetIndex].character));
      const defaultChar = this.getDefaultCharacter();
      this.currentCharacter = {
        ...defaultChar,
        ...preset,
        skills: {
          ...defaultChar.skills,
          // Start with all 6 skills at 0
          ...preset.skills
          // Override with preset values
        },
        personality: {
          dominance: 50,
          openness: 50,
          morality: 50,
          confidence: 50,
          intelligence: 50,
          aggression: 50
        }
      };
      return true;
    }
    return false;
  }
  setGender(gender) {
    this.currentCharacter.gender = gender;
    if (!this.currentCharacter.name) {
      this.currentCharacter.name = this.getDefaultName(gender);
    }
    if (gender === "male" || gender === "Cuntboy") {
      this.currentCharacter.body.breastSize = "flat";
      this.currentCharacter.body.build = "athletic";
    }
    if (gender === "male") {
      this.currentCharacter.body.primaryGenitals = "penis";
    } else if (gender === "female") {
      this.currentCharacter.body.primaryGenitals = "vagina";
    } else if (gender === "futanari") {
      this.currentCharacter.body.primaryGenitals = "both";
    } else if (gender === "Cuntboy") {
      this.currentCharacter.body.primaryGenitals = "vagina";
    }
  }
  getDefaultName(gender) {
    const defaultNames = {
      female: "Isla",
      male: "Kai",
      futanari: "Sage",
      Cuntboy: "River",
      other: "Quinn"
    };
    return defaultNames[gender] || "Survivor";
  }
  updateAttribute(path, value) {
    const keys = path.split(".");
    let obj = this.currentCharacter;
    for (let i = 0; i < keys.length - 1; i++) {
      obj = obj[keys[i]];
    }
    obj[keys[keys.length - 1]] = value;
    if (path === "background") {
      this.applyBackgroundBonuses(value);
    }
  }
  applyBackgroundBonuses(background) {
    this.backgroundBonuses = {
      survival: 0,
      combat: 0,
      charisma: 0,
      crafting: 0,
      medical: 0,
      leadership: 0
    };
    this.currentCharacter.traits = [];
    const bonuses = {
      tourist: {
        skills: { charisma: 2, crafting: 1 },
        trait: "Quick Learner"
      },
      sailor: {
        skills: { survival: 2, combat: 2 },
        trait: "Sea Legs"
      },
      scientist: {
        skills: { medical: 2, crafting: 2 },
        trait: "Analytical Mind"
      },
      criminal: {
        skills: { combat: 2, charisma: 1, survival: 1 },
        trait: "Streetwise"
      },
      drifter: {
        skills: { survival: 2, crafting: 1, leadership: 1 },
        trait: "Self-Reliant"
      },
      pilot: {
        skills: { crafting: 2, leadership: 1, charisma: 1 },
        trait: "Cool Under Pressure"
      },
      custom: {
        skills: {},
        // No background bonuses
        trait: null
        // No trait
      }
    };
    const bonus = bonuses[background];
    if (bonus) {
      Object.keys(bonus.skills).forEach((skill) => {
        this.backgroundBonuses[skill] = bonus.skills[skill];
      });
      if (bonus.trait) {
        this.currentCharacter.traits.push(bonus.trait);
      }
    }
    this.updateTotalSkills();
  }
  updateTotalSkills() {
    Object.keys(this.currentCharacter.skills).forEach((skill) => {
      const backgroundBonus = this.backgroundBonuses[skill] || 0;
      const manualPoints = this.manualSkillPoints[skill] || 0;
      this.currentCharacter.skills[skill] = backgroundBonus + manualPoints;
    });
  }
  getBackgroundBonuses() {
    return { ...this.backgroundBonuses };
  }
  addManualSkillPoint(skill) {
    const totalManual = Object.values(this.manualSkillPoints).reduce((a, b) => a + b, 0);
    const maxPoints = this.currentCharacter.background === "custom" ? 11 : 7;
    if (totalManual < maxPoints) {
      this.manualSkillPoints[skill]++;
      this.updateTotalSkills();
      return true;
    }
    return false;
  }
  removeManualSkillPoint(skill) {
    if (this.manualSkillPoints[skill] > 0) {
      this.manualSkillPoints[skill]--;
      this.updateTotalSkills();
      return true;
    }
    return false;
  }
  getAttribute(path) {
    const keys = path.split(".");
    let value = this.currentCharacter;
    for (const key of keys) {
      value = value[key];
      if (value === void 0) return null;
    }
    return value;
  }
  // Helper to get display value (use custom text if value is 'custom')
  getDisplayValue(value, customPath) {
    if (value === "custom") {
      const customValue = this.getAttribute(customPath);
      return customValue || "custom";
    }
    return value;
  }
  // Unified method that generates comprehensive character description
  // Used for both preview display AND portrait generation
  generateCharacterDescription() {
    const c = this.currentCharacter;
    const body = c.body;
    const height = this.getDisplayValue(body.height, "body.heightCustom");
    const build = this.getDisplayValue(body.build, "body.buildCustom");
    const skinTone = this.getDisplayValue(body.skinTone, "body.skinToneCustom");
    const faceShape = this.getDisplayValue(body.faceShape, "body.faceShapeCustom");
    const eyeColor = this.getDisplayValue(body.eyeColor, "body.eyeColorCustom");
    const eyeShape = this.getDisplayValue(body.eyeShape, "body.eyeShapeCustom");
    const hairColor = this.getDisplayValue(body.hairColor, "body.hairColorCustom");
    const hairLength = this.getDisplayValue(body.hairLength, "body.hairLengthCustom");
    const hairStyle = this.getDisplayValue(body.hairStyle, "body.hairStyleCustom");
    const breastSize = this.getDisplayValue(body.breastSize, "body.breastSizeCustom");
    const buttSize = this.getDisplayValue(body.buttSize, "body.buttSizeCustom");
    const muscleTone = this.getDisplayValue(body.muscleTone, "body.muscleToneCustom");
    const scars = this.getDisplayValue(body.scars, "body.scarsCustom");
    const scarLocation = this.getDisplayValue(body.scarLocation, "body.scarLocationCustom");
    const freckles = this.getDisplayValue(body.freckles, "body.frecklesCustom");
    const birthmarks = body.birthmarks ? body.birthmarksCustom || "birthmarks" : null;
    const beautyMark = body.beautyMark ? body.beautyMarkCustom || "beauty mark" : null;
    const tattoos = this.getDisplayValue(body.tattoos, "body.tattoosCustom");
    const piercings = this.getDisplayValue(body.piercings, "body.piercingsCustom");
    const pubicHair = this.getDisplayValue(body.pubicHair, "body.pubicHairCustom");
    const bodyHair = this.getDisplayValue(body.bodyHair, "body.bodyHairCustom");
    const distinctiveFeaturesCustom = body.distinctiveFeaturesCustom || "";
    return {
      // Basic info
      age: c.age,
      gender: c.gender,
      name: c.name || "Unnamed",
      // Body
      height,
      build,
      skinTone,
      faceShape,
      eyeColor,
      eyeShape,
      hairColor,
      hairLength,
      hairStyle,
      breastSize,
      buttSize,
      muscleTone,
      // Body hair
      pubicHair,
      bodyHair,
      // Distinctive features
      scars,
      scarLocation,
      freckles,
      birthmarks,
      beautyMark,
      tattoos,
      piercings,
      distinctiveFeaturesCustom,
      // Background
      background: c.background,
      backgroundCustom: body.backgroundCustom || "",
      // Skills and traits
      skills: { ...c.skills },
      traits: [...c.traits]
    };
  }
  // Generate AI portrait prompt from character description
  generatePortraitPrompt() {
    const desc = this.generateCharacterDescription();
    let prompt2 = `Full body portrait of a ${desc.age} year old ${desc.gender === "other" ? "androgynous person" : desc.gender}, `;
    prompt2 += `${desc.height} height, ${desc.build} build, ${desc.muscleTone} muscle tone, `;
    prompt2 += `${desc.skinTone} skin, ${desc.faceShape} face shape, `;
    prompt2 += `${desc.eyeColor} ${desc.eyeShape} eyes, `;
    prompt2 += `${desc.hairLength} ${desc.hairStyle} ${desc.hairColor} hair, `;
    if (desc.gender === "female" || desc.gender === "futanari") {
      prompt2 += `${desc.breastSize} breasts, `;
    }
    prompt2 += `${desc.buttSize} butt, `;
    if (desc.bodyHair && desc.bodyHair !== "minimal" && desc.bodyHair !== "average") {
      prompt2 += `${desc.bodyHair} body hair, `;
    }
    if (desc.freckles && desc.freckles !== "none") {
      prompt2 += `${desc.freckles} freckles, `;
    }
    if (desc.beautyMark) {
      prompt2 += `${desc.beautyMark}, `;
    }
    if (desc.birthmarks) {
      prompt2 += `${desc.birthmarks}, `;
    }
    if (desc.scars && desc.scars !== "none") {
      if (desc.scarLocation && desc.scarLocation !== "none") {
        prompt2 += `${desc.scars} scars on ${desc.scarLocation}, `;
      } else {
        prompt2 += `${desc.scars} scars, `;
      }
    }
    if (desc.tattoos && desc.tattoos !== "none") {
      prompt2 += `${desc.tattoos} tattoos, `;
    }
    if (desc.piercings && desc.piercings !== "none") {
      prompt2 += `${desc.piercings} piercings, `;
    }
    if (desc.distinctiveFeaturesCustom) {
      prompt2 += `${desc.distinctiveFeaturesCustom}, `;
    }
    prompt2 += `standing pose, attractive appearance, `;
    prompt2 += `photorealistic, detailed, high quality, full body shot, natural lighting, `;
    prompt2 += `isolated on transparent background, no background elements`;
    return prompt2;
  }
  async generatePortrait(aiModule, styleOverride = null) {
    const style = styleOverride || "realistic";
    try {
      const prompt2 = this.generatePortraitPrompt();
      this.currentCharacter.portraitPrompt = prompt2;
      const imageUrl = await aiModule.generateImageFromPrompt(prompt2, style);
      this.currentCharacter.portraitUrl = imageUrl;
      this.currentCharacter.portraitStyle = style;
      return imageUrl;
    } catch (error) {
      console.error("Failed to generate portrait:", error);
      throw error;
    }
  }
  getCharacter() {
    return JSON.parse(JSON.stringify(this.currentCharacter));
  }
  setCharacter(character) {
    this.currentCharacter = character;
  }
  validateCharacter() {
    const errors = [];
    if (!this.currentCharacter.name || this.currentCharacter.name.trim() === "") {
      errors.push("Character name is required");
    }
    if (this.currentCharacter.age < 18) {
      errors.push("Character must be 18 or older");
    }
    if (!this.currentCharacter.portraitUrl) {
      errors.push("Portrait image is required (click Generate Portrait)");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  randomizeStep(step) {
    const body = this.currentCharacter.body;
    switch (step) {
      case 1:
        const genders = ["female", "male", "futanari", "Cuntboy", "other"];
        const currentIndex = genders.indexOf(this.currentCharacter.gender);
        const nextIndex = (currentIndex + 1) % genders.length;
        this.setGender(genders[nextIndex]);
        break;
      case 3:
        const heights = ["petite", "short", "average", "tall", "very-tall"];
        const builds = ["skinny", "slim", "average", "athletic", "curvy", "muscular", "heavyset"];
        const skins = ["pale", "fair", "tan", "olive", "brown", "dark"];
        const faces = ["oval", "round", "square", "heart", "diamond"];
        const eyeColors = ["brown", "blue", "green", "hazel", "gray", "amber", "heterochromia"];
        const eyeShapes = ["almond", "round", "hooded", "upturned", "downturned"];
        const hairColors = ["black", "brown", "blonde", "red", "auburn", "gray", "white", "unusual"];
        const hairLengths = ["buzzed", "short", "shoulder", "long", "very-long"];
        const hairStyles = ["straight", "wavy", "curly", "kinky", "braided", "tied-up"];
        const breastSizes = ["flat", "small", "medium", "large", "very-large", "huge"];
        const buttSizes = ["small", "medium", "large", "very-large"];
        const muscleTones = ["soft", "toned", "average", "muscular", "very-muscular"];
        const scarsOptions = ["none", "few", "many", "prominent"];
        const frecklesOptions = ["none", "light", "moderate", "heavy"];
        const pubicHairOptions = ["none", "trimmed", "natural", "styled"];
        const bodyHairOptions = ["none", "minimal", "average", "hairy"];
        const tattooOptions = ["none", "few", "many", "custom"];
        const piercingOptions = ["none", "ears", "face", "body", "nipples", "genital", "multiple"];
        body.height = heights[Math.floor(Math.random() * heights.length)];
        body.build = builds[Math.floor(Math.random() * builds.length)];
        body.skinTone = skins[Math.floor(Math.random() * skins.length)];
        body.faceShape = faces[Math.floor(Math.random() * faces.length)];
        body.eyeColor = eyeColors[Math.floor(Math.random() * eyeColors.length)];
        body.eyeShape = eyeShapes[Math.floor(Math.random() * eyeShapes.length)];
        body.hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];
        body.hairLength = hairLengths[Math.floor(Math.random() * hairLengths.length)];
        body.hairStyle = hairStyles[Math.floor(Math.random() * hairStyles.length)];
        body.buttSize = buttSizes[Math.floor(Math.random() * buttSizes.length)];
        body.muscleTone = muscleTones[Math.floor(Math.random() * muscleTones.length)];
        body.scars = scarsOptions[Math.floor(Math.random() * scarsOptions.length)];
        body.freckles = frecklesOptions[Math.floor(Math.random() * frecklesOptions.length)];
        body.birthmarks = Math.random() > 0.7;
        body.beautyMark = Math.random() > 0.8;
        body.pubicHair = pubicHairOptions[Math.floor(Math.random() * pubicHairOptions.length)];
        body.bodyHair = bodyHairOptions[Math.floor(Math.random() * bodyHairOptions.length)];
        body.tattoos = tattooOptions[Math.floor(Math.random() * tattooOptions.length)];
        body.piercings = piercingOptions[Math.floor(Math.random() * piercingOptions.length)];
        if (this.currentCharacter.gender === "female" || this.currentCharacter.gender === "futanari") {
          body.breastSize = breastSizes[Math.floor(Math.random() * breastSizes.length)];
        }
        if (body.scars !== "none") {
          const locations = ["face", "chest", "back", "arms", "legs"];
          body.scarLocation = locations[Math.floor(Math.random() * locations.length)];
        } else {
          body.scarLocation = null;
        }
        break;
      case 4:
        const backgrounds = ["tourist", "sailor", "scientist", "criminal", "drifter", "pilot"];
        const currentBg = backgrounds.indexOf(this.currentCharacter.background);
        const nextBg = (currentBg + 1) % backgrounds.length;
        this.setBackground(backgrounds[nextBg]);
        break;
    }
  }
  getPreviewSummary() {
    const desc = this.generateCharacterDescription();
    let descParts = [];
    descParts.push(`${desc.height} ${desc.build} build`);
    descParts.push(`${desc.muscleTone} muscle tone`);
    descParts.push(`${desc.skinTone} skin`);
    descParts.push(`${desc.faceShape} face`);
    descParts.push(`${desc.hairLength} ${desc.hairStyle} ${desc.hairColor} hair`);
    descParts.push(`${desc.eyeColor} ${desc.eyeShape} eyes`);
    if (desc.gender === "female" || desc.gender === "futanari") {
      descParts.push(`${desc.breastSize} breasts`);
    }
    descParts.push(`${desc.buttSize} butt`);
    if (desc.freckles && desc.freckles !== "none") {
      descParts.push(`${desc.freckles} freckles`);
    }
    if (desc.beautyMark) {
      descParts.push(desc.beautyMark);
    }
    if (desc.birthmarks) {
      descParts.push(desc.birthmarks);
    }
    if (desc.scars && desc.scars !== "none") {
      if (desc.scarLocation) {
        descParts.push(`${desc.scars} scars (${desc.scarLocation})`);
      } else {
        descParts.push(`${desc.scars} scars`);
      }
    }
    if (desc.tattoos && desc.tattoos !== "none") {
      descParts.push(`${desc.tattoos} tattoos`);
    }
    if (desc.piercings && desc.piercings !== "none") {
      descParts.push(`${desc.piercings} piercings`);
    }
    if (desc.bodyHair && desc.bodyHair !== "minimal") {
      descParts.push(`${desc.bodyHair} body hair`);
    }
    if (desc.distinctiveFeaturesCustom) {
      descParts.push(desc.distinctiveFeaturesCustom);
    }
    return {
      name: desc.name,
      age: desc.age,
      gender: desc.gender,
      description: descParts.join(", "),
      background: desc.background,
      skills: desc.skills,
      traits: desc.traits
    };
  }
}
class CharacterCreationUI {
  constructor(gameState2, settingsManager2, perchanceAI) {
    this.gameState = gameState2;
    this.settingsManager = settingsManager2;
    this.ai = perchanceAI;
    this.creator = new CharacterCreator();
    this.currentStep = 1;
    this.totalSteps = 5;
    this.usePreset = false;
  }
  show() {
    this.currentStep = 1;
    this.render();
    const mainMenu2 = document.getElementById("main-menu");
    if (mainMenu2) {
      mainMenu2.classList.add("hidden");
    }
    const container = document.getElementById("character-creation");
    container.style.display = "flex";
    container.offsetHeight;
    container.classList.add("active");
    console.log("‚úÖ Character creation UI shown");
  }
  hide() {
    const container = document.getElementById("character-creation");
    container.classList.remove("active");
    setTimeout(() => {
      container.style.display = "none";
    }, 400);
    console.log("‚úÖ Character creation UI hidden");
  }
  render() {
    const container = document.getElementById("character-creation");
    const preview = this.creator.getPreviewSummary();
    container.innerHTML = `
      <div class="char-creation-wrapper">
        <div class="char-creation-container">
          <div class="char-creation-header">
            <h1>Create Your Character</h1>
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${this.currentStep / this.totalSteps * 100}%"></div>
            </div>
            <p class="step-indicator">Step ${this.currentStep} of ${this.totalSteps}</p>
            ${[1, 3, 4].includes(this.currentStep) ? '<button id="randomize-btn" class="btn-randomize" title="Randomize this step">üé≤ Random</button>' : ""}
          </div>
          
          <div class="char-creation-content">
            ${this.renderStep()}
          </div>
          
          <div class="char-creation-footer">
            ${this.currentStep > 1 ? '<button id="prev-step-btn" class="btn-secondary">‚Üê Previous</button>' : ""}
            ${this.currentStep < this.totalSteps ? '<button id="next-step-btn" class="btn-primary">Next ‚Üí</button>' : ""}
            ${this.currentStep === this.totalSteps ? '<button id="confirm-character-btn" class="btn-primary">Start Game ‚Üí</button>' : ""}
          </div>
        </div>
        
        <div class="char-preview-panel">
          <h3>Character Preview</h3>
          <div class="preview-content">
            <div class="preview-field">
              <span class="preview-label">Name:</span>
              <span class="preview-value ${!preview.name || preview.name === "Unnamed" ? "preview-missing" : ""}">${preview.name}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Age:</span>
              <span class="preview-value">${preview.age}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Gender:</span>
              <span class="preview-value">${preview.gender.charAt(0).toUpperCase() + preview.gender.slice(1)}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Description:</span>
              <span class="preview-value">${preview.description || "Not yet defined"}</span>
            </div>
            <div class="preview-field">
              <span class="preview-label">Background:</span>
              <span class="preview-value">${preview.background.charAt(0).toUpperCase() + preview.background.slice(1)}</span>
            </div>
            
            <div class="preview-section">
              <h4>Skills</h4>
              ${Object.entries(preview.skills).map(([skill, value]) => `
                <div class="preview-skill">
                  <span>${skill.charAt(0).toUpperCase() + skill.slice(1)}</span>
                  <span class="skill-dots">${"‚óè".repeat(value)}${"‚óã".repeat(Math.max(0, 10 - value))}</span>
                </div>
              `).join("")}
            </div>
            
            ${preview.traits.length > 0 ? `
              <div class="preview-section">
                <h4>Traits</h4>
                <div class="preview-traits">
                  ${preview.traits.map((trait) => `<span class="trait-badge">${trait}</span>`).join("")}
                </div>
              </div>
            ` : ""}
          </div>
        </div>
      </div>
    `;
    this.attachEventListeners();
  }
  renderStep() {
    switch (this.currentStep) {
      case 1:
        return this.renderGenderStep();
      case 2:
        return this.renderPresetStep();
      case 3:
        return this.renderAppearanceStep();
      case 4:
        return this.renderBackgroundStep();
      case 5:
        return this.renderPortraitStep();
      default:
        return "";
    }
  }
  renderGenderStep() {
    return `
      <div class="step-content">
        <h2>Choose Your Gender</h2>
        <p class="step-description">Select the gender identity for your character</p>
        
        <div class="gender-options">
          ${this.renderGenderOption("female", "Female", "‚ôÄ", "Feminine body with vagina")}
          ${this.renderGenderOption("male", "Male", "‚ôÇ", "Masculine body with penis")}
          ${this.renderGenderOption("futanari", "Futanari", "‚ö•", "Feminine body with both penis and vagina")}
          ${this.renderGenderOption("Cuntboy", "Cuntboy", "‚ö≤", "Masculine body with vagina")}
          ${this.renderGenderOption("other", "Other/Non-Binary", "‚ö™", "Androgynous or custom configuration")}
        </div>
      </div>
    `;
  }
  renderGenderOption(value, label, symbol, description) {
    const selected = this.creator.currentCharacter.gender === value ? "selected" : "";
    return `
      <div class="gender-card ${selected}" data-gender="${value}">
        <div class="gender-symbol">${symbol}</div>
        <div class="gender-label">${label}</div>
        <div class="gender-description">${description}</div>
      </div>
    `;
  }
  renderPresetStep() {
    const gender = this.creator.currentCharacter.gender;
    const presets = this.creator.getPresetsForGender(gender);
    return `
      <div class="step-content">
        <h2>Choose Creation Method</h2>
        <p class="step-description">Use a preset or customize every detail</p>
        
        <div class="creation-method-options">
          <div class="method-card ${!this.usePreset ? "selected" : ""}" data-method="custom">
            <h3>‚ú® Full Customization</h3>
            <p>Choose every detail of your character's appearance, personality, and background</p>
          </div>
          
          <div class="method-card ${this.usePreset ? "selected" : ""}" data-method="preset">
            <h3>‚ö° Quick Presets</h3>
            <p>Start with a pre-made character template</p>
          </div>
        </div>
        
        ${this.usePreset ? `
          <div class="preset-selection">
            <h3>Select a Preset</h3>
            <div class="preset-options">
              ${presets.map((preset, index) => `
                <div class="preset-card" data-preset="${index}">
                  <h4>${preset.name}</h4>
                  <p>${preset.description}</p>
                </div>
              `).join("")}
            </div>
          </div>
        ` : ""}
      </div>
    `;
  }
  renderAppearanceStep() {
    const body = this.creator.currentCharacter.body;
    const gender = this.creator.currentCharacter.gender;
    return `
      <div class="step-content appearance-step">
        <h2>Customize Appearance</h2>
        <p class="step-description">Design every detail of your character's body</p>
        
        <div class="appearance-sections">
          \x3C!-- Basic Body -->
          <div class="appearance-section">
            <h3>Body Type</h3>
            ${this.renderSelect("body.height", "Height", ["petite", "short", "average", "tall", "very-tall"])}
            ${this.renderSelect("body.build", "Build", ["skinny", "slim", "average", "athletic", "curvy", "muscular", "heavyset"])}
            ${this.renderSelect("body.skinTone", "Skin Tone", ["pale", "fair", "tan", "olive", "brown", "dark"])}
            ${this.renderSelect("body.muscleTone", "Muscle Tone", ["soft", "toned", "average", "muscular", "very-muscular"])}
          </div>
          
          \x3C!-- Face -->
          <div class="appearance-section">
            <h3>Face</h3>
            ${this.renderSelect("body.faceShape", "Face Shape", ["oval", "round", "square", "heart", "diamond"])}
            ${this.renderSelect("body.eyeColor", "Eye Color", ["brown", "blue", "green", "hazel", "gray", "amber", "heterochromia"])}
            ${this.renderSelect("body.eyeShape", "Eye Shape", ["almond", "round", "hooded", "upturned", "downturned"])}
          </div>
          
          \x3C!-- Hair -->
          <div class="appearance-section">
            <h3>Hair</h3>
            ${this.renderSelect("body.hairColor", "Hair Color", ["black", "brown", "blonde", "red", "auburn", "gray", "white", "unusual"])}
            ${this.renderSelect("body.hairLength", "Hair Length", ["buzzed", "short", "shoulder", "long", "very-long"])}
            ${this.renderSelect("body.hairStyle", "Hair Style", ["straight", "wavy", "curly", "kinky", "braided", "tied-up"])}
          </div>
          
          \x3C!-- Body Features -->
          <div class="appearance-section">
            <h3>Body Features</h3>
            ${gender === "female" || gender === "futanari" ? this.renderSelect("body.breastSize", "Breast Size", ["flat", "small", "medium", "large", "very-large", "huge"]) : ""}
            ${this.renderSelect("body.buttSize", "Butt Size", ["small", "medium", "large", "very-large"])}
            ${this.renderSelect("body.pubicHair", "Pubic Hair", ["none", "trimmed", "natural", "styled"])}
            ${this.renderSelect("body.bodyHair", "Body Hair", ["none", "minimal", "average", "hairy"])}
            ${this.renderSelect("body.tattoos", "Tattoos", ["none", "few", "many", "custom"])}
            ${this.renderSelect("body.piercings", "Piercings", ["none", "ears", "face", "body", "nipples", "genital", "multiple"])}
          </div>
          
          \x3C!-- Distinctive Features -->
          <div class="appearance-section">
            <h3>Distinctive Features</h3>
            ${this.renderSelect("body.scars", "Scars", ["none", "few", "many", "prominent"])}
            ${body.scars !== "none" && body.scars !== "custom" ? this.renderSelect("body.scarLocation", "Scar Location", ["face", "chest", "back", "arms", "legs"]) : ""}
            ${this.renderSelect("body.freckles", "Freckles", ["none", "light", "moderate", "heavy"])}
            ${this.renderCheckbox("body.birthmarks", "Has Birthmark(s)", true)}
            ${this.renderCheckbox("body.beautyMark", "Has Beauty Mark", true)}
            
            <div class="form-group">
              <label>Additional Distinctive Features</label>
              <input type="text" 
                     class="custom-text-input" 
                     data-path="body.distinctiveFeaturesCustom" 
                     value="${this.creator.currentCharacter.body.distinctiveFeaturesCustom || ""}" 
                     placeholder="e.g., Unique eyes, distinctive voice, unusual marking...">
              <small style="color: #aaa; font-size: 0.85rem;">Optional: Add any unique features not covered above</small>
            </div>
          </div>
          
          \x3C!-- Sexual Experience -->
          <div class="appearance-section">
            <h3>Sexual Experience</h3>
            ${this.renderSelect("sexualProfile.experience", "Overall Experience", ["virgin", "inexperienced", "experienced", "veteran"])}
            ${this.renderSelect("sexualProfile.preferredRole", "Preferred Role", ["dominant", "submissive", "versatile", "switch"])}
          </div>
          
          \x3C!-- Genitals (Explicit) -->
          <div class="appearance-section explicit-section">
            <h3>‚ö†Ô∏è Genital Customization (Explicit)</h3>
            ${this.renderGenitalOptions()}
          </div>
        </div>
      </div>
    `;
  }
  renderGenitalOptions() {
    const gender = this.creator.currentCharacter.gender;
    const body = this.creator.currentCharacter.body;
    let html = "";
    if (gender === "male" || gender === "futanari" || body.primaryGenitals === "penis" || body.primaryGenitals === "both") {
      html += `
        <div class="genital-subsection">
          <h4>Penis Details</h4>
          ${this.renderSelect("body.penisSize", "Size", ["small", "average", "large", "very-large", "huge"])}
          ${this.renderSelect("body.penisGirth", "Girth", ["thin", "average", "thick", "very-thick"])}
          ${this.renderCheckbox("body.circumcised", "Circumcised")}
        </div>
      `;
    }
    if (gender === "female" || gender === "Cuntboy" || gender === "futanari" || body.primaryGenitals === "vagina" || body.primaryGenitals === "both") {
      html += `
        <div class="genital-subsection">
          <h4>Vagina Details</h4>
          ${this.renderSelect("body.vaginaTightness", "Tightness", ["tight", "average", "loose"])}
          ${this.renderSelect("body.vaginaDepth", "Depth", ["shallow", "average", "deep"])}
        </div>
      `;
    }
    return html;
  }
  renderPersonalityStep() {
    return `
      <div class="step-content personality-step">
        <h2>Define Personality</h2>
        <p class="step-description">Shape your character's behavior and attitudes</p>
        
        <div class="personality-sliders">
          ${this.renderSlider("personality.dominance", "Dominance", "Submissive", "Dominant")}
          ${this.renderSlider("personality.openness", "Sexual Openness", "Reserved", "Promiscuous")}
          ${this.renderSlider("personality.morality", "Morality", "Cruel", "Kind")}
          ${this.renderSlider("personality.confidence", "Confidence", "Shy", "Confident")}
          ${this.renderSlider("personality.intelligence", "Intelligence", "Simple", "Clever")}
          ${this.renderSlider("personality.aggression", "Aggression", "Passive", "Aggressive")}
        </div>
        
        <div class="sexual-preferences">
          <h3>Sexual Experience</h3>
          ${this.renderSelect("preferences.experience", "Experience Level", ["virgin", "inexperienced", "experienced", "expert", "veteran"])}
        </div>
      </div>
    `;
  }
  renderBackgroundStep() {
    return `
      <div class="step-content background-step">
        <h2>Character Background</h2>
        <p class="step-description">Define your character's name, age, and past life before becoming a castaway</p>
        
        <div class="background-form">
          <div class="form-group">
            <label for="char-name">Name</label>
            <input type="text" id="char-name" class="text-input" value="${this.creator.currentCharacter.name}" placeholder="Enter character name">
          </div>
          
          <div class="form-group">
            <label for="char-age">Age (18+)</label>
            <input type="number" id="char-age" class="text-input" min="18" max="99" value="${this.creator.currentCharacter.age}">
          </div>
          
          <div class="form-group">
            <label for="char-background">Previous Life</label>
            ${this.renderSelect("background", "Who were you before you ended up here?", [
      "tourist",
      "sailor",
      "scientist",
      "criminal",
      "drifter",
      "pilot"
    ])}
            <p class="background-description">${this.getBackgroundDescription()}</p>
          </div>
          
          <div class="skills-allocation">
            <h3>Starting Skills</h3>
            <p class="skills-info">Your background determines your starting skill bonuses</p>
            ${this.renderSkillPoints()}
          </div>
        </div>
      </div>
    `;
  }
  renderPortraitStep() {
    const character = this.creator.currentCharacter;
    const preview = this.creator.getPreviewSummary();
    return `
      <div class="step-content portrait-step">
        <h2>Generate Portrait</h2>
        <p class="step-description">Create an AI-generated image of your character based on your choices</p>
        
        <div class="portrait-container">
          <div class="portrait-preview">
            ${character.portraitUrl ? `<img src="${character.portraitUrl}" alt="Character Portrait" class="portrait-image">` : `<div class="portrait-placeholder">
                <div class="placeholder-icon">üë§</div>
                <p>No portrait generated yet</p>
              </div>`}
          </div>
          
          <div class="portrait-controls">
            <button id="generate-portrait-btn" class="btn-primary">
              ${character.portraitUrl ? "üîÑ Regenerate Portrait" : "‚ú® Generate Portrait"}
            </button>
            
            <div class="portrait-info">
              <h4>Character Description</h4>
              <p class="character-description">${preview.description}</p>
              ${character.portraitPrompt ? `
                <details class="prompt-details">
                  <summary>View Full AI Prompt</summary>
                  <p class="prompt-preview">${character.portraitPrompt}</p>
                </details>
              ` : ""}
              ${character.portraitUrl ? '<p class="success-msg">‚úì Portrait generated successfully!</p>' : ""}
            </div>
          </div>
        </div>
      </div>
    `;
  }
  // Helper render methods
  renderSelect(path, label, options, allowCustom = true) {
    const value = this.creator.getAttribute(path);
    const customPath = path + "Custom";
    const customValue = this.creator.getAttribute(customPath) || "";
    if (allowCustom && !options.includes("custom")) {
      options = [...options, "custom"];
    }
    return `
      <div class="form-group">
        <label>${label}</label>
        <select class="char-select" data-path="${path}">
          ${options.map((opt) => `
            <option value="${opt}" ${value === opt ? "selected" : ""}>
              ${opt.replace("-", " ").replace(/\b\w/g, (l) => l.toUpperCase())}
            </option>
          `).join("")}
        </select>
        ${value === "custom" ? `
          <input type="text" 
                 class="custom-text-input" 
                 data-path="${customPath}" 
                 value="${customValue}" 
                 placeholder="Enter custom ${label.toLowerCase()}...">
        ` : ""}
      </div>
    `;
  }
  renderSlider(path, label, minLabel, maxLabel) {
    const value = this.creator.getAttribute(path);
    return `
      <div class="slider-group">
        <label>${label}</label>
        <div class="slider-labels">
          <span>${minLabel}</span>
          <span>${maxLabel}</span>
        </div>
        <input type="range" min="0" max="100" value="${value}" class="char-slider" data-path="${path}">
        <div class="slider-value">${value}</div>
      </div>
    `;
  }
  renderCheckbox(path, label, allowCustom = false) {
    const value = this.creator.getAttribute(path);
    const customPath = path + "Custom";
    const customValue = this.creator.getAttribute(customPath) || "";
    return `
      <div class="checkbox-group">
        <label>
          <input type="checkbox" 
                 class="char-checkbox" 
                 data-path="${path}" 
                 data-allow-custom="${allowCustom}"
                 ${value ? "checked" : ""}>
          ${label}
        </label>
        ${allowCustom && value ? `
          <input type="text" 
                 class="custom-text-input" 
                 data-path="${customPath}" 
                 value="${customValue}" 
                 placeholder="Describe ${label.toLowerCase()}...">
        ` : ""}
      </div>
    `;
  }
  renderSkillPoints() {
    const skills = this.creator.currentCharacter.skills;
    const backgroundBonuses = this.creator.getBackgroundBonuses();
    const manualPoints = {};
    Object.keys(skills).forEach((skill) => {
      const bonus = backgroundBonuses[skill] || 0;
      manualPoints[skill] = skills[skill] - bonus;
    });
    const totalManual = Object.values(manualPoints).reduce((a, b) => a + b, 0);
    const maxPoints = this.creator.currentCharacter.background === "custom" ? 11 : 7;
    const remaining = maxPoints - totalManual;
    return `
      <div class="skills-remaining">Manual Points Remaining: <strong>${remaining}</strong> / ${maxPoints}</div>
      <div class="skills-grid">
        ${Object.keys(skills).map((skill) => {
      const bonus = backgroundBonuses[skill] || 0;
      return `
            <div class="skill-item">
              <label>${skill.replace(/\b\w/g, (l) => l.toUpperCase())}</label>
              <div class="skill-breakdown">
                ${bonus > 0 ? `<span class="skill-bonus">+${bonus} (background)</span>` : ""}
              </div>
              <div class="skill-controls">
                <button type="button" class="skill-btn" data-skill="${skill}" data-action="decrease">‚àí</button>
                <span class="skill-value">${skills[skill]}</span>
                <button type="button" class="skill-btn" data-skill="${skill}" data-action="increase">+</button>
              </div>
            </div>
          `;
    }).join("")}
      </div>
    `;
  }
  getBackgroundDescription() {
    const backgrounds = {
      tourist: "You were on vacation when disaster struck. Resourceful but unprepared. +2 Charisma, +1 Crafting. Trait: Quick Learner",
      sailor: "Experienced seafarer who knows the ocean well. Strong and capable. +2 Survival, +2 Combat. Trait: Sea Legs",
      scientist: "Here on a research expedition. Intelligent and analytical. +2 Medical, +2 Crafting. Trait: Analytical Mind",
      criminal: "Fleeing the law when you crashed. Street-smart and dangerous. +2 Combat, +1 Charisma, +1 Survival. Trait: Streetwise",
      drifter: "Wanderer with no roots, used to hardship and solitude. +2 Survival, +1 Crafting, +1 Leadership. Trait: Self-Reliant",
      pilot: "Your plane went down. Technical skills and leadership. +2 Crafting, +1 Leadership, +1 Charisma. Trait: Cool Under Pressure",
      custom: "Create your own unique background story. No preset bonuses or trait, but you get 11 skill points to allocate freely (instead of 7)!"
    };
    return backgrounds[this.creator.currentCharacter.background] || "";
  }
  attachEventListeners() {
    const nextBtn = document.getElementById("next-step-btn");
    const prevBtn = document.getElementById("prev-step-btn");
    const confirmBtn = document.getElementById("confirm-character-btn");
    const randomizeBtn = document.getElementById("randomize-btn");
    if (nextBtn) nextBtn.addEventListener("click", () => this.nextStep());
    if (prevBtn) prevBtn.addEventListener("click", () => this.prevStep());
    if (confirmBtn) confirmBtn.addEventListener("click", () => this.confirmCharacter());
    if (randomizeBtn) {
      randomizeBtn.addEventListener("click", () => {
        this.creator.randomizeStep(this.currentStep);
        this.render();
      });
    }
    document.querySelectorAll(".gender-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const gender = e.currentTarget.dataset.gender;
        this.creator.setGender(gender);
        this.render();
      });
    });
    document.querySelectorAll(".method-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const method = e.currentTarget.dataset.method;
        this.usePreset = method === "preset";
        this.render();
      });
    });
    document.querySelectorAll(".preset-card").forEach((card) => {
      card.addEventListener("click", (e) => {
        const presetIndex = parseInt(e.currentTarget.dataset.preset);
        const gender = this.creator.currentCharacter.gender;
        this.creator.applyPreset(gender, presetIndex);
        this.render();
      });
    });
    document.querySelectorAll(".char-select").forEach((select) => {
      select.addEventListener("change", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.value);
        const formGroup = e.target.closest(".form-group");
        const existingCustomInput = formGroup.querySelector(".custom-text-input");
        if (e.target.value === "custom" && !existingCustomInput) {
          const customPath = e.target.dataset.path + "Custom";
          const customValue = this.creator.getAttribute(customPath) || "";
          const label = formGroup.querySelector("label").textContent;
          const customInput = document.createElement("input");
          customInput.type = "text";
          customInput.className = "custom-text-input";
          customInput.dataset.path = customPath;
          customInput.value = customValue;
          customInput.placeholder = `Enter custom ${label.toLowerCase()}...`;
          customInput.addEventListener("input", (e2) => {
            this.creator.updateAttribute(e2.target.dataset.path, e2.target.value);
            this.updatePreview();
          });
          e.target.parentNode.appendChild(customInput);
          customInput.focus();
        } else if (e.target.value !== "custom" && existingCustomInput) {
          existingCustomInput.remove();
        }
        this.updatePreview();
        e.target.dataset.lastValue = e.target.value;
      });
    });
    document.querySelectorAll(".char-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.checked);
        const checkboxGroup = e.target.closest(".checkbox-group");
        const existingCustomInput = checkboxGroup.querySelector(".custom-text-input");
        const allowCustom = e.target.dataset.allowCustom === "true";
        if (e.target.checked && allowCustom && !existingCustomInput) {
          const customPath = e.target.dataset.path + "Custom";
          const customValue = this.creator.getAttribute(customPath) || "";
          const label = checkboxGroup.querySelector("label").textContent.trim();
          const customInput = document.createElement("input");
          customInput.type = "text";
          customInput.className = "custom-text-input";
          customInput.dataset.path = customPath;
          customInput.value = customValue;
          customInput.placeholder = `Describe ${label.toLowerCase()}...`;
          customInput.addEventListener("input", (e2) => {
            this.creator.updateAttribute(e2.target.dataset.path, e2.target.value);
            this.updatePreview();
          });
          checkboxGroup.appendChild(customInput);
          customInput.focus();
        } else if (!e.target.checked && existingCustomInput) {
          existingCustomInput.remove();
        }
        this.updatePreview();
      });
    });
    document.querySelectorAll(".custom-text-input").forEach((input) => {
      input.addEventListener("input", (e) => {
        this.creator.updateAttribute(e.target.dataset.path, e.target.value);
        this.updatePreview();
      });
    });
    document.querySelectorAll(".char-slider").forEach((slider) => {
      slider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        this.creator.updateAttribute(e.target.dataset.path, value);
        e.target.nextElementSibling.textContent = value;
      });
    });
    const nameInput = document.getElementById("char-name");
    const ageInput = document.getElementById("char-age");
    if (nameInput) {
      nameInput.addEventListener("input", (e) => {
        this.creator.updateAttribute("name", e.target.value);
        this.updatePreview();
      });
    }
    if (ageInput) {
      ageInput.addEventListener("change", (e) => {
        const age = Math.max(18, parseInt(e.target.value));
        this.creator.updateAttribute("age", age);
        e.target.value = age;
        this.updatePreview();
      });
    }
    document.querySelectorAll(".skill-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const skill = e.target.dataset.skill;
        const action = e.target.dataset.action;
        let changed = false;
        if (action === "increase") {
          changed = this.creator.addManualSkillPoint(skill);
        } else if (action === "decrease") {
          changed = this.creator.removeManualSkillPoint(skill);
        }
        if (changed) {
          this.updateSkillsDisplay();
        }
      });
    });
    const generateBtn = document.getElementById("generate-portrait-btn");
    if (generateBtn) {
      generateBtn.addEventListener("click", async () => {
        generateBtn.disabled = true;
        generateBtn.textContent = "‚è≥ Generating...";
        try {
          await this.creator.generatePortrait(this.ai);
          this.render();
        } catch (error) {
          alert("Failed to generate portrait. Please try again.");
          console.error(error);
        }
      });
    }
  }
  nextStep() {
    if (this.currentStep < this.totalSteps) {
      this.currentStep++;
      this.render();
    }
  }
  prevStep() {
    if (this.currentStep > 1) {
      this.currentStep--;
      this.render();
    }
  }
  async confirmCharacter() {
    const validation = this.creator.validateCharacter();
    if (!validation.valid) {
      alert("Please complete all required fields:\n" + validation.errors.join("\n"));
      return;
    }
    const character = this.creator.getCharacter();
    this.gameState.state.player = {
      ...this.gameState.state.player,
      ...character
    };
    this.hide();
    this.gameState.emit("characterCreated", character);
  }
  updateSkillsDisplay() {
    const skillsContainer = document.querySelector(".skills-allocation");
    if (skillsContainer) {
      const newSkillsHTML = `
        <h3>Starting Skills</h3>
        <p class="skills-info">Your background determines your starting skill bonuses</p>
        ${this.renderSkillPoints()}
      `;
      skillsContainer.innerHTML = newSkillsHTML;
      skillsContainer.querySelectorAll(".skill-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const skill = e.target.dataset.skill;
          const action = e.target.dataset.action;
          let changed = false;
          if (action === "increase") {
            changed = this.creator.addManualSkillPoint(skill);
          } else if (action === "decrease") {
            changed = this.creator.removeManualSkillPoint(skill);
          }
          if (changed) {
            this.updateSkillsDisplay();
            this.updatePreview();
          }
        });
      });
    }
  }
  updatePreview() {
    const previewPanel = document.querySelector(".char-preview-panel");
    if (!previewPanel) return;
    const preview = this.creator.getPreviewSummary();
    const previewContent = previewPanel.querySelector(".preview-content");
    if (previewContent) {
      previewContent.innerHTML = `
        <div class="preview-field">
          <span class="preview-label">Name:</span>
          <span class="preview-value ${!preview.name || preview.name === "Unnamed" ? "preview-missing" : ""}">${preview.name}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Age:</span>
          <span class="preview-value">${preview.age}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Gender:</span>
          <span class="preview-value">${preview.gender.charAt(0).toUpperCase() + preview.gender.slice(1)}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Description:</span>
          <span class="preview-value">${preview.description || "Not yet defined"}</span>
        </div>
        <div class="preview-field">
          <span class="preview-label">Background:</span>
          <span class="preview-value">${preview.background.charAt(0).toUpperCase() + preview.background.slice(1)}</span>
        </div>
        
        <div class="preview-section">
          <h4>Skills</h4>
          ${Object.entries(preview.skills).map(([skill, value]) => `
            <div class="preview-skill">
              <span>${skill.charAt(0).toUpperCase() + skill.slice(1)}</span>
              <span class="skill-dots">${"‚óè".repeat(value)}${"‚óã".repeat(Math.max(0, 10 - value))}</span>
            </div>
          `).join("")}
        </div>
        
        ${preview.traits.length > 0 ? `
          <div class="preview-section">
            <h4>Traits</h4>
            <div class="preview-traits">
              ${preview.traits.map((trait) => `<span class="trait-badge">${trait}</span>`).join("")}
            </div>
          </div>
        ` : ""}
      `;
    }
  }
}
class StoryIntro {
  constructor(gameState2) {
    this.gameState = gameState2;
    this.currentScene = 0;
    this.currentLine = 0;
    this.scenes = this.getIntroScenes();
    this.keyHandler = null;
  }
  getIntroScenes() {
    return [
      // Scene 1: Pre-crash tension
      {
        background: "#1a1a1a",
        lines: [
          "Flight 447 to Fiji.",
          "You settle into your seat, earbuds in, ready for a long flight.",
          "The vacation of a lifetime awaits.",
          "Or so you thought..."
        ]
      },
      // Scene 2: Turbulence begins
      {
        background: "linear-gradient(180deg, #1a1a1a 0%, #2d3561 100%)",
        lines: [
          "Three hours in, the plane shudders.",
          "Once. Twice.",
          "The seatbelt sign dings on.",
          `"This is your captain speaking. We're experiencing some unexpected turbulence..."`
        ]
      },
      // Scene 3: Disaster strikes
      {
        background: "linear-gradient(180deg, #2d3561 0%, #5e0000 100%)",
        lines: [
          "BANG!",
          "The plane lurches violently to the left.",
          "Screams fill the cabin.",
          "Oxygen masks drop from above.",
          '"BRACE FOR IMPACT!"'
        ]
      },
      // Scene 4: The crash
      {
        background: "#000",
        lines: [
          "The world spins.",
          "Metal tears. Glass shatters.",
          "A deafening roar.",
          "",
          "Then... nothing."
        ]
      },
      // Scene 5: Underwater struggle
      {
        background: "linear-gradient(180deg, #000428 0%, #004e92 100%)",
        lines: [
          "Cold.",
          "Pressure.",
          "Salt water burns your throat.",
          "Your eyes snap open.",
          "You're underwater. The plane is sinking."
        ]
      },
      // Scene 6: Swimming to surface
      {
        background: "linear-gradient(180deg, #004e92 0%, #0066cc 100%)",
        lines: [
          "Kick. Swim. Survive.",
          "Your lungs scream for air.",
          "Light above. Keep going.",
          "Almost there...",
          "GASP!"
        ]
      },
      // Scene 7: Ocean survival
      {
        background: "linear-gradient(180deg, #0066cc 0%, #00aaff 100%)",
        lines: [
          "You break the surface, gasping for air.",
          "Debris floats everywhere. People crying out.",
          "You grab onto a piece of the fuselage.",
          "In the distance... an island.",
          "You have to swim. It's your only chance."
        ]
      },
      // Scene 8: The swim
      {
        background: "linear-gradient(180deg, #00aaff 0%, #44bbff 100%)",
        lines: [
          "You swim.",
          "Every stroke burns.",
          "The island grows closer.",
          "Don't give up.",
          "Just a little further..."
        ]
      },
      // Scene 9: Beach arrival
      {
        background: "linear-gradient(135deg, #c9d6ff 0%, #e2e2e2 100%)",
        lines: [
          "Your hand touches sand.",
          "You crawl onto the beach.",
          "Your body collapses.",
          "The sun beats down on your back.",
          "Everything fades to black."
        ]
      },
      // Scene 10: Waking up
      {
        background: "linear-gradient(135deg, #f4e4c1 0%, #ffd89b 100%)",
        lines: [
          "How long were you out?",
          "The sun is lower now. Late afternoon.",
          "You push yourself to your knees.",
          "Your entire body aches.",
          "But you're alive."
        ]
      },
      // Scene 11: Taking stock
      {
        background: "linear-gradient(135deg, #ffd89b 0%, #ffb347 100%)",
        lines: [
          "You look around.",
          "A pristine beach. Untouched jungle beyond.",
          "No signs of civilization.",
          "No rescue in sight.",
          "You're completely alone."
        ]
      },
      // Scene 12: Title reveal
      {
        background: "linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%)",
        lines: [
          "Welcome to paradise.",
          "",
          "HEDONISM ISLAND",
          "",
          "Your survival begins now."
        ]
      }
    ];
  }
  show() {
    const container = document.getElementById("story-intro");
    if (!container) {
      console.error("Story intro container not found");
      return;
    }
    container.classList.remove("hidden");
    container.innerHTML = `
      <div class="vn-container">
        <div class="vn-background" id="vn-background"></div>
        <div class="vn-textbox">
          <div class="vn-text" id="vn-text"></div>
          <div class="vn-continue">‚ñº Click to continue</div>
        </div>
        <button class="vn-skip" id="vn-skip">Skip Intro</button>
      </div>
    `;
    this.currentScene = 0;
    this.currentLine = 0;
    this.showScene();
    this.attachEventListeners();
  }
  hide() {
    const container = document.getElementById("story-intro");
    if (container) {
      container.classList.add("hidden");
      container.innerHTML = "";
    }
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
      this.keyHandler = null;
    }
  }
  showScene() {
    if (this.currentScene >= this.scenes.length) {
      this.complete();
      return;
    }
    const scene = this.scenes[this.currentScene];
    const background = document.getElementById("vn-background");
    if (background) {
      background.style.backgroundColor = scene.background;
    }
    this.showLine();
  }
  showLine() {
    const scene = this.scenes[this.currentScene];
    const textEl = document.getElementById("vn-text");
    if (!textEl) return;
    if (this.currentLine >= scene.lines.length) {
      this.currentScene++;
      this.currentLine = 0;
      if (this.currentScene >= this.scenes.length) {
        this.complete();
        return;
      }
      const bg = document.getElementById("vn-background");
      if (bg) {
        bg.style.opacity = "0";
        setTimeout(() => {
          this.showScene();
          bg.style.opacity = "1";
        }, 500);
      } else {
        this.showScene();
      }
      return;
    }
    const line = scene.lines[this.currentLine];
    textEl.style.opacity = "0";
    setTimeout(() => {
      textEl.textContent = line;
      textEl.style.opacity = "1";
    }, 100);
  }
  advance() {
    this.currentLine++;
    this.showLine();
  }
  complete() {
    console.log("‚úÖ Story intro complete");
    this.hide();
    this.gameState.emit("introComplete");
  }
  attachEventListeners() {
    const container = document.getElementById("story-intro");
    if (!container) return;
    const textbox = container.querySelector(".vn-textbox");
    if (textbox) {
      textbox.addEventListener("click", () => this.advance());
    }
    const skipBtn = document.getElementById("vn-skip");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => this.complete());
    }
    this.keyHandler = (e) => {
      if (e.key === " " || e.key === "Enter") {
        e.preventDefault();
        this.advance();
      } else if (e.key === "Escape") {
        this.complete();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
}
class MapRenderer {
  constructor(canvas, hexGrid) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.hexGrid = hexGrid;
    this.offsetX = 0;
    this.offsetY = 0;
    this.scale = 1;
    this.terrainColors = {
      "sea": "#1e3a8a",
      "beach": "#fde047",
      "river": "#3b82f6",
      "savanna": "#a3e635",
      "forest": "#22c55e",
      "rainforest": "#15803d",
      "dry-hill": "#a8a29e",
      "jungle-hill": "#65a30d",
      "cloud-forest": "#6ee7b7",
      "rocky-peak": "#78716c",
      "misty-peak": "#cbd5e1"
    };
    this.setupCanvas();
  }
  setupCanvas() {
    this.canvas.width = this.canvas.clientWidth;
    this.canvas.height = this.canvas.clientHeight;
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
  }
  // ========================================
  // MAIN RENDER
  // ========================================
  render(tiles) {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "#0f172a";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.save();
    this.ctx.translate(this.offsetX, this.offsetY);
    this.ctx.scale(this.scale, this.scale);
    for (const [key, tile] of tiles) {
      this.renderHex(tile);
    }
    this.ctx.restore();
  }
  // ========================================
  // HEX RENDERING
  // ========================================
  renderHex(tile) {
    const corners = this.hexGrid.getHexCorners(tile.q, tile.r);
    this.ctx.beginPath();
    this.ctx.moveTo(corners[0].x, corners[0].y);
    for (let i = 1; i < corners.length; i++) {
      this.ctx.lineTo(corners[i].x, corners[i].y);
    }
    this.ctx.closePath();
    const baseColor = this.terrainColors[tile.terrain] || "#666666";
    const brightness = tile.isLand ? 1 + (tile.elevation - 0.5) * 0.4 : 1;
    this.ctx.fillStyle = this.adjustBrightness(baseColor, brightness);
    this.ctx.fill();
    this.ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
    this.ctx.lineWidth = 1;
    this.ctx.stroke();
    if (this.scale > 0.8) {
      const center = this.hexGrid.axialToPixel(tile.q, tile.r);
      this.ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      this.ctx.font = "8px monospace";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText(`${tile.q},${tile.r}`, center.x, center.y - 6);
      this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      this.ctx.font = "6px monospace";
      this.ctx.fillText(tile.terrain || "?", center.x, center.y + 6);
    }
  }
  // ========================================
  // CAMERA CONTROLS
  // ========================================
  pan(dx, dy) {
    this.offsetX += dx;
    this.offsetY += dy;
  }
  zoom(delta, mouseX, mouseY) {
    const oldScale = this.scale;
    this.scale *= 1 + delta;
    this.scale = Math.max(0.3, Math.min(3, this.scale));
    const scaleChange = this.scale / oldScale;
    this.offsetX = mouseX - (mouseX - this.offsetX) * scaleChange;
    this.offsetY = mouseY - (mouseY - this.offsetY) * scaleChange;
  }
  resetView() {
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
    this.scale = 1;
  }
  // ========================================
  // UTILITIES
  // ========================================
  adjustBrightness(color, factor) {
    const r = parseInt(color.slice(1, 3), 16);
    const g = parseInt(color.slice(3, 5), 16);
    const b = parseInt(color.slice(5, 7), 16);
    const nr = Math.min(255, Math.floor(r * factor));
    const ng = Math.min(255, Math.floor(g * factor));
    const nb = Math.min(255, Math.floor(b * factor));
    return `rgb(${nr}, ${ng}, ${nb})`;
  }
  // Convert screen coordinates to hex coordinates
  screenToHex(screenX, screenY) {
    const worldX = (screenX - this.offsetX) / this.scale;
    const worldY = (screenY - this.offsetY) / this.scale;
    return this.hexGrid.pixelToAxial(worldX, worldY);
  }
}
class GameView {
  constructor(gameState2, mapData, player2, inventory2, resourceNodeManager2, territoryManager2, travelSystem2) {
    this.gameState = gameState2;
    this.mapData = mapData;
    this.player = player2;
    this.inventory = inventory2;
    this.resourceNodeManager = resourceNodeManager2;
    this.territoryManager = territoryManager2;
    this.travelSystem = travelSystem2;
    this.renderer = null;
    this.moveCount = 0;
  }
  show() {
    const container = document.getElementById("game-view");
    if (!container) {
      console.error("Game view container not found");
      return;
    }
    const mainMenu2 = document.querySelector(".main-menu");
    if (mainMenu2) {
      mainMenu2.classList.add("hidden");
    }
    container.classList.remove("hidden");
    this.render();
    console.log("‚úÖ Game view shown");
  }
  hide() {
    const container = document.getElementById("game-view");
    if (container) {
      container.classList.add("hidden");
    }
  }
  render() {
    const container = document.getElementById("game-view");
    const character = this.gameState.state.player;
    container.innerHTML = `
      <div class="game-container">
        \x3C!-- Top HUD -->
        <div class="game-hud">
          <div class="hud-left">
            <div class="player-info">
              <div class="player-portrait">
                ${character.portraitUrl ? `<img src="${character.portraitUrl}" alt="${character.name}">` : '<div class="portrait-placeholder">üë§</div>'}
              </div>
              <div class="player-details">
                <h3>${character.name}</h3>
                <p class="player-stats">
                  Day ${this.gameState.state.time?.day || 1} ‚Ä¢ ${character.gender}
                </p>
              </div>
            </div>
          </div>
          
          <div class="hud-center">
            <div class="stat-bar">
              <span class="stat-label">‚ù§Ô∏è Health</span>
              <div class="stat-bar-fill">
                <div class="stat-bar-inner" style="width: ${this.player.health}%" id="health-bar"></div>
              </div>
              <span class="stat-value" id="health-value">${Math.round(this.player.health)}/100</span>
            </div>
            <div class="stat-bar">
              <span class="stat-label">üçñ Hunger</span>
              <div class="stat-bar-fill">
                <div class="stat-bar-inner hunger" style="width: ${this.player.hunger}%" id="hunger-bar"></div>
              </div>
              <span class="stat-value" id="hunger-value">${Math.round(this.player.hunger)}/100</span>
            </div>
            <div class="stat-bar">
              <span class="stat-label">üíß Thirst</span>
              <div class="stat-bar-fill">
                <div class="stat-bar-inner thirst" style="width: ${this.player.thirst}%" id="thirst-bar"></div>
              </div>
              <span class="stat-value" id="thirst-value">${Math.round(this.player.thirst)}/100</span>
            </div>
            <div class="stat-bar">
              <span class="stat-label">‚ö° Energy</span>
              <div class="stat-bar-fill">
                <div class="stat-bar-inner energy" style="width: ${this.player.energy}%" id="energy-bar"></div>
              </div>
              <span class="stat-value" id="energy-value">${Math.round(this.player.energy)}/100</span>
            </div>
          </div>
          
          <div class="hud-right">
            <button class="hud-btn" id="inventory-btn" title="Inventory (I)">
              üéí <span>Inventory</span>
            </button>
            <button class="hud-btn" id="crafting-btn" title="Crafting (C)">
              ÔøΩ <span>Craft</span>
            </button>
            <button class="hud-btn" id="skills-btn" title="Skills (K)">
              ‚≠ê <span>Skills</span>
            </button>
            <button class="hud-btn" id="game-menu-btn" title="Menu (ESC)">
              ‚öôÔ∏è <span>Menu</span>
            </button>
          </div>
        </div>

        \x3C!-- Map Display -->
        <div class="map-display">
          <canvas id="game-canvas"></canvas>
          
          \x3C!-- Map Controls -->
          <div class="map-controls">
            <button class="map-control-btn" id="zoom-in-btn" title="Zoom In">üîç+</button>
            <button class="map-control-btn" id="zoom-out-btn" title="Zoom Out">üîç-</button>
            <button class="map-control-btn" id="center-player-btn" title="Center on Player">üéØ</button>
            <button class="map-control-btn" id="toggle-legend-btn" title="Toggle Legend">üó∫Ô∏è</button>
          </div>
          
          \x3C!-- Tile Info -->
          <div class="tile-info" id="tile-info">
            <div class="tile-info-content">
              <h4>Tile Info</h4>
              <p>Hover over tiles to see details</p>
            </div>
          </div>

          \x3C!-- Tutorial Hint -->
          <div class="tutorial-hint">
            <p>üñ±Ô∏è <strong>Click</strong> adjacent tiles to travel</p>
            <p>ÔøΩ <strong>Click</strong> resource nodes to gather</p>
            <p>‚å®Ô∏è <strong>I</strong>=Inventory ‚Ä¢ <strong>C</strong>=Craft ‚Ä¢ <strong>K</strong>=Skills</p>
          </div>
        </div>

        \x3C!-- Action Log -->
        <div class="action-log">
          <h4>üìú Action Log</h4>
          <div class="log-content" id="action-log">
            <p class="log-entry">You wake up on an unfamiliar beach...</p>
            <p class="log-entry">The plane crash knocked you unconscious.</p>
            <p class="log-entry">You need to find water and shelter soon.</p>
          </div>
        </div>
      </div>
    `;
    this.initializeMap();
    this.attachEventListeners();
  }
  initializeMap() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas || !this.mapData) return;
    this.renderer = new MapRenderer(canvas, this.mapData.hexGrid);
    this.renderer.render(this.mapData.tiles);
    console.log(`üèñÔ∏è Player at (${this.player.position.q}, ${this.player.position.r})`);
    this.renderPlayerMarker();
    this.renderResourceNodes();
    setTimeout(() => this.centerOnPlayer(), 100);
  }
  renderPlayerMarker() {
    if (!this.renderer) return;
    this.renderer.render(this.mapData.tiles);
    if (window.game.mapTravelUI) {
      window.game.mapTravelUI.render();
    }
    this.renderResourceNodes();
    const ctx = this.renderer.ctx;
    ctx.save();
    ctx.translate(this.renderer.offsetX, this.renderer.offsetY);
    ctx.scale(this.renderer.scale, this.renderer.scale);
    const center = this.renderer.hexGrid.axialToPixel(
      this.player.position.q,
      this.player.position.r
    );
    ctx.beginPath();
    ctx.arc(center.x, center.y, 15, 0, Math.PI * 2);
    ctx.fillStyle = "#4dd0e1";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üìç", center.x, center.y);
    ctx.restore();
  }
  renderResourceNodes() {
    if (!this.renderer || !this.resourceNodeManager) return;
    const ctx = this.renderer.ctx;
    ctx.save();
    ctx.translate(this.renderer.offsetX, this.renderer.offsetY);
    ctx.scale(this.renderer.scale, this.renderer.scale);
    this.resourceNodeManager.nodes.forEach((node) => {
      if (!node || !node.position) return;
      const territory = this.territoryManager?.getTerritory(node.position.q, node.position.r);
      if (!territory || !territory.discovered) return;
      const center = this.renderer.hexGrid.axialToPixel(
        node.position.q,
        node.position.r
      );
      const icons = {
        tree: "üå≥",
        rock: "ü™®",
        bush: "üåø",
        fish: "ÔøΩ"
      };
      const icon = icons[node.type] || "‚ùì";
      ctx.beginPath();
      ctx.arc(center.x, center.y - 15, 12, 0, Math.PI * 2);
      if (node.state === "full") {
        ctx.fillStyle = "rgba(74, 222, 128, 0.8)";
      } else if (node.state === "depleted") {
        ctx.fillStyle = "rgba(156, 163, 175, 0.6)";
      } else {
        ctx.fillStyle = "rgba(251, 191, 36, 0.7)";
      }
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(icon, center.x, center.y - 15);
    });
    ctx.restore();
  }
  attachEventListeners() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) return;
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        this.renderer.pan(dx, dy);
        this.renderPlayerMarker();
        lastX = e.clientX;
        lastY = e.clientY;
      } else {
        this.showTileInfo(e);
      }
    });
    canvas.addEventListener("mouseup", (e) => {
      if (!isDragging) {
        this.handleTileClick(e);
      }
      isDragging = false;
    });
    canvas.addEventListener("mouseleave", () => {
      isDragging = false;
    });
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = -Math.sign(e.deltaY) * 0.1;
      this.renderer.zoom(delta, e.clientX, e.clientY);
      this.renderPlayerMarker();
    });
    document.getElementById("zoom-in-btn")?.addEventListener("click", () => {
      this.renderer.zoom(0.2, canvas.width / 2, canvas.height / 2);
      this.renderPlayerMarker();
    });
    document.getElementById("zoom-out-btn")?.addEventListener("click", () => {
      this.renderer.zoom(-0.2, canvas.width / 2, canvas.height / 2);
      this.renderPlayerMarker();
    });
    document.getElementById("center-player-btn")?.addEventListener("click", () => {
      this.centerOnPlayer();
    });
    document.getElementById("toggle-legend-btn")?.addEventListener("click", () => {
      const legend = document.getElementById("territory-legend");
      if (legend) {
        legend.style.display = legend.style.display === "none" ? "block" : "none";
      }
    });
    window.addEventListener("resize", () => {
      this.renderer.setupCanvas();
      this.renderPlayerMarker();
    });
    document.getElementById("inventory-btn")?.addEventListener("click", () => {
      window.game.inventoryUI?.toggle();
    });
    document.getElementById("crafting-btn")?.addEventListener("click", () => {
      window.game.craftingUI?.toggle();
    });
    document.getElementById("skills-btn")?.addEventListener("click", () => {
      this.showSkillsMenu();
    });
    document.getElementById("game-menu-btn")?.addEventListener("click", () => {
      this.showGameMenu();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "i" || e.key === "I") {
        e.preventDefault();
        window.game.inventoryUI?.toggle();
      } else if (e.key === "c" || e.key === "C") {
        e.preventDefault();
        window.game.craftingUI?.toggle();
      } else if (e.key === "k" || e.key === "K") {
        e.preventDefault();
        this.showSkillsMenu();
      } else if (e.key === "Escape") {
        window.game.inventoryUI?.hide();
        window.game.craftingUI?.hide();
      }
    });
  }
  showGameMenu() {
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "game-menu-modal";
    const saves = this.gameState.listSaves();
    const currentSave = saves.find((s) => s.slotName === "autosave");
    modal.innerHTML = `
      <div class="modal-content game-menu-modal">
        <div class="modal-header">
          <h2>‚öôÔ∏è Game Menu</h2>
          <button class="close-btn" id="close-game-menu">‚úï</button>
        </div>
        <div class="modal-body">
          <div class="game-menu-buttons">
            <button class="menu-action-btn" id="quick-save-btn">
              üíæ Quick Save
            </button>
            <button class="menu-action-btn" id="save-as-btn">
              üíæ Save As...
            </button>
            <button class="menu-action-btn" id="load-game-btn">
              üìÇ Load Game
            </button>
            <button class="menu-action-btn" id="export-save-btn">
              üì§ Export Save
            </button>
            <button class="menu-action-btn" id="import-save-btn">
              üì• Import Save
            </button>
            <button class="menu-action-btn" id="settings-btn-game">
              ‚öôÔ∏è Settings
            </button>
            <button class="menu-action-btn danger" id="main-menu-btn">
              üè† Main Menu
            </button>
          </div>
          ${currentSave ? `
            <div class="save-info">
              <h4>Current Progress</h4>
              <p>Day ${this.gameState.state.time.day} ‚Ä¢ ${this.gameState.state.characters.length} characters</p>
              <p>Last saved: ${new Date(currentSave.saveDate).toLocaleString()}</p>
            </div>
          ` : ""}
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="resume-game-btn">Resume Game</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-game-menu").onclick = () => modal.remove();
    document.getElementById("resume-game-btn").onclick = () => modal.remove();
    document.getElementById("quick-save-btn").onclick = () => {
      this.gameState.save("autosave");
      this.addLogEntry("üíæ Game saved!");
      modal.remove();
    };
    document.getElementById("save-as-btn").onclick = () => {
      const name = prompt("Enter save name:", `Save ${Date.now()}`);
      if (name) {
        this.gameState.save(name);
        this.addLogEntry(`üíæ Game saved as "${name}"!`);
        modal.remove();
      }
    };
    document.getElementById("load-game-btn").onclick = () => {
      modal.remove();
      this.showLoadGameMenu();
    };
    document.getElementById("export-save-btn").onclick = () => {
      this.gameState.exportSave();
      this.addLogEntry("üì§ Save exported!");
    };
    document.getElementById("import-save-btn").onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              this.gameState.importSave(event.target.result);
              this.addLogEntry("üì• Save imported!");
              modal.remove();
            } catch (err) {
              alert("Failed to import save: " + err.message);
            }
          };
          reader.readAsText(file);
        }
      };
      input.click();
    };
    document.getElementById("main-menu-btn").onclick = () => {
      if (confirm("Return to main menu? Unsaved progress will be lost.")) {
        this.gameState.save("autosave");
        modal.remove();
        this.hide();
        const mainMenu2 = document.getElementById("main-menu");
        if (mainMenu2) mainMenu2.classList.remove("hidden");
      }
    };
  }
  showLoadGameMenu() {
    const saves = this.gameState.listSaves();
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "load-game-modal";
    let savesHTML = "";
    if (saves.length === 0) {
      savesHTML = '<div class="no-saves">No saved games found.</div>';
    } else {
      savesHTML = '<div class="save-list">';
      saves.forEach((save) => {
        const date = new Date(save.saveDate).toLocaleString();
        savesHTML += `
          <div class="save-item" data-slot="${save.slotName}">
            <div class="save-info">
              <h4>${save.slotName}</h4>
              <p>Day ${save.day} ‚Ä¢ ${save.characterCount} characters</p>
              <p class="save-date">${date}</p>
            </div>
            <div class="save-actions">
              <button class="btn-load-game" data-slot="${save.slotName}">Load</button>
            </div>
          </div>
        `;
      });
      savesHTML += "</div>";
    }
    modal.innerHTML = `
      <div class="modal-content load-game-modal">
        <div class="modal-header">
          <h2>üìÇ Load Game</h2>
          <button class="close-btn" id="close-load-game">‚úï</button>
        </div>
        <div class="modal-body">
          ${savesHTML}
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="cancel-load-game">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-load-game").onclick = () => modal.remove();
    document.getElementById("cancel-load-game").onclick = () => modal.remove();
    modal.querySelectorAll(".btn-load-game").forEach((btn) => {
      btn.onclick = (e) => {
        const slot = e.target.dataset.slot;
        const savedData = localStorage.getItem(`hedonism_save_${slot}`);
        if (savedData && confirm("Load this save? Current progress will be lost.")) {
          this.gameState.save("autosave");
          modal.remove();
          try {
            const saveState = JSON.parse(savedData);
            this.gameState.emit("loadGame", saveState);
            this.hide();
          } catch (err) {
            alert("Failed to load save: " + err.message);
          }
        }
      };
    });
  }
  showTileInfo(event) {
    const hex = this.renderer.screenToHex(event.clientX, event.clientY);
    const tile = this.mapData.tiles.get(`${hex.q},${hex.r}`);
    const infoPanel = document.getElementById("tile-info");
    if (!tile || !infoPanel) return;
    const distance = this.renderer.hexGrid.distance(
      this.player.position.q,
      this.player.position.r,
      tile.q,
      tile.r
    );
    const nodes = this.resourceNodeManager?.getNodesAt(hex.q, hex.r);
    const node = nodes && nodes.length > 0 ? nodes[0] : null;
    let nodeInfo = "";
    if (node) {
      nodeInfo = `<p><strong>Resource:</strong> ${node.type} (${node.state})</p>`;
    }
    infoPanel.innerHTML = `
      <div class="tile-info-content">
        <h4>${this.getTerrainName(tile.terrain)}</h4>
        <p><strong>Location:</strong> (${tile.q}, ${tile.r})</p>
        <p><strong>Distance:</strong> ${distance} tiles</p>
        <p><strong>Elevation:</strong> ${Math.round(tile.elevation * 100)}m</p>
        ${tile.isLand ? `<p><strong>Moisture:</strong> ${Math.round(tile.moisture * 100)}%</p>` : ""}
        ${nodeInfo}
      </div>
    `;
  }
  handleTileClick(event) {
    const hex = this.renderer.screenToHex(event.clientX, event.clientY);
    const tile = this.mapData.tiles.get(`${hex.q},${hex.r}`);
    if (!tile) return;
    const nodes = this.resourceNodeManager.getNodesAt(hex.q, hex.r);
    const node = nodes && nodes.length > 0 ? nodes[0] : null;
    if (node) {
      const distance = Math.abs(hex.q - this.player.position.q) + Math.abs(hex.r - this.player.position.r) + Math.abs(-hex.q - hex.r - (-this.player.position.q - this.player.position.r));
      if (distance === 0 || distance === 2) {
        window.game.gatheringUI?.show(node);
        return;
      } else {
        this.addLogEntry("‚ùå Too far away. Move closer to gather.");
        return;
      }
    }
    if (!tile.isPassable) {
      this.addLogEntry("‚ùå You can't travel there.");
      return;
    }
    const result = this.travelSystem.startTravel(hex.q, hex.r);
    if (!result.success) {
      this.addLogEntry(`‚ùå ${result.reason}`);
    }
  }
  triggerTerrainEvent(tile) {
    const events = {
      "beach": [
        "üêö You find some seashells.",
        "üåä The waves lap gently at your feet.",
        "‚òÄÔ∏è The sun warms your skin."
      ],
      "forest": [
        "üçé You spot some edible berries.",
        "üåø The forest is thick here.",
        "ü¶é A lizard scurries away."
      ],
      "rainforest": [
        "üåßÔ∏è Moisture drips from the canopy.",
        "ü¶ú You hear exotic bird calls.",
        "üçÑ Strange mushrooms grow nearby."
      ]
    };
    const terrainEvents = events[tile.terrain];
    if (terrainEvents && Math.random() < 0.3) {
      const event = terrainEvents[Math.floor(Math.random() * terrainEvents.length)];
      this.addLogEntry(event);
    }
  }
  // Update HUD with real-time player stats
  updateHUD() {
    if (!this.player) return;
    const healthBar = document.getElementById("health-bar");
    const hungerBar = document.getElementById("hunger-bar");
    const thirstBar = document.getElementById("thirst-bar");
    const energyBar = document.getElementById("energy-bar");
    const healthValue = document.getElementById("health-value");
    const hungerValue = document.getElementById("hunger-value");
    const thirstValue = document.getElementById("thirst-value");
    const energyValue = document.getElementById("energy-value");
    if (healthBar) healthBar.style.width = `${this.player.health}%`;
    if (hungerBar) hungerBar.style.width = `${this.player.hunger}%`;
    if (thirstBar) thirstBar.style.width = `${this.player.thirst}%`;
    if (energyBar) energyBar.style.width = `${this.player.energy}%`;
    if (healthValue) healthValue.textContent = `${Math.round(this.player.health)}/100`;
    if (hungerValue) hungerValue.textContent = `${Math.round(this.player.hunger)}/100`;
    if (thirstValue) thirstValue.textContent = `${Math.round(this.player.thirst)}/100`;
    if (energyValue) energyValue.textContent = `${Math.round(this.player.energy)}/100`;
  }
  // Show skills menu
  showSkillsMenu() {
    const modal = document.createElement("div");
    modal.className = "modal-overlay";
    modal.id = "skills-modal";
    let skillsHTML = '<div class="skills-grid">';
    Object.entries(this.player.skills).forEach(([skill, data]) => {
      const progress = data.experience % 100 / 100 * 100;
      skillsHTML += `
        <div class="skill-card">
          <h4>${skill}</h4>
          <div class="skill-level">Level ${data.level}</div>
          <div class="skill-progress-bar">
            <div class="skill-progress-fill" style="width: ${progress}%"></div>
          </div>
          <div class="skill-xp">${data.experience} XP</div>
        </div>
      `;
    });
    skillsHTML += "</div>";
    modal.innerHTML = `
      <div class="modal-content skills-modal">
        <div class="modal-header">
          <h2>‚≠ê Skills</h2>
          <button class="close-btn" id="close-skills">‚úï</button>
        </div>
        <div class="modal-body">
          ${skillsHTML}
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="close-skills-btn">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById("close-skills").onclick = () => modal.remove();
    document.getElementById("close-skills-btn").onclick = () => modal.remove();
    const escHandler = (e) => {
      if (e.key === "Escape") {
        modal.remove();
        document.removeEventListener("keydown", escHandler);
      }
    };
    document.addEventListener("keydown", escHandler);
  }
  centerOnPlayer() {
    if (!this.renderer) return;
    const canvas = document.getElementById("game-canvas");
    const center = this.renderer.hexGrid.axialToPixel(
      this.player.position.q,
      this.player.position.r
    );
    this.renderer.offsetX = canvas.width / 2 - center.x * this.renderer.scale;
    this.renderer.offsetY = canvas.height / 2 - center.y * this.renderer.scale;
    this.renderPlayerMarker();
  }
  addLogEntry(text) {
    const log = document.getElementById("action-log");
    if (!log) return;
    const entry = document.createElement("p");
    entry.className = "log-entry";
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
    while (log.children.length > 50) {
      log.removeChild(log.firstChild);
    }
  }
  getTerrainName(terrain) {
    const names = {
      "sea": "Ocean",
      "beach": "Beach",
      "river": "River",
      "savanna": "Savanna",
      "forest": "Forest",
      "rainforest": "Rainforest",
      "dry-hill": "Dry Hill",
      "jungle-hill": "Jungle Hill",
      "cloud-forest": "Cloud Forest",
      "rocky-peak": "Rocky Peak",
      "misty-peak": "Misty Peak"
    };
    return names[terrain] || "Unknown";
  }
}
class SaveManager {
  constructor(gameState2) {
    this.gameState = gameState2;
    this.view = {
      tab: "manual",
      // 'manual' or 'auto'
      sortKey: "savedAt",
      sortDir: "desc",
      // 'asc' or 'desc'
      query: "",
      selectedId: null
    };
    this.modal = null;
    this.editingNameId = null;
  }
  /**
   * Show save manager modal
   */
  show() {
    if (this.modal) return;
    this.modal = document.createElement("div");
    this.modal.className = "save-manager-modal";
    this.modal.innerHTML = this.buildHTML();
    document.body.appendChild(this.modal);
    this.attachEventListeners();
    this.updateButtonStates();
    this.render();
  }
  /**
   * Check if there's an active game (not on main menu)
   */
  hasActiveGame() {
    const mainMenu2 = document.getElementById("main-menu");
    const isOnMainMenu = mainMenu2 && !mainMenu2.classList.contains("hidden");
    if (isOnMainMenu) return false;
    const hasPlayer = this.gameState.state.player && this.gameState.state.player.name;
    return hasPlayer;
  }
  /**
   * Update button states based on game state
   */
  updateButtonStates() {
    if (!this.modal) return;
    const hasGame = this.hasActiveGame();
    const quickSaveBtn = this.modal.querySelector("#sm-quick-save");
    const exportBtn = this.modal.querySelector("#sm-export");
    if (quickSaveBtn) {
      quickSaveBtn.disabled = !hasGame;
      if (!hasGame) {
        quickSaveBtn.title = "Start a game first to save";
      }
    }
    if (exportBtn) {
      const { manual, auto } = this.getSaves();
      const hasSaves = manual.length > 0 || auto.length > 0;
      exportBtn.disabled = !hasSaves;
      if (!hasSaves) {
        exportBtn.title = "No saves to export";
      }
    }
  }
  /**
   * Hide and cleanup
   */
  hide() {
    if (this.modal) {
      this.modal.remove();
      this.modal = null;
    }
  }
  /**
   * Build main HTML structure
   */
  buildHTML() {
    return `
      <div class="save-manager-container">
        \x3C!-- Header -->
        <div class="save-manager-header">
          <div class="save-manager-title">
            <div class="save-manager-logo">üíæ</div>
            <div>
              <h2>Save Manager</h2>
              <div class="save-manager-subtitle">Continue ‚Ä¢ Save/Load ‚Ä¢ Import/Export</div>
            </div>
          </div>
          <button class="save-manager-close" id="sm-close">‚úï</button>
        </div>

        \x3C!-- Actions -->
        <div class="save-manager-actions">
          <button class="sm-btn accent" id="sm-continue">‚ñ∂ Continue</button>
          <button class="sm-btn success" id="sm-quick-save">‚è∫ Quick Save</button>
          <button class="sm-btn primary" id="sm-quick-load">‚èÆ Quick Load</button>
          <button class="sm-btn" id="sm-export">‚¨á Export</button>
          <button class="sm-btn" id="sm-import">‚¨Ü Import</button>
          <input type="file" id="sm-import-file" accept=".json" style="display: none;">
        </div>

        \x3C!-- Toolbar -->
        <div class="save-manager-toolbar">
          <div class="save-tab-group">
            <button class="save-tab active" id="sm-tab-manual">Manual Saves</button>
            <button class="save-tab" id="sm-tab-auto">Autosaves</button>
          </div>
          <div class="save-search-box">
            <span class="save-search-icon">üîç</span>
            <input type="text" id="sm-search" placeholder="Search by name, location, character..." />
          </div>
        </div>

        \x3C!-- Save List -->
        <div class="save-list-container">
          <table class="save-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="name">Name <span class="sort-arrow">‚ñæ</span></th>
                <th class="sortable" data-sort="day">Day/Time</th>
                <th class="sortable" data-sort="savedAt">Saved At</th>
                <th>Character</th>
                <th>Location</th>
                <th class="sortable" data-sort="playTime">Playtime</th>
                <th style="width: 200px;">Actions</th>
              </tr>
            </thead>
            <tbody id="sm-tbody">
              \x3C!-- Rows generated dynamically -->
            </tbody>
          </table>
        </div>

        \x3C!-- Footer -->
        <div class="save-manager-footer">
          <div class="save-footer-hint">
            <span>Tip:</span>
            <span><span class="kbd">F5</span> Quick Save</span>
            <span><span class="kbd">F9</span> Quick Load</span>
            <span><span class="kbd">Esc</span> Close</span>
          </div>
          <div class="save-count" id="sm-count"></div>
        </div>
      </div>
    `;
  }
  /**
   * Attach all event listeners
   */
  attachEventListeners() {
    const closeBtn = this.modal.querySelector("#sm-close");
    closeBtn?.addEventListener("click", () => this.hide());
    this.modal.addEventListener("click", (e) => {
      if (e.target === this.modal) this.hide();
    });
    const manualTab = this.modal.querySelector("#sm-tab-manual");
    const autoTab = this.modal.querySelector("#sm-tab-auto");
    manualTab?.addEventListener("click", () => this.switchTab("manual"));
    autoTab?.addEventListener("click", () => this.switchTab("auto"));
    const searchInput = this.modal.querySelector("#sm-search");
    searchInput?.addEventListener("input", (e) => {
      this.view.query = e.target.value.toLowerCase();
      this.render();
    });
    this.modal.querySelectorAll("th.sortable").forEach((th) => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (this.view.sortKey === key) {
          this.view.sortDir = this.view.sortDir === "asc" ? "desc" : "asc";
        } else {
          this.view.sortKey = key;
          this.view.sortDir = "desc";
        }
        this.render();
      });
    });
    const continueBtn = this.modal.querySelector("#sm-continue");
    const quickSaveBtn = this.modal.querySelector("#sm-quick-save");
    const quickLoadBtn = this.modal.querySelector("#sm-quick-load");
    const exportBtn = this.modal.querySelector("#sm-export");
    const importBtn = this.modal.querySelector("#sm-import");
    const importFile = this.modal.querySelector("#sm-import-file");
    continueBtn?.addEventListener("click", () => this.handleContinue());
    quickSaveBtn?.addEventListener("click", () => this.handleQuickSave());
    quickLoadBtn?.addEventListener("click", () => this.handleQuickLoad());
    exportBtn?.addEventListener("click", () => this.handleExport());
    importBtn?.addEventListener("click", () => importFile?.click());
    importFile?.addEventListener("change", (e) => this.handleImport(e));
    this.keyHandler = (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        this.hide();
      }
      if (e.key === "F5") {
        e.preventDefault();
        this.handleQuickSave();
      }
      if (e.key === "F9") {
        e.preventDefault();
        this.handleQuickLoad();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
  /**
   * Switch between manual/auto tabs
   */
  switchTab(tab) {
    this.view.tab = tab;
    const manualTab = this.modal.querySelector("#sm-tab-manual");
    const autoTab = this.modal.querySelector("#sm-tab-auto");
    if (tab === "manual") {
      manualTab?.classList.add("active");
      autoTab?.classList.remove("active");
    } else {
      autoTab?.classList.add("active");
      manualTab?.classList.remove("active");
    }
    this.render();
  }
  /**
   * Get all saves from GameState
   */
  getSaves() {
    const saves = this.gameState.listSaves();
    const manual = saves.filter((s) => s.slotName !== "autosave" && !s.slotName.startsWith("auto_"));
    const auto = saves.filter((s) => s.slotName === "autosave" || s.slotName.startsWith("auto_"));
    return { manual, auto, all: saves };
  }
  /**
   * Format time duration
   */
  formatDuration(seconds) {
    if (!seconds) return "0m";
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
  }
  /**
   * Format date
   */
  formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString();
  }
  /**
   * Get save type tag
   */
  getSaveTag(slotName) {
    if (slotName === "autosave") return '<span class="save-tag auto">autosave</span>';
    if (slotName.startsWith("auto_")) return '<span class="save-tag auto">auto</span>';
    if (slotName.startsWith("quick_")) return '<span class="save-tag quick">quick</span>';
    return '<span class="save-tag">manual</span>';
  }
  /**
   * Build table row HTML
   */
  buildRowHTML(save) {
    const isSelected = this.view.selectedId === save.slotName;
    const selectedClass = isSelected ? "selected" : "";
    return `
      <tr class="${selectedClass}" data-slot="${save.slotName}">
        <td>
          <div class="save-name-cell">
            <input 
              type="text" 
              class="save-name-input" 
              value="${save.slotName}" 
              data-slot="${save.slotName}"
              data-original="${save.slotName}"
            />
            ${this.getSaveTag(save.slotName)}
          </div>
        </td>
        <td class="meta">Day ${save.day || 1}</td>
        <td class="meta">${this.formatDate(save.saveDate)}</td>
        <td>${this.gameState.state.player?.name || "Unknown"}</td>
        <td>${this.gameState.state.player?.position ? "Exploring" : "Unknown"}</td>
        <td class="meta">${this.formatDuration(save.playTime)}</td>
        <td>
          <div class="save-row-actions">
            <button class="save-action-btn load" data-action="load" data-slot="${save.slotName}">Load</button>
            <button class="save-action-btn export" data-action="export" data-slot="${save.slotName}">Export</button>
            <button class="save-action-btn delete" data-action="delete" data-slot="${save.slotName}">‚úï</button>
          </div>
        </td>
      </tr>
    `;
  }
  /**
   * Build create new save row
   */
  buildCreateRow() {
    return `
      <tr class="create-row" id="sm-create-row">
        <td colspan="7">
          <span class="create-save-link">
            <span>+</span>
            <span>Create New Save</span>
          </span>
        </td>
      </tr>
    `;
  }
  /**
   * Build empty state
   */
  buildEmptyState() {
    return `
      <tr>
        <td colspan="7">
          <div class="save-list-empty">
            <div class="save-list-empty-icon">üíæ</div>
            <div class="save-list-empty-text">No saves found</div>
            <div class="save-list-empty-hint">Click "Quick Save" or "Create New Save" to get started</div>
          </div>
        </td>
      </tr>
    `;
  }
  /**
   * Render save list
   */
  render() {
    const tbody = this.modal.querySelector("#sm-tbody");
    if (!tbody) return;
    const { manual, auto } = this.getSaves();
    const list = this.view.tab === "manual" ? manual : auto;
    let filtered = [...list];
    if (this.view.query) {
      filtered = filtered.filter((s) => {
        const searchStr = `${s.slotName} ${this.gameState.state.player?.name || ""}`.toLowerCase();
        return searchStr.includes(this.view.query);
      });
    }
    filtered.sort((a, b) => {
      let aVal, bVal;
      switch (this.view.sortKey) {
        case "name":
          aVal = a.slotName.toLowerCase();
          bVal = b.slotName.toLowerCase();
          break;
        case "day":
          aVal = a.day || 0;
          bVal = b.day || 0;
          break;
        case "savedAt":
          aVal = new Date(a.saveDate).getTime();
          bVal = new Date(b.saveDate).getTime();
          break;
        case "playTime":
          aVal = a.playTime || 0;
          bVal = b.playTime || 0;
          break;
        default:
          aVal = new Date(a.saveDate).getTime();
          bVal = new Date(b.saveDate).getTime();
      }
      const dir = this.view.sortDir === "asc" ? 1 : -1;
      return aVal > bVal ? dir : aVal < bVal ? -dir : 0;
    });
    let html = "";
    if (this.view.tab === "manual" && this.hasActiveGame()) {
      html += this.buildCreateRow();
    }
    if (filtered.length === 0 && this.view.tab !== "manual") {
      html += this.buildEmptyState();
    } else {
      html += filtered.map((s) => this.buildRowHTML(s)).join("");
    }
    tbody.innerHTML = html;
    const countEl = this.modal.querySelector("#sm-count");
    if (countEl) {
      countEl.textContent = `${manual.length} manual ‚Ä¢ ${auto.length} autosaves ‚Ä¢ showing ${filtered.length}`;
    }
    this.modal.querySelectorAll("th.sortable").forEach((th) => {
      const arrow = th.querySelector(".sort-arrow");
      if (th.dataset.sort === this.view.sortKey) {
        th.classList.add("sorted");
        if (arrow) arrow.textContent = this.view.sortDir === "asc" ? "‚ñ¥" : "‚ñæ";
      } else {
        th.classList.remove("sorted");
        if (arrow) arrow.textContent = "‚ñæ";
      }
    });
    this.attachRowListeners();
  }
  /**
   * Attach event listeners to dynamically created rows
   */
  attachRowListeners() {
    const createRow = this.modal.querySelector("#sm-create-row");
    createRow?.addEventListener("click", () => this.handleCreateSave());
    this.modal.querySelectorAll("tr[data-slot]").forEach((row) => {
      row.addEventListener("click", (e) => {
        if (e.target.closest("button") || e.target.closest("input")) return;
        this.view.selectedId = row.dataset.slot;
        this.render();
      });
    });
    this.modal.querySelectorAll(".save-name-input").forEach((input) => {
      input.addEventListener("blur", (e) => this.handleRename(e));
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.target.blur();
        }
      });
    });
    this.modal.querySelectorAll("[data-action]").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const action = btn.dataset.action;
        const slot = btn.dataset.slot;
        switch (action) {
          case "load":
            this.handleLoad(slot);
            break;
          case "export":
            this.handleExportSingle(slot);
            break;
          case "delete":
            this.handleDelete(slot);
            break;
        }
      });
    });
  }
  /**
   * Handle continue (load most recent save)
   */
  handleContinue() {
    const { manual, auto } = this.getSaves();
    const allSaves = [...manual, ...auto];
    if (allSaves.length === 0) {
      this.showNotification("No saves available", "error");
      return;
    }
    const latest = allSaves.sort(
      (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
    )[0];
    this.handleLoad(latest.slotName);
  }
  /**
   * Handle quick save
   */
  handleQuickSave() {
    if (!this.hasActiveGame()) {
      this.showNotification("Start a game first to save", "error");
      return;
    }
    const timestamp = Date.now();
    const slotName = `quick_${timestamp}`;
    const success = this.gameState.save(slotName);
    if (success) {
      this.showNotification("Quick saved!", "success");
      this.render();
    } else {
      this.showNotification("Failed to save", "error");
    }
  }
  /**
   * Handle quick load (load most recent quick save)
   */
  handleQuickLoad() {
    const saves = this.gameState.listSaves();
    const quickSaves = saves.filter((s) => s.slotName.startsWith("quick_"));
    if (quickSaves.length === 0) {
      this.showNotification("No quick saves found", "error");
      return;
    }
    const latest = quickSaves.sort(
      (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
    )[0];
    this.handleLoad(latest.slotName);
  }
  /**
   * Handle create new save
   */
  handleCreateSave() {
    if (!this.hasActiveGame()) {
      this.showNotification("Start a game first to save", "error");
      return;
    }
    const timestamp = Date.now();
    const slotName = `save_${timestamp}`;
    const success = this.gameState.save(slotName);
    if (success) {
      this.showNotification("Save created!", "success");
      this.view.selectedId = slotName;
      this.render();
    } else {
      this.showNotification("Failed to create save", "error");
    }
  }
  /**
   * Handle rename save
   */
  handleRename(event) {
    const input = event.target;
    const oldSlot = input.dataset.original;
    const newName = input.value.trim();
    if (!newName || newName === oldSlot) {
      input.value = oldSlot;
      return;
    }
    const saves = this.gameState.listSaves();
    if (saves.some((s) => s.slotName === newName)) {
      this.showNotification("Save name already exists", "error");
      input.value = oldSlot;
      return;
    }
    const success = this.gameState.load(oldSlot);
    if (success) {
      this.gameState.save(newName);
      this.gameState.deleteSave(oldSlot);
      if (this.view.selectedId === oldSlot) {
        this.view.selectedId = newName;
      }
      this.showNotification("Save renamed", "success");
      this.render();
    } else {
      input.value = oldSlot;
      this.showNotification("Failed to rename", "error");
    }
  }
  /**
   * Handle load save
   */
  handleLoad(slotName) {
    const success = this.gameState.load(slotName);
    if (success) {
      this.showNotification("Loading game...", "success");
      this.hide();
      const storyIntro2 = document.getElementById("story-intro");
      const characterCreation2 = document.getElementById("character-creation");
      const mainMenu2 = document.getElementById("main-menu");
      if (storyIntro2) storyIntro2.classList.add("hidden");
      if (characterCreation2) characterCreation2.classList.add("hidden");
      if (mainMenu2) mainMenu2.classList.add("hidden");
      this.gameState.emit("loadGame", this.gameState.state);
    } else {
      this.showNotification("Failed to load save", "error");
    }
  }
  /**
   * Handle delete save
   */
  handleDelete(slotName) {
    this.gameState.deleteSave(slotName);
    if (this.view.selectedId === slotName) {
      this.view.selectedId = null;
    }
    this.showNotification("Save deleted", "success");
    this.render();
  }
  /**
   * Handle export selected or most recent
   */
  handleExport() {
    const { manual, auto } = this.getSaves();
    const allSaves = [...manual, ...auto];
    let saveToExport;
    if (this.view.selectedId) {
      saveToExport = allSaves.find((s) => s.slotName === this.view.selectedId);
    } else {
      saveToExport = allSaves.sort(
        (a, b) => new Date(b.saveDate).getTime() - new Date(a.saveDate).getTime()
      )[0];
    }
    if (!saveToExport) {
      this.showNotification("No save to export", "error");
      return;
    }
    this.handleExportSingle(saveToExport.slotName);
  }
  /**
   * Handle export single save
   */
  handleExportSingle(slotName) {
    const savedData = localStorage.getItem(`hedonism_save_${slotName}`);
    if (!savedData) {
      this.showNotification("Save not found", "error");
      return;
    }
    const blob = new Blob([savedData], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `hedonism_island_${slotName}.json`;
    a.click();
    URL.revokeObjectURL(url);
    this.showNotification("Save exported", "success");
  }
  /**
   * Handle import save
   */
  handleImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target.result;
        const success = this.gameState.importSave(content);
        if (success) {
          this.showNotification("Save imported successfully", "success");
          this.render();
        } else {
          this.showNotification("Failed to import save", "error");
        }
      } catch (err) {
        console.error("Import error:", err);
        this.showNotification("Invalid save file", "error");
      }
    };
    reader.readAsText(file);
    event.target.value = "";
  }
  /**
   * Show notification (simple toast)
   */
  showNotification(message, type = "info") {
    const toast = document.createElement("div");
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: ${type === "success" ? "#10b37f" : type === "error" ? "#ff5d7a" : "#0bbbd1"};
      color: ${type === "error" ? "#fff" : "#000"};
      border-radius: 8px;
      font-weight: 600;
      z-index: 100000;
      animation: slideIn 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = "slideOut 0.3s ease";
      setTimeout(() => toast.remove(), 300);
    }, 2e3);
  }
  /**
   * Cleanup when destroyed
   */
  destroy() {
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
    }
    this.hide();
  }
}
class OptionsMenu {
  constructor(gameState2, settingsMenu2, saveManager2) {
    this.gameState = gameState2;
    this.settingsMenu = settingsMenu2;
    this.saveManager = saveManager2;
    this.modal = null;
  }
  /**
   * Show options menu modal
   */
  show() {
    if (this.modal) return;
    this.modal = document.createElement("div");
    this.modal.className = "options-menu-modal";
    this.modal.innerHTML = this.buildHTML();
    document.body.appendChild(this.modal);
    this.attachEventListeners();
  }
  /**
   * Hide and cleanup
   */
  hide() {
    if (this.modal) {
      this.modal.remove();
      this.modal = null;
    }
  }
  /**
   * Build main HTML structure
   */
  buildHTML() {
    return `
      <div class="options-menu-overlay">
        <div class="options-menu-container">
          <div class="options-menu-header">
            <h2>‚öôÔ∏è Options</h2>
            <button class="options-close-btn" id="opt-close">‚úï</button>
          </div>
          
          <div class="options-menu-grid">
            <button class="option-card" id="opt-save-load">
              <div class="option-icon">üíæ</div>
              <div class="option-title">Save / Load</div>
              <div class="option-desc">Manage your saved games</div>
            </button>

            <button class="option-card" id="opt-settings">
              <div class="option-icon">‚öôÔ∏è</div>
              <div class="option-title">Settings</div>
              <div class="option-desc">Game preferences and options</div>
            </button>

            <button class="option-card" id="opt-main-menu">
              <div class="option-icon">üè†</div>
              <div class="option-title">Main Menu</div>
              <div class="option-desc">Return to main menu</div>
            </button>

            <button class="option-card" id="opt-continue">
              <div class="option-icon">‚ñ∂Ô∏è</div>
              <div class="option-title">Resume</div>
              <div class="option-desc">Continue playing</div>
            </button>
          </div>
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    const closeBtn = this.modal.querySelector("#opt-close");
    closeBtn?.addEventListener("click", () => this.hide());
    const overlay = this.modal.querySelector(".options-menu-overlay");
    overlay?.addEventListener("click", (e) => {
      if (e.target === overlay) this.hide();
    });
    const saveLoadBtn = this.modal.querySelector("#opt-save-load");
    saveLoadBtn?.addEventListener("click", () => {
      this.hide();
      this.saveManager.show();
    });
    const settingsBtn = this.modal.querySelector("#opt-settings");
    settingsBtn?.addEventListener("click", () => {
      this.hide();
      this.settingsMenu.show();
    });
    const mainMenuBtn = this.modal.querySelector("#opt-main-menu");
    mainMenuBtn?.addEventListener("click", () => {
      this.handleMainMenu();
    });
    const continueBtn = this.modal.querySelector("#opt-continue");
    continueBtn?.addEventListener("click", () => {
      this.hide();
    });
    this.keyHandler = (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        this.hide();
      }
    };
    document.addEventListener("keydown", this.keyHandler);
  }
  /**
   * Handle return to main menu
   */
  handleMainMenu() {
    this.gameState.save("autosave");
    this.hide();
    const storyIntro2 = document.getElementById("story-intro");
    const gameView2 = document.getElementById("game-view");
    const characterCreation2 = document.getElementById("character-creation");
    const globalMenuBtn2 = document.getElementById("global-menu-btn");
    if (storyIntro2) storyIntro2.classList.add("hidden");
    if (gameView2) gameView2.classList.add("hidden");
    if (characterCreation2) characterCreation2.classList.add("hidden");
    if (globalMenuBtn2) globalMenuBtn2.classList.add("hidden");
    const mainMenuEl = document.getElementById("main-menu");
    if (mainMenuEl) mainMenuEl.classList.remove("hidden");
    if (window.game && window.game.mainMenu && typeof window.game.mainMenu.checkContinueButton === "function") {
      window.game.mainMenu.checkContinueButton();
    }
  }
  /**
   * Cleanup when destroyed
   */
  destroy() {
    if (this.keyHandler) {
      document.removeEventListener("keydown", this.keyHandler);
    }
    this.hide();
  }
}
class HexGrid {
  constructor(radius = 7) {
    this.radius = radius;
    this.hexSize = 40;
  }
  // ========================================
  // COORDINATE CONVERSIONS
  // ========================================
  // Convert axial (q, r) to cube (x, y, z) coordinates
  axialToCube(q, r) {
    const x = q;
    const z = r;
    const y = -x - z;
    return { x, y, z };
  }
  // Convert cube to axial coordinates
  cubeToAxial(x, y, z) {
    const q = x;
    const r = z;
    return { q, r };
  }
  // Convert axial to pixel coordinates (for rendering)
  axialToPixel(q, r) {
    const x = this.hexSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
    const y = this.hexSize * (3 / 2 * r);
    return { x, y };
  }
  // Convert pixel to axial coordinates (for mouse clicks)
  pixelToAxial(x, y) {
    const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / this.hexSize;
    const r = 2 / 3 * y / this.hexSize;
    return this.roundAxial(q, r);
  }
  // Round fractional axial coordinates to nearest hex
  roundAxial(q, r) {
    return this.cubeToAxial(...this.roundCube(q, -q - r, r));
  }
  // Round fractional cube coordinates
  roundCube(x, y, z) {
    let rx = Math.round(x);
    let ry = Math.round(y);
    let rz = Math.round(z);
    const x_diff = Math.abs(rx - x);
    const y_diff = Math.abs(ry - y);
    const z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) {
      rx = -ry - rz;
    } else if (y_diff > z_diff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }
    return [rx, ry, rz];
  }
  // ========================================
  // DISTANCE & NEIGHBORS
  // ========================================
  // Distance between two hexes (in hex units)
  distance(q1, r1, q2, r2) {
    const cube1 = this.axialToCube(q1, r1);
    const cube2 = this.axialToCube(q2, r2);
    return Math.max(
      Math.abs(cube1.x - cube2.x),
      Math.abs(cube1.y - cube2.y),
      Math.abs(cube1.z - cube2.z)
    );
  }
  // Get all 6 neighbors of a hex
  getNeighbors(q, r) {
    const directions = [
      { q: 1, r: 0 },
      // East
      { q: 1, r: -1 },
      // Northeast
      { q: 0, r: -1 },
      // Northwest
      { q: -1, r: 0 },
      // West
      { q: -1, r: 1 },
      // Southwest
      { q: 0, r: 1 }
      // Southeast
    ];
    return directions.map((dir) => ({
      q: q + dir.q,
      r: r + dir.r
    }));
  }
  // Get specific neighbor by direction (0-5)
  getNeighbor(q, r, direction) {
    const neighbors = this.getNeighbors(q, r);
    return neighbors[direction % 6];
  }
  // ========================================
  // AREA QUERIES
  // ========================================
  // Get all hexes within a certain range
  getHexesInRange(centerQ, centerR, range) {
    const hexes = [];
    for (let q = -range; q <= range; q++) {
      const r1 = Math.max(-range, -q - range);
      const r2 = Math.min(range, -q + range);
      for (let r = r1; r <= r2; r++) {
        hexes.push({ q: centerQ + q, r: centerR + r });
      }
    }
    return hexes;
  }
  // Get hexes in a ring at exact distance
  getRing(centerQ, centerR, radius) {
    const results = [];
    if (radius === 0) {
      return [{ q: centerQ, r: centerR }];
    }
    let hex = { q: centerQ - radius, r: centerR + radius };
    const directions = [
      { q: 1, r: -1 },
      { q: 1, r: 0 },
      { q: 0, r: 1 },
      { q: -1, r: 1 },
      { q: -1, r: 0 },
      { q: 0, r: -1 }
    ];
    for (let i = 0; i < 6; i++) {
      for (let j = 0; j < radius; j++) {
        results.push({ ...hex });
        hex.q += directions[i].q;
        hex.r += directions[i].r;
      }
    }
    return results;
  }
  // Get all hexes in a line between two points
  getLine(q1, r1, q2, r2) {
    const dist = this.distance(q1, r1, q2, r2);
    if (dist === 0) return [{ q: q1, r: r1 }];
    const results = [];
    for (let i = 0; i <= dist; i++) {
      const t = i / dist;
      const q = q1 * (1 - t) + q2 * t;
      const r = r1 * (1 - t) + r2 * t;
      const rounded = this.roundAxial(q, r);
      results.push(rounded);
    }
    return results;
  }
  // ========================================
  // MAP GENERATION HELPERS
  // ========================================
  // Generate all hexes in a circular map
  generateCircularMap(radius) {
    const hexes = [];
    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        if (this.distance(0, 0, q, r) <= radius) {
          hexes.push({ q, r });
        }
      }
    }
    return hexes;
  }
  // Check if hex is within map bounds
  isInBounds(q, r, radius) {
    return this.distance(0, 0, q, r) <= radius;
  }
  // ========================================
  // PATHFINDING (A*)
  // ========================================
  // Find shortest path between two hexes
  findPath(startQ, startR, goalQ, goalR, costFn = () => 1) {
    const start2 = { q: startQ, r: startR };
    const goal = { q: goalQ, r: goalR };
    const frontier = [{ hex: start2, priority: 0 }];
    const cameFrom = /* @__PURE__ */ new Map();
    const costSoFar = /* @__PURE__ */ new Map();
    const key = (hex) => `${hex.q},${hex.r}`;
    cameFrom.set(key(start2), null);
    costSoFar.set(key(start2), 0);
    while (frontier.length > 0) {
      frontier.sort((a, b) => a.priority - b.priority);
      const current2 = frontier.shift().hex;
      if (current2.q === goal.q && current2.r === goal.r) {
        break;
      }
      const neighbors = this.getNeighbors(current2.q, current2.r);
      for (const next of neighbors) {
        const newCost = costSoFar.get(key(current2)) + costFn(next.q, next.r);
        const nextKey = key(next);
        if (!costSoFar.has(nextKey) || newCost < costSoFar.get(nextKey)) {
          costSoFar.set(nextKey, newCost);
          const priority = newCost + this.distance(next.q, next.r, goal.q, goal.r);
          frontier.push({ hex: next, priority });
          cameFrom.set(nextKey, current2);
        }
      }
    }
    const path = [];
    let current = goal;
    while (current) {
      path.unshift(current);
      current = cameFrom.get(key(current));
    }
    return path.length > 0 && path[0].q === start2.q && path[0].r === start2.r ? path : [];
  }
  // ========================================
  // RENDERING HELPERS
  // ========================================
  // Get polygon points for drawing a hex
  getHexCorners(q, r) {
    const center = this.axialToPixel(q, r);
    const corners = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 6;
      corners.push({
        x: center.x + this.hexSize * Math.cos(angle),
        y: center.y + this.hexSize * Math.sin(angle)
      });
    }
    return corners;
  }
}
class SimplexNoise {
  constructor(seed = 0) {
    if (typeof seed === "string") {
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        hash = (hash << 5) - hash + seed.charCodeAt(i);
        hash = hash & hash;
      }
      seed = Math.abs(hash);
    }
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ];
    this.p = [];
    for (let i = 0; i < 256; i++) {
      this.p[i] = i;
    }
    let n, q;
    for (let i = 255; i > 0; i--) {
      n = Math.floor((seed = seed * 16807 % 2147483647) / 2147483647 * (i + 1));
      q = this.p[i];
      this.p[i] = this.p[n];
      this.p[n] = q;
    }
    this.perm = [];
    this.permMod12 = [];
    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }
  dot(g, x, y) {
    return g[0] * x + g[1] * y;
  }
  noise2D(xin, yin) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    let n0, n1, n2;
    const s = (xin + yin) * F2;
    const i = Math.floor(xin + s);
    const j = Math.floor(yin + s);
    const t = (i + j) * G2;
    const X0 = i - t;
    const Y0 = j - t;
    const x0 = xin - X0;
    const y0 = yin - Y0;
    let i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    const x1 = x0 - i1 + G2;
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2;
    const y2 = y0 - 1 + 2 * G2;
    const ii = i & 255;
    const jj = j & 255;
    const permJJ = this.perm[jj] || 0;
    const permJJ1 = this.perm[jj + j1 & 255] || 0;
    const permJJ2 = this.perm[jj + 1 & 255] || 0;
    const gi0 = this.permMod12[ii + permJJ & 511] || 0;
    const gi1 = this.permMod12[ii + i1 + permJJ1 & 511] || 0;
    const gi2 = this.permMod12[ii + 1 + permJJ2 & 511] || 0;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      const g0 = this.grad3[gi0];
      n0 = g0 ? t0 * t0 * this.dot(g0, x0, y0) : 0;
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      const g1 = this.grad3[gi1];
      n1 = g1 ? t1 * t1 * this.dot(g1, x1, y1) : 0;
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) {
      n2 = 0;
    } else {
      t2 *= t2;
      const g2 = this.grad3[gi2];
      n2 = g2 ? t2 * t2 * this.dot(g2, x2, y2) : 0;
    }
    return 70 * (n0 + n1 + n2);
  }
  // Fractal/Octave noise for more natural terrain
  fractal(x, y, octaves = 4, persistence = 0.5, lacunarity = 2) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;
    for (let i = 0; i < octaves; i++) {
      total += this.noise2D(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= persistence;
      frequency *= lacunarity;
    }
    return total / maxValue;
  }
}
class SeededRandom {
  constructor(seed = Date.now()) {
    this.seed = seed;
    this.state = seed;
  }
  // Mulberry32 - fast, high quality PRNG
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  // Random float between min and max
  range(min, max) {
    return min + this.next() * (max - min);
  }
  // Random integer between min (inclusive) and max (exclusive)
  int(min, max) {
    return Math.floor(this.range(min, max));
  }
  // Random boolean
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  // Random element from array
  choice(array) {
    return array[this.int(0, array.length)];
  }
  // Shuffle array in place
  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = this.int(0, i + 1);
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  // Reset to initial seed
  reset() {
    this.state = this.seed;
  }
  // Set new seed
  setSeed(seed) {
    this.seed = seed;
    this.state = seed;
  }
}
class MapEngine {
  constructor(seed = Date.now()) {
    this.seed = seed;
    this.rng = new SeededRandom(seed);
    this.hexGrid = new HexGrid(20);
    this.tiles = /* @__PURE__ */ new Map();
    this.config = {
      radius: 20,
      oceanBoundaryWidth: 1,
      // Hexes from edge that should be ocean
      elevationScale: 0.18,
      moistureScale: 0.14,
      falloffExponent: 1.8,
      // Lower = gentler falloff (more land)
      beachWidth: 1,
      riverSources: 2,
      landThreshold: 0.3,
      // Lower = more land coverage
      edgeNoiseStrength: 0.25
      // Adds natural irregularity to coastline
    };
  }
  // ========================================
  // MAIN GENERATION PIPELINE
  // ========================================
  generate() {
    console.log(`üèùÔ∏è Generating island with seed: ${this.seed}`);
    const hexes = this.hexGrid.generateCircularMap(this.config.radius);
    console.log(`üìê Generated ${hexes.length} hexes in circular pattern`);
    this.generateElevation(hexes);
    console.log(`‚õ∞Ô∏è  Generated elevation with radial falloff`);
    this.thresholdLandSea();
    console.log(`üåä Separated land from sea`);
    this.markBeaches();
    console.log(`üèñÔ∏è  Marked beach tiles`);
    this.carveRiver();
    console.log(`üèûÔ∏è  Carved rivers from mountains to sea`);
    this.generateMoisture();
    console.log(`üíß Generated moisture distribution`);
    this.assignBiomes();
    console.log(`üå¥ Assigned biomes based on elevation and moisture`);
    this.smoothBiomes();
    console.log(`‚ú® Smoothed biome transitions`);
    const stats = this.getMapStats();
    console.log(`üìä Map Stats:`, stats);
    return {
      tiles: this.tiles,
      hexGrid: this.hexGrid,
      seed: this.seed,
      stats,
      config: this.config
    };
  }
  // ========================================
  // STEP 1: ELEVATION GENERATION
  // ========================================
  generateElevation(hexes) {
    const noise = new SimplexNoise(this.seed);
    const edgeNoise = new SimplexNoise(this.seed + 500);
    for (const hex of hexes) {
      const distFromCenter = this.hexGrid.distance(0, 0, hex.q, hex.r);
      distFromCenter / this.config.radius;
      const oceanBoundaryDist = this.config.radius - this.config.oceanBoundaryWidth;
      if (distFromCenter > oceanBoundaryDist) {
        this.setTile(hex.q, hex.r, {
          q: hex.q,
          r: hex.r,
          elevation: 0,
          terrain: null,
          moisture: 0,
          isEdge: true
        });
        continue;
      }
      const landRadius = oceanBoundaryDist;
      const landDist = distFromCenter / landRadius;
      const coastlineNoise = edgeNoise.noise2D(hex.q * 0.3, hex.r * 0.3);
      const adjustedLandDist = Math.max(0, landDist + coastlineNoise * this.config.edgeNoiseStrength);
      const falloff = Math.pow(1 - adjustedLandDist, this.config.falloffExponent);
      const noiseValue = noise.fractal(
        hex.q * this.config.elevationScale,
        hex.r * this.config.elevationScale,
        4,
        // octaves
        0.5,
        // persistence
        2
        // lacunarity
      );
      const elevation = 0.5 * falloff + 0.5 * (noiseValue * 0.5 + 0.5);
      this.setTile(hex.q, hex.r, {
        q: hex.q,
        r: hex.r,
        elevation: Math.max(0, Math.min(1, elevation)),
        terrain: null,
        moisture: 0,
        isEdge: false
      });
    }
  }
  // ========================================
  // STEP 2: LAND/SEA THRESHOLD
  // ========================================
  thresholdLandSea() {
    for (const [key, tile] of this.tiles) {
      if (tile.isEdge || tile.elevation <= this.config.landThreshold) {
        tile.terrain = "sea";
        tile.isLand = false;
        tile.isPassable = false;
      } else {
        tile.isLand = true;
        tile.isPassable = true;
      }
    }
  }
  // ========================================
  // STEP 3: BEACHES
  // ========================================
  markBeaches() {
    const beachTiles = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand) continue;
      const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
      const hasSeaNeighbor = neighbors.some((n) => {
        const neighbor = this.getTile(n.q, n.r);
        return neighbor && neighbor.terrain === "sea";
      });
      if (hasSeaNeighbor) {
        tile.terrain = "beach";
        tile.distanceToWater = 0;
        beachTiles.push(tile);
      }
    }
    this.calculateWaterDistance(beachTiles);
  }
  calculateWaterDistance(waterTiles) {
    const queue = [...waterTiles];
    const visited = new Set(waterTiles.map((t) => this.key(t.q, t.r)));
    while (queue.length > 0) {
      const current = queue.shift();
      const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
      for (const n of neighbors) {
        const key = this.key(n.q, n.r);
        if (visited.has(key)) continue;
        const neighbor = this.getTile(n.q, n.r);
        if (!neighbor || !neighbor.isLand) continue;
        neighbor.distanceToWater = (current.distanceToWater || 0) + 1;
        visited.add(key);
        queue.push(neighbor);
      }
    }
  }
  // ========================================
  // STEP 4: RIVER CARVING
  // ========================================
  carveRiver() {
    const potentialSources = [];
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand || tile.terrain === "beach") continue;
      if (tile.elevation > 0.65 && tile.distanceToWater > 3) {
        potentialSources.push(tile);
      }
    }
    if (potentialSources.length === 0) {
      console.warn("‚ö†Ô∏è  No suitable river sources found");
      return;
    }
    potentialSources.sort((a, b) => b.elevation - a.elevation);
    const numRivers = Math.min(this.config.riverSources, potentialSources.length);
    const riverSources = potentialSources.slice(0, numRivers);
    console.log(`üèûÔ∏è  Carving ${numRivers} river(s) from sources at elevation ${riverSources[0].elevation.toFixed(2)}`);
    let totalRiverTiles = 0;
    for (let i = 0; i < riverSources.length; i++) {
      const source = riverSources[i];
      const riverPath = [];
      let current = source;
      const visited = /* @__PURE__ */ new Set();
      while (current && current.terrain !== "sea" && riverPath.length < 100) {
        riverPath.push(current);
        visited.add(this.key(current.q, current.r));
        const neighbors = this.hexGrid.getNeighbors(current.q, current.r);
        let lowest = null;
        let lowestScore = Infinity;
        for (const n of neighbors) {
          const neighbor = this.getTile(n.q, n.r);
          if (!neighbor || visited.has(this.key(n.q, n.r))) continue;
          const elevationScore = neighbor.elevation * 100;
          const waterScore = (neighbor.distanceToWater || 10) * 2;
          const score = elevationScore + waterScore;
          if (score < lowestScore) {
            lowestScore = score;
            lowest = neighbor;
          }
        }
        current = lowest;
      }
      for (const tile of riverPath) {
        if (tile.terrain !== "beach") {
          tile.terrain = "river";
          tile.isRiver = true;
          tile.isPassable = true;
          tile.distanceToWater = 0;
          totalRiverTiles++;
        }
      }
      console.log(`   River ${i + 1}: ${riverPath.length} tiles`);
    }
    console.log(`üèûÔ∏è  Total river tiles: ${totalRiverTiles}`);
  }
  // ========================================
  // STEP 5: MOISTURE GENERATION
  // ========================================
  generateMoisture() {
    const noise = new SimplexNoise(this.seed + 1e3);
    for (const [key, tile] of this.tiles) {
      if (!tile.isLand) {
        tile.moisture = 0;
        continue;
      }
      const baseMoisture = noise.fractal(
        tile.q * this.config.moistureScale,
        tile.r * this.config.moistureScale,
        3
      ) * 0.5 + 0.5;
      const waterProximity = 1 / (1 + (tile.distanceToWater || 10) * 0.3);
      tile.moisture = Math.max(0, Math.min(1, baseMoisture * 0.6 + waterProximity * 0.4));
    }
  }
  // ========================================
  // STEP 6: BIOME ASSIGNMENT
  // ========================================
  assignBiomes() {
    for (const [key, tile] of this.tiles) {
      if (tile.terrain === "sea" || tile.terrain === "beach" || tile.terrain === "river") {
        continue;
      }
      const elev = tile.elevation;
      const moist = tile.moisture;
      if (elev < 0.5) {
        if (moist < 0.3) tile.terrain = "savanna";
        else if (moist < 0.6) tile.terrain = "forest";
        else tile.terrain = "rainforest";
      } else if (elev < 0.7) {
        if (moist < 0.4) tile.terrain = "dry-hill";
        else if (moist < 0.7) tile.terrain = "jungle-hill";
        else tile.terrain = "cloud-forest";
      } else {
        if (moist < 0.5) tile.terrain = "rocky-peak";
        else tile.terrain = "misty-peak";
      }
    }
  }
  // ========================================
  // STEP 7: SMOOTHING
  // ========================================
  smoothBiomes(passes = 2) {
    for (let pass = 0; pass < passes; pass++) {
      const changes = [];
      for (const [key, tile] of this.tiles) {
        if (!tile.isLand || tile.isRiver || tile.terrain === "beach") continue;
        const neighbors = this.hexGrid.getNeighbors(tile.q, tile.r);
        const neighborTerrains = neighbors.map((n) => this.getTile(n.q, n.r)).filter((n) => n && n.isLand).map((n) => n.terrain);
        const counts = {};
        for (const terrain of neighborTerrains) {
          counts[terrain] = (counts[terrain] || 0) + 1;
        }
        const modal = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
        if (modal && modal[1] >= 4 && modal[0] !== tile.terrain) {
          changes.push({ tile, newTerrain: modal[0] });
        }
      }
      for (const { tile, newTerrain } of changes) {
        tile.terrain = newTerrain;
      }
    }
  }
  // ========================================
  // UTILITY METHODS
  // ========================================
  key(q, r) {
    return `${q},${r}`;
  }
  getTile(q, r) {
    return this.tiles.get(this.key(q, r));
  }
  setTile(q, r, data) {
    this.tiles.set(this.key(q, r), data);
  }
  getMapStats() {
    const stats = {
      totalTiles: this.tiles.size,
      terrainCounts: {},
      landTiles: 0,
      seaTiles: 0,
      landPercentage: 0,
      edgeTiles: 0
    };
    for (const [key, tile] of this.tiles) {
      stats.terrainCounts[tile.terrain] = (stats.terrainCounts[tile.terrain] || 0) + 1;
      if (tile.isLand) stats.landTiles++;
      else stats.seaTiles++;
      if (tile.isEdge) stats.edgeTiles++;
    }
    stats.landPercentage = (stats.landTiles / stats.totalTiles * 100).toFixed(1);
    return stats;
  }
  // ========================================
  // FUTURE FEATURES - PLACEHOLDERS
  // ========================================
  /**
   * FUTURE: Place Points of Interest (POIs)
   * Examples: Shipwreck, ancient ruins, cave system, waterfall, 
   * volcano crater, mysterious monolith, abandoned camp, etc.
   * 
   * Design Notes:
   * - Each POI should have narrative significance
   * - Limit to 5-10 major POIs per map
   * - Place based on terrain suitability
   * - Ensure they're discoverable but not too obvious
   * - Can unlock quests, resources, or story events
   */
  placePOIs() {
    const pois = [];
    return pois;
  }
  /**
   * FUTURE: Define Faction Territories
   * Examples: Survivor camps, native tribes, wildlife zones, 
   * "claimed" areas, danger zones, etc.
   * 
   * Design Notes:
   * - Factions control regions, not individual tiles
   * - Should have organic boundaries (follow terrain features)
   * - 3-5 major factions maximum
   * - Player starts neutral or with one faction
   * - Territories can overlap (contested zones)
   * - Affects encounters, resources, quests
   */
  defineFactionTerritories() {
    const territories = [];
    return territories;
  }
  /**
   * FUTURE: Place Resource Nodes
   * Examples: Fruit trees, freshwater springs, stone quarries,
   * fishing spots, herb patches, wildlife dens, etc.
   * 
   * Design Notes:
   * - Should be numerous but not overwhelming
   * - Cluster by terrain type
   * - Some renewable (fruit, fish), some finite (stone, minerals)
   * - Higher quality resources in dangerous areas
   * - Can be depleted and regenerate over time
   */
  placeResourceNodes() {
    const resources = [];
    return resources;
  }
  /**
   * FUTURE: Fog of War System
   * 
   * Design Notes:
   * - All tiles start hidden except player's starting location
   * - Tiles reveal when player moves adjacent to them
   * - Three states: unexplored, explored, visible
   * - Can see terrain type when explored, but not current details
   * - High ground (mountains) reveals larger area
   * - Story events can reveal specific areas
   */
  initializeFogOfWar(startingTile) {
  }
  /**
   * FUTURE: Landmarks System
   * Special one-of-a-kind locations that serve as waypoints
   * 
   * Examples: The Great Banyan, Skull Rock, Crystal Lagoon,
   * The Spire, Dead Man's Cove, etc.
   * 
   * Design Notes:
   * - Visually distinctive on map
   * - Named and memorable
   * - Often multi-tile structures
   * - Used for navigation and quests
   * - 3-5 major landmarks per map
   */
  placeLandmarks() {
    const landmarks = [];
    return landmarks;
  }
}
class Territory {
  constructor(position) {
    this.position = position;
    this.owner = null;
    this.discovered = false;
    this.visited = false;
    this.visibleFromFog = false;
    this.hasResourceNode = false;
    this.resourceNodeId = null;
    this.hasEvent = false;
    this.eventId = null;
    this.hasNPC = false;
    this.npcId = null;
    this.controlStrength = 0;
    this.lastVisited = null;
    this.discoveredBy = null;
    this.travelCostModifier = 1;
    this.travelSpeedModifier = 1;
    this.terrain = null;
    this.elevation = 0;
    this.biome = null;
  }
  /**
   * Set the owner of this territory
   */
  setOwner(faction, strength = 50) {
    this.owner = faction;
    this.controlStrength = strength;
    this.updateTravelModifiers();
  }
  /**
   * Update travel modifiers based on ownership
   */
  updateTravelModifiers() {
    if (this.owner === "player") {
      this.travelCostModifier = 0.5;
      this.travelSpeedModifier = 1.5;
    } else if (this.owner) {
      this.travelCostModifier = 1.2;
      this.travelSpeedModifier = 0.9;
    } else {
      this.travelCostModifier = 1;
      this.travelSpeedModifier = 1;
    }
  }
  /**
   * Discover this territory
   */
  discover(discoveredBy) {
    if (!this.discovered) {
      this.discovered = true;
      this.discoveredBy = discoveredBy;
      this.visibleFromFog = true;
    }
  }
  /**
   * Visit this territory
   */
  visit() {
    this.visited = true;
    this.lastVisited = Date.now();
    this.discover("player");
  }
  /**
   * Get faction color
   */
  getFactionColor() {
    const colors = {
      player: "#4dd0e1",
      // Cyan
      castaways: "#4ade80",
      // Green
      natives_clan1: "#fbbf24",
      // Yellow
      natives_clan2: "#f97316",
      // Orange
      mercenaries: "#dc2626"
      // Red
    };
    return colors[this.owner] || null;
  }
  /**
   * Get control strength color (for visualization)
   */
  getControlColor() {
    const baseColor = this.getFactionColor();
    if (!baseColor) return null;
    const alpha = this.controlStrength / 100;
    return `${baseColor}${Math.floor(alpha * 255).toString(16).padStart(2, "0")}`;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      position: this.position,
      owner: this.owner,
      discovered: this.discovered,
      visited: this.visited,
      controlStrength: this.controlStrength,
      hasResourceNode: this.hasResourceNode,
      resourceNodeId: this.resourceNodeId,
      hasEvent: this.hasEvent,
      eventId: this.eventId,
      hasNPC: this.hasNPC,
      npcId: this.npcId,
      lastVisited: this.lastVisited
    };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data) {
    const territory = new Territory(data.position);
    Object.assign(territory, data);
    territory.updateTravelModifiers();
    return territory;
  }
}
class TerritoryManager {
  constructor() {
    this.territories = /* @__PURE__ */ new Map();
    this.factionTerritories = {
      player: [],
      castaways: [],
      natives_clan1: [],
      natives_clan2: [],
      mercenaries: []
    };
  }
  /**
   * Initialize territories from map data
   */
  initFromMap(mapData) {
    mapData.tiles.forEach((tile, key) => {
      const [q, r] = key.split(",").map(Number);
      const territory = new Territory({ q, r });
      territory.terrain = tile.terrain || tile.type;
      territory.elevation = tile.elevation;
      territory.biome = tile.biome || this.getBiomeFromTerrain(tile.terrain || tile.type);
      territory.isPassable = tile.isPassable !== false;
      this.territories.set(key, territory);
    });
    console.log(`üó∫Ô∏è Initialized ${this.territories.size} territories`);
  }
  /**
   * Get biome from terrain type
   */
  getBiomeFromTerrain(terrain) {
    const biomes = {
      "deep_water": "ocean",
      "water": "ocean",
      "beach": "coastal",
      "lowland": "tropical",
      "forest": "jungle",
      "highland": "hills",
      "mountain": "mountain"
    };
    return biomes[terrain] || "tropical";
  }
  /**
   * Get territory at position
   */
  getTerritory(q, r) {
    return this.territories.get(`${q},${r}`) || null;
  }
  /**
   * Get all territories owned by faction
   */
  getFactionTerritories(faction) {
    return Array.from(this.territories.values()).filter((t) => t.owner === faction);
  }
  /**
   * Set territory owner
   */
  setOwner(q, r, faction, strength = 50) {
    const territory = this.getTerritory(q, r);
    if (territory) {
      territory.setOwner(faction, strength);
      return true;
    }
    return false;
  }
  /**
   * Expand faction territory (claim adjacent tiles)
   */
  expandTerritory(q, r, faction, strength = 30) {
    const adjacent = this.getAdjacentTerritories(q, r);
    const claimed = [];
    for (const territory of adjacent) {
      if (!territory.owner || territory.controlStrength < 30) {
        territory.setOwner(faction, strength);
        claimed.push(territory);
      }
    }
    return claimed;
  }
  /**
   * Get adjacent territories
   */
  getAdjacentTerritories(q, r) {
    const directions = [
      { q: 1, r: 0 },
      { q: 1, r: -1 },
      { q: 0, r: -1 },
      { q: -1, r: 0 },
      { q: -1, r: 1 },
      { q: 0, r: 1 }
    ];
    return directions.map((dir) => this.getTerritory(q + dir.q, r + dir.r)).filter((t) => t !== null);
  }
  /**
   * Get visible territories (fog of war)
   */
  getVisibleTerritories(playerPosition, visionRange = 2) {
    const visible = [];
    const center = this.getTerritory(playerPosition.q, playerPosition.r);
    if (!center) return visible;
    center.visibleFromFog = true;
    visible.push(center);
    for (let q = -visionRange; q <= visionRange; q++) {
      for (let r = -visionRange; r <= visionRange; r++) {
        const distance = Math.abs(q) + Math.abs(r) + Math.abs(-q - r);
        if (distance <= visionRange * 2) {
          const territory = this.getTerritory(
            playerPosition.q + q,
            playerPosition.r + r
          );
          if (territory) {
            territory.visibleFromFog = true;
            visible.push(territory);
          }
        }
      }
    }
    return visible;
  }
  /**
   * Update fog of war based on discoveries
   */
  updateFogOfWar(discoveredPositions) {
    discoveredPositions.forEach((pos) => {
      const territory = this.getTerritory(pos.q, pos.r);
      if (territory) {
        territory.discover("player");
      }
    });
  }
  /**
   * Generate starting territories
   */
  generateStartingTerritories(playerStart) {
    console.log(`üèÅ Generating starting territories at (${playerStart.q}, ${playerStart.r})`);
    this.setOwner(playerStart.q, playerStart.r, "player", 100);
    const territory = this.getTerritory(playerStart.q, playerStart.r);
    if (territory) {
      territory.discover("player");
      territory.visit();
      console.log(`‚úÖ Player territory discovered and visited`);
    } else {
      console.error(`‚ùå No territory found at player start position (${playerStart.q}, ${playerStart.r})`);
    }
    const visible = this.getVisibleTerritories(playerStart, 2);
    console.log(`üëÅÔ∏è Revealed ${visible.length} visible territories`);
    this.generateFactionTerritories();
    console.log("üèÅ Starting territories generated");
  }
  /**
   * Generate faction territories across the island
   */
  generateFactionTerritories() {
    const allTerritories = Array.from(this.territories.values());
    const suitable = allTerritories.filter(
      (t) => t.terrain !== "deep_water" && t.terrain !== "water" && t.elevation < 0.85 && !t.owner
      // Not already claimed
    );
    const factions = [
      { id: "castaways", count: 3, strength: 40 },
      { id: "natives_clan1", count: 5, strength: 60 },
      { id: "natives_clan2", count: 4, strength: 55 },
      { id: "mercenaries", count: 2, strength: 70 }
    ];
    factions.forEach((faction) => {
      for (let i = 0; i < faction.count; i++) {
        const randomIndex = Math.floor(Math.random() * suitable.length);
        const territory = suitable[randomIndex];
        if (territory) {
          territory.setOwner(faction.id, faction.strength);
          const expanded = this.expandTerritory(
            territory.position.q,
            territory.position.r,
            faction.id,
            faction.strength - 10
          );
          suitable.splice(randomIndex, 1);
          expanded.forEach((t) => {
            const idx = suitable.indexOf(t);
            if (idx !== -1) suitable.splice(idx, 1);
          });
        }
      }
    });
    Object.keys(this.factionTerritories).forEach((faction) => {
      const count = this.getFactionTerritories(faction).length;
      if (count > 0) {
        console.log(`  ${faction}: ${count} territories`);
      }
    });
  }
  /**
   * Get territory statistics
   */
  getStats() {
    const stats = {
      total: this.territories.size,
      discovered: 0,
      visited: 0,
      owned: {},
      unclaimed: 0
    };
    this.territories.forEach((territory) => {
      if (territory.discovered) stats.discovered++;
      if (territory.visited) stats.visited++;
      if (territory.owner) {
        stats.owned[territory.owner] = (stats.owned[territory.owner] || 0) + 1;
      } else {
        stats.unclaimed++;
      }
    });
    return stats;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    const territories = {};
    this.territories.forEach((territory, key) => {
      territories[key] = territory.toJSON();
    });
    return { territories };
  }
  /**
   * Load from saved data
   */
  static fromJSON(data) {
    const manager = new TerritoryManager();
    Object.entries(data.territories).forEach(([key, territoryData]) => {
      manager.territories.set(key, Territory.fromJSON(territoryData));
    });
    return manager;
  }
}
class TravelSystem {
  constructor(player2, territoryManager2) {
    this.player = player2;
    this.territoryManager = territoryManager2;
    this.currentPosition = { q: 0, r: 0 };
    this.targetPosition = null;
    this.travelPath = [];
    this.isTraveling = false;
    this.travelProgress = 0;
    this.travelSpeed = 1;
    this.baseEnergyCost = 5;
    this.baseTravelTime = 1e3;
    this.eventHandlers = [];
    this.lastEventCheck = Date.now();
    this.eventCheckInterval = 2e3;
  }
  /**
   * Calculate energy cost for traveling to a tile
   */
  calculateEnergyCost(fromPos, toPos) {
    const fromTerritory = this.territoryManager.getTerritory(fromPos.q, fromPos.r);
    const toTerritory = this.territoryManager.getTerritory(toPos.q, toPos.r);
    if (!toTerritory) return Infinity;
    let cost = this.baseEnergyCost;
    const terrainCosts = {
      "deep_water": 999,
      // Can't travel through deep water
      "water": 20,
      // Very expensive
      "beach": 3,
      "lowland": 5,
      "forest": 7,
      "highland": 10,
      "mountain": 15
    };
    cost *= (terrainCosts[toTerritory.terrain] || 5) / 5;
    cost *= toTerritory.travelCostModifier;
    if (fromTerritory) {
      const elevationChange = Math.abs(toTerritory.elevation - fromTerritory.elevation);
      cost *= 1 + elevationChange * 2;
    }
    return Math.ceil(cost);
  }
  /**
   * Calculate travel time for a tile
   */
  calculateTravelTime(fromPos, toPos) {
    const toTerritory = this.territoryManager.getTerritory(toPos.q, toPos.r);
    if (!toTerritory) return Infinity;
    let time = this.baseTravelTime;
    time /= toTerritory.travelSpeedModifier;
    const terrainSpeed = {
      "beach": 0.9,
      "lowland": 1,
      "forest": 1.3,
      "highland": 1.5,
      "mountain": 2
    };
    time *= terrainSpeed[toTerritory.terrain] || 1;
    return Math.ceil(time);
  }
  /**
   * Check if can travel to position
   */
  canTravelTo(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) {
      console.log(`‚ùå Cannot travel to (${q}, ${r}): No territory`);
      return false;
    }
    if (territory.terrain === "deep_water") {
      console.log(`‚ùå Cannot travel to (${q}, ${r}): Deep water`);
      return false;
    }
    const dq = Math.abs(q - this.currentPosition.q);
    const dr = Math.abs(r - this.currentPosition.r);
    const ds = Math.abs(-q - r - (-this.currentPosition.q - this.currentPosition.r));
    const distance = Math.max(dq, dr, ds);
    console.log(`üîç Travel check from (${this.currentPosition.q}, ${this.currentPosition.r}) to (${q}, ${r}): distance=${distance}`);
    if (distance > 1) {
      console.log(`‚ùå Cannot travel to (${q}, ${r}): Too far (distance ${distance})`);
      return false;
    }
    const energyCost = this.calculateEnergyCost(this.currentPosition, { q, r });
    if (this.player.energy < energyCost) {
      console.log(`‚ùå Cannot travel to (${q}, ${r}): Not enough energy (need ${energyCost}, have ${this.player.energy})`);
      return false;
    }
    console.log(`‚úÖ Can travel to (${q}, ${r})`);
    return true;
  }
  /**
   * Start traveling to a position
   */
  startTravel(q, r) {
    if (!this.canTravelTo(q, r)) {
      return {
        success: false,
        reason: "Cannot travel to that location"
      };
    }
    const energyCost = this.calculateEnergyCost(this.currentPosition, { q, r });
    const travelTime = this.calculateTravelTime(this.currentPosition, { q, r });
    this.targetPosition = { q, r };
    this.isTraveling = true;
    this.travelProgress = 0;
    this.travelSpeed = 1e3 / travelTime;
    this.player.energy = Math.max(0, this.player.energy - energyCost);
    this.emitEvent("travelStart", {
      from: { ...this.currentPosition },
      to: { q, r },
      energyCost,
      travelTime
    });
    return {
      success: true,
      energyCost,
      travelTime
    };
  }
  /**
   * Update travel progress (called from game loop)
   */
  update(deltaTime) {
    if (!this.isTraveling) return;
    this.travelProgress += this.travelSpeed * deltaTime / 1e3;
    if (this.travelProgress >= 1) {
      this.arriveAtDestination();
    }
    const now = Date.now();
    if (now - this.lastEventCheck >= this.eventCheckInterval) {
      this.checkForTravelEvents();
      this.lastEventCheck = now;
    }
  }
  /**
   * Arrive at destination
   */
  arriveAtDestination() {
    if (!this.targetPosition) return;
    const oldPosition = { ...this.currentPosition };
    this.currentPosition = { ...this.targetPosition };
    this.targetPosition = null;
    this.isTraveling = false;
    this.travelProgress = 0;
    const territory = this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
    if (territory) {
      territory.visit();
      this.territoryManager.getVisibleTerritories(this.currentPosition, 1);
      this.checkForDiscoveries(territory);
    }
    this.emitEvent("travelComplete", {
      from: oldPosition,
      to: this.currentPosition,
      territory
    });
    console.log(`üö∂ Arrived at (${this.currentPosition.q}, ${this.currentPosition.r})`);
  }
  /**
   * Check for discoveries at new territory
   */
  checkForDiscoveries(territory) {
    const discoveries = [];
    if (!territory.hasResourceNode && Math.random() < 0.3) {
      const nodeTypes = ["tree", "rock", "bush"];
      const nodeType = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
      territory.hasResourceNode = true;
      territory.resourceNodeId = `${nodeType}_${territory.position.q}_${territory.position.r}`;
      discoveries.push({
        type: "resource",
        nodeType,
        nodeId: territory.resourceNodeId
      });
    }
    if (!territory.hasEvent && Math.random() < 0.2) {
      territory.hasEvent = true;
      territory.eventId = this.generateRandomEvent(territory);
      discoveries.push({
        type: "event",
        eventId: territory.eventId
      });
    }
    if (!territory.hasNPC && Math.random() < 0.15) {
      territory.hasNPC = true;
      territory.npcId = `npc_${territory.position.q}_${territory.position.r}`;
      discoveries.push({
        type: "npc",
        npcId: territory.npcId
      });
    }
    if (discoveries.length > 0) {
      this.emitEvent("discoveries", {
        territory,
        discoveries
      });
    }
  }
  /**
   * Check for travel events (while traveling)
   */
  checkForTravelEvents() {
    if (!this.isTraveling) return;
    const currentTerritory = this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
    if (!currentTerritory || !currentTerritory.owner) return;
    const faction = currentTerritory.owner;
    const relationship = this.getRelationshipWithFaction(faction);
    this.rollFactionEncounter(faction, relationship, currentTerritory);
  }
  /**
   * Get relationship with faction
   */
  getRelationshipWithFaction(faction) {
    if (faction === "player") return 100;
    const rep = this.player.reputation[faction] || 0;
    if (rep >= 75) return "ally";
    if (rep >= 50) return "friendly";
    if (rep >= 25) return "neutral";
    if (rep >= -25) return "unfriendly";
    if (rep >= -50) return "hostile";
    return "enemy";
  }
  /**
   * Roll for faction encounters
   */
  rollFactionEncounter(faction, relationship, territory) {
    let encounterChance = 0;
    const baseChances = {
      castaways: 0.15,
      natives_clan1: 0.2,
      natives_clan2: 0.18,
      mercenaries: 0.3
    };
    encounterChance = baseChances[faction] || 0.1;
    encounterChance *= territory.controlStrength / 50;
    if (Math.random() > encounterChance) return;
    const encounterType = this.determineEncounterType(relationship);
    this.emitEvent("factionEncounter", {
      faction,
      relationship,
      encounterType,
      territory
    });
  }
  /**
   * Determine encounter type based on relationship
   */
  determineEncounterType(relationship) {
    const encounters = {
      ally: ["trade", "gift", "quest", "chat"],
      friendly: ["trade", "chat", "help"],
      neutral: ["chat", "ignore", "warning"],
      unfriendly: ["warning", "demand", "threat"],
      hostile: ["ambush", "attack", "chase"],
      enemy: ["attack", "ambush"]
    };
    const options = encounters[relationship] || ["ignore"];
    return options[Math.floor(Math.random() * options.length)];
  }
  /**
   * Generate random event
   */
  generateRandomEvent(territory) {
    const events = [
      "chest_found",
      "strange_sound",
      "animal_tracks",
      "abandoned_camp",
      "mysterious_shrine",
      "hidden_cave",
      "fruit_tree",
      "fresh_water"
    ];
    return events[Math.floor(Math.random() * events.length)];
  }
  /**
   * Get current territory
   */
  getCurrentTerritory() {
    return this.territoryManager.getTerritory(
      this.currentPosition.q,
      this.currentPosition.r
    );
  }
  /**
   * Set player position (for initialization)
   */
  setPosition(q, r) {
    this.currentPosition = { q, r };
    const territory = this.territoryManager.getTerritory(q, r);
    if (territory) {
      territory.visit();
    }
  }
  /**
   * Event system
   */
  on(event, handler) {
    this.eventHandlers.push({ event, handler });
  }
  emitEvent(event, data) {
    this.eventHandlers.filter((h) => h.event === event).forEach((h) => h.handler(data));
  }
  /**
   * Get travel info for UI
   */
  getTravelInfo(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) return null;
    const canTravel = this.canTravelTo(q, r);
    const energyCost = this.calculateEnergyCost(this.currentPosition, { q, r });
    const travelTime = this.calculateTravelTime(this.currentPosition, { q, r });
    return {
      canTravel,
      energyCost,
      travelTime,
      territory,
      reason: !canTravel ? this.getCannotTravelReason(q, r) : null
    };
  }
  /**
   * Get reason why can't travel
   */
  getCannotTravelReason(q, r) {
    const territory = this.territoryManager.getTerritory(q, r);
    if (!territory) return "Invalid location";
    if (territory.terrain === "deep_water") return "Cannot cross deep water";
    const energyCost = this.calculateEnergyCost(this.currentPosition, { q, r });
    if (this.player.energy < energyCost) return `Need ${energyCost} energy`;
    return "Too far away";
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      currentPosition: this.currentPosition,
      isTraveling: this.isTraveling,
      targetPosition: this.targetPosition,
      travelProgress: this.travelProgress
    };
  }
  /**
   * Load from saved data
   */
  loadFromJSON(data) {
    this.currentPosition = data.currentPosition || { q: 0, r: 0 };
    this.isTraveling = data.isTraveling || false;
    this.targetPosition = data.targetPosition || null;
    this.travelProgress = data.travelProgress || 0;
  }
}
class InventoryUI {
  constructor(inventory2) {
    this.inventory = inventory2;
    this.container = null;
    this.selectedSlot = null;
    this.draggedSlot = null;
    this.isOpen = false;
    this.createUI();
    this.setupEventListeners();
  }
  /**
   * Create the main UI structure
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "inventory-overlay";
    this.container.style.display = "none";
    const modal = document.createElement("div");
    modal.className = "inventory-modal";
    const header = this.createHeader();
    modal.appendChild(header);
    const content = document.createElement("div");
    content.className = "inventory-content";
    const equipmentPanel = this.createEquipmentPanel();
    content.appendChild(equipmentPanel);
    const gridPanel = this.createGridPanel();
    content.appendChild(gridPanel);
    modal.appendChild(content);
    const detailsPanel = this.createDetailsPanel();
    modal.appendChild(detailsPanel);
    this.container.appendChild(modal);
    document.body.appendChild(this.container);
  }
  /**
   * Create header with title and close button
   */
  createHeader() {
    const header = document.createElement("div");
    header.className = "inventory-header";
    const title = document.createElement("h2");
    title.textContent = "INVENTORY";
    header.appendChild(title);
    const closeBtn = document.createElement("button");
    closeBtn.className = "inventory-close";
    closeBtn.innerHTML = "√ó";
    closeBtn.onclick = () => this.close();
    header.appendChild(closeBtn);
    return header;
  }
  /**
   * Create equipment panel (left side)
   */
  createEquipmentPanel() {
    const panel = document.createElement("div");
    panel.className = "equipment-panel";
    const title = document.createElement("h3");
    title.textContent = "EQUIPMENT";
    panel.appendChild(title);
    const slots = ["weapon", "tool", "clothing", "backpack"];
    slots.forEach((slotType) => {
      const slotContainer = this.createEquipmentSlot(slotType);
      panel.appendChild(slotContainer);
    });
    return panel;
  }
  /**
   * Create individual equipment slot
   */
  createEquipmentSlot(slotType) {
    const container = document.createElement("div");
    container.className = "equipment-slot-container";
    const label = document.createElement("div");
    label.className = "equipment-label";
    label.textContent = slotType.toUpperCase();
    container.appendChild(label);
    const slot = document.createElement("div");
    slot.className = "equipment-slot";
    slot.dataset.slotType = slotType;
    const placeholder = document.createElement("div");
    placeholder.className = "equipment-placeholder";
    placeholder.textContent = this.getEquipmentIcon(slotType);
    slot.appendChild(placeholder);
    container.appendChild(slot);
    return container;
  }
  /**
   * Get icon for equipment slot
   */
  getEquipmentIcon(slotType) {
    const icons = {
      weapon: "‚öîÔ∏è",
      tool: "üîß",
      clothing: "üëï",
      backpack: "üéí"
    };
    return icons[slotType] || "?";
  }
  /**
   * Create grid panel (center)
   */
  createGridPanel() {
    const panel = document.createElement("div");
    panel.className = "grid-panel";
    const grid = document.createElement("div");
    grid.className = "inventory-grid";
    for (let i = 0; i < 20; i++) {
      const slot = this.createInventorySlot(i);
      grid.appendChild(slot);
    }
    panel.appendChild(grid);
    const weightBar = this.createWeightBar();
    panel.appendChild(weightBar);
    const actions = this.createActionButtons();
    panel.appendChild(actions);
    return panel;
  }
  /**
   * Create individual inventory slot
   */
  createInventorySlot(index) {
    const slot = document.createElement("div");
    slot.className = "inventory-slot";
    slot.dataset.slotIndex = index;
    const icon = document.createElement("div");
    icon.className = "slot-icon";
    slot.appendChild(icon);
    const count = document.createElement("div");
    count.className = "slot-count";
    slot.appendChild(count);
    const border = document.createElement("div");
    border.className = "slot-border";
    slot.appendChild(border);
    slot.addEventListener("click", () => this.selectSlot(index));
    slot.addEventListener("dragstart", (e) => this.onDragStart(e, index));
    slot.addEventListener("dragover", (e) => this.onDragOver(e));
    slot.addEventListener("drop", (e) => this.onDrop(e, index));
    slot.addEventListener("mouseenter", () => this.showTooltip(index));
    slot.addEventListener("mouseleave", () => this.hideTooltip());
    return slot;
  }
  /**
   * Create weight capacity bar
   */
  createWeightBar() {
    const container = document.createElement("div");
    container.className = "weight-container";
    const label = document.createElement("div");
    label.className = "weight-label";
    container.appendChild(label);
    const barBg = document.createElement("div");
    barBg.className = "weight-bar-bg";
    const barFill = document.createElement("div");
    barFill.className = "weight-bar-fill";
    barBg.appendChild(barFill);
    container.appendChild(barBg);
    return container;
  }
  /**
   * Create action buttons
   */
  createActionButtons() {
    const container = document.createElement("div");
    container.className = "action-buttons";
    const sortBtn = this.createButton("Sort", () => this.sortInventory());
    const stackBtn = this.createButton("Stack All", () => this.stackAll());
    const dropBtn = this.createButton("Drop All", () => this.dropAll());
    container.appendChild(sortBtn);
    container.appendChild(stackBtn);
    container.appendChild(dropBtn);
    return container;
  }
  /**
   * Create details panel (bottom)
   */
  createDetailsPanel() {
    const panel = document.createElement("div");
    panel.className = "details-panel";
    const empty = document.createElement("div");
    empty.className = "details-empty";
    empty.textContent = "Select an item to view details";
    panel.appendChild(empty);
    const details = document.createElement("div");
    details.className = "details-content";
    details.style.display = "none";
    const icon = document.createElement("div");
    icon.className = "details-icon";
    details.appendChild(icon);
    const info = document.createElement("div");
    info.className = "details-info";
    const name = document.createElement("div");
    name.className = "details-name";
    info.appendChild(name);
    const description = document.createElement("div");
    description.className = "details-description";
    info.appendChild(description);
    const durability = document.createElement("div");
    durability.className = "details-durability";
    info.appendChild(durability);
    const effects = document.createElement("div");
    effects.className = "details-effects";
    info.appendChild(effects);
    details.appendChild(info);
    const buttons = document.createElement("div");
    buttons.className = "details-buttons";
    const useBtn = this.createButton("Use", () => this.useSelectedItem());
    const equipBtn = this.createButton("Equip", () => this.equipSelectedItem());
    const dropBtn = this.createButton("Drop", () => this.dropSelectedItem());
    buttons.appendChild(useBtn);
    buttons.appendChild(equipBtn);
    buttons.appendChild(dropBtn);
    details.appendChild(buttons);
    panel.appendChild(details);
    return panel;
  }
  /**
   * Create a button
   */
  createButton(text, onclick) {
    const btn = document.createElement("button");
    btn.className = "inventory-button";
    btn.textContent = text;
    btn.onclick = onclick;
    return btn;
  }
  /**
   * Setup event listeners
   */
  setupEventListeners() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isOpen) {
        this.close();
      } else if (e.key === "i" || e.key === "I") {
        this.toggle();
      }
    });
    this.container.addEventListener("click", (e) => {
      if (e.target === this.container) {
        this.close();
      }
    });
  }
  /**
   * Open inventory
   */
  open() {
    this.isOpen = true;
    this.container.style.display = "flex";
    this.refresh();
  }
  /**
   * Close inventory
   */
  close() {
    this.isOpen = false;
    this.container.style.display = "none";
    this.selectedSlot = null;
  }
  /**
   * Toggle inventory
   */
  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * Refresh all UI elements
   */
  refresh() {
    this.refreshInventoryGrid();
    this.refreshEquipmentSlots();
    this.refreshWeightBar();
    this.refreshDetails();
  }
  /**
   * Refresh inventory grid
   */
  refreshInventoryGrid() {
    const slots = this.container.querySelectorAll(".inventory-slot");
    slots.forEach((slotElement, index) => {
      const slot = this.inventory.slots[index];
      const icon = slotElement.querySelector(".slot-icon");
      const count = slotElement.querySelector(".slot-count");
      const border = slotElement.querySelector(".slot-border");
      if (slot && !slot.isEmpty()) {
        const item = slot.item;
        icon.style.display = "block";
        icon.textContent = this.getItemIcon(item);
        if (item.stackable && slot.quantity > 1) {
          count.style.display = "block";
          count.textContent = slot.quantity;
        } else {
          count.style.display = "none";
        }
        border.style.display = "block";
        border.style.borderColor = this.getRarityColor(item.rarity);
        slotElement.draggable = true;
      } else {
        icon.style.display = "none";
        count.style.display = "none";
        border.style.display = "none";
        slotElement.draggable = false;
      }
      if (this.selectedSlot === index) {
        slotElement.classList.add("selected");
      } else {
        slotElement.classList.remove("selected");
      }
    });
  }
  /**
   * Refresh equipment slots
   */
  refreshEquipmentSlots() {
    const slotTypes = ["weapon", "tool", "clothing", "backpack"];
    slotTypes.forEach((slotType) => {
      const slotElement = this.container.querySelector(`[data-slot-type="${slotType}"]`);
      const item = this.inventory.equipment[slotType];
      slotElement.innerHTML = "";
      if (item) {
        const icon = document.createElement("div");
        icon.className = "equipment-icon";
        icon.textContent = this.getItemIcon(item);
        slotElement.appendChild(icon);
        const border = document.createElement("div");
        border.className = "equipment-border";
        border.style.borderColor = this.getRarityColor(item.rarity);
        slotElement.appendChild(border);
      } else {
        const placeholder = document.createElement("div");
        placeholder.className = "equipment-placeholder";
        placeholder.textContent = this.getEquipmentIcon(slotType);
        slotElement.appendChild(placeholder);
      }
      slotElement.onclick = () => {
        if (item) {
          this.inventory.unequip(slotType);
          this.refresh();
        }
      };
    });
  }
  /**
   * Refresh weight bar
   */
  refreshWeightBar() {
    const currentWeight = this.inventory.getTotalWeight();
    const maxWeight = this.inventory.maxWeight;
    const percentage = currentWeight / maxWeight * 100;
    const label = this.container.querySelector(".weight-label");
    const fill = this.container.querySelector(".weight-bar-fill");
    label.textContent = `Weight: ${currentWeight.toFixed(1)} / ${maxWeight} lbs`;
    fill.style.width = `${Math.min(percentage, 100)}%`;
    if (percentage >= 100) {
      fill.style.backgroundColor = "#e74c3c";
    } else if (percentage >= 80) {
      fill.style.backgroundColor = "#f39c12";
    } else if (percentage >= 60) {
      fill.style.backgroundColor = "#f1c40f";
    } else {
      fill.style.backgroundColor = "#2ecc71";
    }
  }
  /**
   * Refresh details panel
   */
  refreshDetails() {
    const empty = this.container.querySelector(".details-empty");
    const content = this.container.querySelector(".details-content");
    if (this.selectedSlot === null || this.inventory.slots[this.selectedSlot].isEmpty()) {
      empty.style.display = "block";
      content.style.display = "none";
      return;
    }
    empty.style.display = "none";
    content.style.display = "flex";
    const slot = this.inventory.slots[this.selectedSlot];
    const item = slot.item;
    const icon = content.querySelector(".details-icon");
    icon.textContent = this.getItemIcon(item);
    icon.style.borderColor = this.getRarityColor(item.rarity);
    const name = content.querySelector(".details-name");
    name.textContent = item.name;
    name.style.color = this.getRarityColor(item.rarity);
    const description = content.querySelector(".details-description");
    description.textContent = item.description;
    const durabilityDiv = content.querySelector(".details-durability");
    if (item.durability !== void 0) {
      const percentage = item.durability / item.maxDurability * 100;
      const bars = Math.round(percentage / 10);
      const filled = "‚ñà".repeat(bars);
      const empty2 = "‚ñë".repeat(10 - bars);
      durabilityDiv.style.display = "block";
      durabilityDiv.textContent = `Durability: ${filled}${empty2} ${item.durability}/${item.maxDurability}`;
    } else {
      durabilityDiv.style.display = "none";
    }
    const effectsDiv = content.querySelector(".details-effects");
    if (item.effects && Object.keys(item.effects).length > 0) {
      const effectText = Object.entries(item.effects).map(([key, value]) => {
        const prefix = value > 0 ? "+" : "";
        return `${prefix}${value} ${this.formatEffectName(key)}`;
      }).join(", ");
      effectsDiv.style.display = "block";
      effectsDiv.textContent = effectText;
    } else {
      effectsDiv.style.display = "none";
    }
    const buttons = content.querySelector(".details-buttons");
    const useBtn = buttons.children[0];
    const equipBtn = buttons.children[1];
    useBtn.style.display = item.consumable || item.usable ? "inline-block" : "none";
    equipBtn.style.display = item.equippable ? "inline-block" : "none";
  }
  /**
   * Select a slot
   */
  selectSlot(index) {
    this.selectedSlot = index;
    this.refresh();
  }
  /**
   * Drag and drop handlers
   */
  onDragStart(e, index) {
    this.draggedSlot = index;
    e.dataTransfer.effectAllowed = "move";
    e.target.classList.add("dragging");
  }
  onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }
  onDrop(e, targetIndex) {
    e.preventDefault();
    if (this.draggedSlot !== null && this.draggedSlot !== targetIndex) {
      this.inventory.swapSlots(this.draggedSlot, targetIndex);
      this.refresh();
    }
    const dragged = this.container.querySelector(".dragging");
    if (dragged) dragged.classList.remove("dragging");
    this.draggedSlot = null;
  }
  /**
   * Tooltip (simple for now, can be enhanced)
   */
  showTooltip(index) {
  }
  hideTooltip() {
  }
  /**
   * Action handlers
   */
  sortInventory() {
    this.inventory.sortInventory();
    this.refresh();
  }
  stackAll() {
    this.inventory.stackAll();
    this.refresh();
  }
  dropAll() {
    if (confirm("Drop all items? This cannot be undone!")) {
      this.inventory.slots.forEach((slot) => slot.clear());
      this.refresh();
    }
  }
  useSelectedItem() {
    if (this.selectedSlot !== null) {
      const result = this.inventory.useItem(this.selectedSlot);
      if (result) {
        console.log("Used item:", result);
      }
      this.refresh();
    }
  }
  equipSelectedItem() {
    if (this.selectedSlot !== null) {
      const slot = this.inventory.slots[this.selectedSlot];
      if (!slot.isEmpty() && slot.item.equippable) {
        const slotType = this.determineEquipmentSlot(slot.item);
        this.inventory.equip(slot.item, slotType);
        this.refresh();
      }
    }
  }
  dropSelectedItem() {
    if (this.selectedSlot !== null) {
      const slot = this.inventory.slots[this.selectedSlot];
      if (!slot.isEmpty()) {
        const item = slot.item;
        if (confirm(`Drop ${item.name}?`)) {
          this.inventory.removeItem(item.id, 1);
          this.refresh();
        }
      }
    }
  }
  /**
   * Determine which equipment slot an item goes in
   */
  determineEquipmentSlot(item) {
    if (item.type === "weapon") return "weapon";
    if (item.type === "tool") return "tool";
    if (item.type === "equipment") {
      if (item.category === "clothing") return "clothing";
      if (item.category === "backpack") return "backpack";
    }
    return null;
  }
  /**
   * Get emoji icon for item (placeholder until we have real icons)
   */
  getItemIcon(item) {
    const iconMap = {
      // Food
      coconut: "ü••",
      berries: "ü´ê",
      cooked_fish: "üçñ",
      raw_fish: "üêü",
      cooked_meat: "ü•©",
      // Water
      water_bottle: "üíß",
      dirty_water: "üí¶",
      // Medicine
      bandage: "ü©π",
      herbal_remedy: "üåø",
      // Materials
      wood: "ü™µ",
      stone: "ü™®",
      fiber: "üßµ",
      leather: "üü´",
      metal_scrap: "‚öôÔ∏è",
      // Tools
      stone_axe: "ü™ì",
      stone_pickaxe: "‚õèÔ∏è",
      knife: "üî™",
      fishing_rod: "üé£",
      // Weapons
      stone_spear: "üó°Ô∏è",
      wooden_club: "üèè",
      bow: "üèπ",
      // Equipment
      cloth_shirt: "üëï",
      leather_vest: "ü¶∫",
      leather_backpack: "üéí",
      waterskin: "ü´ô"
    };
    return iconMap[item.id] || "üì¶";
  }
  /**
   * Get color for rarity
   */
  getRarityColor(rarity) {
    const colors = {
      common: "#9e9e9e",
      uncommon: "#4caf50",
      rare: "#2196f3",
      epic: "#9c27b0",
      legendary: "#ff9800"
    };
    return colors[rarity] || colors.common;
  }
  /**
   * Format effect name for display
   */
  formatEffectName(effect) {
    const names = {
      hunger: "Hunger",
      thirst: "Thirst",
      health: "Health",
      energy: "Energy",
      damage: "Damage",
      defense: "Defense",
      woodcutting: "Woodcutting",
      mining: "Mining",
      crafting: "Crafting",
      fishing: "Fishing",
      range: "Range",
      capacity: "Capacity"
    };
    return names[effect] || effect;
  }
}
class GatheringUI {
  constructor() {
    this.container = null;
    this.isGathering = false;
    this.currentNode = null;
    this.gatheringProgress = 0;
    this.gatherStartTime = 0;
    this.animationFrame = null;
    this.createUI();
  }
  /**
   * Create UI elements
   */
  createUI() {
    this.container = document.createElement("div");
    this.container.className = "gathering-overlay";
    this.container.style.display = "none";
    const modal = document.createElement("div");
    modal.className = "gathering-modal";
    const info = document.createElement("div");
    info.className = "gathering-info";
    const icon = document.createElement("div");
    icon.className = "gathering-icon";
    info.appendChild(icon);
    const name = document.createElement("div");
    name.className = "gathering-name";
    info.appendChild(name);
    modal.appendChild(info);
    const progressContainer = document.createElement("div");
    progressContainer.className = "gathering-progress-container";
    const progressLabel = document.createElement("div");
    progressLabel.className = "gathering-progress-label";
    progressLabel.textContent = "Gathering...";
    progressContainer.appendChild(progressLabel);
    const progressBg = document.createElement("div");
    progressBg.className = "gathering-progress-bg";
    const progressFill = document.createElement("div");
    progressFill.className = "gathering-progress-fill";
    progressBg.appendChild(progressFill);
    progressContainer.appendChild(progressBg);
    modal.appendChild(progressContainer);
    const details = document.createElement("div");
    details.className = "gathering-details";
    modal.appendChild(details);
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "gathering-cancel";
    cancelBtn.textContent = "Cancel (ESC)";
    cancelBtn.onclick = () => this.cancel();
    modal.appendChild(cancelBtn);
    this.container.appendChild(modal);
    document.body.appendChild(this.container);
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isGathering) {
        this.cancel();
      }
    });
  }
  /**
   * Start gathering from a node
   */
  startGathering(node, player2, onComplete) {
    if (this.isGathering) return;
    this.isGathering = true;
    this.currentNode = node;
    this.gatheringProgress = 0;
    this.gatherStartTime = Date.now();
    this.onComplete = onComplete;
    const icon = this.container.querySelector(".gathering-icon");
    const name = this.container.querySelector(".gathering-name");
    const details = this.container.querySelector(".gathering-details");
    icon.textContent = node.getSprite();
    name.textContent = node.getName();
    const info = node.getInfo();
    details.innerHTML = `
      <div class="detail-row">
        <span class="detail-label">Tool Required:</span>
        <span class="detail-value">${info.requiredTool}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Energy Cost:</span>
        <span class="detail-value">${info.energyCost}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Time:</span>
        <span class="detail-value">${info.gatherTime}</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Uses Remaining:</span>
        <span class="detail-value">${info.usesRemaining}</span>
      </div>
    `;
    this.container.style.display = "flex";
    this.animate();
  }
  /**
   * Animate gathering progress
   */
  animate() {
    if (!this.isGathering) return;
    const elapsed = Date.now() - this.gatherStartTime;
    const duration = this.currentNode.gatherTime;
    this.gatheringProgress = Math.min(elapsed / duration * 100, 100);
    const fill = this.container.querySelector(".gathering-progress-fill");
    fill.style.width = `${this.gatheringProgress}%`;
    if (this.gatheringProgress >= 100) {
      this.complete();
      return;
    }
    this.animationFrame = requestAnimationFrame(() => this.animate());
  }
  /**
   * Complete gathering
   */
  complete() {
    this.isGathering = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    if (this.onComplete) {
      this.onComplete();
    }
    setTimeout(() => {
      this.container.style.display = "none";
    }, 500);
  }
  /**
   * Cancel gathering
   */
  cancel() {
    this.isGathering = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.container.style.display = "none";
  }
  /**
   * Show gathering result
   */
  showResult(result) {
    if (!result.success) {
      this.showNotification("Failed", result.reason, "error");
      return;
    }
    const itemNames = result.items.map((item) => item.name).join(", ");
    let message = `Gathered: ${itemNames}`;
    if (result.xpGained) {
      message += `
+${result.xpGained} XP`;
    }
    this.showNotification("Success!", message, "success");
  }
  /**
   * Show notification popup
   */
  showNotification(title, message, type = "info") {
    const notification = document.createElement("div");
    notification.className = `gathering-notification ${type}`;
    const titleEl = document.createElement("div");
    titleEl.className = "notification-title";
    titleEl.textContent = title;
    notification.appendChild(titleEl);
    const messageEl = document.createElement("div");
    messageEl.className = "notification-message";
    messageEl.textContent = message;
    notification.appendChild(messageEl);
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.classList.add("show");
    }, 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3e3);
  }
  /**
   * Cleanup
   */
  destroy() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }
}
class Recipe {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description || "";
    this.category = data.category;
    this.ingredients = data.ingredients || [];
    this.requiredTool = data.requiredTool || null;
    this.requiredSkill = data.requiredSkill || null;
    this.minimumSkillLevel = data.minimumSkillLevel || 0;
    this.requiredStation = data.requiredStation || null;
    this.output = data.output || [];
    this.craftTime = data.craftTime || 5e3;
    this.energyCost = data.energyCost || 10;
    this.difficulty = data.difficulty || "easy";
    this.unlocked = data.unlocked !== false;
    this.unlockConditions = data.unlockConditions || null;
    this.baseXP = data.baseXP || 10;
    this.qualityEnabled = data.qualityEnabled !== false;
    this.icon = data.icon || "recipes/default.png";
  }
  /**
   * Check if player can craft this recipe
   */
  canCraft(player2) {
    if (!this.unlocked) {
      return { success: false, reason: "Recipe not unlocked" };
    }
    if (this.unlockConditions) {
      if (this.unlockConditions.skill) {
        const skillLevel = player2.getEffectiveSkill(this.unlockConditions.skill);
        if (skillLevel < this.unlockConditions.level) {
          return {
            success: false,
            reason: `Requires ${this.unlockConditions.skill} level ${this.unlockConditions.level}`
          };
        }
      }
    }
    if (player2.stats.energy < this.energyCost) {
      return { success: false, reason: "Not enough energy" };
    }
    if (this.requiredSkill && this.minimumSkillLevel > 0) {
      const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
      if (skillLevel < this.minimumSkillLevel) {
        return {
          success: false,
          reason: `Requires ${this.requiredSkill} level ${this.minimumSkillLevel}`
        };
      }
    }
    for (const ingredient of this.ingredients) {
      const count = player2.inventory.getItemCount(ingredient.itemId);
      if (count < ingredient.quantity) {
        return {
          success: false,
          reason: `Need ${ingredient.quantity}x ${ingredient.itemId} (have ${count})`
        };
      }
    }
    if (this.requiredTool) {
      const hasTool = this.checkPlayerHasTool(player2, this.requiredTool);
      if (!hasTool) {
        return { success: false, reason: `Requires ${this.requiredTool}` };
      }
    }
    if (this.requiredStation) ;
    return { success: true };
  }
  /**
   * Check if player has required tool equipped
   */
  checkPlayerHasTool(player2, toolType) {
    const equipped = player2.inventory.equipment;
    const weapon = equipped.weapon;
    const tool = equipped.tool;
    if (toolType === "axe") {
      return weapon?.category === "axe" || tool?.category === "axe";
    }
    if (toolType === "pickaxe") {
      return weapon?.category === "pickaxe" || tool?.category === "pickaxe";
    }
    if (toolType === "knife") {
      return weapon?.category === "knife" || tool?.category === "knife";
    }
    if (toolType === "hammer") {
      return weapon?.category === "hammer" || tool?.category === "hammer";
    }
    return false;
  }
  /**
   * Get the equipped tool being used
   */
  getEquippedTool(player2) {
    const equipped = player2.inventory.equipment;
    if (this.requiredTool === "axe") {
      return equipped.weapon?.category === "axe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "pickaxe") {
      return equipped.weapon?.category === "pickaxe" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "knife") {
      return equipped.weapon?.category === "knife" ? equipped.weapon : equipped.tool;
    }
    if (this.requiredTool === "hammer") {
      return equipped.weapon?.category === "hammer" ? equipped.weapon : equipped.tool;
    }
    return null;
  }
  /**
   * Craft the item
   */
  craft(player2) {
    const canCraft = this.canCraft(player2);
    if (!canCraft.success) {
      return {
        success: false,
        reason: canCraft.reason
      };
    }
    for (const ingredient of this.ingredients) {
      player2.inventory.removeItem(ingredient.itemId, ingredient.quantity);
    }
    player2.stats.energy -= this.energyCost;
    if (this.requiredTool) {
      const tool = this.getEquippedTool(player2);
      if (tool && tool.durability !== null) {
        tool.damage(2);
        if (tool.durability <= 0) {
          console.log(`${tool.name} broke while crafting!`);
        }
      }
    }
    const quality = this.qualityEnabled ? this.calculateQuality(player2) : "normal";
    const createdItems = [];
    for (const output of this.output) {
      const item = window.itemDB.get(output.itemId);
      if (item) {
        if (quality === "excellent") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 1.5);
          if (item.effects) {
            Object.keys(item.effects).forEach((key) => {
              item.effects[key] = Math.floor(item.effects[key] * 1.2);
            });
          }
        } else if (quality === "good") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 1.25);
          if (item.effects) {
            Object.keys(item.effects).forEach((key) => {
              item.effects[key] = Math.floor(item.effects[key] * 1.1);
            });
          }
        } else if (quality === "poor") {
          if (item.durability) item.maxDurability = Math.floor(item.maxDurability * 0.75);
        }
        if (item.durability !== null) {
          item.durability = item.maxDurability;
        }
        const added = player2.inventory.addItem(item, output.quantity);
        if (added) {
          createdItems.push({ item, quantity: output.quantity, quality });
        }
      }
    }
    if (this.requiredSkill) {
      const xpBonus = quality === "excellent" ? 1.5 : quality === "good" ? 1.2 : 1;
      const xpGained = Math.floor(this.baseXP * xpBonus);
      player2.gainSkillXP(this.requiredSkill, xpGained);
    }
    return {
      success: true,
      items: createdItems,
      quality,
      xpGained: this.requiredSkill ? this.baseXP : 0
    };
  }
  /**
   * Calculate crafting quality based on skill
   */
  calculateQuality(player2) {
    if (!this.requiredSkill) return "normal";
    const skillLevel = player2.getEffectiveSkill(this.requiredSkill);
    const roll = Math.random() * 100;
    const excellentThreshold = Math.max(0, skillLevel - 50);
    const goodThreshold = Math.max(0, skillLevel - 20);
    const poorThreshold = Math.max(0, 100 - skillLevel);
    if (roll < excellentThreshold) return "excellent";
    if (roll < goodThreshold) return "good";
    if (roll > 100 - poorThreshold && skillLevel < 30) return "poor";
    return "normal";
  }
  /**
   * Get difficulty color
   */
  getDifficultyColor() {
    const colors = {
      easy: "#4ade80",
      medium: "#fbbf24",
      hard: "#f97316",
      expert: "#dc2626"
    };
    return colors[this.difficulty] || colors.easy;
  }
  /**
   * Serialize for saving
   */
  toJSON() {
    return {
      id: this.id,
      unlocked: this.unlocked
    };
  }
}
class RecipeDatabase {
  constructor() {
    this.recipes = /* @__PURE__ */ new Map();
    this.loadRecipes();
  }
  /**
   * Load all recipe definitions
   */
  loadRecipes() {
    const recipeDefinitions = this.getRecipeDefinitions();
    recipeDefinitions.forEach((def) => {
      this.recipes.set(def.id, new Recipe(def));
    });
    console.log(`üìã Loaded ${this.recipes.size} recipes`);
  }
  /**
   * Get recipe by ID
   */
  get(recipeId) {
    return this.recipes.get(recipeId) || null;
  }
  /**
   * Get all recipes
   */
  getAll() {
    return Array.from(this.recipes.values());
  }
  /**
   * Get recipes by category
   */
  getByCategory(category) {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.category === category);
  }
  /**
   * Get craftable recipes (player can make)
   */
  getCraftable(player2) {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.canCraft(player2).success);
  }
  /**
   * Get unlocked recipes
   */
  getUnlocked() {
    return Array.from(this.recipes.values()).filter((recipe) => recipe.unlocked);
  }
  /**
   * Recipe definitions
   */
  getRecipeDefinitions() {
    return [
      // ===== BASIC TOOLS =====
      {
        id: "stone_axe",
        name: "Stone Axe",
        description: "A crude but effective axe for chopping wood.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "stone", quantity: 2 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_axe", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 8e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "stone_pickaxe",
        name: "Stone Pickaxe",
        description: "Break rocks and mine stone.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "stone", quantity: 3 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_pickaxe", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 8e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "crude_knife",
        name: "Crude Knife",
        description: "A sharp knife for cutting and crafting.",
        category: "tools",
        ingredients: [
          { itemId: "stone", quantity: 2 },
          { itemId: "wood", quantity: 1 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [{ itemId: "knife", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12
      },
      {
        id: "fishing_rod",
        name: "Fishing Rod",
        description: "Catch fish more easily.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "fiber", quantity: 5 }
        ],
        output: [{ itemId: "fishing_rod", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 6e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 18
      },
      // ===== WEAPONS =====
      {
        id: "stone_spear",
        name: "Stone Spear",
        description: "A sharp spear for hunting and combat.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "stone", quantity: 1 },
          { itemId: "fiber", quantity: 2 }
        ],
        output: [{ itemId: "stone_spear", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 7e3,
        energyCost: 10,
        difficulty: "easy",
        baseXP: 15
      },
      {
        id: "wooden_club",
        name: "Wooden Club",
        description: "A heavy club for bashing.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 4 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [{ itemId: "wooden_club", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12
      },
      {
        id: "bow",
        name: "Hunting Bow",
        description: "A ranged weapon for hunting.",
        category: "weapons",
        ingredients: [
          { itemId: "wood", quantity: 3 },
          { itemId: "fiber", quantity: 8 }
        ],
        output: [{ itemId: "bow", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 15,
        craftTime: 12e3,
        energyCost: 15,
        difficulty: "medium",
        baseXP: 25
      },
      // ===== CONSUMABLES =====
      {
        id: "cook_fish",
        name: "Cook Fish",
        description: "Cook raw fish over a fire.",
        category: "consumables",
        ingredients: [
          { itemId: "raw_fish", quantity: 1 },
          { itemId: "wood", quantity: 1 }
        ],
        output: [{ itemId: "cooked_fish", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 3e3,
        energyCost: 3,
        difficulty: "easy",
        baseXP: 5,
        qualityEnabled: false
      },
      {
        id: "cook_meat",
        name: "Cook Meat",
        description: "Cook raw meat over a fire.",
        category: "consumables",
        ingredients: [
          { itemId: "raw_meat", quantity: 1 },
          { itemId: "wood", quantity: 1 }
        ],
        output: [{ itemId: "cooked_meat", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 4e3,
        energyCost: 3,
        difficulty: "easy",
        baseXP: 6,
        qualityEnabled: false
      },
      {
        id: "herbal_remedy",
        name: "Herbal Remedy",
        description: "Craft medicine from island plants.",
        category: "consumables",
        ingredients: [
          { itemId: "fiber", quantity: 5 },
          { itemId: "berries", quantity: 3 }
        ],
        output: [{ itemId: "herbal_remedy", quantity: 1 }],
        requiredSkill: "survival",
        minimumSkillLevel: 10,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "medium",
        baseXP: 20
      },
      {
        id: "bandage",
        name: "Bandage",
        description: "Create bandages from cloth.",
        category: "consumables",
        ingredients: [
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "bandage", quantity: 2 }],
        requiredSkill: "survival",
        minimumSkillLevel: 0,
        craftTime: 2e3,
        energyCost: 2,
        difficulty: "easy",
        baseXP: 3,
        qualityEnabled: false
      },
      // ===== MATERIALS =====
      {
        id: "rope",
        name: "Rope",
        description: "Twist plant fibers into rope.",
        category: "materials",
        ingredients: [
          { itemId: "fiber", quantity: 10 }
        ],
        output: [{ itemId: "rope", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 0,
        craftTime: 5e3,
        energyCost: 5,
        difficulty: "easy",
        baseXP: 8,
        qualityEnabled: false
      },
      {
        id: "cloth",
        name: "Cloth",
        description: "Weave plant fibers into cloth.",
        category: "materials",
        ingredients: [
          { itemId: "fiber", quantity: 15 }
        ],
        output: [{ itemId: "cloth", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 12,
        qualityEnabled: false
      },
      // ===== EQUIPMENT =====
      {
        id: "cloth_shirt",
        name: "Cloth Shirt",
        description: "Basic clothing for protection.",
        category: "equipment",
        ingredients: [
          { itemId: "cloth", quantity: 2 },
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "cloth_shirt", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 1e4,
        energyCost: 10,
        difficulty: "medium",
        baseXP: 18
      },
      {
        id: "leather_vest",
        name: "Leather Vest",
        description: "Sturdy leather protection.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 3 },
          { itemId: "fiber", quantity: 5 }
        ],
        output: [{ itemId: "leather_vest", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 15,
        craftTime: 15e3,
        energyCost: 15,
        difficulty: "medium",
        baseXP: 30
      },
      {
        id: "leather_backpack",
        name: "Leather Backpack",
        description: "Increases carrying capacity.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 4 },
          { itemId: "fiber", quantity: 8 },
          { itemId: "rope", quantity: 2 }
        ],
        output: [{ itemId: "leather_backpack", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 20,
        craftTime: 2e4,
        energyCost: 20,
        difficulty: "hard",
        baseXP: 50
      },
      {
        id: "waterskin",
        name: "Waterskin",
        description: "Carry water with you.",
        category: "equipment",
        ingredients: [
          { itemId: "leather", quantity: 2 },
          { itemId: "fiber", quantity: 3 }
        ],
        output: [{ itemId: "waterskin", quantity: 1 }],
        requiredSkill: "crafting",
        minimumSkillLevel: 10,
        craftTime: 8e3,
        energyCost: 8,
        difficulty: "medium",
        baseXP: 20
      },
      // ===== TOOL REPAIR =====
      {
        id: "repair_tool",
        name: "Repair Tool",
        description: "Restore durability to damaged tools.",
        category: "tools",
        ingredients: [
          { itemId: "wood", quantity: 2 },
          { itemId: "stone", quantity: 1 },
          { itemId: "fiber", quantity: 1 }
        ],
        output: [],
        // Special: repairs equipped tool instead
        requiredSkill: "crafting",
        minimumSkillLevel: 5,
        craftTime: 5e3,
        energyCost: 8,
        difficulty: "easy",
        baseXP: 10,
        qualityEnabled: false
      }
    ];
  }
}
const recipeDB = new RecipeDatabase();
class CraftingUI {
  constructor(player2) {
    this.player = player2;
    this.isVisible = false;
    this.selectedRecipe = null;
    this.currentCategory = "all";
    this.craftingQueue = [];
    this.isCrafting = false;
    this.container = null;
    this.init();
  }
  /**
   * Initialize the UI
   */
  init() {
    this.container = document.createElement("div");
    this.container.id = "crafting-ui";
    this.container.className = "crafting-modal hidden";
    document.body.appendChild(this.container);
    document.addEventListener("keydown", (e) => {
      if (e.key === "c" || e.key === "C") {
        if (!this.isVisible) this.show();
        else this.hide();
      }
      if (e.key === "Escape" && this.isVisible) {
        this.hide();
      }
    });
  }
  /**
   * Show the crafting UI
   */
  show() {
    this.isVisible = true;
    this.render();
    this.container.classList.remove("hidden");
    console.log("üìã Crafting menu opened");
  }
  /**
   * Hide the crafting UI
   */
  hide() {
    this.isVisible = false;
    this.container.classList.add("hidden");
  }
  /**
   * Toggle visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Render the complete UI
   */
  render() {
    const recipes = this.currentCategory === "all" ? recipeDB.getAll() : recipeDB.getByCategory(this.currentCategory);
    this.container.innerHTML = `
      <div class="crafting-overlay"></div>
      <div class="crafting-window">
        \x3C!-- Header -->
        <div class="crafting-header">
          <h2>üî® Crafting</h2>
          <button class="close-btn" onclick="window.craftingUI?.hide()">‚úï</button>
        </div>

        \x3C!-- Main Content -->
        <div class="crafting-content">
          \x3C!-- Left: Categories -->
          <div class="crafting-categories">
            <h3>Categories</h3>
            <div class="category-list">
              ${this.renderCategories()}
            </div>
            <div class="crafting-stats">
              <div class="stat-item">
                <span class="stat-label">‚ö° Energy</span>
                <span class="stat-value">${Math.floor(this.player.stats.energy)}</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">üî® Crafting</span>
                <span class="stat-value">${Math.floor(this.player.skills.crafting)}</span>
              </div>
            </div>
          </div>

          \x3C!-- Center: Recipe List -->
          <div class="crafting-recipes">
            <div class="recipes-header">
              <h3>${this.getCategoryName(this.currentCategory)}</h3>
              <span class="recipe-count">${recipes.length} recipes</span>
            </div>
            <div class="recipe-list">
              ${this.renderRecipeList(recipes)}
            </div>
          </div>

          \x3C!-- Right: Recipe Details -->
          <div class="crafting-details">
            ${this.selectedRecipe ? this.renderRecipeDetails(this.selectedRecipe) : this.renderEmptyDetails()}
          </div>
        </div>

        \x3C!-- Footer: Crafting Queue -->
        ${this.craftingQueue.length > 0 ? this.renderCraftingQueue() : ""}
      </div>
    `;
    this.attachEventListeners();
  }
  /**
   * Render category buttons
   */
  renderCategories() {
    const categories = [
      { id: "all", name: "All", icon: "üìã" },
      { id: "tools", name: "Tools", icon: "üîß" },
      { id: "weapons", name: "Weapons", icon: "‚öîÔ∏è" },
      { id: "equipment", name: "Equipment", icon: "üéΩ" },
      { id: "consumables", name: "Consumables", icon: "üçñ" },
      { id: "materials", name: "Materials", icon: "üì¶" }
    ];
    return categories.map((cat) => `
      <button 
        class="category-btn ${this.currentCategory === cat.id ? "active" : ""}"
        data-category="${cat.id}"
      >
        <span class="category-icon">${cat.icon}</span>
        <span class="category-name">${cat.name}</span>
      </button>
    `).join("");
  }
  /**
   * Get category display name
   */
  getCategoryName(categoryId) {
    const names = {
      all: "All Recipes",
      tools: "Tools",
      weapons: "Weapons",
      equipment: "Equipment",
      consumables: "Consumables",
      materials: "Materials"
    };
    return names[categoryId] || "Recipes";
  }
  /**
   * Render recipe list
   */
  renderRecipeList(recipes) {
    if (recipes.length === 0) {
      return '<div class="no-recipes">No recipes in this category</div>';
    }
    return recipes.map((recipe) => {
      const canCraft = recipe.canCraft(this.player);
      const isSelected = this.selectedRecipe?.id === recipe.id;
      return `
        <div 
          class="recipe-item ${isSelected ? "selected" : ""} ${!canCraft.success ? "disabled" : ""}"
          data-recipe-id="${recipe.id}"
        >
          <div class="recipe-icon">${this.getRecipeIcon(recipe)}</div>
          <div class="recipe-info">
            <div class="recipe-name">${recipe.name}</div>
            <div class="recipe-difficulty" style="color: ${recipe.getDifficultyColor()}">
              ${recipe.difficulty.toUpperCase()}
            </div>
          </div>
          <div class="recipe-status">
            ${canCraft.success ? '<span class="status-can-craft">‚úì</span>' : '<span class="status-cannot-craft" title="' + canCraft.reason + '">‚úï</span>'}
          </div>
        </div>
      `;
    }).join("");
  }
  /**
   * Get recipe icon
   */
  getRecipeIcon(recipe) {
    const icons = {
      tools: "üîß",
      weapons: "‚öîÔ∏è",
      equipment: "üéΩ",
      consumables: "üçñ",
      materials: "üì¶"
    };
    return icons[recipe.category] || "üìã";
  }
  /**
   * Render recipe details panel
   */
  renderRecipeDetails(recipe) {
    const canCraft = recipe.canCraft(this.player);
    return `
      <div class="details-header">
        <h3>${recipe.name}</h3>
        <div class="difficulty-badge" style="background: ${recipe.getDifficultyColor()}">
          ${recipe.difficulty}
        </div>
      </div>

      <div class="details-description">
        ${recipe.description}
      </div>

      <div class="details-section">
        <h4>Requirements</h4>
        <div class="requirements-list">
          ${recipe.energyCost > 0 ? `
            <div class="requirement">
              <span class="req-icon">‚ö°</span>
              <span class="req-label">Energy:</span>
              <span class="req-value ${this.player.stats.energy >= recipe.energyCost ? "available" : "unavailable"}">
                ${recipe.energyCost}
              </span>
            </div>
          ` : ""}
          
          ${recipe.requiredSkill ? `
            <div class="requirement">
              <span class="req-icon">üî®</span>
              <span class="req-label">${recipe.requiredSkill}:</span>
              <span class="req-value ${this.player.getEffectiveSkill(recipe.requiredSkill) >= recipe.minimumSkillLevel ? "available" : "unavailable"}">
                ${recipe.minimumSkillLevel} (${Math.floor(this.player.getEffectiveSkill(recipe.requiredSkill))})
              </span>
            </div>
          ` : ""}

          ${recipe.requiredTool ? `
            <div class="requirement">
              <span class="req-icon">üõ†Ô∏è</span>
              <span class="req-label">Tool:</span>
              <span class="req-value ${recipe.checkPlayerHasTool(this.player, recipe.requiredTool) ? "available" : "unavailable"}">
                ${recipe.requiredTool}
              </span>
            </div>
          ` : ""}
        </div>
      </div>

      <div class="details-section">
        <h4>Ingredients</h4>
        <div class="ingredients-list">
          ${recipe.ingredients.map((ing) => {
      const item = itemDB.get(ing.itemId);
      const hasCount = this.player.inventory.getItemCount(ing.itemId);
      const hasEnough = hasCount >= ing.quantity;
      return `
              <div class="ingredient ${hasEnough ? "available" : "unavailable"}">
                <span class="ingredient-name">${item?.name || ing.itemId}</span>
                <span class="ingredient-count">
                  ${hasCount}/${ing.quantity}
                </span>
              </div>
            `;
    }).join("")}
        </div>
      </div>

      <div class="details-section">
        <h4>Output</h4>
        <div class="output-list">
          ${recipe.output.map((out) => {
      const item = itemDB.get(out.itemId);
      return `
              <div class="output-item">
                <span class="output-name">${item?.name || out.itemId}</span>
                <span class="output-quantity">√ó${out.quantity}</span>
              </div>
            `;
    }).join("")}
        </div>
      </div>

      <div class="details-footer">
        <div class="craft-time">
          ‚è±Ô∏è ${(recipe.craftTime / 1e3).toFixed(1)}s
        </div>
        <div class="craft-xp">
          ‚≠ê +${recipe.baseXP} XP
        </div>
      </div>

      <div class="details-actions">
        <button 
          class="craft-btn ${canCraft.success ? "" : "disabled"}"
          data-recipe-id="${recipe.id}"
          ${!canCraft.success ? "disabled" : ""}
        >
          ${canCraft.success ? "üî® Craft" : `‚úï ${canCraft.reason}`}
        </button>
      </div>
    `;
  }
  /**
   * Render empty details panel
   */
  renderEmptyDetails() {
    return `
      <div class="details-empty">
        <div class="empty-icon">üî®</div>
        <div class="empty-text">Select a recipe to view details</div>
      </div>
    `;
  }
  /**
   * Render crafting queue
   */
  renderCraftingQueue() {
    return `
      <div class="crafting-queue">
        <div class="queue-header">
          <h4>Crafting Queue</h4>
          <span class="queue-count">${this.craftingQueue.length} items</span>
        </div>
        <div class="queue-items">
          ${this.craftingQueue.map((item, index) => `
            <div class="queue-item">
              <span class="queue-recipe">${item.recipe.name}</span>
              <div class="queue-progress">
                <div class="queue-progress-bar" style="width: ${item.progress}%"></div>
              </div>
              <button class="queue-cancel" data-index="${index}">‚úï</button>
            </div>
          `).join("")}
        </div>
      </div>
    `;
  }
  /**
   * Attach event listeners
   */
  attachEventListeners() {
    this.container.querySelectorAll(".category-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        this.currentCategory = btn.dataset.category;
        this.render();
      });
    });
    this.container.querySelectorAll(".recipe-item").forEach((item) => {
      item.addEventListener("click", () => {
        const recipeId = item.dataset.recipeId;
        this.selectRecipe(recipeId);
      });
    });
    const craftBtn = this.container.querySelector(".craft-btn");
    if (craftBtn) {
      craftBtn.addEventListener("click", () => {
        const recipeId = craftBtn.dataset.recipeId;
        this.startCrafting(recipeId);
      });
    }
    this.container.querySelectorAll(".queue-cancel").forEach((btn) => {
      btn.addEventListener("click", () => {
        const index = parseInt(btn.dataset.index);
        this.cancelCrafting(index);
      });
    });
    const overlay = this.container.querySelector(".crafting-overlay");
    if (overlay) {
      overlay.addEventListener("click", () => this.hide());
    }
  }
  /**
   * Select a recipe
   */
  selectRecipe(recipeId) {
    this.selectedRecipe = recipeDB.get(recipeId);
    this.render();
  }
  /**
   * Start crafting an item
   */
  startCrafting(recipeId) {
    const recipe = recipeDB.get(recipeId);
    if (!recipe) return;
    const canCraft = recipe.canCraft(this.player);
    if (!canCraft.success) {
      this.showNotification(canCraft.reason, "error");
      return;
    }
    const queueItem = {
      recipe,
      progress: 0,
      startTime: Date.now()
    };
    this.craftingQueue.push(queueItem);
    if (!this.isCrafting) {
      this.processCraftingQueue();
    }
    this.render();
    this.showNotification(`Crafting ${recipe.name}...`, "info");
  }
  /**
   * Process crafting queue
   */
  async processCraftingQueue() {
    if (this.craftingQueue.length === 0) {
      this.isCrafting = false;
      return;
    }
    this.isCrafting = true;
    const current = this.craftingQueue[0];
    const recipe = current.recipe;
    const startTime = Date.now();
    const updateInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      current.progress = Math.min(100, elapsed / recipe.craftTime * 100);
      if (this.isVisible) {
        this.render();
      }
    }, 100);
    await new Promise((resolve) => setTimeout(resolve, recipe.craftTime));
    clearInterval(updateInterval);
    const result = recipe.craft(this.player);
    if (result.success) {
      const itemNames = result.items.map((i) => i.item.name).join(", ");
      const qualityText = result.quality !== "normal" ? ` (${result.quality})` : "";
      this.showNotification(`‚úì Crafted ${itemNames}${qualityText}`, "success");
      if (result.xpGained > 0) {
        this.showNotification(`+${result.xpGained} ${recipe.requiredSkill} XP`, "info");
      }
    } else {
      this.showNotification(`‚úï Crafting failed: ${result.reason}`, "error");
    }
    this.craftingQueue.shift();
    if (this.craftingQueue.length > 0) {
      this.processCraftingQueue();
    } else {
      this.isCrafting = false;
      this.render();
    }
  }
  /**
   * Cancel crafting
   */
  cancelCrafting(index) {
    if (index === 0 && this.isCrafting) {
      this.showNotification("Cannot cancel item currently being crafted", "warning");
      return;
    }
    const item = this.craftingQueue[index];
    this.craftingQueue.splice(index, 1);
    this.showNotification(`Cancelled crafting ${item.recipe.name}`, "info");
    this.render();
  }
  /**
   * Show notification
   */
  showNotification(message, type = "info") {
    const notification = document.createElement("div");
    notification.className = `crafting-notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.classList.add("show");
    }, 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), 300);
    }, 3e3);
  }
  /**
   * Update (called by game loop)
   */
  update() {
    if (this.isVisible && this.isCrafting) {
      this.render();
    }
  }
}
class MapTravelUI {
  constructor(mapEngine2, travelSystem2, territoryManager2) {
    this.mapEngine = mapEngine2;
    this.travelSystem = travelSystem2;
    this.territoryManager = territoryManager2;
    this.hoveredHex = null;
    this.selectedHex = null;
    this.initialized = false;
    this.territoryLayer = null;
    this.fogLayer = null;
    this.markerLayer = null;
  }
  /**
   * Initialize layers and event listeners (call after canvas exists)
   */
  initialize() {
    if (this.initialized) return;
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.warn("Canvas not found, deferring MapTravelUI initialization");
      return;
    }
    this.createLayers();
    this.setupEventListeners();
    this.initialized = true;
    console.log("‚úÖ MapTravelUI initialized");
  }
  /**
   * Get pixel coordinates for a hex (uses renderer)
   */
  hexToPixel(q, r) {
    const renderer = window.game.gameView?.renderer;
    if (!renderer || !renderer.hexGrid) {
      return { x: 0, y: 0 };
    }
    return renderer.hexGrid.axialToPixel(q, r);
  }
  /**
   * Get hex size
   */
  getHexSize() {
    const renderer = window.game.gameView?.renderer;
    return renderer?.hexGrid?.hexSize || 40;
  }
  /**
   * Get renderer for transformations
   */
  getRenderer() {
    return window.game.gameView?.renderer;
  }
  /**
   * Create canvas layers for territories and fog
   */
  createLayers() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.error("Canvas not found for creating layers");
      return;
    }
    this.territoryLayer = document.createElement("canvas");
    this.territoryLayer.width = canvas.width;
    this.territoryLayer.height = canvas.height;
    this.territoryLayer.style.position = "absolute";
    this.territoryLayer.style.top = "0";
    this.territoryLayer.style.left = "0";
    this.territoryLayer.style.pointerEvents = "none";
    this.territoryLayer.style.mixBlendMode = "multiply";
    canvas.parentElement.appendChild(this.territoryLayer);
    this.fogLayer = document.createElement("canvas");
    this.fogLayer.width = canvas.width;
    this.fogLayer.height = canvas.height;
    this.fogLayer.style.position = "absolute";
    this.fogLayer.style.top = "0";
    this.fogLayer.style.left = "0";
    this.fogLayer.style.pointerEvents = "none";
    canvas.parentElement.appendChild(this.fogLayer);
    this.markerLayer = document.createElement("canvas");
    this.markerLayer.width = canvas.width;
    this.markerLayer.height = canvas.height;
    this.markerLayer.style.position = "absolute";
    this.markerLayer.style.top = "0";
    this.markerLayer.style.left = "0";
    this.markerLayer.style.pointerEvents = "none";
    canvas.parentElement.appendChild(this.markerLayer);
  }
  /**
   * Setup event listeners for hex interaction
   */
  setupEventListeners() {
    const canvas = document.getElementById("game-canvas");
    if (!canvas) {
      console.error("Canvas not found for event listeners");
      return;
    }
    canvas.addEventListener("mousemove", (e) => {
      const renderer = window.game.gameView?.renderer;
      if (!renderer) return;
      const hex = renderer.screenToHex(e.clientX, e.clientY);
      this.onHexHover(hex);
    });
    canvas.addEventListener("click", (e) => {
      const renderer = window.game.gameView?.renderer;
      if (!renderer) return;
      const hex = renderer.screenToHex(e.clientX, e.clientY);
      this.onHexClick(hex);
    });
    canvas.addEventListener("mouseleave", () => {
      this.onHexHover(null);
    });
  }
  /**
   * Handle hex hover
   */
  onHexHover(hex) {
    if (!hex) {
      this.hoveredHex = null;
      this.hideTooltip();
      return;
    }
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (!territory || !territory.visibleFromFog) {
      this.hoveredHex = null;
      this.hideTooltip();
      return;
    }
    this.hoveredHex = hex;
    this.showTooltip(hex, territory);
    this.render();
  }
  /**
   * Handle hex click
   */
  onHexClick(hex) {
    if (!hex) return;
    const territory = this.territoryManager.getTerritory(hex.q, hex.r);
    if (!territory || !territory.visibleFromFog) return;
    const result = this.travelSystem.startTravel(hex.q, hex.r);
    if (result.success) {
      this.selectedHex = hex;
      this.showTravelNotification(result);
    } else {
      this.showErrorNotification(result.reason);
    }
    this.render();
  }
  /**
   * Show tooltip for hex
   */
  showTooltip(hex, territory) {
    let tooltip = document.getElementById("hex-tooltip");
    if (!tooltip) {
      tooltip = document.createElement("div");
      tooltip.id = "hex-tooltip";
      tooltip.className = "hex-tooltip";
      document.body.appendChild(tooltip);
    }
    let content = `<div class="tooltip-title">${this.getTerrainName(territory.terrain)}</div>`;
    if (territory.owner) {
      const factionName = this.getFactionName(territory.owner);
      content += `<div class="tooltip-faction" style="color: ${territory.getFactionColor()}">
        ${factionName} Territory (${territory.controlStrength}%)
      </div>`;
    } else {
      content += `<div class="tooltip-faction">Unclaimed</div>`;
    }
    const travelInfo = this.travelSystem.getTravelInfo(hex.q, hex.r);
    if (travelInfo) {
      if (travelInfo.canTravel) {
        content += `<div class="tooltip-travel">
          ‚ö° ${travelInfo.energyCost} energy
          ‚è±Ô∏è ${(travelInfo.travelTime / 1e3).toFixed(1)}s
        </div>`;
      } else {
        content += `<div class="tooltip-error">${travelInfo.reason}</div>`;
      }
    }
    if (territory.discovered) {
      if (territory.hasResourceNode) {
        content += `<div class="tooltip-feature">üå≥ Resources Available</div>`;
      }
      if (territory.hasNPC) {
        content += `<div class="tooltip-feature">üë§ NPC Present</div>`;
      }
      if (territory.hasEvent) {
        content += `<div class="tooltip-feature">‚ùó Event Available</div>`;
      }
    }
    tooltip.innerHTML = content;
    const canvas = document.getElementById("game-canvas");
    const pixel = this.hexToPixel(hex.q, hex.r);
    const renderer = window.game.gameView?.renderer;
    if (canvas && renderer) {
      const screenX = pixel.x * renderer.scale + renderer.offsetX;
      const screenY = pixel.y * renderer.scale + renderer.offsetY;
      tooltip.style.left = `${screenX + canvas.offsetLeft + 40}px`;
      tooltip.style.top = `${screenY + canvas.offsetTop - 20}px`;
    }
    tooltip.style.display = "block";
  }
  /**
   * Hide tooltip
   */
  hideTooltip() {
    const tooltip = document.getElementById("hex-tooltip");
    if (tooltip) {
      tooltip.style.display = "none";
    }
  }
  /**
   * Render all layers
   */
  render() {
    if (!this.initialized) {
      this.initialize();
      if (!this.initialized) return;
    }
    this.renderTerritories();
    this.renderFogOfWar();
    this.renderMarkers();
    this.renderHoverHighlight();
  }
  /**
   * Render faction territories
   */
  renderTerritories() {
    if (!this.territoryLayer) return;
    const ctx = this.territoryLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.territoryLayer.width, this.territoryLayer.height);
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      if (!territory.owner || !territory.visibleFromFog) return;
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      ctx.save();
      ctx.translate(pixel.x, pixel.y);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i - Math.PI / 6;
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      const color = territory.getFactionColor();
      const alpha = territory.controlStrength / 100 * 0.4;
      ctx.fillStyle = this.hexToRGBA(color, alpha);
      ctx.fill();
      if (territory.controlStrength > 60) {
        ctx.strokeStyle = this.hexToRGBA(color, 0.8);
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    });
    ctx.restore();
  }
  /**
   * Render fog of war
   */
  renderFogOfWar() {
    if (!this.fogLayer) return;
    const ctx = this.fogLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.fogLayer.width, this.fogLayer.height);
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      ctx.save();
      ctx.translate(pixel.x, pixel.y);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i - Math.PI / 6;
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      if (!territory.discovered) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
        ctx.fill();
      } else if (territory.discovered && !territory.visited) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fill();
      }
      ctx.restore();
    });
    ctx.restore();
  }
  /**
   * Render markers for resources, NPCs, events
   */
  renderMarkers() {
    if (!this.markerLayer) return;
    const ctx = this.markerLayer.getContext("2d");
    const renderer = this.getRenderer();
    if (!renderer) return;
    ctx.clearRect(0, 0, this.markerLayer.width, this.markerLayer.height);
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    this.territoryManager.territories.forEach((territory) => {
      if (!territory.visited) return;
      const pixel = this.hexToPixel(territory.position.q, territory.position.r);
      const size = this.getHexSize();
      if (territory.hasResourceNode) {
        this.drawMarker(ctx, pixel.x - size * 0.3, pixel.y - size * 0.3, "üå≥", 16);
      }
      if (territory.hasNPC) {
        this.drawMarker(ctx, pixel.x + size * 0.3, pixel.y - size * 0.3, "üë§", 16);
      }
      if (territory.hasEvent) {
        this.drawMarker(ctx, pixel.x, pixel.y + size * 0.4, "‚ùó", 16);
      }
      const currentPos = this.travelSystem.currentPosition;
      if (territory.position.q === currentPos.q && territory.position.r === currentPos.r) {
        this.drawMarker(ctx, pixel.x, pixel.y, "üìç", 24);
      }
    });
    ctx.restore();
  }
  /**
   * Draw a marker (emoji/icon)
   */
  drawMarker(ctx, x, y, icon, size) {
    ctx.save();
    ctx.font = `${size}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
    ctx.shadowBlur = 4;
    ctx.fillText(icon, x, y);
    ctx.restore();
  }
  /**
   * Render hover highlight
   */
  renderHoverHighlight() {
    if (!this.hoveredHex) return;
    const territory = this.territoryManager.getTerritory(this.hoveredHex.q, this.hoveredHex.r);
    if (!territory || !territory.visibleFromFog) return;
    const renderer = this.getRenderer();
    if (!renderer) return;
    const ctx = renderer.ctx;
    const pixel = this.hexToPixel(this.hoveredHex.q, this.hoveredHex.r);
    const size = this.getHexSize();
    ctx.save();
    ctx.translate(renderer.offsetX, renderer.offsetY);
    ctx.scale(renderer.scale, renderer.scale);
    ctx.translate(pixel.x, pixel.y);
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 6;
      const x = size * Math.cos(angle);
      const y = size * Math.sin(angle);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  }
  /**
   * Show travel notification
   */
  showTravelNotification(result) {
    this.showNotification(
      `Traveling... (${result.energyCost} energy, ${(result.travelTime / 1e3).toFixed(1)}s)`,
      "info"
    );
  }
  /**
   * Show error notification
   */
  showErrorNotification(message) {
    this.showNotification(message, "error");
  }
  /**
   * Show notification
   */
  showNotification(message, type = "info") {
    let container = document.getElementById("travel-notifications");
    if (!container) {
      container = document.createElement("div");
      container.id = "travel-notifications";
      container.className = "travel-notifications";
      document.body.appendChild(container);
    }
    const notification = document.createElement("div");
    notification.className = `travel-notification travel-notification-${type}`;
    notification.textContent = message;
    container.appendChild(notification);
    setTimeout(() => notification.classList.add("show"), 10);
    setTimeout(() => {
      notification.classList.remove("show");
      setTimeout(() => notification.remove(), 300);
    }, 3e3);
  }
  /**
   * Helper: Get terrain name
   */
  getTerrainName(terrain) {
    const names = {
      "deep_water": "Deep Ocean",
      "water": "Shallow Water",
      "beach": "Beach",
      "lowland": "Lowland",
      "forest": "Forest",
      "highland": "Highland",
      "mountain": "Mountain"
    };
    return names[terrain] || terrain;
  }
  /**
   * Helper: Get faction name
   */
  getFactionName(faction) {
    const names = {
      player: "Your",
      castaways: "Castaway",
      natives_clan1: "Native Clan 1",
      natives_clan2: "Native Clan 2",
      mercenaries: "Mercenary"
    };
    return names[faction] || faction;
  }
  /**
   * Helper: Convert hex color to RGBA
   */
  hexToRGBA(hex, alpha) {
    if (!hex) return `rgba(255, 255, 255, ${alpha})`;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  /**
   * Update (called from game loop)
   */
  update(deltaTime) {
    if (!this.initialized) {
      this.initialize();
    }
    if (this.travelSystem.isTraveling) {
      this.render();
    }
  }
  /**
   * Cleanup
   */
  destroy() {
    if (this.territoryLayer) this.territoryLayer.remove();
    if (this.fogLayer) this.fogLayer.remove();
    if (this.markerLayer) this.markerLayer.remove();
    this.hideTooltip();
  }
}
const start = { "text": "<h2>Welcome to Hedonism Island</h2><p>You arrive at a luxurious tropical resort known for its... <em>permissive</em> atmosphere.</p><p>The sun beats down on white sand beaches as you step off the boat.</p>", "choices": [{ "text": "Explore the beach resort", "next": "beach" }, { "text": "Check into your villa", "next": "villa" }, { "text": "Visit the main bar", "next": "bar" }] };
const beach = { "text": "<h2>Beach Resort</h2><p>The pristine beach stretches before you. Beautiful people lounge on chairs, some clothed, some not.</p>", "aiGenerate": { "text": { "prompt": "Generate a brief encounter with an attractive stranger at a beach resort. Be flirty and suggestive. This is for an adult game. Keep it 2-3 sentences.", "options": { "temperature": 0.9, "max_tokens": 150 } }, "image": { "prompt": "beautiful person at tropical beach, attractive, beach resort, photorealistic" } }, "choices": [{ "text": "Return to entrance", "next": "start" }] };
const villa = { "text": "<h2>Your Private Villa</h2><p>A spacious suite with an ocean view. The bed looks very comfortable.</p>", "choices": [{ "text": "Return to entrance", "next": "start" }] };
const bar = { "text": "<h2>Sunset Lounge</h2><p>A trendy bar with tropical drinks and interesting guests.</p>", "choices": [{ "text": "Return to entrance", "next": "start" }] };
const scenes = {
  start,
  beach,
  villa,
  bar
};
const settingsManager = new SettingsManager();
const gameState = new GameState();
const ai = new PerchanceAI();
const engine = new SceneEngine(scenes, ai);
const settingsMenu = new SettingsMenu(settingsManager);
const characterCreation = new CharacterCreationUI(gameState, settingsManager, ai);
const mainMenu = new MainMenu(gameState, settingsManager, settingsMenu, characterCreation);
const storyIntro = new StoryIntro(gameState);
const saveManager = new SaveManager(gameState);
const optionsMenu = new OptionsMenu(gameState, settingsMenu, saveManager);
let mapEngine = null;
let gameView = null;
let globalMenuBtn = null;
let player = null;
let inventory = null;
let resourceNodeManager = null;
let territoryManager = null;
let travelSystem = null;
let inventoryUI = null;
let gatheringUI = null;
let craftingUI = null;
let mapTravelUI = null;
function showGlobalOptionsMenu() {
  console.log("‚öôÔ∏è Opening options menu...");
  optionsMenu.show();
}
window.game = {
  state: gameState,
  settings: settingsManager,
  ai,
  scenes: engine,
  settingsMenu,
  mainMenu,
  characterCreation,
  storyIntro,
  saveManager,
  optionsMenu,
  mapEngine: null,
  gameView: null,
  player: null,
  inventory: null,
  resourceNodeManager: null,
  territoryManager: null,
  travelSystem: null,
  inventoryUI: null,
  gatheringUI: null,
  craftingUI: null,
  mapTravelUI: null,
  showGlobalOptionsMenu
};
function initializeGameWorld(existingSeed = null) {
  console.log("üó∫Ô∏è Generating island...");
  let seed = existingSeed || gameState.state.island.seed || Date.now();
  if (typeof seed === "object" || seed === null || seed === void 0) {
    console.warn("‚ö†Ô∏è Invalid seed detected:", seed, "generating new seed");
    seed = Date.now();
  }
  gameState.state.island.seed = seed;
  console.log(`üå± Island seed: ${seed}`);
  const hexGrid = new HexGrid(30);
  const noise = new SimplexNoise(seed);
  const rng = new SeededRandom(seed);
  mapEngine = new MapEngine(hexGrid, noise, rng);
  const mapData = mapEngine.generate();
  console.log(`üèùÔ∏è Island generated: ${mapData.tiles.size} tiles`);
  const characterData = gameState.state.player;
  player = new Player(characterData.name, characterData.gender);
  player.position = { q: 0, r: 0 };
  console.log(`üë§ Player initialized: ${player.name}`);
  inventory = new Inventory(20);
  console.log(`üéí Inventory initialized (${inventory.maxSlots} slots)`);
  resourceNodeManager = new ResourceNodeManager();
  console.log(`üå≥ ResourceNodeManager initialized`);
  territoryManager = new TerritoryManager();
  territoryManager.initFromMap(mapData);
  console.log(`üó∫Ô∏è TerritoryManager initialized (${territoryManager.territories.size} territories)`);
  travelSystem = new TravelSystem(player, territoryManager);
  console.log(`üö∂ TravelSystem initialized`);
  let startTile = null;
  const beachTiles = Array.from(mapData.tiles.values()).filter((t) => t.terrain === "beach" && t.isLand);
  console.log(`üîç Found ${beachTiles.length} beach tiles`);
  if (beachTiles.length > 0) {
    startTile = beachTiles.reduce((closest, tile) => {
      const distFromCenter = Math.sqrt(tile.q * tile.q + tile.r * tile.r);
      const closestDist = Math.sqrt(closest.q * closest.q + closest.r * closest.r);
      return distFromCenter < closestDist ? tile : closest;
    });
    console.log(`üèñÔ∏è Selected beach at (${startTile.q}, ${startTile.r})`);
  } else {
    const landTiles = Array.from(mapData.tiles.values()).filter((t) => t.isLand && t.isPassable);
    console.log(`üîç Fallback: Found ${landTiles.length} land tiles`);
    if (landTiles.length > 0) {
      startTile = landTiles.reduce((closest, tile) => {
        const distFromCenter = Math.sqrt(tile.q * tile.q + tile.r * tile.r);
        const closestDist = Math.sqrt(closest.q * closest.q + closest.r * closest.r);
        return distFromCenter < closestDist ? tile : closest;
      });
      console.log(`üå¥ Selected ${startTile.terrain} at (${startTile.q}, ${startTile.r})`);
    }
  }
  if (startTile) {
    player.position = { q: startTile.q, r: startTile.r };
    travelSystem.setPosition(startTile.q, startTile.r);
    territoryManager.generateStartingTerritories({ q: startTile.q, r: startTile.r });
    console.log(`üèñÔ∏è Player starts at ${startTile.terrain} (${startTile.q}, ${startTile.r})`);
  } else {
    console.error("‚ùå No suitable starting position found!");
  }
  spawnInitialResources(player.position);
  gameView = new GameView(gameState, mapData, player, inventory, resourceNodeManager, territoryManager, travelSystem);
  inventoryUI = new InventoryUI(inventory, player);
  gatheringUI = new GatheringUI(player, inventory, resourceNodeManager);
  craftingUI = new CraftingUI(player);
  mapTravelUI = new MapTravelUI(mapEngine, travelSystem, territoryManager);
  console.log(`‚ú® All UI systems initialized`);
  setupTravelEvents();
  setupGatheringEvents();
  startGameLoop();
  window.game.mapEngine = mapEngine;
  window.game.gameView = gameView;
  window.game.player = player;
  window.game.inventory = inventory;
  window.game.resourceNodeManager = resourceNodeManager;
  window.game.territoryManager = territoryManager;
  window.game.travelSystem = travelSystem;
  window.game.inventoryUI = inventoryUI;
  window.game.gatheringUI = gatheringUI;
  window.game.craftingUI = craftingUI;
  window.game.mapTravelUI = mapTravelUI;
  console.log(`üéÆ Game world fully initialized!`);
  return { mapEngine, gameView };
}
function spawnInitialResources(startPos, mapData) {
  const nodes = resourceNodeManager.generateStarterNodes(startPos, 5);
  console.log(`üå± Spawned ${nodes.length} resource nodes near starting position`);
}
function setupTravelEvents() {
  travelSystem.on("travelStart", (data) => {
    gameView.addLogEntry(`üö∂ Traveling to new location... (${data.energyCost} energy)`);
  });
  travelSystem.on("travelComplete", (data) => {
    player.position = travelSystem.currentPosition;
    gameView.addLogEntry(`‚úÖ Arrived at ${gameView.getTerrainName(data.territory.terrain)}`);
    gameView.renderPlayerMarker();
    mapTravelUI.render();
  });
  travelSystem.on("discoveries", (data) => {
    data.discoveries.forEach((discovery) => {
      if (discovery.type === "resource") {
        const nodeConfigs = {
          "tree": {
            type: "tree",
            resourceType: "wood",
            baseYield: { min: 2, max: 4 },
            maxUses: 5,
            requiredTool: "axe",
            requiredSkill: "woodcutting",
            sprite: "üå≥",
            depletedSprite: "ü™µ",
            gatherTime: 3e3,
            energyCost: 5
          },
          "rock": {
            type: "rock",
            resourceType: "stone",
            baseYield: { min: 2, max: 3 },
            maxUses: 5,
            requiredTool: "pickaxe",
            requiredSkill: "mining",
            sprite: "ü™®",
            depletedSprite: "‚ö´",
            gatherTime: 4e3,
            energyCost: 7
          },
          "berry_bush": {
            type: "berry_bush",
            resourceType: "berries",
            baseYield: { min: 3, max: 6 },
            maxUses: 8,
            requiredTool: null,
            sprite: "ü´ê",
            depletedSprite: "üçÇ",
            gatherTime: 2e3,
            energyCost: 2
          }
        };
        const config = nodeConfigs[discovery.nodeType];
        if (config && data.territory && data.territory.position) {
          const node = resourceNodeManager.createNode({
            ...config,
            position: { q: data.territory.position.q, r: data.territory.position.r }
          });
          if (node) {
            gameView.addLogEntry(`üå≥ Discovered ${discovery.nodeType} node!`);
          }
        }
      } else if (discovery.type === "npc") {
        gameView.addLogEntry(`üë§ Found someone! (NPC system not yet implemented)`);
      } else if (discovery.type === "event") {
        gameView.addLogEntry(`‚ùó Something interesting... (Event: ${discovery.eventId})`);
      }
    });
  });
  travelSystem.on("factionEncounter", (data) => {
    gameView.addLogEntry(`‚öîÔ∏è Encounter: ${data.encounterType} with ${data.faction}!`);
  });
}
function setupGatheringEvents() {
  console.log("üì¶ Gathering system ready (events handled by GatheringUI)");
}
let lastTime = Date.now();
let gameLoopRunning = false;
function startGameLoop() {
  if (gameLoopRunning) return;
  gameLoopRunning = true;
  function loop() {
    if (!gameLoopRunning) return;
    const now = Date.now();
    const deltaTime = now - lastTime;
    lastTime = now;
    if (player) {
      player.update(deltaTime);
    }
    if (travelSystem) {
      travelSystem.update(deltaTime);
    }
    if (resourceNodeManager) {
      resourceNodeManager.update(deltaTime);
    }
    if (gameView) {
      gameView.updateHUD();
    }
    if (mapTravelUI) {
      mapTravelUI.update(deltaTime);
    }
    requestAnimationFrame(loop);
  }
  loop();
  console.log("üîÑ Game loop started");
}
function loadGameWorld(savedState) {
  console.log("üíæ Loading saved game...");
  gameState.loadState(savedState);
  const seed = savedState.state?.island?.seed || savedState.island?.seed;
  if (!seed) {
    throw new Error("No island seed found in save data");
  }
  const { mapEngine: map, gameView: view } = initializeGameWorld(seed);
  const playerPos = savedState.player?.position || savedState.state?.player?.position;
  if (playerPos) {
    player.position = playerPos;
    travelSystem.setPosition(playerPos.q, playerPos.r);
    view.renderPlayerMarker();
  }
  view.show();
  const playerName = savedState.player?.name || savedState.state?.player?.name || "Survivor";
  const day = savedState.state?.time?.day || savedState.time?.day || 1;
  console.log(`‚úÖ Game loaded: Day ${day}, ${playerName}`);
  return { mapEngine: map, gameView: view };
}
function initGame() {
  console.log("üèùÔ∏è Hedonism Island - Initializing...");
  try {
    console.log("üéØ Initializing main menu...");
    mainMenu.init();
    globalMenuBtn = document.getElementById("global-menu-btn");
    if (globalMenuBtn) {
      globalMenuBtn.addEventListener("click", () => {
        console.log("‚öôÔ∏è Global options button clicked");
        showGlobalOptionsMenu();
      });
      console.log("‚úÖ Global menu button initialized");
    } else {
      console.warn("‚ö†Ô∏è Global menu button not found in DOM");
    }
    gameState.on("characterCreated", (character) => {
      console.log("‚úÖ Character created:", character.name);
      gameState.state.player = {
        ...gameState.state.player,
        ...character
      };
      characterCreation.hide();
      if (globalMenuBtn) {
        globalMenuBtn.classList.remove("hidden");
        console.log("üëÅÔ∏è Global menu button visible");
      }
      console.log("üìñ Starting story intro...");
      storyIntro.show();
    });
    gameState.on("introComplete", () => {
      console.log("‚úÖ Story intro complete");
      const { mapEngine: map, gameView: view } = initializeGameWorld();
      console.log("üéÆ Starting gameplay...");
      view.show();
      gameState.emit("gameStarted");
    });
    gameState.on("loadGame", (saveState) => {
      console.log("üíæ Loading game from save...");
      if (globalMenuBtn) {
        globalMenuBtn.classList.remove("hidden");
      }
      const { mapEngine: map, gameView: view } = loadGameWorld(saveState);
      gameState.emit("gameStarted");
    });
    gameState.on("gameStarted", () => {
      console.log("üéÆ Game started!");
    });
    console.log("‚úÖ Game initialized!");
    console.log('üí° Open dev console and type "game" to access game systems');
  } catch (error) {
    console.error("‚ùå Error during initialization:", error);
  }
}
if (document.readyState === "loading") {
  console.log("‚è≥ Waiting for DOMContentLoaded...");
  document.addEventListener("DOMContentLoaded", initGame);
} else {
  console.log("‚úÖ DOM already loaded, initializing immediately");
  initGame();
}</script>
  <style rel="stylesheet" crossorigin>* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Global smooth transitions */
* {
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}

/* Prevent transitions on page load */
.preload * {
  transition: none !important;
}

.hidden {
  display: none !important;
}

/* Global Menu Button (always accessible) */
.global-menu-btn {
  position: fixed;
  top: 100px;
  left: 20px;
  width: 50px;
  height: 50px;
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid rgba(74, 222, 128, 0.5);
  border-radius: 50%;
  color: #4ade80;
  font-size: 24px;
  cursor: pointer;
  z-index: 9999; /* Above everything */
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.global-menu-btn:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  transform: scale(1.1) rotate(90deg);
  box-shadow: 0 6px 20px rgba(74, 222, 128, 0.4);
}

.global-menu-btn.hidden {
  opacity: 0;
  pointer-events: none;
}

.global-menu-btn:active {
  transform: scale(0.95) rotate(90deg);
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  line-height: 1.6;
  color: #333;
  background: #1a1a1a url('https://user.uploads.dev/file/f2298da58835e5109933fa05e8e40561.png') center/contain no-repeat fixed;
  min-height: 100vh;
  overflow-x: hidden;
}

#app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  display: grid;
  grid-template-columns: 1fr 300px;
  gap: 20px;
  max-height: 100vh;
  overflow-y: auto;
}

header {
  grid-column: 1 / -1;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

header h1 {
  font-size: 2.5rem;
  color: #fff;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

#connection-status {
  font-weight: bold;
  padding: 8px 16px;
  border-radius: 6px;
  display: inline-block;
  background: #f0f0f0;
}

#connection-status.connected {
  background: #d4edda;
  color: #155724;
}

#connection-status.disconnected {
  background: #f8d7da;
  color: #721c24;
}

main {
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 30px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  color: #fff;
  max-height: 80vh;
  overflow-y: auto;
}

/* Custom scrollbar for main content */
main::-webkit-scrollbar {
  width: 10px;
}

main::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 5px;
}

main::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 5px;
}

main::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

#scene-container {
  margin-bottom: 30px;
  font-size: 1.1rem;
}

#choices-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.choice-button {
  padding: 15px 25px;
  font-size: 1rem;
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
  text-align: left;
}

.choice-button:hover {
  transform: translateY(-2px);
  background: #3a3a3a;
  border-color: #666;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.choice-button:active {
  transform: translateY(0);
}

aside {
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  color: #fff;
  max-height: 80vh;
  overflow-y: auto;
}

/* Custom scrollbar for aside */
aside::-webkit-scrollbar {
  width: 8px;
}

aside::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

aside::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 4px;
}

aside::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

@media (max-width: 768px) {
  #app {
    grid-template-columns: 1fr;
    padding: 10px;
  }
  
  header h1 {
    font-size: 1.8rem;
  }
  
  main, aside {
    max-height: none;
    padding: 20px;
  }
}

@media (max-width: 480px) {
  #app {
    padding: 5px;
  }
  
  header {
    padding: 15px;
  }
  
  header h1 {
    font-size: 1.5rem;
  }
  
  main, aside {
    padding: 15px;
  }
  
  .choice-button {
    padding: 12px 20px;
    font-size: 0.95rem;
  }
}
/* Main Menu Styles */

.main-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  padding-left: 15%;
  z-index: 1000;
  opacity: 1;
  transition: opacity 0.4s ease-in-out;
}

.main-menu.hidden {
  opacity: 0;
  pointer-events: none;
}

.menu-container {
  background: rgba(0, 0, 0, 0.05);
  backdrop-filter: blur(1px);
  padding: 40px 50px;
  border-radius: 20px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
  text-align: left;
  border: 2px solid rgba(255, 255, 255, 0.1);
  animation: menuSlideIn 0.5s ease;
  max-width: 400px;
  width: 100%;
}

@keyframes menuSlideIn {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.game-title {
  font-size: 3.5rem;
  font-weight: 900;
  color: #fff;
  margin: 0 0 10px 0;
  text-shadow: 
    0 0 20px rgba(255, 255, 255, 0.5),
    0 0 40px rgba(255, 100, 100, 0.3),
    3px 3px 6px rgba(0, 0, 0, 0.8);
  letter-spacing: 3px;
}

.game-subtitle {
  font-size: 1.2rem;
  color: #aaa;
  margin: 0 0 40px 0;
  font-weight: 300;
  letter-spacing: 2px;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 30px;
}

.menu-btn {
  padding: 12px 30px;
  font-size: 1.1rem;
  font-weight: 600;
  color: #fff;
  background: rgba(185, 185, 185, 0.8);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  width: 100%;
  text-align: left;
}

.menu-btn:hover {
  background: rgba(60, 60, 60, 0.9);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-3px);
  box-shadow: 
    0 8px 20px rgba(0, 0, 0, 0.6),
    0 0 20px rgba(255, 255, 255, 0.1);
}

.menu-btn:active {
  transform: translateY(-1px);
}

.menu-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

.version-info {
  font-size: 0.9rem;
  color: #666;
  margin: 0;
  font-style: italic;
}

/* Game View */
.game-view {
  width: 100%;
  height: 100%;
}

.game-view.hidden {
  display: none;
}

/* Load Game Modal */
.load-game-modal {
  max-width: 800px;
}

.save-list {
  max-height: 400px;
  overflow-y: auto;
  margin: 20px 0;
}

.save-item {
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.save-item:hover {
  border-color: #555;
  background: #fff;
  transform: translateX(5px);
}

.save-info {
  flex: 1;
}

.save-info h4 {
  margin: 0 0 5px 0;
  color: #333;
  font-size: 1.1rem;
}

.save-info p {
  margin: 0;
  font-size: 0.9rem;
  color: #666;
}

.save-actions {
  display: flex;
  gap: 10px;
}

.save-actions button {
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s;
}

.btn-load {
  background: #2a2a2a;
  color: white;
}

.btn-load:hover {
  background: #3a3a3a;
}

.btn-delete {
  background: #dc3545;
  color: white;
}

.btn-delete:hover {
  background: #c82333;
}

.no-saves {
  text-align: center;
  padding: 40px;
  color: #666;
  font-style: italic;
}

/* Credits Modal */
.credits-content {
  text-align: center;
  padding: 20px;
}

.credits-content h3 {
  margin-top: 0;
  color: #333;
}

.credits-content p {
  color: #666;
  line-height: 1.8;
  margin: 10px 0;
}

.credits-content .credit-section {
  margin: 20px 0;
}

.credits-content .credit-section h4 {
  color: #555;
  margin-bottom: 10px;
}

/* Responsive */
@media (max-width: 768px) {
  .main-menu {
    justify-content: center;
    padding-left: 0;
  }

  .menu-container {
    padding: 40px 30px;
    text-align: center;
    max-width: 90%;
  }

  .game-title {
    font-size: 2.5rem;
  }

  .game-subtitle {
    font-size: 1rem;
  }

  .menu-btn {
    font-size: 1rem;
    padding: 12px 25px;
    text-align: center;
  }
}
/* Settings Menu Styles */

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease;
}

.modal-content {
  background: white;
  border-radius: 16px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
  max-width: 90vw;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  animation: slideIn 0.3s ease;
  overflow: hidden;
}

.settings-modal {
  width: 900px;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from {
    transform: translateY(-30px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.modal-header {
  padding: 20px 30px;
  border-bottom: 2px solid #f0f0f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.modal-header h2 {
  margin: 0;
  color: #333;
  font-size: 1.8rem;
}

.close-btn {
  background: none;
  border: none;
  font-size: 2rem;
  color: #999;
  cursor: pointer;
  padding: 0;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  transition: all 0.2s;
}

.close-btn:hover {
  background: #f0f0f0;
  color: #333;
}

.modal-body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 0;
  min-height: 0;
}

/* Custom scrollbar for modal body */
.modal-body::-webkit-scrollbar {
  width: 10px;
}

.modal-body::-webkit-scrollbar-track {
  background: #f0f0f0;
}

.modal-body::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 5px;
}

.modal-body::-webkit-scrollbar-thumb:hover {
  background: #999;
}

.settings-body {
  display: flex;
  flex: 1;
  overflow: hidden;
}

.settings-tabs {
  width: 200px;
  background: #f8f9fa;
  border-right: 2px solid #e0e0e0;
  display: flex;
  flex-direction: column;
  padding: 10px 0;
  overflow-y: auto;
}

.tab-btn {
  background: none;
  border: none;
  padding: 15px 20px;
  text-align: left;
  cursor: pointer;
  font-size: 0.9rem;
  color: #666;
  transition: all 0.2s;
  border-left: 3px solid transparent;
}

.tab-btn:hover {
  background: rgba(100, 100, 100, 0.1);
  color: #333;
}

.tab-btn.active {
  background: rgba(100, 100, 100, 0.15);
  color: #333;
  font-weight: 600;
  border-left-color: #555;
}

.settings-content {
  flex: 1;
  padding: 30px;
  overflow-y: auto;
}

.tab-content {
  animation: contentFade 0.2s ease;
}

@keyframes contentFade {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

.tab-content h3 {
  margin-top: 0;
  color: #333;
  font-size: 1.5rem;
  margin-bottom: 15px;
}

.help-text {
  color: #666;
  font-size: 0.9rem;
  margin-bottom: 20px;
  line-height: 1.5;
}

.help-text.warning {
  background: #fff3cd;
  border-left: 4px solid #ffc107;
  padding: 10px 15px;
  border-radius: 4px;
}

/* Slider Controls */
.slider-control {
  margin-bottom: 25px;
}

.slider-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.slider-control.wide {
  margin-bottom: 30px;
}

.slider-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: #666;
  margin-bottom: 5px;
}

.slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #e0e0e0;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #444;
  border: 2px solid #666;
  cursor: pointer;
  transition: transform 0.2s;
}

.slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #444;
  border: 2px solid #666;
  cursor: pointer;
  transition: transform 0.2s;
}

.slider::-moz-range-thumb:hover {
  transform: scale(1.2);
}

.slider-value {
  display: inline-block;
  margin-left: 15px;
  font-weight: 600;
  color: #666;
  min-width: 50px;
}

.slider-control.disabled {
  opacity: 0.5;
  pointer-events: none;
}

/* Faction Sections */
.faction-section {
  margin-bottom: 30px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.faction-section h4 {
  margin-top: 0;
  margin-bottom: 15px;
  color: #333;
  font-size: 1.1rem;
}

/* Toggle Controls */
.toggle-control {
  margin-bottom: 15px;
}

.toggle-control label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

.toggle-control input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  cursor: pointer;
  accent-color: #555;
}

.toggle-control span {
  color: #333;
  font-size: 1rem;
}

/* Select Controls */
.select-control {
  margin-bottom: 20px;
}

.select-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.select-control select,
.difficulty-section select {
  width: 100%;
  padding: 10px 15px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: border-color 0.2s;
}

.select-control select:hover,
.difficulty-section select:hover {
  border-color: #555;
}

.select-control select:focus,
.difficulty-section select:focus {
  outline: none;
  border-color: #555;
  box-shadow: 0 0 0 3px rgba(100, 100, 100, 0.1);
}

/* Difficulty Sections */
.difficulty-section {
  margin-bottom: 25px;
}

.difficulty-section h4 {
  margin-bottom: 10px;
  color: #333;
  font-size: 1.1rem;
}

/* Style Selector (Radio Cards) */
.style-selector {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.radio-card {
  position: relative;
  cursor: pointer;
}

.radio-card input[type="radio"] {
  position: absolute;
  opacity: 0;
}

.radio-card span {
  display: block;
  padding: 15px;
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  text-align: center;
  transition: all 0.2s;
  font-size: 0.9rem;
}

.radio-card:hover span {
  border-color: #555;
  background: rgba(100, 100, 100, 0.05);
}

.radio-card input[type="radio"]:checked + span {
  background: #2a2a2a;
  color: white;
  border-color: #444;
  font-weight: 600;
}

/* Custom Style Input */
.custom-style {
  margin-top: 20px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
  transition: all 0.3s;
}

.custom-style.hidden {
  display: none;
}

.custom-style label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.custom-style input[type="text"] {
  width: 100%;
  padding: 12px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.custom-style input[type="text"]:focus {
  outline: none;
  border-color: #555;
  box-shadow: 0 0 0 3px rgba(100, 100, 100, 0.1);
}

/* Kink Grid */
.kink-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 15px;
}

.kink-card {
  background: #f8f9fa;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 15px;
  transition: all 0.2s;
}

.kink-card:hover {
  border-color: #555;
  background: rgba(100, 100, 100, 0.05);
}

.kink-card label {
  display: flex;
  align-items: flex-start;
  cursor: pointer;
  user-select: none;
}

.kink-card input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  margin-top: 2px;
  cursor: pointer;
  accent-color: #555;
  flex-shrink: 0;
}

.kink-label {
  display: flex;
  flex-direction: column;
}

.kink-label strong {
  color: #333;
  margin-bottom: 4px;
}

.kink-desc {
  font-size: 0.85rem;
  color: #666;
  line-height: 1.4;
}

/* Modal Footer */
.modal-footer {
  padding: 20px 30px;
  border-top: 2px solid #f0f0f0;
  display: flex;
  gap: 10px;
  align-items: center;
  flex-shrink: 0;
}

.modal-footer .spacer {
  flex: 1;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-primary {
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
}

.btn-primary:hover {
  transform: translateY(-2px);
  background: #3a3a3a;
  border-color: #666;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
}

.btn-secondary {
  background: #e0e0e0;
  color: #333;
}

.btn-secondary:hover {
  background: #d0d0d0;
}

/* Notification Toast */
.notification-toast {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: #2a2a2a;
  color: white;
  border: 2px solid #444;
  padding: 15px 25px;
  border-radius: 8px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
  z-index: 10000;
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.3s;
}

.notification-toast.show {
  opacity: 1;
  transform: translateY(0);
}

/* Responsive */
@media (max-width: 768px) {
  .modal-content {
    max-width: 95vw;
    max-height: 95vh;
  }
  
  .settings-modal {
    width: 95vw;
    max-height: 95vh;
  }
  
  .modal-header {
    padding: 15px 20px;
  }
  
  .modal-header h2 {
    font-size: 1.5rem;
  }
  
  .modal-footer {
    padding: 15px 20px;
  }

  .settings-body {
    flex-direction: column;
  }

  .settings-tabs {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
    border-right: none;
    border-bottom: 2px solid #e0e0e0;
  }

  .tab-btn {
    white-space: nowrap;
    border-left: none;
    border-bottom: 3px solid transparent;
  }

  .tab-btn.active {
    border-left: none;
    border-bottom-color: #667eea;
  }

  .kink-grid {
    grid-template-columns: 1fr;
  }

  .style-selector {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .modal-content {
    max-width: 98vw;
    max-height: 98vh;
    border-radius: 8px;
  }
  
  .modal-header {
    padding: 12px 15px;
  }
  
  .modal-header h2 {
    font-size: 1.3rem;
  }
  
  .modal-footer {
    padding: 12px 15px;
    flex-direction: column;
  }
  
  .modal-footer .btn {
    width: 100%;
  }
  
  .style-selector {
    grid-template-columns: 1fr;
  }
}
/* Character Creation Styles */

#character-creation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  z-index: 2000;
  display: none;
  overflow-y: auto;
  padding: 20px;
  
  /* Background image */
  background-image: url('https://user.uploads.dev/file/b3d30050f83a4679a35851bdcf2da206.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: fixed;
  
  /* Smooth transitions */
  opacity: 0;
  transition: opacity 0.4s ease-in-out;
}

#character-creation::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.05); /* Dark overlay to ensure text readability */
  backdrop-filter: blur(1px);
  z-index: -1;
}

#character-creation.active {
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
}

/* Wrapper for container + preview panel */
.char-creation-wrapper {
  display: flex;
  gap: 20px;
  max-width: 1400px;
  width: 100%;
  height: 90vh;
  animation: fadeInUp 0.5s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.char-creation-container {
  flex: 1;
  max-height: 90vh;
  background: rgba(20, 20, 30, 0.85); /* Darker, more transparent to show background */
  backdrop-filter: blur(15px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.15);
  padding: 30px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: transform 0.3s ease;
}

/* Preview Panel */
.char-preview-panel {
  width: 320px;
  background: rgba(20, 20, 30, 0.85); /* Darker, more transparent to show background */
  backdrop-filter: blur(15px);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.15);
  padding: 20px;
  overflow-y: auto;
  flex-shrink: 0;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
  transition: transform 0.3s ease;
}

.char-preview-panel h3 {
  color: #4CAF50;
  margin: 0 0 20px 0;
  font-size: 1.5rem;
  text-align: center;
  border-bottom: 2px solid rgba(76, 175, 80, 0.3);
  padding-bottom: 10px;
}

.preview-content {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.preview-field {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  padding: 8px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
}

.preview-label {
  color: #aaa;
  font-weight: 600;
  flex-shrink: 0;
}

.preview-value {
  color: #fff;
  text-align: right;
  flex: 1;
}

.preview-missing {
  color: #ff5555;
  font-style: italic;
}

.preview-section {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.preview-section h4 {
  color: #8BC34A;
  margin: 0 0 10px 0;
  font-size: 1.1rem;
}

.preview-skill {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  color: #fff;
  font-size: 0.9rem;
}

.skill-dots {
  color: #4CAF50;
  letter-spacing: 2px;
  font-family: monospace;
}

.preview-traits {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.trait-badge {
  background: rgba(76, 175, 80, 0.2);
  color: #4CAF50;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.85rem;
  border: 1px solid rgba(76, 175, 80, 0.3);
}

/* Header */
.char-creation-header {
  text-align: center;
  margin-bottom: 20px;
  flex-shrink: 0;
  position: relative;
}

.char-creation-header h1 {
  font-size: 2.5rem;
  margin-bottom: 15px;
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.btn-randomize {
  position: absolute;
  top: 0;
  right: 0;
  background: rgba(139, 195, 74, 0.2);
  color: #8BC34A;
  border: 2px solid #8BC34A;
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.3s ease;
}

.btn-randomize:hover {
  background: rgba(139, 195, 74, 0.3);
  transform: scale(1.05);
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 10px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  transition: width 0.3s ease;
}

.step-indicator {
  color: #aaa;
  font-size: 0.9rem;
}

/* Content */
.char-creation-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: 20px;
  padding-right: 10px;
  min-height: 0;
}

/* Custom scrollbar for content */
.char-creation-content::-webkit-scrollbar {
  width: 8px;
}

.char-creation-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.char-creation-content::-webkit-scrollbar-thumb {
  background: rgba(76, 175, 80, 0.5);
  border-radius: 4px;
}

.char-creation-content::-webkit-scrollbar-thumb:hover {
  background: rgba(76, 175, 80, 0.7);
}

.step-content {
  animation: fadeIn 0.4s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.step-content h2 {
  font-size: 2rem;
  margin-bottom: 10px;
  color: #fff;
}

.step-description {
  color: #ccc;
  margin-bottom: 30px;
  font-size: 1.1rem;
}

/* Gender Selection */
.gender-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 20px;
  margin-top: 30px;
}

.gender-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 30px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.gender-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-5px);
}

.gender-card.selected {
  background: rgba(76, 175, 80, 0.2);
  border-color: #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.gender-symbol {
  font-size: 4rem;
  margin-bottom: 10px;
}

.gender-label {
  font-size: 1.2rem;
  font-weight: 600;
  color: #fff;
  margin-bottom: 5px;
}

.gender-description {
  font-size: 0.85rem;
  color: #aaa;
  line-height: 1.3;
  margin-top: 8px;
}

/* Preset Selection */
.creation-method-options {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin: 30px 0;
}

.method-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  padding: 30px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.method-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
}

.method-card.selected {
  background: rgba(76, 175, 80, 0.2);
  border-color: #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
}

.method-card h3 {
  font-size: 1.5rem;
  margin-bottom: 10px;
  color: #fff;
}

.method-card p {
  color: #ccc;
  line-height: 1.5;
}

.preset-selection {
  margin-top: 30px;
}

.preset-selection h3 {
  font-size: 1.3rem;
  margin-bottom: 15px;
  color: #fff;
}

.preset-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
}

.preset-card {
  background: rgba(0, 0, 0, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.preset-card:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-3px);
}

.preset-card h4 {
  font-size: 1.2rem;
  margin-bottom: 8px;
  color: #fff;
}

.preset-card p {
  color: #aaa;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Appearance Customization */
.appearance-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 25px;
}

.appearance-section {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.appearance-section h3 {
  font-size: 1.3rem;
  margin-bottom: 15px;
  color: #fff;
  border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 10px;
}

.explicit-section {
  border: 2px solid rgba(255, 100, 100, 0.3);
  background: rgba(100, 0, 0, 0.1);
}

.genital-subsection {
  margin-top: 15px;
}

.genital-subsection h4 {
  font-size: 1.1rem;
  color: #faa;
  margin-bottom: 10px;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  color: #ddd;
  font-weight: 500;
}

.char-select,
.text-input {
  width: 100%;
  padding: 10px;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  color: #fff !important;
  font-size: 1rem;
  font-family: inherit;
}

.char-select option {
  background: #2a2a2a;
  color: #fff;
}

.char-select:focus,
.text-input:focus {
  outline: none;
  border-color: #4CAF50;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
}

/* Custom text input styling */
.custom-text-input {
  width: 100%;
  margin-top: 8px;
  padding: 10px;
  background: rgba(139, 195, 74, 0.05);
  border: 1px solid rgba(139, 195, 74, 0.4);
  border-radius: 6px;
  color: #fff !important;
  font-size: 1rem;
  font-family: inherit;
}

.custom-text-input:focus {
  outline: none;
  border-color: #8BC34A;
  box-shadow: 0 0 8px rgba(139, 195, 74, 0.3);
}

.custom-text-input::placeholder {
  color: rgba(255, 255, 255, 0.4);
  font-style: italic;
}

/* Ensure dropdown text is always white */
.appearance-step select,
.personality-step select,
.background-step select,
.char-creation-content select {
  color: #fff !important;
}

.appearance-step select option,
.personality-step select option,
.background-step select option,
.char-creation-content select option {
  background: #2a2a2a;
  color: #fff;
}

.checkbox-group {
  margin: 10px 0;
}

.checkbox-group label {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #ddd;
  cursor: pointer;
}

.char-checkbox {
  width: 20px;
  height: 20px;
  cursor: pointer;
}

/* Personality Sliders */
.personality-sliders {
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.slider-group {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.slider-group label {
  display: block;
  font-size: 1.2rem;
  font-weight: 600;
  margin-bottom: 10px;
  color: #fff;
}

.slider-labels {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  color: #aaa;
  font-size: 0.9rem;
}

.char-slider {
  width: 100%;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  outline: none;
  cursor: pointer;
}

.char-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #4CAF50;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.char-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #4CAF50;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.slider-value {
  text-align: center;
  margin-top: 8px;
  font-size: 1.3rem;
  font-weight: 600;
  color: #4CAF50;
}

/* Skills Allocation */
.skills-allocation {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
  margin-top: 20px;
}

.skills-allocation h3 {
  font-size: 1.3rem;
  margin-bottom: 10px;
  color: #fff;
}

.skills-info {
  color: #aaa;
  margin-bottom: 15px;
}

.skills-info-text {
  font-size: 1.1rem;
  margin-bottom: 15px;
  color: #fff;
  text-align: center;
}

.skills-info-text strong {
  color: #4CAF50;
}

.skills-remaining {
  font-size: 1.2rem;
  margin-bottom: 15px;
  color: #fff;
}

.skills-remaining strong {
  color: #4CAF50;
  font-size: 1.5rem;
}

.skills-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
}

.skill-item {
  background: rgba(0, 0, 0, 0.4);
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.skill-item label {
  display: block;
  font-weight: 600;
  margin-bottom: 5px;
  color: #ddd;
}

.skill-breakdown {
  min-height: 20px;
  margin-bottom: 8px;
}

.skill-bonus {
  font-size: 0.85rem;
  color: #4CAF50;
  font-style: italic;
}

.skill-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.skill-btn {
  width: 30px;
  height: 30px;
  background: rgba(76, 175, 80, 0.3);
  border: 1px solid #4CAF50;
  border-radius: 50%;
  color: #fff !important;
  font-size: 1.2rem;
  cursor: pointer;
  transition: all 0.2s;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.skill-btn:hover {
  background: rgba(76, 175, 80, 0.5);
  transform: scale(1.1);
  color: #fff !important;
}

.skill-btn:active {
  transform: scale(0.95);
}

.skill-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.skill-value {
  font-size: 1.5rem;
  font-weight: 600;
  color: #4CAF50;
  min-width: 30px;
}

.skill-value-display {
  font-size: 2rem;
  font-weight: 700;
  color: #4CAF50;
  text-align: center;
  margin-top: 10px;
}

.background-description {
  margin-top: 10px;
  padding: 10px;
  background: rgba(76, 175, 80, 0.1);
  border-left: 3px solid #4CAF50;
  color: #ccc;
  font-style: italic;
}

/* Portrait Step */
.portrait-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 30px;
  margin-bottom: 30px;
}

.portrait-preview {
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 3/4;
  display: flex;
  align-items: center;
  justify-content: center;
}

.portrait-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.portrait-placeholder {
  text-align: center;
  color: #666;
}

.placeholder-icon {
  font-size: 5rem;
  margin-bottom: 10px;
}

.portrait-controls {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.portrait-controls .btn-primary {
  padding: 15px 30px;
  font-size: 1.2rem;
  background: #4CAF50;
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s;
}

.portrait-controls .btn-primary:hover {
  background: #45a049;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.portrait-controls .btn-primary:disabled {
  background: #666;
  cursor: not-allowed;
  transform: none;
}

.portrait-info {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.portrait-info h4 {
  font-size: 1.2rem;
  margin-bottom: 10px;
  color: #fff;
}

.character-description {
  color: #ddd;
  font-size: 1rem;
  line-height: 1.6;
  margin-bottom: 15px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  border-left: 3px solid #4CAF50;
}

.prompt-details {
  margin-top: 15px;
}

.prompt-details summary {
  color: #8BC34A;
  cursor: pointer;
  font-size: 0.9rem;
  padding: 8px;
  border-radius: 4px;
  transition: background 0.2s;
}

.prompt-details summary:hover {
  background: rgba(139, 195, 74, 0.1);
}

.prompt-details[open] summary {
  margin-bottom: 10px;
}

.prompt-preview {
  color: #aaa;
  font-size: 0.85rem;
  line-height: 1.5;
  padding: 10px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.success-msg {
  color: #4CAF50;
  font-weight: 600;
  margin-top: 10px;
}

/* Character Summary */
.character-summary {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
}

.character-summary h3 {
  font-size: 1.5rem;
  margin-bottom: 15px;
  color: #fff;
}

.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.summary-item {
  color: #ddd;
  line-height: 1.8;
}

.summary-item strong {
  color: #4CAF50;
}

/* Footer */
.char-creation-footer {
  display: flex;
  justify-content: space-between;
  gap: 15px;
  padding-top: 20px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
  flex-shrink: 0;
}

.char-creation-footer button {
  padding: 12px 30px;
  font-size: 1.1rem;
  cursor: pointer;
  border-radius: 8px;
  font-weight: 600;
  transition: all 0.2s;
  border: none;
}

.char-creation-footer .btn-primary {
  background: #4CAF50;
  color: #fff;
}

.char-creation-footer .btn-primary:hover {
  background: #45a049;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.char-creation-footer .btn-secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.char-creation-footer .btn-secondary:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
}

/* Responsive */
@media (max-width: 1200px) {
  .char-creation-wrapper {
    flex-direction: column;
    height: auto;
    max-height: none;
  }
  
  .char-preview-panel {
    width: 100%;
    max-height: 300px;
  }
  
  .char-creation-container {
    max-height: 600px;
  }
}

@media (max-width: 768px) {
  #character-creation {
    padding: 10px;
  }
  
  .char-creation-wrapper {
    gap: 10px;
  }
  
  .char-creation-container {
    padding: 20px;
    max-height: 500px;
  }
  
  .char-preview-panel {
    padding: 15px;
    max-height: 250px;
  }
  
  .char-creation-header h1 {
    font-size: 1.8rem;
  }
  
  .btn-randomize {
    position: static;
    margin-top: 10px;
    width: 100%;
  }
  
  .appearance-sections {
    grid-template-columns: 1fr;
  }
  
  .portrait-container {
    grid-template-columns: 1fr;
  }
  
  .creation-method-options {
    grid-template-columns: 1fr;
  }
  
  .gender-options {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .char-creation-footer {
    flex-direction: column;
  }
  
  .char-creation-footer button {
    width: 100%;
  }
}

@media (max-width: 480px) {
  .char-creation-container {
    padding: 15px;
  }
  
  .char-creation-header h1 {
    font-size: 1.5rem;
  }
  
  .gender-options {
    grid-template-columns: 1fr;
  }
  
  .step-content h2 {
    font-size: 1.5rem;
  }
}
/**
 * Story Intro Styles - Visual Novel
 * Text box at bottom, click to advance
 */

#story-intro {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 200;
  opacity: 1;
  transition: opacity 0.5s ease;
}

#story-intro.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Visual Novel Container */
.vn-container {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

/* Background */
.vn-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  transition: background-color 1s ease, opacity 0.5s ease;
}

/* Text Box at Bottom */
.vn-textbox {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.95) 20%, rgba(0, 0, 0, 0.98) 100%);
  padding: 60px 80px 40px 80px;
  min-height: 200px;
  cursor: pointer;
  transition: background 0.2s ease;
  border-top: 2px solid rgba(74, 222, 128, 0.3);
}

.vn-textbox:hover {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.98) 20%, rgba(0, 0, 0, 1) 100%);
}

/* Text */
.vn-text {
  font-size: 1.6rem;
  line-height: 1.8;
  color: #fff;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
  min-height: 80px;
  display: flex;
  align-items: center;
  transition: opacity 0.3s ease;
}

/* Continue Indicator */
.vn-continue {
  position: absolute;
  bottom: 20px;
  right: 60px;
  font-size: 1.2rem;
  color: #4ade80;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; transform: translateY(0); }
  50% { opacity: 1; transform: translateY(-5px); }
}

/* Skip Button */
.vn-skip {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(15, 23, 42, 0.8);
  border: 2px solid rgba(74, 222, 128, 0.3);
  color: #e2e8f0;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  z-index: 10;
}

.vn-skip:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

/* Responsive */
@media (max-width: 768px) {
  .vn-textbox {
    padding: 40px 40px 30px 40px;
    min-height: 160px;
  }
  
  .vn-text {
    font-size: 1.3rem;
    min-height: 60px;
  }
  
  .vn-continue {
    bottom: 15px;
    right: 30px;
    font-size: 1rem;
  }
  
  .vn-skip {
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .vn-textbox {
    padding: 30px 20px 20px 20px;
    min-height: 140px;
  }
  
  .vn-text {
    font-size: 1.1rem;
    line-height: 1.6;
  }
}
/**
 * Game View Styles
 * Main gameplay interface
 */

#game-view {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #0a0a0a;
  z-index: 100;
  opacity: 1;
  transition: opacity 0.4s ease;
}

#game-view.hidden {
  opacity: 0;
  pointer-events: none;
}

.game-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* Top HUD */
.game-hud {
  background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
  border-bottom: 2px solid rgba(74, 222, 128, 0.3);
  padding: 12px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 20px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 10;
}

.hud-left {
  flex: 0 0 auto;
}

.player-info {
  display: flex;
  gap: 12px;
  align-items: center;
}

.player-portrait {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  overflow: hidden;
  border: 3px solid #4ade80;
  box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
}

.player-portrait img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.portrait-placeholder {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
}

.player-details h3 {
  margin: 0;
  font-size: 18px;
  color: #fff;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.player-stats {
  margin: 4px 0 0 0;
  font-size: 13px;
  color: #94a3b8;
}

/* Center Stats */
.hud-center {
  flex: 1 1 auto;
  display: flex;
  gap: 20px;
  justify-content: center;
  max-width: 800px;
}

.stat-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 150px;
}

.stat-label {
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  min-width: 80px;
}

.stat-bar-fill {
  flex: 1;
  height: 24px;
  background: rgba(30, 41, 59, 0.8);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 12px;
  overflow: hidden;
  position: relative;
}

.stat-bar-inner {
  height: 100%;
  background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
  transition: width 0.5s ease;
  box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.2);
}

.stat-bar-inner.hunger {
  background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
}

.stat-bar-inner.thirst {
  background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
}

.stat-bar-inner.energy {
  background: linear-gradient(90deg, #8b5cf6 0%, #a78bfa 100%);
}

.stat-value {
  font-size: 12px;
  font-weight: 600;
  color: #e2e8f0;
  min-width: 60px;
  text-align: right;
}

/* Right Buttons */
.hud-right {
  flex: 0 0 auto;
  display: flex;
  gap: 8px;
}

.hud-btn {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
  border: 2px solid rgba(74, 222, 128, 0.3);
  color: #e2e8f0;
  padding: 10px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s ease;
}

.hud-btn:hover {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.15) 100%);
  border-color: #4ade80;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

.hud-btn span {
  display: inline;
}

/* Map Display */
.map-display {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: #000;
}

#game-canvas {
  width: 100%;
  height: 100%;
  display: block;
  cursor: grab;
}

#game-canvas:active {
  cursor: grabbing;
}

/* Map Controls */
.map-controls {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 5;
}

.map-control-btn {
  width: 44px;
  height: 44px;
  background: rgba(15, 23, 42, 0.9);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 8px;
  color: #e2e8f0;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.map-control-btn:hover {
  background: rgba(74, 222, 128, 0.2);
  border-color: #4ade80;
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
}

/* Tile Info */
.tile-info {
  position: absolute;
  bottom: 120px;
  left: 20px;
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 12px;
  padding: 16px;
  min-width: 220px;
  max-width: 300px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 5;
}

.tile-info-content h4 {
  margin: 0 0 8px 0;
  font-size: 16px;
  color: #4ade80;
}

.tile-info-content p {
  margin: 4px 0;
  font-size: 13px;
  color: #cbd5e1;
}

.tile-info-content strong {
  color: #e2e8f0;
}

/* Tutorial Hint */
.tutorial-hint {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid rgba(74, 222, 128, 0.3);
  border-radius: 12px;
  padding: 12px 20px;
  display: flex;
  gap: 20px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  animation: slideDown 0.5s ease, fadeOutSlow 1s ease 8s forwards;
  z-index: 5;
}

.tutorial-hint p {
  margin: 0;
  font-size: 14px;
  color: #e2e8f0;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

@keyframes fadeOutSlow {
  to {
    opacity: 0;
    pointer-events: none;
  }
}

/* Action Log */
.action-log {
  background: rgba(15, 23, 42, 0.95);
  border-top: 2px solid rgba(74, 222, 128, 0.3);
  padding: 12px 20px;
  height: 120px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  z-index: 10;
}

.action-log h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #4ade80;
  display: flex;
  align-items: center;
  gap: 6px;
}

.log-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  font-size: 13px;
  line-height: 1.6;
}

.log-entry {
  margin: 2px 0;
  color: #cbd5e1;
  padding: 4px 0;
  animation: fadeIn 0.3s ease;
}

.log-entry:last-child {
  color: #e2e8f0;
  font-weight: 500;
}

/* Scrollbar */
.log-content::-webkit-scrollbar {
  width: 8px;
}

.log-content::-webkit-scrollbar-track {
  background: rgba(30, 41, 59, 0.5);
  border-radius: 4px;
}

.log-content::-webkit-scrollbar-thumb {
  background: rgba(74, 222, 128, 0.3);
  border-radius: 4px;
}

.log-content::-webkit-scrollbar-thumb:hover {
  background: rgba(74, 222, 128, 0.5);
}

/* Responsive */
@media (max-width: 1200px) {
  .hud-btn span {
    display: none;
  }
  
  .hud-btn {
    padding: 10px;
  }
  
  .stat-label {
    min-width: 70px;
    font-size: 13px;
  }
}

@media (max-width: 768px) {
  .game-hud {
    flex-wrap: wrap;
    padding: 10px;
  }
  
  .hud-center {
    order: 3;
    width: 100%;
    max-width: 100%;
    flex-wrap: wrap;
    gap: 10px;
  }
  
  .stat-bar {
    min-width: calc(50% - 5px);
  }
  
  .tutorial-hint {
    flex-direction: column;
    gap: 8px;
    padding: 10px 16px;
  }
  
  .action-log {
    height: 80px;
  }
}

/* Game Menu Modal */
.game-menu-modal .modal-body {
  padding: 30px;
}

.game-menu-buttons {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 15px;
  margin-bottom: 30px;
}

.menu-action-btn {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.15) 0%, rgba(74, 222, 128, 0.05) 100%);
  border: 2px solid rgba(74, 222, 128, 0.3);
  color: #e2e8f0;
  padding: 16px 20px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.menu-action-btn:hover {
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.25) 0%, rgba(74, 222, 128, 0.15) 100%);
  border-color: #4ade80;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

.menu-action-btn.danger {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(239, 68, 68, 0.05) 100%);
  border-color: rgba(239, 68, 68, 0.3);
}

.menu-action-btn.danger:hover {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.25) 0%, rgba(239, 68, 68, 0.15) 100%);
  border-color: #ef4444;
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.save-info {
  background: rgba(30, 41, 59, 0.5);
  border: 2px solid rgba(74, 222, 128, 0.2);
  border-radius: 10px;
  padding: 20px;
  text-align: center;
}

.save-info h4 {
  margin: 0 0 10px 0;
  color: #4ade80;
  font-size: 18px;
}

.save-info p {
  margin: 5px 0;
  color: #cbd5e1;
  font-size: 14px;
}

/* Save List in Load Menu */
.save-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 400px;
  overflow-y: auto;
}

.save-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(30, 41, 59, 0.5);
  border: 2px solid rgba(74, 222, 128, 0.2);
  border-radius: 8px;
  padding: 15px;
  transition: all 0.2s ease;
}

.save-item:hover {
  border-color: rgba(74, 222, 128, 0.4);
  background: rgba(30, 41, 59, 0.7);
}

.save-item .save-info {
  background: none;
  border: none;
  padding: 0;
  text-align: left;
}

.save-item .save-info h4 {
  margin: 0 0 5px 0;
  font-size: 16px;
}

.save-item .save-info p {
  margin: 2px 0;
  font-size: 13px;
}

.save-date {
  color: #94a3b8;
  font-size: 12px !important;
}

.save-actions {
  display: flex;
  gap: 8px;
}

.btn-load-game {
  background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
  border: none;
  color: #000;
  padding: 8px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
}

.btn-load-game:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
}

.no-saves {
  text-align: center;
  padding: 40px;
  color: #94a3b8;
  font-size: 16px;
}
/**
 * Save Manager UI - Comprehensive Save/Load System
 * Modern list-based interface with inline editing and no popups
 */

/* Save Manager Modal */
.save-manager-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  padding: 20px;
  animation: fadeIn 0.2s ease;
}

.save-manager-container {
  width: 100%;
  max-width: 1200px;
  max-height: 90vh;
  background: rgba(11, 15, 20, 0.95);
  border: 1px solid #1c2738;
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header */
.save-manager-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, rgba(20, 32, 53, 0.8), rgba(14, 22, 35, 0.8));
  border-bottom: 1px solid #1c2738;
}

.save-manager-title {
  display: flex;
  align-items: center;
  gap: 12px;
}

.save-manager-logo {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: linear-gradient(160deg, #3dd6ed, #8b5cf6);
  box-shadow: 0 2px 12px rgba(61, 214, 237, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

.save-manager-title h2 {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
  color: #e8f0f7;
}

.save-manager-subtitle {
  font-size: 12px;
  color: #8aa1b4;
  margin-top: 2px;
}

.save-manager-close {
  background: transparent;
  border: 1px solid #1c2738;
  color: #8aa1b4;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
  transition: all 0.2s ease;
}

.save-manager-close:hover {
  background: rgba(255, 93, 122, 0.1);
  border-color: #ff5d7a;
  color: #ff5d7a;
}

/* Top Actions */
.save-manager-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 16px 20px;
  background: rgba(15, 22, 35, 0.5);
  border-bottom: 1px solid #1c2738;
}

.sm-btn {
  padding: 10px 16px;
  border: 1px solid #1c2738;
  background: linear-gradient(180deg, #142035, #0e1623);
  color: #e8f0f7;
  border-radius: 10px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 6px;
}

.sm-btn:hover {
  transform: translateY(-1px);
  border-color: #2a3a53;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.sm-btn.primary {
  background: linear-gradient(180deg, #1a2b43, #15243a);
  border-color: #284162;
}

.sm-btn.accent {
  background: linear-gradient(180deg, #0bbbd1, #0aa1b5);
  border-color: #0b8ea0;
  color: #001318;
  font-weight: 700;
}

.sm-btn.success {
  background: linear-gradient(180deg, #20d2a0, #10b37f);
  border-color: #0f9e70;
  color: #05231b;
  font-weight: 700;
}

.sm-btn.danger {
  background: linear-gradient(180deg, #ff7a92, #ff5d7a);
  border-color: #f54e69;
  color: #4a0713;
  font-weight: 700;
}

.sm-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

/* Toolbar */
.save-manager-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  background: rgba(14, 21, 34, 0.8);
  border-bottom: 1px solid #1c2738;
  gap: 12px;
  flex-wrap: wrap;
}

.save-tab-group {
  display: inline-flex;
  border: 1px solid #1c2738;
  border-radius: 10px;
  overflow: hidden;
  background: #0f1623;
}

.save-tab {
  padding: 8px 16px;
  background: transparent;
  border: none;
  color: #8aa1b4;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s ease;
}

.save-tab.active {
  background: linear-gradient(180deg, #1a2a3f, #122136);
  color: #dff7ff;
}

.save-search-box {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #0f1623;
  border: 1px solid #1c2738;
  border-radius: 10px;
  padding: 8px 12px;
  flex: 1;
  min-width: 200px;
  max-width: 400px;
}

.save-search-icon {
  color: #8aa1b4;
  font-size: 14px;
}

.save-search-box input {
  background: transparent;
  border: none;
  outline: none;
  color: #e8f0f7;
  width: 100%;
  font-size: 13px;
}

.save-search-box input::placeholder {
  color: #8aa1b4;
}

/* Save List Table */
.save-list-container {
  flex: 1;
  overflow-y: auto;
  overflow-x: auto;
}

.save-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  min-width: 900px;
}

.save-table thead {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #0e1522;
}

.save-table th {
  padding: 12px 12px;
  text-align: left;
  font-size: 12px;
  font-weight: 600;
  color: #8aa1b4;
  border-bottom: 1px solid #1c2738;
  white-space: nowrap;
}

.save-table th.sortable {
  cursor: pointer;
  user-select: none;
}

.save-table th.sortable:hover {
  color: #dff7ff;
}

.sort-arrow {
  display: inline-block;
  margin-left: 4px;
  opacity: 0.4;
  font-size: 10px;
}

.save-table th.sorted .sort-arrow {
  opacity: 1;
  color: #3dd6ed;
}

.save-table tbody tr {
  background: #0f1623;
  transition: all 0.15s ease;
}

.save-table tbody tr:nth-child(2n) {
  background: #121b2b;
}

.save-table tbody tr:hover {
  background: rgba(61, 214, 237, 0.05);
}

.save-table tbody tr.selected {
  outline: 2px solid #3dd6ed;
  outline-offset: -2px;
  background: rgba(61, 214, 237, 0.08);
}

.save-table tbody tr.create-row {
  background: linear-gradient(90deg, rgba(61, 214, 237, 0.06), transparent);
  cursor: pointer;
}

.save-table tbody tr.create-row:hover {
  background: linear-gradient(90deg, rgba(61, 214, 237, 0.12), transparent);
}

.save-table td {
  padding: 12px;
  border-bottom: 1px solid #1c2738;
  font-size: 13px;
  color: #e8f0f7;
  vertical-align: middle;
}

.save-table td.meta {
  color: #8aa1b4;
  font-size: 12px;
}

.save-name-cell {
  display: flex;
  align-items: center;
  gap: 8px;
}

.save-name-input {
  background: rgba(15, 22, 35, 0.8);
  border: 1px solid #1c2738;
  color: #e8f0f7;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 13px;
  flex: 1;
  min-width: 120px;
}

.save-name-input:focus {
  outline: none;
  border-color: #3dd6ed;
  background: rgba(61, 214, 237, 0.05);
}

.save-tag {
  display: inline-block;
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 500;
  border: 1px solid #1c2738;
  background: #101a2a;
  color: #bcd2e6;
}

.save-tag.auto {
  background: #0e1c2e;
  border-color: #1f2b46;
  color: #b9c9ff;
}

.save-tag.quick {
  background: #0e2e1c;
  border-color: #1f462b;
  color: #b9ffc9;
}

.create-save-link {
  color: #3dd6ed;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
}

.create-save-link:hover {
  color: #5ee5f5;
}

/* Action buttons in table */
.save-row-actions {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
}

.save-action-btn {
  padding: 6px 12px;
  border: 1px solid #1c2738;
  background: linear-gradient(180deg, #142035, #0e1623);
  color: #e8f0f7;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.15s ease;
}

.save-action-btn:hover {
  border-color: #2a3a53;
  transform: translateY(-1px);
}

.save-action-btn.load {
  background: linear-gradient(180deg, #20d2a0, #10b37f);
  border-color: #0f9e70;
  color: #05231b;
  font-weight: 600;
}

.save-action-btn.delete {
  background: linear-gradient(180deg, #ff7a92, #ff5d7a);
  border-color: #f54e69;
  color: #fff;
  font-weight: 600;
  width: 32px;
  padding: 6px;
}

.save-action-btn.export {
  background: linear-gradient(180deg, #0bbbd1, #0aa1b5);
  border-color: #0b8ea0;
  color: #001318;
  font-weight: 600;
}

/* Footer */
.save-manager-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: rgba(14, 21, 34, 0.8);
  border-top: 1px solid #1c2738;
  font-size: 12px;
  color: #8aa1b4;
  flex-wrap: wrap;
  gap: 12px;
}

.save-footer-hint {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.kbd {
  padding: 2px 6px;
  border: 1px solid #334155;
  border-bottom-width: 2px;
  border-radius: 4px;
  background: #0c1421;
  color: #cfe5ff;
  font-size: 11px;
  font-family: monospace;
}

.save-count {
  color: #8aa1b4;
}

/* Empty state */
.save-list-empty {
  text-align: center;
  padding: 60px 20px;
  color: #8aa1b4;
}

.save-list-empty-icon {
  font-size: 48px;
  opacity: 0.3;
  margin-bottom: 16px;
}

.save-list-empty-text {
  font-size: 16px;
  margin-bottom: 8px;
}

.save-list-empty-hint {
  font-size: 13px;
  opacity: 0.7;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .save-manager-container {
    max-width: 100%;
    max-height: 100vh;
    border-radius: 0;
  }

  .save-manager-actions {
    padding: 12px;
  }

  .sm-btn {
    padding: 8px 12px;
    font-size: 12px;
  }

  .save-table {
    font-size: 12px;
  }

  .save-table th,
  .save-table td {
    padding: 8px;
  }

  .save-row-actions {
    flex-direction: column;
  }

  .save-search-box {
    min-width: 150px;
  }

  .save-footer-hint {
    display: none;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/**
 * Options Menu Styles
 * Quick access overlay menu
 */

.options-menu-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9998;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease;
}

.options-menu-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.options-menu-container {
  background: linear-gradient(135deg, rgba(17, 24, 38, 0.98), rgba(11, 15, 20, 0.98));
  border: 2px solid #1c2738;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
  padding: 32px;
  max-width: 600px;
  width: 100%;
  animation: slideUp 0.3s ease;
}

.options-menu-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 28px;
  padding-bottom: 20px;
  border-bottom: 1px solid #1c2738;
}

.options-menu-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  color: #e8f0f7;
  display: flex;
  align-items: center;
  gap: 12px;
}

.options-close-btn {
  background: rgba(15, 22, 35, 0.8);
  border: 1px solid #1c2738;
  color: #8aa1b4;
  width: 36px;
  height: 36px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 20px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.options-close-btn:hover {
  background: rgba(255, 93, 122, 0.1);
  border-color: #ff5d7a;
  color: #ff5d7a;
  transform: scale(1.05);
}

/* Options Grid */
.options-menu-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

.option-card {
  background: linear-gradient(135deg, rgba(20, 32, 53, 0.6), rgba(14, 22, 35, 0.6));
  border: 2px solid #1c2738;
  border-radius: 16px;
  padding: 24px 20px;
  cursor: pointer;
  transition: all 0.25s ease;
  text-align: center;
  position: relative;
  overflow: hidden;
}

.option-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(61, 214, 237, 0.05), rgba(139, 92, 246, 0.05));
  opacity: 0;
  transition: opacity 0.25s ease;
}

.option-card:hover::before {
  opacity: 1;
}

.option-card:hover {
  border-color: #3dd6ed;
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(61, 214, 237, 0.2);
}

.option-card:active {
  transform: translateY(-2px);
}

.option-icon {
  font-size: 48px;
  margin-bottom: 12px;
  filter: drop-shadow(0 2px 8px rgba(61, 214, 237, 0.3));
}

.option-title {
  font-size: 16px;
  font-weight: 600;
  color: #e8f0f7;
  margin-bottom: 6px;
}

.option-desc {
  font-size: 12px;
  color: #8aa1b4;
  line-height: 1.4;
}

/* Specific card hover effects */
.option-card:nth-child(1):hover {
  border-color: #3dd6ed;
  box-shadow: 0 8px 24px rgba(61, 214, 237, 0.25);
}

.option-card:nth-child(2):hover {
  border-color: #8b5cf6;
  box-shadow: 0 8px 24px rgba(139, 92, 246, 0.25);
}

.option-card:nth-child(3):hover {
  border-color: #ff5d7a;
  box-shadow: 0 8px 24px rgba(255, 93, 122, 0.25);
}

.option-card:nth-child(4):hover {
  border-color: #1bc97c;
  box-shadow: 0 8px 24px rgba(27, 201, 124, 0.25);
}

/* Mobile responsiveness */
@media (max-width: 640px) {
  .options-menu-container {
    padding: 24px;
    max-width: 100%;
  }

  .options-menu-grid {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .option-card {
    padding: 20px 16px;
  }

  .option-icon {
    font-size: 40px;
  }

  .option-title {
    font-size: 15px;
  }

  .option-desc {
    font-size: 11px;
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* ============================================
   INVENTORY UI - ELEGANT MULTI-PANEL DESIGN
   ============================================ */

/* Overlay */
.inventory-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(4px);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Main Modal */
.inventory-modal {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #0f3460;
  border-radius: 12px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  color: #e0e0e0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateY(-50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Header */
.inventory-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 25px;
  border-bottom: 2px solid #0f3460;
  background: linear-gradient(to right, #1a1a2e, #0f3460);
}

.inventory-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  letter-spacing: 2px;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

.inventory-close {
  background: none;
  border: none;
  font-size: 36px;
  color: #e0e0e0;
  cursor: pointer;
  padding: 0;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.2s;
}

.inventory-close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #ff6b6b;
  transform: rotate(90deg);
}

/* Content Area */
.inventory-content {
  display: flex;
  padding: 20px;
  gap: 20px;
  flex: 1;
  overflow: hidden;
}

/* ============================================
   EQUIPMENT PANEL (LEFT)
   ============================================ */

.equipment-panel {
  flex: 0 0 200px;
  background: rgba(15, 52, 96, 0.3);
  border: 1px solid #0f3460;
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.equipment-panel h3 {
  margin: 0 0 10px 0;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 1px;
  color: #4dd0e1;
  text-align: center;
  border-bottom: 1px solid #0f3460;
  padding-bottom: 10px;
}

.equipment-slot-container {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.equipment-label {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  color: #9e9e9e;
  text-transform: uppercase;
}

.equipment-slot {
  width: 100%;
  height: 80px;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #0f3460;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}

.equipment-slot:hover {
  border-color: #4dd0e1;
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.3);
  transform: translateY(-2px);
}

.equipment-placeholder {
  font-size: 36px;
  opacity: 0.3;
  filter: grayscale(100%);
}

.equipment-icon {
  font-size: 48px;
  animation: equipPop 0.3s ease-out;
}

@keyframes equipPop {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}

.equipment-border {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 3px solid;
  border-radius: 6px;
  pointer-events: none;
  box-shadow: inset 0 0 10px currentColor;
}

/* ============================================
   GRID PANEL (CENTER)
   ============================================ */

.grid-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 8px;
  flex: 1;
}

.inventory-slot {
  aspect-ratio: 1;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #0f3460;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}

.inventory-slot:hover {
  border-color: #4dd0e1;
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.3);
  transform: scale(1.05);
}

.inventory-slot.selected {
  border-color: #ffd700;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
  background: rgba(255, 215, 0, 0.1);
}

.inventory-slot.dragging {
  opacity: 0.5;
}

.slot-icon {
  font-size: 42px;
  display: none;
  pointer-events: none;
}

.slot-count {
  position: absolute;
  bottom: 4px;
  right: 6px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 3px;
  display: none;
  pointer-events: none;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.slot-border {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 3px solid;
  border-radius: 6px;
  pointer-events: none;
  display: none;
  box-shadow: inset 0 0 10px currentColor;
}

/* Weight Bar */
.weight-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.weight-label {
  font-size: 14px;
  font-weight: 600;
  color: #e0e0e0;
  text-align: center;
}

.weight-bar-bg {
  width: 100%;
  height: 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid #0f3460;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.weight-bar-fill {
  height: 100%;
  background: #2ecc71;
  transition: width 0.3s ease, background-color 0.3s ease;
  border-radius: 10px;
  box-shadow: 0 0 10px currentColor;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
}

.inventory-button {
  padding: 10px 20px;
  background: linear-gradient(135deg, #0f3460, #1a1a2e);
  border: 1px solid #4dd0e1;
  border-radius: 6px;
  color: #e0e0e0;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.inventory-button:hover {
  background: linear-gradient(135deg, #4dd0e1, #0f3460);
  box-shadow: 0 0 15px rgba(77, 208, 225, 0.5);
  transform: translateY(-2px);
}

.inventory-button:active {
  transform: translateY(0);
}

/* ============================================
   DETAILS PANEL (BOTTOM)
   ============================================ */

.details-panel {
  border-top: 2px solid #0f3460;
  padding: 20px 25px;
  background: rgba(15, 52, 96, 0.2);
  min-height: 140px;
  display: flex;
  align-items: center;
}

.details-empty {
  width: 100%;
  text-align: center;
  color: #9e9e9e;
  font-style: italic;
  font-size: 16px;
}

.details-content {
  width: 100%;
  display: none;
  gap: 20px;
  align-items: flex-start;
}

.details-icon {
  font-size: 64px;
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 3px solid;
  border-radius: 8px;
  flex-shrink: 0;
  box-shadow: inset 0 0 15px currentColor;
}

.details-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.details-name {
  font-size: 22px;
  font-weight: 700;
  letter-spacing: 1px;
  text-shadow: 0 0 10px currentColor;
}

.details-description {
  font-size: 14px;
  color: #b0b0b0;
  line-height: 1.5;
}

.details-durability {
  font-size: 13px;
  font-family: 'Courier New', monospace;
  color: #4dd0e1;
  letter-spacing: 1px;
}

.details-effects {
  font-size: 14px;
  color: #ffd700;
  font-weight: 600;
}

.details-buttons {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0;
}

.details-buttons .inventory-button {
  min-width: 120px;
}

/* ============================================
   RESPONSIVE DESIGN
   ============================================ */

@media (max-width: 768px) {
  .inventory-modal {
    width: 95%;
    max-height: 95vh;
  }

  .inventory-content {
    flex-direction: column;
    overflow-y: auto;
  }

  .equipment-panel {
    flex: 0 0 auto;
    flex-direction: row;
    flex-wrap: wrap;
  }

  .equipment-slot-container {
    flex: 1;
    min-width: 100px;
  }

  .inventory-grid {
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
  }

  .details-content {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .details-buttons {
    flex-direction: row;
    width: 100%;
  }

  .details-buttons .inventory-button {
    flex: 1;
  }
}

/* ============================================
   ANIMATIONS & EFFECTS
   ============================================ */

@keyframes itemAdd {
  0% {
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
  50% {
    transform: scale(1.3) rotate(-10deg);
  }
  100% {
    transform: scale(1) rotate(0);
    opacity: 1;
  }
}

@keyframes itemRemove {
  0% {
    transform: scale(1) rotate(0);
    opacity: 1;
  }
  100% {
    transform: scale(0) rotate(180deg);
    opacity: 0;
  }
}

/* Glow effect for rare items */
@keyframes rarityGlow {
  0%, 100% {
    box-shadow: 0 0 5px currentColor;
  }
  50% {
    box-shadow: 0 0 20px currentColor;
  }
}

.slot-border,
.equipment-border {
  animation: rarityGlow 2s ease-in-out infinite;
}

/* ============================================
   SCROLLBAR STYLING
   ============================================ */

.inventory-content::-webkit-scrollbar {
  width: 8px;
}

.inventory-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.inventory-content::-webkit-scrollbar-thumb {
  background: #0f3460;
  border-radius: 4px;
}

.inventory-content::-webkit-scrollbar-thumb:hover {
  background: #4dd0e1;
}
/* ============================================
   RESOURCE GATHERING UI
   ============================================ */

/* Gathering Overlay */
.gathering-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1100;
  animation: fadeIn 0.2s ease-out;
}

/* Gathering Modal */
.gathering-modal {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #0f3460;
  border-radius: 16px;
  padding: 30px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    transform: translateY(30px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Resource Info */
.gathering-info {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-bottom: 25px;
  padding-bottom: 20px;
  border-bottom: 2px solid rgba(77, 208, 225, 0.3);
}

.gathering-icon {
  font-size: 64px;
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 3px solid #4dd0e1;
  border-radius: 12px;
  box-shadow: 0 0 20px rgba(77, 208, 225, 0.3);
}

.gathering-name {
  flex: 1;
  font-size: 28px;
  font-weight: 700;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

/* Progress Bar */
.gathering-progress-container {
  margin-bottom: 20px;
}

.gathering-progress-label {
  font-size: 14px;
  font-weight: 600;
  color: #e0e0e0;
  margin-bottom: 10px;
  text-align: center;
  letter-spacing: 1px;
  text-transform: uppercase;
}

.gathering-progress-bg {
  width: 100%;
  height: 30px;
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid #0f3460;
  border-radius: 15px;
  overflow: hidden;
  position: relative;
}

.gathering-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #26c6da 100%);
  border-radius: 15px;
  transition: width 0.1s linear;
  box-shadow: 0 0 20px rgba(77, 208, 225, 0.5);
  position: relative;
  overflow: hidden;
}

/* Progress shimmer effect */
.gathering-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.5),
    transparent
  );
  animation: progressShimmer 1.5s infinite;
}

@keyframes progressShimmer {
  0% {
    left: -100%;
  }
  100% {
    left: 100%;
  }
}

/* Details */
.gathering-details {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
}

.detail-label {
  color: #9e9e9e;
  font-weight: 600;
}

.detail-value {
  color: #4dd0e1;
  font-weight: 700;
}

/* Cancel Button */
.gathering-cancel {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  border: 2px solid #e74c3c;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.gathering-cancel:hover {
  background: linear-gradient(135deg, #c0392b, #a93226);
  box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
  transform: translateY(-2px);
}

/* ============================================
   NODE INSPECTOR (Near Node Info)
   ============================================ */

.node-inspector {
  position: fixed;
  bottom: 150px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(26, 26, 46, 0.98) 0%, rgba(15, 52, 96, 0.98) 100%);
  border: 2px solid rgba(77, 208, 225, 0.6);
  border-radius: 12px;
  padding: 20px;
  min-width: 350px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 800;
  animation: inspectorSlideUp 0.3s ease-out;
}

@keyframes inspectorSlideUp {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* Inspector Header */
.inspector-header {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 15px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(77, 208, 225, 0.3);
}

.inspector-icon {
  font-size: 48px;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
}

.inspector-name {
  flex: 1;
  font-size: 20px;
  font-weight: 700;
  color: #4dd0e1;
  text-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
}

.inspector-quality {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.inspector-quality.poor {
  background: rgba(158, 158, 158, 0.3);
  color: #9e9e9e;
}

.inspector-quality.normal {
  background: rgba(46, 204, 113, 0.3);
  color: #2ecc71;
}

.inspector-quality.rich {
  background: rgba(52, 152, 219, 0.3);
  color: #3498db;
}

.inspector-quality.abundant {
  background: rgba(155, 89, 182, 0.3);
  color: #9b59b6;
}

/* Inspector State */
.inspector-state {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.state-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 1px;
}

.state-badge.full {
  background: rgba(46, 204, 113, 0.3);
  color: #2ecc71;
}

.state-badge.depleted {
  background: rgba(231, 76, 60, 0.3);
  color: #e74c3c;
}

.state-badge.regenerating {
  background: rgba(241, 196, 15, 0.3);
  color: #f1c40f;
}

.regen-progress {
  font-size: 12px;
  color: #f1c40f;
  font-weight: 600;
}

/* Inspector Details */
.inspector-details {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 15px;
}

.inspector-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  padding: 6px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
}

.inspector-label {
  color: #9e9e9e;
  font-weight: 600;
}

.inspector-value {
  color: #e0e0e0;
  font-weight: 700;
}

/* Inspector Action */
.inspector-action {
  margin-top: 15px;
}

.inspector-button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #4dd0e1, #26c6da);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
  animation: buttonPulse 2s ease-in-out infinite;
}

@keyframes buttonPulse {
  0%, 100% {
    box-shadow: 0 0 10px rgba(77, 208, 225, 0.3);
  }
  50% {
    box-shadow: 0 0 25px rgba(77, 208, 225, 0.6);
  }
}

.inspector-button:hover {
  background: linear-gradient(135deg, #26c6da, #00acc1);
  transform: translateY(-2px);
  box-shadow: 0 0 30px rgba(77, 208, 225, 0.8);
}

.inspector-error {
  text-align: center;
  padding: 12px;
  background: rgba(231, 76, 60, 0.2);
  border: 1px solid #e74c3c;
  border-radius: 8px;
  color: #e74c3c;
  font-size: 14px;
  font-weight: 600;
}

/* ============================================
   GATHERING NOTIFICATIONS
   ============================================ */

.gathering-notification {
  position: fixed;
  top: 100px;
  right: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid;
  border-radius: 12px;
  padding: 20px 25px;
  min-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  z-index: 1200;
  transform: translateX(400px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

.gathering-notification.show {
  transform: translateX(0);
  opacity: 1;
}

.gathering-notification.success {
  border-color: #2ecc71;
  box-shadow: 0 8px 32px rgba(46, 204, 113, 0.4);
}

.gathering-notification.error {
  border-color: #e74c3c;
  box-shadow: 0 8px 32px rgba(231, 76, 60, 0.4);
}

.gathering-notification.info {
  border-color: #3498db;
  box-shadow: 0 8px 32px rgba(52, 152, 219, 0.4);
}

.notification-title {
  font-size: 18px;
  font-weight: 700;
  color: #4dd0e1;
  margin-bottom: 8px;
  letter-spacing: 1px;
}

.notification-message {
  font-size: 14px;
  color: #e0e0e0;
  line-height: 1.5;
  white-space: pre-line;
}

/* ============================================
   MOBILE RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
  .gathering-modal {
    min-width: 90vw;
    padding: 20px;
  }

  .gathering-icon {
    font-size: 48px;
    width: 60px;
    height: 60px;
  }

  .gathering-name {
    font-size: 22px;
  }

  .node-inspector {
    bottom: 100px;
    min-width: 90vw;
    padding: 15px;
  }

  .gathering-notification {
    right: 10px;
    left: 10px;
    min-width: auto;
  }
}
/**
 * Crafting UI Styles
 * Beautiful dark-themed crafting interface with smooth animations
 */

/* Modal Overlay */
.crafting-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10000;
  display: flex;
  justify-content: center;
  align-items: center;
  animation: fadeIn 0.3s ease;
}

.crafting-modal.hidden {
  display: none;
}

.crafting-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
}

/* Main Window */
.crafting-window {
  position: relative;
  width: 90%;
  max-width: 1200px;
  height: 85vh;
  max-height: 800px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: slideUp 0.3s ease;
}

/* Header */
.crafting-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  background: linear-gradient(135deg, #0f3460 0%, #1a1a2e 100%);
  border-bottom: 2px solid #4dd0e1;
}

.crafting-header h2 {
  margin: 0;
  color: #4dd0e1;
  font-size: 24px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 2px 8px rgba(77, 208, 225, 0.3);
}

.close-btn {
  background: transparent;
  border: 2px solid #4dd0e1;
  color: #4dd0e1;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.close-btn:hover {
  background: #4dd0e1;
  color: #1a1a2e;
  transform: rotate(90deg);
}

/* Content Area */
.crafting-content {
  display: grid;
  grid-template-columns: 200px 1fr 350px;
  gap: 20px;
  padding: 20px;
  flex: 1;
  overflow: hidden;
}

/* Categories Panel */
.crafting-categories {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.crafting-categories h3 {
  color: #4dd0e1;
  font-size: 16px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin: 0 0 10px 0;
}

.category-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.category-btn {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: rgba(77, 208, 225, 0.1);
  border: 1px solid rgba(77, 208, 225, 0.3);
  border-radius: 8px;
  color: #e0e0e0;
  cursor: pointer;
  transition: all 0.3s;
  font-size: 14px;
}

.category-btn:hover {
  background: rgba(77, 208, 225, 0.2);
  border-color: #4dd0e1;
  transform: translateX(5px);
}

.category-btn.active {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-color: #667eea;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.category-icon {
  font-size: 20px;
}

.category-name {
  flex: 1;
  text-align: left;
}

.crafting-stats {
  margin-top: auto;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border: 1px solid rgba(77, 208, 225, 0.2);
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
}

.stat-item:last-child {
  margin-bottom: 0;
}

.stat-label {
  color: #b0b0b0;
}

.stat-value {
  color: #4dd0e1;
  font-weight: 600;
}

/* Recipe List Panel */
.crafting-recipes {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.recipes-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.recipes-header h3 {
  color: #4dd0e1;
  font-size: 18px;
  margin: 0;
}

.recipe-count {
  color: #b0b0b0;
  font-size: 13px;
}

.recipe-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-right: 10px;
}

/* Custom Scrollbar */
.recipe-list::-webkit-scrollbar,
.details-section::-webkit-scrollbar {
  width: 8px;
}

.recipe-list::-webkit-scrollbar-track,
.details-section::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

.recipe-list::-webkit-scrollbar-thumb,
.details-section::-webkit-scrollbar-thumb {
  background: #4dd0e1;
  border-radius: 4px;
}

.recipe-list::-webkit-scrollbar-thumb:hover,
.details-section::-webkit-scrollbar-thumb:hover {
  background: #667eea;
}

/* Recipe Item */
.recipe-item {
  display: grid;
  grid-template-columns: 40px 1fr 30px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  background: rgba(77, 208, 225, 0.05);
  border: 1px solid rgba(77, 208, 225, 0.2);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s;
}

.recipe-item:hover {
  background: rgba(77, 208, 225, 0.1);
  border-color: #4dd0e1;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(77, 208, 225, 0.2);
}

.recipe-item.selected {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
  border-color: #667eea;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.recipe-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.recipe-item.disabled:hover {
  transform: none;
  box-shadow: none;
}

.recipe-icon {
  font-size: 28px;
  text-align: center;
}

.recipe-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.recipe-name {
  color: #e0e0e0;
  font-size: 14px;
  font-weight: 600;
}

.recipe-difficulty {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.recipe-status {
  text-align: center;
  font-size: 18px;
}

.status-can-craft {
  color: #4ade80;
}

.status-cannot-craft {
  color: #f87171;
}

.no-recipes {
  padding: 40px;
  text-align: center;
  color: #b0b0b0;
  font-size: 14px;
}

/* Details Panel */
.crafting-details {
  display: flex;
  flex-direction: column;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(77, 208, 225, 0.2);
  border-radius: 8px;
  padding: 20px;
  overflow-y: auto;
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 15px;
}

.details-header h3 {
  color: #4dd0e1;
  font-size: 20px;
  margin: 0;
  flex: 1;
}

.difficulty-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  color: #000;
}

.details-description {
  color: #b0b0b0;
  font-size: 14px;
  line-height: 1.6;
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(77, 208, 225, 0.2);
}

.details-section {
  margin-bottom: 20px;
}

.details-section h4 {
  color: #4dd0e1;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin: 0 0 12px 0;
}

/* Requirements */
.requirements-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.requirement {
  display: grid;
  grid-template-columns: 30px 1fr auto;
  gap: 8px;
  align-items: center;
  padding: 8px;
  background: rgba(77, 208, 225, 0.05);
  border-radius: 6px;
  font-size: 13px;
}

.req-icon {
  text-align: center;
  font-size: 16px;
}

.req-label {
  color: #b0b0b0;
}

.req-value {
  font-weight: 600;
  text-align: right;
}

.req-value.available {
  color: #4ade80;
}

.req-value.unavailable {
  color: #f87171;
}

/* Ingredients */
.ingredients-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ingredient {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(77, 208, 225, 0.05);
  border-radius: 6px;
  border-left: 3px solid transparent;
  font-size: 13px;
}

.ingredient.available {
  border-left-color: #4ade80;
}

.ingredient.unavailable {
  border-left-color: #f87171;
}

.ingredient-name {
  color: #e0e0e0;
}

.ingredient-count {
  font-weight: 600;
}

.ingredient.available .ingredient-count {
  color: #4ade80;
}

.ingredient.unavailable .ingredient-count {
  color: #f87171;
}

/* Output */
.output-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.output-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(77, 208, 225, 0.1);
  border-radius: 6px;
  border-left: 3px solid #4dd0e1;
  font-size: 13px;
}

.output-name {
  color: #e0e0e0;
  font-weight: 600;
}

.output-quantity {
  color: #4dd0e1;
  font-weight: 600;
}

/* Details Footer */
.details-footer {
  display: flex;
  justify-content: space-around;
  padding: 15px 0;
  margin: 20px 0;
  border-top: 1px solid rgba(77, 208, 225, 0.2);
  border-bottom: 1px solid rgba(77, 208, 225, 0.2);
}

.craft-time,
.craft-xp {
  font-size: 14px;
  color: #b0b0b0;
  font-weight: 600;
}

/* Actions */
.details-actions {
  margin-top: auto;
}

.craft-btn {
  width: 100%;
  padding: 15px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  border-radius: 8px;
  color: white;
  font-size: 16px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s;
}

.craft-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.craft-btn:active {
  transform: translateY(0);
}

.craft-btn.disabled {
  background: rgba(180, 180, 180, 0.2);
  color: #999;
  cursor: not-allowed;
  box-shadow: none;
}

.craft-btn.disabled:hover {
  transform: none;
}

/* Empty State */
.details-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 20px;
}

.empty-icon {
  font-size: 64px;
  opacity: 0.3;
}

.empty-text {
  color: #b0b0b0;
  font-size: 16px;
}

/* Crafting Queue */
.crafting-queue {
  padding: 15px 20px;
  background: rgba(0, 0, 0, 0.3);
  border-top: 2px solid #4dd0e1;
}

.queue-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.queue-header h4 {
  color: #4dd0e1;
  font-size: 14px;
  text-transform: uppercase;
  margin: 0;
}

.queue-count {
  color: #b0b0b0;
  font-size: 12px;
}

.queue-items {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.queue-item {
  display: grid;
  grid-template-columns: 1fr auto 30px;
  gap: 15px;
  align-items: center;
  padding: 10px;
  background: rgba(77, 208, 225, 0.1);
  border-radius: 6px;
}

.queue-recipe {
  color: #e0e0e0;
  font-size: 13px;
  font-weight: 600;
}

.queue-progress {
  width: 200px;
  height: 6px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 3px;
  overflow: hidden;
}

.queue-progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #667eea 100%);
  transition: width 0.1s linear;
  position: relative;
  overflow: hidden;
}

.queue-progress-bar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.3) 50%,
    transparent 100%
  );
  animation: shimmer 2s infinite;
}

.queue-cancel {
  background: transparent;
  border: 1px solid #f87171;
  color: #f87171;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.queue-cancel:hover {
  background: #f87171;
  color: #fff;
}

/* Notifications */
.crafting-notification {
  position: fixed;
  top: 80px;
  right: -400px;
  padding: 15px 20px;
  background: rgba(26, 26, 46, 0.95);
  border-left: 4px solid #4dd0e1;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  color: #e0e0e0;
  font-size: 14px;
  z-index: 10001;
  transition: right 0.3s ease;
  max-width: 350px;
}

.crafting-notification.show {
  right: 20px;
}

.crafting-notification.success {
  border-left-color: #4ade80;
}

.crafting-notification.error {
  border-left-color: #f87171;
}

.crafting-notification.warning {
  border-left-color: #fbbf24;
}

.crafting-notification.info {
  border-left-color: #60a5fa;
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

/* Responsive */
@media (max-width: 1024px) {
  .crafting-content {
    grid-template-columns: 180px 1fr 300px;
  }
}

@media (max-width: 768px) {
  .crafting-window {
    width: 100%;
    height: 100vh;
    max-height: 100vh;
    border-radius: 0;
  }

  .crafting-content {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr;
  }

  .crafting-categories {
    flex-direction: row;
    overflow-x: auto;
  }

  .category-list {
    flex-direction: row;
  }

  .category-btn {
    flex-shrink: 0;
  }

  .crafting-stats {
    display: none;
  }

  .crafting-details {
    grid-row: 3;
  }
}
/**
 * Map Travel UI Styles
 * Beautiful travel interface with tooltips, notifications, and territory colors
 */

/* Hex Tooltip */
.hex-tooltip {
  position: absolute;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 12px;
  min-width: 200px;
  max-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  z-index: 10000;
  pointer-events: none;
  display: none;
  animation: tooltipFadeIn 0.2s ease-out;
  backdrop-filter: blur(10px);
}

@keyframes tooltipFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.tooltip-title {
  font-size: 16px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.tooltip-faction {
  font-size: 13px;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.tooltip-travel {
  font-size: 12px;
  color: #b0b0b0;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(77, 208, 225, 0.2);
  display: flex;
  gap: 12px;
}

.tooltip-error {
  font-size: 12px;
  color: #ff6b6b;
  margin-top: 8px;
  padding: 6px 8px;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 4px;
  border-left: 3px solid #ff6b6b;
}

.tooltip-feature {
  font-size: 12px;
  color: #4ade80;
  margin-top: 4px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* Travel Notifications */
.travel-notifications {
  position: fixed;
  top: 80px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.travel-notification {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 12px 20px;
  min-width: 250px;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  transform: translateX(450px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  font-size: 14px;
  color: #e0e0e0;
}

.travel-notification.show {
  transform: translateX(0);
  opacity: 1;
}

.travel-notification-info {
  border-color: #4dd0e1;
  color: #4dd0e1;
}

.travel-notification-success {
  border-color: #4ade80;
  color: #4ade80;
}

.travel-notification-warning {
  border-color: #fbbf24;
  color: #fbbf24;
}

.travel-notification-error {
  border-color: #ff6b6b;
  color: #ff6b6b;
}

/* Territory Legend (optional overlay) */
.territory-legend {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  padding: 16px;
  min-width: 200px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9998;
}

.territory-legend-title {
  font-size: 14px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.territory-legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
  font-size: 13px;
  color: #e0e0e0;
}

.territory-legend-color {
  width: 20px;
  height: 20px;
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Travel Progress Bar */
.travel-progress {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 25px;
  padding: 12px 24px;
  min-width: 300px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9999;
  display: none;
}

.travel-progress.active {
  display: block;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.travel-progress-text {
  font-size: 13px;
  color: #4dd0e1;
  margin-bottom: 8px;
  text-align: center;
  font-weight: bold;
}

.travel-progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(77, 208, 225, 0.2);
  border-radius: 4px;
  overflow: hidden;
}

.travel-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4dd0e1 0%, #00bcd4 100%);
  border-radius: 4px;
  transition: width 0.1s linear;
  box-shadow: 0 0 10px rgba(77, 208, 225, 0.5);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

/* Travel Stats Panel */
.travel-stats {
  position: fixed;
  top: 80px;
  left: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #4dd0e1;
  border-radius: 12px;
  padding: 16px;
  min-width: 220px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(10px);
  z-index: 9998;
}

.travel-stats-title {
  font-size: 14px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.travel-stat {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
  color: #e0e0e0;
}

.travel-stat-label {
  color: #b0b0b0;
}

.travel-stat-value {
  color: #4dd0e1;
  font-weight: bold;
}

/* Territory Control Indicator */
.territory-control {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 4px;
}

.territory-control-bar {
  flex: 1;
  height: 6px;
  background: rgba(77, 208, 225, 0.2);
  border-radius: 3px;
  overflow: hidden;
}

.territory-control-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s ease;
}

.territory-control-text {
  font-size: 11px;
  color: #b0b0b0;
  min-width: 40px;
  text-align: right;
}

/* Faction Encounter Modal */
.faction-encounter {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.faction-encounter.active {
  opacity: 1;
  pointer-events: all;
}

.faction-encounter-content {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 3px solid #4dd0e1;
  border-radius: 16px;
  padding: 32px;
  max-width: 600px;
  width: 90%;
  box-shadow: 0 16px 64px rgba(0, 0, 0, 0.9);
  transform: scale(0.9);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.faction-encounter.active .faction-encounter-content {
  transform: scale(1);
}

.faction-encounter-title {
  font-size: 24px;
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 16px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.faction-encounter-text {
  font-size: 16px;
  color: #e0e0e0;
  line-height: 1.6;
  margin-bottom: 24px;
  text-align: center;
}

.faction-encounter-choices {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.faction-encounter-choice {
  background: rgba(77, 208, 225, 0.1);
  border: 2px solid #4dd0e1;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
  color: #e0e0e0;
  text-align: left;
}

.faction-encounter-choice:hover {
  background: rgba(77, 208, 225, 0.2);
  transform: translateX(8px);
  box-shadow: 0 4px 16px rgba(77, 208, 225, 0.3);
}

.faction-encounter-choice-title {
  font-weight: bold;
  color: #4dd0e1;
  margin-bottom: 4px;
}

.faction-encounter-choice-description {
  font-size: 12px;
  color: #b0b0b0;
}

/* Discovery Animation */
.discovery-flash {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle, rgba(77, 208, 225, 0.3) 0%, transparent 70%);
  pointer-events: none;
  z-index: 9997;
  opacity: 0;
  animation: discoveryFlash 1s ease-out;
}

@keyframes discoveryFlash {
  0% {
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
  .hex-tooltip {
    min-width: 150px;
    max-width: 200px;
    padding: 8px;
  }

  .tooltip-title {
    font-size: 14px;
  }

  .travel-notifications {
    top: 60px;
    right: 10px;
    left: 10px;
  }

  .travel-notification {
    min-width: auto;
    max-width: none;
  }

  .territory-legend {
    bottom: 10px;
    right: 10px;
    padding: 12px;
    min-width: 150px;
  }

  .travel-stats {
    top: 60px;
    left: 10px;
    padding: 12px;
    min-width: 180px;
  }

  .faction-encounter-content {
    padding: 24px;
    width: 95%;
  }

  .faction-encounter-title {
    font-size: 20px;
  }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: light) {
  .hex-tooltip,
  .travel-notification,
  .territory-legend,
  .travel-stats,
  .faction-encounter-content {
    background: linear-gradient(135deg, #f0f0f5 0%, #e8e8f0 100%);
    color: #1a1a2e;
  }

  .tooltip-title,
  .territory-legend-title,
  .travel-stats-title,
  .faction-encounter-title {
    color: #0891b2;
  }

  .tooltip-travel,
  .travel-stat,
  .faction-encounter-text {
    color: #4a4a4a;
  }
}</style>
</head>
<body>
  <div id="app">
    <!-- Global Save Menu Button (always visible) -->
    <button id="global-menu-btn" class="global-menu-btn hidden" title="Save/Load Menu">
      ‚öôÔ∏è
    </button>
    
    <!-- Main Menu (shown on startup) -->
    <div id="main-menu" class="main-menu">
      <div class="menu-container">
        <h1 class="game-title">HEDONISM ISLAND</h1>
        <p class="game-subtitle">Survival ‚Ä¢ Romance ‚Ä¢ Degeneracy</p>
        
        <div class="menu-buttons">
          <button class="menu-btn" id="btn-continue">Continue</button>
          <button class="menu-btn" id="btn-new-game">New Game</button>
          <button class="menu-btn" id="btn-load">Load Game</button>
          <button class="menu-btn" id="btn-settings">Settings</button>
          <button class="menu-btn" id="btn-credits">Credits</button>
        </div>
        
        <p class="version-info">v1.0.0 - Alpha Build</p>
      </div>
    </div>
    
    <!-- Character Creation (shown after New Game) -->
    <div id="character-creation"></div>
    
    <!-- Story Intro (shown after character creation) -->
    <div id="story-intro" class="hidden"></div>
    
    <!-- Game View (shown after intro) -->
    <div id="game-view" class="hidden"></div>
  </div>
  
</body>
</html>
