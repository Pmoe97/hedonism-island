<!-- Top Bar -->
<div id="topBar" style="position:sticky; top:0; z-index:1000; display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background:#1a1a2e; color:white; box-shadow:0 2px 10px rgba(0,0,0,0.5);">
  <div style="display:flex; gap:20px; align-items:center;">
    <div>Cash: $<span id="cashEl">0</span></div>
    <div>$/sec: $<span id="cashPerSecEl">0</span></div>
    <div>Employees: <span id="employeeCountEl">0</span></div>
    <div>Products: <span id="productCountEl">0</span></div>
    <div id="game-time-display" style="font-size:0.9rem; opacity:0.9; border-left:1px solid rgba(255,255,255,0.2); padding-left:20px; margin-left:10px;">
      🌅 Loading...
    </div>
  </div>
  <div style="display:flex; gap:10px; align-items:center;">
    <a href="https://discord.com/invite/E6N9WKpGPA" target="_blank" rel="noopener noreferrer" style="background:transparent; border:none; color:#5865F2; cursor:pointer; display:flex; align-items:center; text-decoration:none;" title="Join our Discord">
      <svg width="24" height="24" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="currentColor"/>
      </svg>
    </a>
    <button id="settingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">⚙️</button>
  </div>
</div>

<!-- News Ticker -->
<div id="newsTicker" style="position:sticky; top:49px; z-index:999; background:#0f3460; color:#e94560; padding:8px 20px; white-space:nowrap; overflow:hidden; font-size:0.9rem;">
  <span id="newsContent">Welcome to your new business venture! Start clicking products to earn cash.</span>
</div>

<!-- Tab Navigation -->
<div id="tabNav" style="position:sticky; top:82px; z-index:998; display:flex; background:#16213e; padding:0; overflow-x:auto;">
  <button class="tab-btn active" data-tab="dashboard" style="padding:15px 20px; background:transparent; border:none; color:#e94560; cursor:pointer; font-weight:bold;">Dashboard</button>
  <button class="tab-btn" data-tab="business" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Business</button>
  <button class="tab-btn" data-tab="upgrades" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">⚡ Upgrades</button>
  <button class="tab-btn" data-tab="people" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">People</button>
  <button class="tab-btn" data-tab="social" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Social</button>
  <button class="tab-btn" data-tab="gifts" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Gifts</button>
  <button class="tab-btn" data-tab="hr" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">HR</button>
  <button class="tab-btn" data-tab="invest" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Invest</button>
  <button class="tab-btn" data-tab="ceocorner" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">👑 CEO Corner</button>
</div>

<!-- Main Content Area -->
<div id="mainContent" style="padding:20px; background:#0f1419; min-height:calc(100vh - 140px); color:white;">
  
  <!-- Dashboard Tab -->
  <div id="dashboardTab" class="tab-content active">
    <h2 style="margin-top:0;">📊 Command Center</h2>
    
    <!-- Top Stats Row - Key Metrics -->
    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:25px;">
      <!-- Cash -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(102,126,234,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">CURRENT CASH</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashCash">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">💰 <span id="dashCashPerSec">0</span>/sec</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">💵</div>
        </div>
      </div>
      
      <!-- Lifetime Earnings -->
      <div class="card dashboard-card" onclick="switchTab('invest')" style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(245,87,108,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">LIFETIME EARNINGS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashLifetimeEarnings">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">✨ Level <span id="dashPrestigeLevel">0</span> Prestige</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">🌟</div>
        </div>
      </div>
      
      <!-- Employees -->
      <div class="card dashboard-card" onclick="switchTab('people')" style="background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(79,172,254,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">EMPLOYEES</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashEmployeeCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">💼 <span id="dashManagerCount">0</span> Managers</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">👥</div>
        </div>
      </div>
      
      <!-- Products -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(67,233,123,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">PRODUCTS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashProductCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">📦 <span id="dashRunningProducts">0</span> Running</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">🏭</div>
        </div>
      </div>
    </div>
    
    <!-- Main Content Grid -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      
      <!-- Left Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Unread Messages -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#00d4ff;">💬 Recent Messages</h3>
            <button onclick="switchTab('people')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#00d4ff; cursor:pointer; font-size:0.85rem;">View All →</button>
          </div>
          <div id="dashRecentMessages" style="max-height:250px; overflow-y:auto;">
            <!-- Messages will be populated here -->
          </div>
        </div>
        
        <!-- Boss Fights Progress -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#e94560;">⚔️ Boss Fights</h3>
            <button onclick="switchTab('business')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#e94560; cursor:pointer; font-size:0.85rem;">View Map →</button>
          </div>
          <div id="dashBossProgress">
            <!-- Boss progress will be populated here -->
          </div>
        </div>
        
        <!-- Quick Stats -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#ffd700;">📈 Quick Stats</h3>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Locations</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashLocationCount">0</span>/<span id="dashTotalLocations">0</span></div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Avg Efficiency</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashEfficiency">100</span>%</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Influence Points</div>
              <div style="font-size:1.3rem; font-weight:600; color:#ffd700;"><span id="dashInfluencePoints">0</span> IP</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Income Bonus</div>
              <div style="font-size:1.3rem; font-weight:600; color:#4ecca3;"><span id="dashIncomeMultiplier">1.0</span>x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Right Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Social Feed Mentions -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#ff6b9d;">📱 @TheBoss Mentions</h3>
            <button onclick="switchTab('social')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#ff6b9d; cursor:pointer; font-size:0.85rem;">View Feed →</button>
          </div>
          <div id="dashSocialMentions" style="max-height:300px; overflow-y:auto;">
            <!-- Mentions will be populated here -->
          </div>
        </div>
        
        <!-- AI Quality Training Stats -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#c77dff;">🤖 AI Quality Training</h3>
            <button onclick="switchTab('social')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#c77dff; cursor:pointer; font-size:0.85rem;">Vote on Content →</button>
          </div>
          
          <!-- Summary Stats -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
            <div style="background:#0f3460; padding:12px; border-radius:8px; text-align:center;">
              <div style="color:#aaa; font-size:0.75rem; margin-bottom:4px;">TOTAL VOTES</div>
              <div style="font-size:1.5rem; font-weight:700; color:#c77dff;" id="dashTotalVotes">0</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px; text-align:center;">
              <div style="color:#aaa; font-size:0.75rem; margin-bottom:4px;">QUALITY SCORE</div>
              <div style="font-size:1.5rem; font-weight:700; color:#ffd700;" id="dashQualityScore">--%</div>
            </div>
          </div>
          
          <!-- Upvote/Downvote Breakdown -->
          <div style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:15px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <div style="display:flex; align-items:center; gap:6px;">
                <svg width="14" height="14" viewBox="0 0 24 24" style="transform:translateY(-1px);">
                  <path fill="#ff4500" d="M12 4l8 8h-6v8h-4v-8H4z"/>
                </svg>
                <span style="color:#ff4500; font-weight:600;">Upvotes</span>
              </div>
              <span style="font-weight:700; font-size:1.1rem;" id="dashUpvotes">0</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="display:flex; align-items:center; gap:6px;">
                <svg width="14" height="14" viewBox="0 0 24 24" style="transform:translateY(1px);">
                  <path fill="#7193ff" d="M12 20l-8-8h6V4h4v8h6z"/>
                </svg>
                <span style="color:#7193ff; font-weight:600;">Downvotes</span>
              </div>
              <span style="font-weight:700; font-size:1.1rem;" id="dashDownvotes">0</span>
            </div>
          </div>
          
          <!-- Content Type Breakdown -->
          <div style="background:#0f3460; padding:12px; border-radius:8px;">
            <div style="color:#aaa; font-size:0.8rem; margin-bottom:8px; font-weight:600;">VOTES BY TYPE</div>
            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="font-size:0.85rem;">📝 Posts</span>
              <span style="font-weight:600;" id="dashPostsVoted">0</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="font-size:0.85rem;">💬 Comments</span>
              <span style="font-weight:600;" id="dashCommentsVoted">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="font-size:0.85rem;">💭 Chats</span>
              <span style="font-weight:600;" id="dashChatsVoted">0</span>
            </div>
          </div>
        </div>
        
        <!-- Top Performers -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#4ecca3;">🏆 Top Performers</h3>
          </div>
          <div id="dashTopPerformers">
            <!-- Top performers will be populated here -->
          </div>
        </div>
        
        <!-- Company News -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#00d4ff;">📰 Company News</h3>
          <div id="newsFeed" style="max-height:250px; overflow-y:auto;">
            <!-- News items will be populated here -->
          </div>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Business Tab -->
  <div id="businessTab" class="tab-content" hidden>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Business Operations</h2>
      
      <!-- Upgrade Multiplier Toggle -->
      <div style="display:flex; align-items:center; gap:10px;">
        <span style="color:#aaa; font-size:0.9rem;">Bulk Buy:</span>
        <button id="upgradeMultiplierBtn" style="padding:8px 16px; background:#0f3460; border:2px solid #e94560; border-radius:6px; color:#e94560; cursor:pointer; font-weight:bold; min-width:80px;">
          x1
        </button>
      </div>
    </div>
    
    <!-- Location Subtabs -->
    <div id="locationSubtabs" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding-bottom:5px; border-bottom:2px solid #0f3460;">
      <!-- Location subtabs will be populated here -->
    </div>
    
    <!-- Current Location Info -->
    <div id="locationInfo" style="margin-bottom:20px; padding:15px; background:rgba(15, 52, 96, 0.3); border-radius:8px; border-left:4px solid #e94560; display:none;">
      <!-- Location description will be populated here -->
    </div>
    
    <!-- Products Section -->
    <div style="margin-top:20px;">
      <div id="productsList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Product cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Upgrades Tab -->
  <div id="upgradesTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">⚡ Global Upgrades</h2>
    <p style="color:#aaa; margin-bottom:30px;">Permanent upgrades that boost your entire operation. <span style="color:#ff6b6b;">⚠️ These reset on prestige!</span></p>
    
    <!-- Click Power Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <div>
          <h3 style="margin:0 0 5px 0;">👆 Click Power</h3>
          <p style="color:#aaa; margin:0; font-size:0.9rem;">Each upgrade reduces production time by -0.1 seconds per click</p>
        </div>
        <div style="text-align:right;">
          <div style="font-size:1.5rem; font-weight:bold; color:#4caf50;" id="clickPowerLevel">Level 0</div>
          <div style="color:#aaa; font-size:0.9rem;" id="clickPowerEffect">-1.0s per click</div>
        </div>
      </div>
      <button id="buyClickPowerBtn" style="width:100%; padding:15px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1.1rem;">
        Upgrade Click Power - <span id="clickPowerCost">$1,000</span>
      </button>
    </div>
    
    <!-- Income Boost Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">💰 Income Boost</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Permanently increase income for all products in a location. Each level provides less benefit.</p>
      <div id="incomeBoostList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Income boost buttons will be populated here -->
      </div>
    </div>
    
    <!-- Cost Reduction Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">💸 Cost Reduction</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Reduces ALL costs in a location: product unlocks, upgrades, manager hires & upgrades. Capped at 90%.</p>
      <div id="costReductionList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Cost reduction buttons will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- People Tab -->
  <div id="peopleTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Team Management</h2>
    
    <!-- Pyramid Button -->
    <div style="margin-bottom:15px;">
      <button onclick="openCorporatePyramidModal()" style="padding:12px 24px; background:linear-gradient(135deg, #ffd700, #ffed4e); border:none; border-radius:8px; color:#0f1419; cursor:pointer; font-weight:700; font-size:1rem; box-shadow:0 4px 12px rgba(255,215,0,0.3); display:inline-flex; align-items:center; gap:10px; transition:all 0.3s;"
           onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(255,215,0,0.5)';"
           onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(255,215,0,0.3)';">
        <span style="font-size:1.3rem;">🏢</span>
        <span>Corporate Pyramid</span>
      </button>
    </div>
    
    <!-- Sorting Controls -->
    <div style="background:#16213e; border-radius:10px; padding:15px; margin-bottom:20px; box-shadow:0 4px 10px rgba(0,0,0,0.2);">
      <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px;">
        <div style="display:flex; align-items:center; gap:8px;">
          <label style="color:#aaa; font-size:0.9rem; font-weight:600;">Sort By:</label>
          <select id="peopleSortSelect" style="padding:8px 12px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#fff; cursor:pointer; font-size:0.9rem;">
            <option value="newest">⏰ Newest First</option>
            <option value="oldest">📅 Oldest First</option>
            <option value="relationshipHigh">💖 Highest Relationship</option>
            <option value="relationshipLow">💔 Lowest Relationship</option>
            <option value="location">📍 By Location</option>
            <option value="name">🔤 Alphabetical</option>
          </select>
        </div>
        
        <div style="display:flex; align-items:center; gap:8px;">
          <button id="toggleFavoritesOnly" style="padding:8px 16px; background:#0f3460; border:1px solid #ffd700; border-radius:6px; color:#ffd700; cursor:pointer; font-size:0.9rem; font-weight:600; transition:all 0.3s;">
            ⭐ Show Favorites Only
          </button>
          <span id="employeeCount" style="color:#aaa; font-size:0.85rem; margin-left:8px;">0 employees</span>
        </div>
      </div>
    </div>
    
    <!-- Company-Wide Development Actions -->
    <div style="background:linear-gradient(135deg, #16213e 0%, #0f1419 100%); border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 10px rgba(0,0,0,0.2); border:2px solid #4ecca3;">
      <h3 style="margin:0 0 15px 0; color:#4ecca3; display:flex; align-items:center; gap:8px;">
        <span style="font-size:1.2rem;">📈</span>
        Employee Development Programs
      </h3>
      <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">
        
        <!-- Training Workshop -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #533483;">
          <div style="font-size:1.2rem; margin-bottom:8px;">🎓</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Training Workshop</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">All employees gain +5-10 productivity and management XP</p>
          <button id="conductTrainingBtn" onclick="conductTrainingWorkshop()" style="width:100%; padding:10px; background:linear-gradient(135deg, #533483, #7b5ba6); border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s;" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(83,52,131,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Conduct Workshop
          </button>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;" id="workshopCostDisplay">Cost: $500 per employee</div>
        </div>
        
        <!-- Team Building -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #e94560;">
          <div style="font-size:1.2rem; margin-bottom:8px;">🎉</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Team Building</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">Boost productivity +3-7, morale +8, social skills for all</p>
          <button id="conductTeamBuildingBtn" onclick="conductTeamBuilding()" style="width:100%; padding:10px; background:linear-gradient(135deg, #e94560, #ff6b9d); border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s;" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(233,69,96,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Host Event
          </button>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;" id="teamBuildingCostDisplay">Cost: $800 per employee • 14 day cooldown</div>
        </div>
        
        <!-- Performance Review Note -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #00d4ff;">
          <div style="font-size:1.2rem; margin-bottom:8px;">📊</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Performance Reviews</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">Individual reviews: +5-20 productivity based on current level</p>
          <div style="padding:10px; background:rgba(0,212,255,0.1); border-radius:6px; text-align:center;">
            <div style="color:#00d4ff; font-size:0.85rem; font-weight:600;">Use "📊 Review" button</div>
            <div style="color:#aaa; font-size:0.75rem; margin-top:4px;">on each employee card</div>
          </div>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;">Cost: $200 • 7 day cooldown per employee</div>
        </div>
        
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Employees</h3>
      <div id="employeesList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(250px, 1fr)); gap:15px; margin-top:10px;">
        <!-- Employee cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Social Tab -->
  <div id="socialTab" class="tab-content" hidden>
    <div style="display:flex; gap:20px; height:calc(100vh - 200px);">
      
      <!-- Left Sidebar - Player Post Composer & Filters -->
      <div style="flex:0 0 280px; display:flex; flex-direction:column; gap:12px;">
        
        <!-- Player Post Composer -->
        <div style="background:#16213e; border-radius:10px; padding:12px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 10px 0; color:#00d4ff; font-size:0.95rem;">Create Post</h3>
          
          <button id="playerPostBtn" style="width:100%; padding:10px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.95rem; display:flex; align-items:center; justify-content:center; gap:6px;">
            <span style="font-size:1.1rem;">✏️</span> New Post
          </button>
        </div>
        
        <!-- Feed Filters -->
        <div style="background:#16213e; border-radius:10px; padding:12px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 10px 0; color:#00d4ff; font-size:0.95rem;">Filter Feed</h3>
          
          <div style="display:flex; flex-direction:column; gap:6px;">
            <button class="feed-filter-btn active" data-filter="all" style="padding:8px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.9rem;">
              📱 All Posts
            </button>
            <button class="feed-filter-btn" data-filter="work" style="padding:8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.9rem;">
              💼 Work
            </button>
            <button class="feed-filter-btn" data-filter="personal" style="padding:8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.9rem;">
              ❤️ Personal
            </button>
            <button class="feed-filter-btn" data-filter="spicy" style="padding:8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.9rem;">
              🌶️ Spicy
            </button>
            <button class="feed-filter-btn" data-filter="explicit" style="padding:8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.9rem;">
              🔞 Explicit
            </button>
          </div>
        </div>
        
        <!-- Sort Options -->
        <div style="background:#16213e; border-radius:10px; padding:12px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 10px 0; color:#00d4ff; font-size:0.95rem;">Sort By</h3>
          
          <select id="feedSortSelect" style="width:100%; padding:8px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:white; cursor:pointer; font-size:0.9rem;">
            <option value="recent">🕐 Most Recent</option>
            <option value="popular">❤️ Most Popular</option>
            <option value="comments">💬 Most Comments</option>
          </select>
        </div>
        
        <!-- Feed Stats -->
        <div style="background:#16213e; border-radius:10px; padding:12px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 10px 0; color:#00d4ff; font-size:0.95rem;">Stats</h3>
          
          <div style="display:flex; flex-direction:column; gap:6px; font-size:0.85rem;">
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Total Posts:</span>
              <span id="totalPostsCount" style="color:#00d4ff; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Active Users:</span>
              <span id="activeUsersCount" style="color:#4ecca3; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Today's Posts:</span>
              <span id="todayPostsCount" style="color:#e94560; font-weight:600;">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Main Feed -->
      <div style="flex:1; display:flex; flex-direction:column; background:#16213e; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.3); overflow:hidden;">
        
        <!-- Feed Header -->
        <div style="padding:15px 20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <div>
            <h2 style="margin:0; color:#00d4ff; font-size:1.3rem;">🌐 The Social Feed</h2>
            <div id="feedStatsText" style="color:#8899a6; font-size:0.85rem; margin-top:4px;">Loading...</div>
          </div>
          <button id="refreshFeedBtn" style="padding:8px 16px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer; font-weight:600; display:flex; align-items:center; gap:6px; transition:all 0.2s;">
            <span style="font-size:1.1rem;">🔄</span> Refresh
          </button>
        </div>
        
        <!-- Feed Content -->
        <div id="socialFeedContent" style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Posts will be rendered here -->
          <div id="feedEmptyState" style="text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:4rem; margin-bottom:20px; opacity:0.3;">📱</div>
            <h3 style="margin:0 0 10px 0; color:#666;">No Posts Yet</h3>
            <p style="margin:0; font-size:0.95rem;">Posts from your employees will appear here. Start hiring employees and they'll begin posting!</p>
            <button id="testGeneratePostBtn" style="margin-top:20px; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
              Generate Test Post
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Gifts Tab -->
  <div id="giftsTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">🎁 Gift Store</h2>
    
    <!-- Gift Genie Section -->
    <div style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:15px; padding:25px; margin-bottom:25px; border:2px solid #667eea;">
      <h3 style="margin:0 0 10px 0; color:#fff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:2rem;">✨</span>
        Gift Genie
      </h3>
      <p style="color:#f0f0f0; margin:0 0 20px 0; font-size:0.95rem;">
        Describe any gift you can imagine - from candy bars to private islands - and the genie will create it for you!
      </p>
      
      <div style="position:relative;">
        <input 
          type="text" 
          id="giftGenieInput" 
          style="
            width:100%; 
            padding:15px; 
            border-radius:10px; 
            border:none; 
            font-size:1.1rem; 
            background:#fff; 
            color:#333;
            box-shadow:0 4px 15px rgba(0,0,0,0.2);
          ">
        <div id="giftGenieSuggestion" style="
          position:absolute;
          top:15px;
          left:15px;
          color:#aaa;
          font-size:1.1rem;
          pointer-events:none;
          transition:opacity 0.3s;
        "></div>
      </div>
      
      <div style="display:flex; gap:10px; margin-top:15px; flex-wrap:wrap;">
        <button id="generateGiftBtn" style="
          flex:1;
          min-width:200px;
          padding:15px 25px;
          background:#e94560;
          border:none;
          border-radius:10px;
          color:white;
          font-size:1.1rem;
          font-weight:bold;
          cursor:pointer;
          box-shadow:0 4px 15px rgba(233,69,96,0.3);
          transition:all 0.3s;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(233,69,96,0.4)'"
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(233,69,96,0.3)'">
          ✨ Create Gift
        </button>
        
        <div style="display:flex; gap:10px; align-items:center; background:rgba(255,255,255,0.1); padding:10px 15px; border-radius:10px;">
          <label style="color:#fff; white-space:nowrap;">Max Budget:</label>
          <select id="giftBudgetLimit" style="
            padding:8px 12px;
            border-radius:6px;
            border:none;
            background:#fff;
            color:#333;
            font-size:0.95rem;
            cursor:pointer;
          ">
            <option value="Infinity">No Limit</option>
            <option value="100">$100</option>
            <option value="1000">$1,000</option>
            <option value="10000">$10,000</option>
            <option value="100000">$100,000</option>
            <option value="1000000">$1M</option>
            <option value="10000000">$10M</option>
            <option value="100000000">$100M</option>
          </select>
        </div>
      </div>
      
      <!-- Company scale info -->
      <div id="giftScaleInfo" style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.15); border-radius:8px; color:#f0f0f0; font-size:0.9rem;">
        💡 Based on your company's progress, recommended gift range: <span id="recommendedGiftRange">$10 - $10,000</span>
      </div>
    </div>
    
    <!-- Gift Preview Modal (shown after generating) -->
    <div id="giftPreviewModal" style="display:none; background:#0f3460; border-radius:15px; padding:25px; margin-bottom:25px; border:2px solid #00d4ff;">
      <h3 style="margin:0 0 15px 0; color:#00d4ff;">🧞‍♂️ Gift Genie Created This</h3>
      
      <div id="giftPreviewContent" style="display:grid; grid-template-columns:1fr 2fr; gap:20px;">
        <!-- Image placeholder -->
        <div>
          <div id="giftPreviewImage" style="
            width:100%;
            aspect-ratio:1;
            background:#16213e;
            border-radius:10px;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:4rem;
          ">🎁</div>
          <button id="generateGiftImageBtn" style="
            width:100%;
            margin-top:10px;
            padding:10px;
            background:#667eea;
            border:none;
            border-radius:8px;
            color:white;
            cursor:pointer;
            font-size:0.9rem;
          ">📸 Generate Image</button>
        </div>
        
        <!-- Gift details -->
        <div>
          <h4 id="giftPreviewName" style="margin:0 0 10px 0; color:#fff; font-size:1.5rem;"></h4>
          <div style="display:flex; gap:15px; margin-bottom:15px; flex-wrap:wrap;">
            <div style="background:rgba(233,69,96,0.2); padding:8px 15px; border-radius:8px; border:1px solid #e94560;">
              <span style="color:#e94560; font-weight:bold; font-size:1.2rem;" id="giftPreviewPrice"></span>
            </div>
            <div style="background:rgba(102,126,234,0.2); padding:8px 15px; border-radius:8px; border:1px solid #667eea;">
              <span id="giftPreviewCategory" style="color:#667eea;"></span>
            </div>
          </div>
          
          <p id="giftPreviewDescription" style="color:#ddd; line-height:1.6; margin-bottom:15px;"></p>
          
          <div id="giftPreviewUnique" style="display:none; background:rgba(255,215,0,0.1); border:2px solid gold; border-radius:8px; padding:12px; margin-bottom:15px;">
            <strong style="color:gold;">⭐ ONE-OF-A-KIND GIFT</strong>
            <p style="margin:5px 0 0 0; font-size:0.9rem; color:#ddd;">This unique gift can only be created once! After you stock it in the store and someone purchases it, you can never create it again.</p>
          </div>
          
          <div style="display:flex; gap:10px; margin-top:20px;">
            <button id="approveGiftBtn" style="
              flex:1;
              padding:12px 20px;
              background:#4ecca3;
              border:none;
              border-radius:8px;
              color:#0f1419;
              font-weight:bold;
              cursor:pointer;
              font-size:1rem;
            ">✅ Approve - Stock in Store</button>
            
            <button id="denyGiftBtn" style="
              padding:12px 20px;
              background:#e94560;
              border:none;
              border-radius:8px;
              color:white;
              font-weight:bold;
              cursor:pointer;
            ">❌ Deny - Delete</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Gift Store (Available for Purchase) -->
    <div style="margin-top:30px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <h3 style="margin:0; color:#00d4ff;">🏪 Gift Store - Available Gifts</h3>
        <div style="color:#aaa;">
          <span id="giftStoreCount">0</span> gifts in stock
        </div>
      </div>
      
      <div id="giftStoreGrid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:15px; margin-bottom:30px;"></div>
    </div>
    
    <!-- Gift Inventory -->
    <div style="margin-top:30px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <h3 style="margin:0; color:#00d4ff;">📦 Your Purchased Gifts (Ready to Give)</h3>
        <div style="color:#aaa;">
          <span id="giftInventoryCount">0</span> gifts ready
        </div>
      </div>
      
      <div id="giftInventoryGrid" style="
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(220px, 1fr));
        gap:15px;
        min-height:200px;
      ">
        <!-- Gift inventory items will be populated here -->
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:60px 20px;
          color:#666;
          font-size:1.1rem;
        ">
          Your inventory is empty. Create gifts above to get started! ✨
        </div>
      </div>
    </div>
  </div>
  
  <!-- HR Tab -->
  <div id="hrTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">HR Policies & Office Culture</h2>
    
    <div style="margin-top:20px;">
      <h3>Office Culture Settings</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        These settings control how employees interact with you and respond to conversations. 
        Adjust these to create the office atmosphere you prefer.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <!-- Office Atmosphere -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Office Atmosphere</label>
            <span id="atmosphereValue" style="color:#e94560; font-weight:600;">Balanced</span>
          </div>
          <input type="range" id="atmosphereSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>← Professional</span>
            <span>Relaxed →</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Professional):</strong> Formal workplace. NPCs keep professional distance, maintain boundaries, and focus on work topics.</li>
              <li><strong>34-66 (Balanced):</strong> Friendly workplace. NPCs are approachable and personable while maintaining appropriate boundaries.</li>
              <li><strong>67-100 (Relaxed):</strong> Casual workplace. NPCs are very comfortable, open about personal topics, and boundaries are more flexible.</li>
            </ul>
          </div>
        </div>
        
        <!-- Interaction Style -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Interaction Style</label>
            <span id="guidelinesValue" style="color:#e94560; font-weight:600;">Standard</span>
          </div>
          <input type="range" id="guidelinesSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>← Reserved</span>
            <span>Outgoing →</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Reserved):</strong> NPCs are more distant and may seem cold, tsundere-like, or defensive. Harder to build relationships.</li>
              <li><strong>34-66 (Standard):</strong> NPCs have balanced personalities - some warm, some cool, all realistic and varied.</li>
              <li><strong>67-100 (Outgoing):</strong> NPCs are friendly, expressive, and eager to connect. Relationships develop more easily.</li>
            </ul>
          </div>
        </div>
        
        <!-- Consent Model -->
        <div style="margin-bottom:15px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Consent Model</label>
            <span id="policyValue" style="color:#e94560; font-weight:600;">Professional</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd; margin-bottom:15px;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>Professional:</strong> NPCs maintain professional boundaries. Flirting/advances require high relationship stats and are met cautiously.</li>
              <li><strong>Casual:</strong> NPCs are open to personal connections once comfortable. Flirting is welcome when trust/affection are moderate.</li>
              <li><strong>Enthusiastic:</strong> NPCs are receptive and interested in all interactions. Everyone's consenting and relationships develop naturally without barriers.</li>
            </ul>
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="policy-btn" data-policy="professional" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Professional</button>
            <button class="policy-btn" data-policy="casual" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Casual</button>
            <button class="policy-btn" data-policy="open" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Enthusiastic</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- GENDER DIVERSITY SECTION -->
    <div style="margin-top:30px;">
      <h3>Gender Diversity Options</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        Control the gender distribution of new hires. All employees will still be female by default (100%), but you can adjust these sliders to introduce variety.
        Sliders are automatically proportional - they will always add up to 100%.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <button id="genderOptionsBtn" style="width:100%; padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s; margin-bottom:15px;">
          ⚧️ Configure Gender Options
        </button>
        
        <!-- Current Distribution Display -->
        <div style="background:#0f3460; padding:15px; border-radius:6px;">
          <div style="margin-bottom:8px; color:#aaa; font-size:0.9rem; font-weight:600;">Current Distribution:</div>
          <div id="genderDistributionDisplay" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
            <!-- Will be populated by JS -->
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Invest Tab -->
  <div id="investTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Investment & Prestige</h2>
    
    <!-- Prestige Overview Section -->
    <div style="background:#0f3460; border-radius:15px; padding:25px; margin-bottom:20px; border:2px solid #00d4ff;">
      <h3 style="margin:0 0 15px 0; color:#00d4ff;">🌟 Prestige System</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Reset your progress to gain <strong style="color:#ffd700;">Influence Points</strong>, which unlock permanent bonuses that persist across all future runs. The more you've earned, the more influence you'll gain!
      </p>
      
      <!-- Current Stats -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Prestige Level</div>
          <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="currentPrestigeLevel">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Lifetime Earnings</div>
          <div style="font-size:1.5rem; font-weight:700; color:#2ecc71;" id="lifetimeEarningsDisplay">$0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Influence Points</div>
          <div style="font-size:1.5rem; font-weight:700; color:#ffd700;" id="currentInfluencePoints">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Income Multiplier</div>
          <div style="font-size:1.5rem; font-weight:700; color:#e74c3c;" id="currentMultiplier">1.0x</div>
        </div>
      </div>
      
      <!-- Prestige Button -->
      <div style="background:#16213e; border-radius:10px; padding:20px; text-align:center;">
        <div style="margin-bottom:15px;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Next Prestige Will Grant</div>
          <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="nextPrestigeInfluence">0</div>
          <div style="color:#ffd700; font-size:0.9rem;">Influence Points</div>
        </div>
        <button id="prestigeBtn" style="padding:15px 40px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:10px; color:white; font-size:1.2rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s;">
          ✨ Prestige Now
        </button>
        <div id="prestigeRequirement" style="margin-top:10px; color:#e74c3c; font-size:0.9rem;"></div>
      </div>
    </div>
    
    <!-- Influence Points Upgrade Shop -->
    <div style="background:#0f3460; border-radius:15px; padding:25px;">
      <h3 style="margin:0 0 15px 0; color:#ffd700;">💎 Permanent Upgrades</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Spend Influence Points on permanent bonuses that carry through all prestige runs.
      </p>
      
      <div id="influenceUpgradesContainer" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Upgrades will be dynamically populated here -->
      </div>
    </div>
  </div>
  
  <!-- CEO Corner Tab -->
  <div id="ceocornerTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">👑 CEO Corner - Global Chatroom</h2>
    
    <div style="background:#0f3460; border-radius:15px; padding:25px; margin-bottom:20px; border:2px solid #ffd700;">
      <div style="display:flex; align-items:center; gap:15px; margin-bottom:15px;">
        <div style="font-size:3rem;">💬</div>
        <div>
          <h3 style="margin:0; color:#ffd700;">Welcome to the CEO Corner!</h3>
          <p style="color:#aaa; margin:5px 0 0 0; line-height:1.5;">
            Chat with other players from around the world. Share tips, strategies, and stories from your business empire!
          </p>
        </div>
      </div>
      
      <div style="background:#16213e; border-radius:10px; padding:15px; margin-top:15px;">
        <h4 style="margin:0 0 10px 0; color:#00d4ff;">📜 Chat Rules</h4>
        <ul style="color:#aaa; font-size:0.9rem; margin:0; padding-left:20px; line-height:1.8;">
          <li>Be respectful to all players</li>
          <li>No spam or excessive caps</li>
          <li>Share game tips and help others</li>
          <li>Have fun and make friends! 🎉</li>
        </ul>
      </div>
    </div>
    
    <!-- Chatroom Container -->
    <div style="background:#16213e; border-radius:15px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <div id="ceoChatroom" style="width:100%; height:600px;">
        [commentsPlugin(ceoChatOptions)]
      </div>
    </div>
  </div>
</div>

<!-- Settings Panel -->
<div id="settingsPanel" class="settings-panel" hidden style="position:fixed; top:0; right:0; width:350px; height:100%; background:#16213e; color:white; z-index:1000; box-shadow:-5px 0 15px rgba(0,0,0,0.5); overflow-y:auto;">
  <div style="padding:20px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Settings</h2>
      <button id="closeSettingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Game Preferences</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <div style="margin-bottom:15px;">
          <label>UI Density: <span id="densityValue">Normal</span></label>
          <input type="range" id="densitySlider" min="0" max="100" value="50" style="width:100%; margin-top:5px;">
        </div>
        <div style="margin-bottom:15px;">
          <label style="display:flex; align-items:center; gap:10px;">
            <input type="checkbox" id="autosaveToggle" checked style="width:18px; height:18px;">
            <span>Autosave</span>
          </label>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>⚡ Performance Settings</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 12px 0;">Adjust these settings if you experience lag or freezing, especially with large social feeds.</p>
        <div style="margin-bottom:15px;">
          <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <span>Posts Per Page</span>
            <span id="postsPerPageValue" style="color:#00d4ff; font-weight:600;">20</span>
          </label>
          <input type="range" id="postsPerPageSlider" min="10" max="50" value="20" step="5" style="width:100%;">
          <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">Lower = Better performance</div>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>🎨 Image Generation Style</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 12px 0;">Choose the default art style for ALL generated images (profiles, conversations, social posts, scenes).</p>
        <select id="imageStyleSelect" style="width:100%; padding:10px; background:#16213e; border:1px solid #667eea; border-radius:6px; color:white; font-size:0.95rem; cursor:pointer;">
          <option value="photorealistic">📸 Photorealistic</option>
          <option value="anime">🎌 Anime/Manga</option>
          <option value="artistic">🎨 Artistic/Painterly</option>
          <option value="cartoon">🎭 Cartoon/Comic</option>
          <option value="cinematic">🎬 Cinematic</option>
          <option value="professional">💼 Professional Studio</option>
          <option value="custom">✏️ Custom Prompt</option>
        </select>
        <div id="customPromptContainer" style="display:none; margin-top:12px;">
          <label style="display:block; color:#aaa; font-size:0.85rem; margin-bottom:6px;">Custom Style Prompt:</label>
          <textarea id="customStylePrompt" placeholder="Enter your custom style directive (e.g., 'watercolor painting, soft colors, dreamy atmosphere')" style="width:100%; min-height:80px; padding:10px; background:#16213e; border:1px solid #667eea; border-radius:6px; color:white; font-size:0.9rem; resize:vertical; font-family:inherit;"></textarea>
          <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">This will be appended to all image generation prompts.</div>
        </div>
        <div style="color:#8899a6; font-size:0.75rem; margin-top:8px;">This style will be applied to all future image generations consistently.</div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Player Profile</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.9rem; margin:0 0 10px 0;">Set up your detailed profile so NPCs can reference you accurately in conversations, image generation, and social posts.</p>
        <button id="openPlayerProfileBtn" style="width:100%; padding:12px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">👤</span> Edit Your Profile
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>🎮 Cheats & Debugging</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 10px 0;">Modify game values for testing or just having fun!</p>
        <button id="openCheatsBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">⚡</span> Open Cheats Panel
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>📋 Patch Notes</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 10px 0;">View update history and recent changes.</p>
        <button id="openPatchNotesBtn" style="width:100%; padding:12px; background:#667eea; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">📝</span> View Patch Notes
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Data Management</h3>
      <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
        <div style="display:flex; gap:10px;">
          <button id="saveBtn" style="flex:1; padding:10px; background:#4ecca3; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600;">💾 Save Now</button>
          <button id="loadBtn" style="flex:1; padding:10px; background:#00d4ff; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600;">📂 Load Save</button>
        </div>
        <button id="exportBtn" style="width:100%; padding:10px; background:#667eea; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600;">📤 Export to File</button>
        <button id="importBtn" style="width:100%; padding:10px; background:#764ba2; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600;">📥 Import from File</button>
        <button id="resetBtn" style="width:100%; padding:10px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600;">🗑️ Reset Game</button>
      </div>
    </div>
  </div>
</div>

<!-- Hidden file input for importing saves -->
<input type="file" id="importFileInput" accept=".json" style="display:none;">

<!-- Chat Modal -->
<div id="chatModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.7) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; pointer-events:none !important;">
  <div style="background:#16213e; width:90%; max-width:500px; height:80%; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; pointer-events:auto;">
    <div style="padding:15px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
      <div style="display:flex; align-items:center; gap:10px;">
        <img id="chatAvatar" src="" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
        <div>
          <h3 id="chatName" style="margin:0;"></h3>
          <p id="chatStatus" style="margin:0; font-size:0.8rem; color:#aaa;">Online</p>
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="clearChatBtn" style="background:#0f3460; border:none; padding:8px 12px; border-radius:5px; color:#aaa; cursor:pointer; font-size:0.8rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'; this.style.color='#e94560'" onmouseleave="this.style.background='#0f3460'; this.style.color='#aaa'">🗑️ Clear</button>
        <button id="closeChatBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
      </div>
    </div>
    
    <div id="chatMessages" style="flex:1; padding:15px; overflow-y:auto; display:flex; flex-direction:column; gap:10px;">
      <!-- Chat messages will appear here -->
    </div>
    
    <div style="padding:15px; border-top:1px solid #0f3460; display:flex; gap:10px; position:relative;">
      <button id="chatAttachBtn" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:bold; font-size:1.2rem;">+</button>
      <button id="chatEmojiBtn" class="emoji-picker-trigger" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; cursor:pointer; font-size:1.2rem;">😊</button>
      <input id="chatInput" type="text" placeholder="Type a message..." style="flex:1; padding:10px; background:#0f1419; border:none; border-radius:5px; color:white;">
      <button id="chatSendBtn" style="padding:8px 15px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer;">Send</button>
      
      <!-- Attachment Menu (hidden by default) -->
      <div id="attachmentMenu" style="display:none; position:absolute; bottom:60px; left:0; background:#0f3460; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.4); min-width:200px; z-index:10;">
        <button class="attach-menu-item" data-action="send-money" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#4ecca3; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
          <span style="font-size:1.2rem;">💰</span> Send Money
        </button>
        <button class="attach-menu-item" data-action="give-gift" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#ff6b9d; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
          <span style="font-size:1.2rem;">🎁</span> Give Gift
        </button>
        <button class="attach-menu-item" data-action="request" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📷</span> Request Image
        </button>
        <button class="attach-menu-item" data-action="send" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📤</span> Send Image
        </button>
        <button class="attach-menu-item" data-action="request-post" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📱</span> Request Social Post
        </button>
        <button class="attach-menu-item" data-action="visualize" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">🎬</span> Visual Current Scene
        </button>
      </div>
    </div>
    
    <div id="chatTypingIndicator" style="padding:10px 15px; color:#aaa; font-style:italic; display:none;">
      <span id="chatTypingName"></span> is typing...
    </div>
  </div>
</div>

<!-- Patch Notes Modal -->
<div id="patchNotesModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); width:95%; max-width:900px; max-height:90vh; border-radius:20px; box-shadow:0 10px 40px rgba(102,126,234,0.4); border:2px solid #667eea; overflow-y:auto; margin:20px;">
    <div style="position:sticky; top:0; background:linear-gradient(135deg, #16213e 0%, #0f3460 100%); padding:20px; border-bottom:2px solid #667eea; z-index:10; border-radius:20px 20px 0 0;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <span style="font-size:2rem;">📝</span>
          <h2 style="margin:0; color:#667eea; text-shadow:0 0 10px rgba(102,126,234,0.5);">Patch Notes</h2>
        </div>
        <button id="closePatchNotesBtn" style="background:transparent; border:2px solid #667eea; color:#667eea; font-size:1.5rem; cursor:pointer; width:40px; height:40px; border-radius:50%; transition:all 0.3s;" onmouseenter="this.style.background='#667eea'; this.style.color='white'" onmouseleave="this.style.background='transparent'; this.style.color='#667eea'">✕</button>
      </div>
    </div>
    
    <div id="patchNotesContent" style="padding:25px; color:white;">
      <!-- Patch notes will be dynamically inserted here -->
      <p style="color:#aaa; text-align:center;">Loading patch notes...</p>
    </div>
  </div>
</div>

<!-- Send Money Modal -->
<div id="sendMoneyModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#4ecca3;">💰 Send Money</h3>
      <button id="closeSendMoneyModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">Your Balance:</p>
      <p id="sendMoneyBalance" style="color:#4ecca3; margin:0; font-size:1.4rem; font-weight:600;">$0</p>
    </div>
    
    <p style="color:#aaa; margin-bottom:15px;">Choose an amount to send or enter a custom value:</p>
    
    <!-- Quick Amount Presets -->
    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-bottom:15px;">
      <button class="money-preset" data-preset="small" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Small</div>
        <div id="moneySmall" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
      <button class="money-preset" data-preset="medium" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Medium</div>
        <div id="moneyMedium" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
      <button class="money-preset" data-preset="large" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Large</div>
        <div id="moneyLarge" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
    </div>
    
    <!-- Custom Amount Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Custom Amount:</label>
      <div style="position:relative;">
        <span style="position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#4ecca3; font-weight:600; font-size:1.1rem;">$</span>
        <input type="number" id="customMoneyAmount" placeholder="0" min="1" style="width:100%; padding:12px 12px 12px 30px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; font-size:1.1rem;" />
      </div>
    </div>
    
    <!-- Message/Purpose Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">What's this for? (Optional)</label>
      <textarea id="moneyMessage" placeholder="E.g., 'For your hard work', 'Buy yourself something nice', 'Just because', etc." style="width:100%; height:60px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical;"></textarea>
    </div>
    
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelSendMoney" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmSendMoney" style="padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#16213e; cursor:pointer; font-weight:600;">Send Money</button>
    </div>
  </div>
</div>

<!-- Gift Selection Modal -->
<div id="giftSelectionModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:#16213e; width:95%; max-width:700px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column;">
    <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h3 style="margin:0; color:#ff6b9d; display:flex; align-items:center; gap:10px;">
          🎁 Give a Gift
        </h3>
        <p id="giftRecipientName" style="margin:5px 0 0 0; color:#aaa; font-size:0.9rem;"></p>
      </div>
      <button id="closeGiftSelectionModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <!-- Gift Preferences Hint -->
    <div id="giftPreferencesHint" style="padding:15px 20px; background:#0f3460; border-bottom:1px solid #16213e;">
      <p style="margin:0 0 8px 0; color:#aaa; font-size:0.85rem; font-weight:600;">📊 Their Preferences:</p>
      <p style="margin:0 0 10px 0; color:#888; font-size:0.75rem; font-style:italic;">💡 Give gifts to discover what they love and hate!</p>
      <div style="display:flex; gap:20px; flex-wrap:wrap;">
        <div>
          <span style="color:#4ecca3; font-size:0.9rem;">💕 Loves:</span>
          <span id="giftLovesHint" style="color:white; font-size:0.9rem; margin-left:5px;"></span>
        </div>
        <div>
          <span style="color:#e94560; font-size:0.9rem;">💔 Hates:</span>
          <span id="giftHatesHint" style="color:white; font-size:0.9rem; margin-left:5px;"></span>
        </div>
      </div>
    </div>
    
    <!-- Gift Inventory Grid -->
    <div id="giftSelectionGrid" style="flex:1; padding:20px; overflow-y:auto; display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:15px; max-height:500px;">
      <!-- Gifts will be populated here -->
    </div>
    
    <!-- Empty State -->
    <div id="giftSelectionEmpty" style="display:none; padding:40px; text-align:center; color:#aaa;">
      <div style="font-size:4rem; margin-bottom:15px;">🎁</div>
      <p style="font-size:1.1rem; margin:0 0 10px 0;">No gifts in inventory</p>
      <p style="font-size:0.9rem; margin:0;">Visit the Gifts tab to create and purchase gifts!</p>
    </div>
    
    <!-- Personal Message Input -->
    <div style="padding:15px 20px; border-top:1px solid #0f3460; background:#0f1419;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">💌 Add a personal message (optional):</label>
      <textarea 
        id="giftPersonalMessage" 
        placeholder="Type a message to send with your gift..."
        style="width:100%; min-height:60px; padding:10px; background:#16213e; border:1px solid #0f3460; border-radius:8px; color:white; font-size:0.9rem; resize:vertical; font-family:inherit;"
        maxlength="500"
      ></textarea>
      <div style="text-align:right; color:#666; font-size:0.75rem; margin-top:4px;">
        <span id="giftMessageCharCount">0</span>/500
      </div>
    </div>
    
    <div style="padding:15px 20px; border-top:1px solid #0f3460; background:#0f1419; border-radius:0 0 15px 15px; display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelGiftSelection" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="sendGiftBtn" disabled style="padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer; opacity:0.5; transition:all 0.2s;">
        🎁 Send Gift
      </button>
    </div>
  </div>
</div>

<!-- Counter Offer Modal -->
<div id="counterOfferModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000000; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#ff9800;">↔️ Counter Offer</h3>
      <button id="closeCounterOfferModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">They requested:</p>
      <p id="counterOriginalAmount" style="color:#ff9800; margin:0; font-size:1.3rem; font-weight:600;">$0</p>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">Your Balance:</p>
      <p id="counterYourBalance" style="color:#4ecca3; margin:0; font-size:1.4rem; font-weight:600;">$0</p>
    </div>
    
    <p style="color:#aaa; margin-bottom:15px;">Enter the amount you want to send instead:</p>
    
    <!-- Counter Amount Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Counter Amount:</label>
      <div style="position:relative;">
        <span style="position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#4ecca3; font-weight:600; font-size:1.1rem;">$</span>
        <input type="number" id="counterAmount" placeholder="0" min="1" style="width:100%; padding:12px 12px 12px 30px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; font-size:1.1rem;" />
      </div>
    </div>
    
    <!-- Justification Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Why this amount? (Optional)</label>
      <textarea id="counterJustification" placeholder="E.g., 'This is all I can spare right now', 'I think this should be enough', 'Here's a bit extra because I care', etc." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical;"></textarea>
    </div>
    
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelCounterOffer" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmCounterOffer" style="padding:10px 20px; background:#ff9800; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Send Counter</button>
    </div>
  </div>
</div>

<!-- Send Image Modal -->
<div id="sendImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📤 Send an Image</h3>
      <button id="closeSendImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    <p style="color:#aaa; margin-bottom:15px;">Describe what image you want to send. The AI will respond based on your description and conversation context.</p>
    <textarea id="sendImagePrompt" placeholder="E.g., 'A selfie of me at the beach' or 'My new car'" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelSendImage" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmSendImage" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Send Image</button>
    </div>
  </div>
</div>

<!-- Request Image Modal -->
<div id="requestImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📷 Request an Image</h3>
      <button id="closeRequestImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div id="requestImageMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose a preset or create a custom request:</p>
      
      <!-- Auto Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-preset" data-preset="casual" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          😊 Casual Selfie
        </button>
        <button class="request-preset" data-preset="work" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          👔 Work Selfie
        </button>
        <button class="request-preset" data-preset="lewd" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          😏 Lewd Selfie
        </button>
        <button class="request-preset" data-preset="nude" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔞 Nude Selfie
        </button>
        <button class="request-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #ff0055; border-radius:8px; color:#ff0055; cursor:pointer; transition:all 0.2s; grid-column:1/-1; font-weight:600;">
          🔥 Explicit Content
        </button>
      </div>
      
      <!-- Manual Option -->
      <button id="requestManualBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        ✏️ Custom Request
      </button>
      
      <!-- Manual Input (hidden by default) -->
      <div id="requestManualInput" style="display:none;">
        <textarea id="requestImagePrompt" placeholder="Describe what you'd like them to send (e.g., 'a photo of you in your favorite outfit')" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestManual" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestManual" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Request Social Post Modal -->
<div id="requestPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📱 Request a Social Post</h3>
      <button id="closeRequestPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div id="requestPostMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose what kind of post you want them to make:</p>
      
      <!-- Post Type Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-post-preset" data-preset="text" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          📝 Status Update
        </button>
        <button class="request-post-preset" data-preset="selfie" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🤳 Selfie
        </button>
        <button class="request-post-preset" data-preset="thirst_trap" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔥 Thirst Trap
        </button>
        <button class="request-post-preset" data-preset="nude" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔞 Nude Photo
        </button>
        <button class="request-post-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #ff0055; border-radius:8px; color:#ff0055; cursor:pointer; transition:all 0.2s; grid-column:1/-1; font-weight:600;">
          🔥 Explicit Sexual Content
        </button>
      </div>
      
      <!-- Custom Request Option -->
      <button id="requestPostCustomBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        ✏️ Custom Request
      </button>
      
      <!-- Custom Input (hidden by default) -->
      <div id="requestPostCustomInput" style="display:none;">
        <textarea id="requestPostPrompt" placeholder="Describe what you want them to post (e.g., 'Post a picture of you masturbating' or 'Write about how you're feeling right now')" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestPostCustom" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestPostCustom" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Player Post Composer Modal -->
<div id="playerPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:600px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px; max-height:90vh; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">✏️ Create a Post</h3>
      <button id="closePlayerPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <!-- Post Type Selection -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Post Type</label>
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px;">
        <button class="post-type-btn active" data-type="text" style="padding:10px; background:#0f3460; border:2px solid #00d4ff; border-radius:6px; color:white; cursor:pointer; transition:all 0.2s;">
          📝 Text
        </button>
        <button class="post-type-btn" data-type="image" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          🖼️ Image
        </button>
        <button class="post-type-btn" data-type="selfie" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          🤳 Selfie
        </button>
      </div>
    </div>
    
    <!-- Caption Input -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Caption <span style="color:#666; font-size:0.85rem;">(Type @ to mention someone)</span></label>
      <div style="position:relative;">
        <textarea id="playerPostCaption" placeholder="What's on your mind? Type @ to mention someone..." style="width:100%; height:100px; padding:12px; padding-right:45px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:1rem;"></textarea>
        <button id="postCaptionEmojiBtn" class="emoji-picker-trigger" style="position:absolute; right:8px; top:8px; padding:6px 10px; background:#0f3460; border:none; border-radius:6px; cursor:pointer; font-size:1.2rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">😊</button>
        
        <!-- Mention Suggestions Dropdown -->
        <div id="mentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:5px;">
          <!-- Dynamically populated -->
        </div>
      </div>
      <div style="margin-top:6px; font-size:0.8rem; color:#666;">
        <span id="captionCharCount">0</span>/500 characters
      </div>
    </div>
    
    <!-- Image Section (shown for image/selfie posts) -->
    <div id="playerPostImageSection" style="display:none; margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Image Prompt</label>
      <textarea id="playerPostImagePrompt" placeholder="Describe the image you want to generate (e.g., 'Me at the beach wearing sunglasses')" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
      
      <div style="margin-top:15px;">
        <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">
          Alt Text (What NPCs "see")
          <span style="color:#666; font-size:0.85rem;">- Describe what's in the image for NPCs</span>
        </label>
        <textarea id="playerPostAltText" placeholder="E.g., 'Picture of me smiling at the beach, wearing a blue swimsuit and sunglasses, sunset in background'" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
      </div>
      
      <!-- Preview Image -->
      <div id="playerPostImagePreview" style="display:none; margin-top:15px;">
        <img id="playerPostPreviewImg" style="width:100%; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
        <button id="playerPostRegenerateImg" style="width:100%; margin-top:10px; padding:8px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer;">
          🔄 Regenerate Image
        </button>
      </div>
    </div>
    
    <!-- Explicit Content Warning -->
    <div style="margin-bottom:20px; background:#0f3460; padding:12px; border-radius:6px; border-left:3px solid #e94560;">
      <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
        <input type="checkbox" id="playerPostExplicit" style="width:18px; height:18px;">
        <span style="font-size:0.9rem; color:#ddd;">
          🔞 This post contains explicit/NSFW content
        </span>
      </label>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerPost" style="padding:12px 24px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">
        Cancel
      </button>
      <button id="generatePlayerPostImage" style="display:none; padding:12px 24px; background:#533483; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        🎨 Generate Image
      </button>
      <button id="submitPlayerPost" style="padding:12px 24px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        📤 Post
      </button>
    </div>
  </div>
</div>

<!-- AFK Income Modal -->
<div id="afkIncomeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:500px; border-radius:20px; padding:30px; box-shadow:0 10px 50px rgba(76,204,163,0.3); border:2px solid #4ecca3; position:relative;">
    
    <!-- Close button -->
    <button id="closeAfkIncome" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      ✕
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:20px;">
      <div style="font-size:4rem; margin-bottom:10px;">💰</div>
      <h2 style="margin:0 0 10px 0; color:#4ecca3; font-size:1.8rem;">Welcome Back!</h2>
      <p style="color:#aaa; margin:0; font-size:0.95rem;">You've been away for a while...</p>
    </div>
    
    <!-- Time Away -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px; text-align:center;">
      <div style="color:#666; font-size:0.85rem; margin-bottom:5px;">TIME AWAY</div>
      <div id="afkTimeAway" style="color:#00d4ff; font-size:1.4rem; font-weight:bold;">0h 0m</div>
    </div>
    
    <!-- Earnings Breakdown -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Your Income Rate:</span>
        <span id="afkIncomeRate" style="color:white; font-weight:600;">$0/sec</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Full Earnings:</span>
        <span id="afkFullEarnings" style="color:#666; text-decoration:line-through;">$0</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; padding-top:12px; border-top:1px solid #2a3f5f;">
        <span style="color:#4ecca3; font-size:1.1rem; font-weight:600;">AFK Earnings (<span id="afkRate">50</span>%):</span>
        <span id="afkEarnings" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">$0</span>
      </div>
    </div>
    
    <!-- Claim Button -->
    <button id="claimAfkIncome" style="width:100%; padding:15px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:12px; color:white; font-size:1.2rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 20px rgba(76,204,163,0.4); transition:all 0.3s;">
      💰 Claim Earnings
    </button>
    
    <div style="text-align:center; margin-top:15px; color:#666; font-size:0.8rem;">
      * AFK earnings are capped at 50% of your income rate and 24 hours maximum
    </div>
  </div>
</div>

<!-- Prestige Confirmation Modal -->
<div id="prestigeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:600px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:35px; box-shadow:0 10px 60px rgba(102,126,234,0.5); border:3px solid #667eea; position:relative; margin:auto;">
    
    <!-- Close button -->
    <button id="closePrestigeModal" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      ✕
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:25px;">
      <div style="font-size:5rem; margin-bottom:10px;">✨</div>
      <h2 style="margin:0 0 10px 0; color:#667eea; font-size:2rem; font-weight:700;">Prestige Confirmation</h2>
      <p style="color:#aaa; margin:0; font-size:1rem; line-height:1.6;">
        Are you sure you want to prestige? This action cannot be undone!
      </p>
    </div>
    
    <!-- What You'll Lose Section -->
    <div style="background:#1a0f0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #e74c3c;">
      <h3 style="margin:0 0 15px 0; color:#e74c3c; font-size:1.2rem;">⚠️ What You'll Lose:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All current cash</li>
        <li>All products and progress</li>
        <li>All employees and their relationships</li>
        <li>All owned locations (except Garage)</li>
        <li>All boss fight progress</li>
        <li>Chat history and social feed</li>
      </ul>
    </div>
    
    <!-- What You'll Keep Section -->
    <div style="background:#0f1a0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #2ecc71;">
      <h3 style="margin:0 0 15px 0; color:#2ecc71; font-size:1.2rem;">✅ What You'll Keep:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All Influence Points (current + new)</li>
        <li>Lifetime earnings total</li>
        <li>Prestige level (increases by 1)</li>
        <li>All permanent upgrades</li>
        <li>Player bio and settings</li>
      </ul>
    </div>
    
    <!-- What You'll Gain Section -->
    <div style="background:#1a1a0f; padding:20px; border-radius:12px; margin-bottom:25px; border-left:4px solid #ffd700;">
      <h3 style="margin:0 0 15px 0; color:#ffd700; font-size:1.2rem;">🌟 What You'll Gain:</h3>
      <div style="text-align:center; margin-top:15px;">
        <div style="font-size:3rem; color:#ffd700; font-weight:bold; margin-bottom:10px;" id="prestigeGainAmount">+0</div>
        <div style="color:#ffd700; font-size:1.1rem; font-weight:600;">Influence Points</div>
        <div style="color:#aaa; font-size:0.9rem; margin-top:10px;">
          Use these to purchase permanent upgrades that boost all future runs!
        </div>
      </div>
    </div>
    
    <!-- Confirmation Buttons -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
      <button id="cancelPrestige" style="padding:15px; background:#2c3e50; border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:600; cursor:pointer; transition:all 0.3s;">
        ❌ Cancel
      </button>
      <button id="confirmPrestige" style="padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 20px rgba(102,126,234,0.4); transition:all 0.3s;">
        ✨ Prestige Now
      </button>
    </div>
    
    <div style="text-align:center; margin-top:20px; color:#666; font-size:0.85rem; line-height:1.5;">
      💡 Tip: Prestige when you feel your progress has slowed down. The more you've earned, the more influence you'll gain!
    </div>
  </div>
</div>

<!-- Boss Fight Modal -->
<div id="bossFightModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.9) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; padding:20px !important; overflow-y:auto !important;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%); width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:20px; box-shadow:0 10px 50px rgba(255,0,0,0.3); border:2px solid #e94560; margin:auto;">
    
    <!-- Boss Info Header -->
    <div id="bossHeader" style="text-align:center; margin-bottom:15px;">
      <h2 id="bossName" style="margin:0 0 5px 0; font-size:1.6rem; color:#e94560;">Boss Name</h2>
      <div id="bossTitle" style="color:#00d4ff; font-size:1rem; margin-bottom:8px;">Title</div>
      <div id="bossDescription" style="color:#aaa; font-size:0.85rem; max-width:600px; margin:0 auto;">Description</div>
    </div>
    
    <!-- Boss Image -->
    <div style="text-align:center; margin-bottom:15px;">
      <div id="bossImageContainer" style="width:200px; height:200px; margin:0 auto; border-radius:15px; overflow:hidden; background:#0f1419; display:flex; align-items:center; justify-content:center; border:3px solid #e94560; box-shadow:0 0 30px rgba(233,69,96,0.5);">
        <div id="bossImagePlaceholder" style="color:#666; font-size:2rem;">👤</div>
        <img id="bossImage" style="width:100%; height:100%; object-fit:cover; display:none;">
      </div>
    </div>
    
    <!-- Dialogue -->
    <div id="bossDialogue" style="background:#16213e; padding:12px; border-radius:10px; margin-bottom:15px; text-align:center; font-style:italic; color:#ddd; font-size:0.95rem; min-height:50px; display:flex; align-items:center; justify-content:center; border-left:4px solid #e94560;">
      "Boss dialogue appears here..."
    </div>
    
    <!-- Health Bars -->
    <div style="margin-bottom:20px;">
      <!-- Boss Health -->
      <div style="margin-bottom:12px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#e94560; font-weight:bold; font-size:0.9rem;">Boss Health</span>
          <span id="bossHealthText" style="color:#e94560; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #e94560;">
          <div id="bossHealthBar" style="width:100%; height:100%; background:linear-gradient(90deg, #e94560 0%, #ff6b9d 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
      
      <!-- Player Stamina (based on income) -->
      <div>
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">Your Stamina</span>
          <span id="playerStaminaText" style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #4ecca3;">
          <div id="playerStaminaBar" style="width:100%; height:100%; background:linear-gradient(90deg, #4ecca3 0%, #00d4ff 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
    </div>
    
    <!-- Combat Stats -->
    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin-bottom:15px;">
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Your Attack Power</div>
        <div id="playerAttack" style="color:#e94560; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;">Total Damage/Click</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Team Support</div>
        <div id="playerTeamPower" style="color:#ff6b9d; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;"><span id="playerTeamCount">0</span> Employees</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Defense/Regen</div>
        <div id="playerDefense" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">0/sec</div>
        <div style="color:#666; font-size:0.75rem;">Income Per Second</div>
      </div>
    </div>
    
    <!-- Combat Log -->
    <div style="background:#0f1419; padding:12px; border-radius:10px; margin-bottom:15px; max-height:100px; overflow-y:auto;" id="combatLog">
      <div style="color:#666; text-align:center; font-size:0.85rem;">Combat log will appear here...</div>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:12px; justify-content:center;">
      <button id="attackBtn" onclick="bossFightAttack()" style="padding:12px 30px; background:#e94560; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 15px rgba(233,69,96,0.4); transition:all 0.2s;">
        ⚔️ ATTACK
      </button>
      <button id="retreatBtn" onclick="bossFightRetreat()" style="padding:12px 30px; background:#666; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:all 0.2s;">
        🏃 Retreat
      </button>
    </div>
    
    <!-- Timer -->
    <div id="bossTimer" style="text-align:center; margin-top:15px; font-size:1rem; color:#00d4ff;">
      Time Remaining: <span id="bossTimeRemaining">60</span>s
    </div>
  </div>
</div>

<!-- Player Profile Modal -->
<div id="playerProfileModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:700px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">👤</span> Your Profile
      </h2>
      <button id="closePlayerProfileModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <!-- Basic Info -->
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">First Name</label>
        <input id="playerFirstName" type="text" placeholder="e.g., Alex" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Last Name</label>
        <input id="playerLastName" type="text" placeholder="e.g., Smith" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Age</label>
        <input id="playerAge" type="number" min="18" max="99" placeholder="e.g., 28" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Gender</label>
        <select id="playerGender" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-Binary</option>
          <option value="other">Other</option>
        </select>
      </div>
    </div>
    
    <!-- Physical Description -->
    <h3 style="margin:20px 0 15px 0; color:#00d4ff; font-size:1.2rem;">Physical Description</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Ethnicity/Race</label>
        <input id="playerEthnicity" type="text" placeholder="e.g., Caucasian, Asian, Hispanic..." style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Skin Tone</label>
        <input id="playerSkinTone" type="text" placeholder="e.g., fair, tan, brown, dark" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Height</label>
        <input id="playerHeight" type="text" placeholder="e.g., 5'10&quot;, 178cm" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Body Type</label>
        <input id="playerBodyType" type="text" placeholder="e.g., athletic, slim, curvy, muscular" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Color</label>
        <input id="playerHairColor" type="text" placeholder="e.g., brown, blonde, black" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Style</label>
        <input id="playerHairStyle" type="text" placeholder="e.g., short, long, wavy, bald" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Eye Color</label>
        <input id="playerEyeColor" type="text" placeholder="e.g., blue, brown, green" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Facial Hair</label>
        <input id="playerFacialHair" type="text" placeholder="e.g., beard, mustache, clean shaven" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Intimate Details -->
    <h3 style="margin:20px 0 15px 0; color:#e94560; font-size:1.2rem;">🔞 Intimate Details</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Genital Type</label>
        <select id="playerGenitalType" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="penis">Penis</option>
          <option value="vagina">Vagina</option>
          <option value="both">Both (Intersex)</option>
          <option value="other">Other</option>
        </select>
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Size/Details</label>
        <input id="playerGenitalDetails" type="text" placeholder="e.g., average, large, small, specific measurements" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Breast/Chest Size</label>
        <input id="playerChestSize" type="text" placeholder="e.g., flat, C-cup, muscular pecs" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Build Details</label>
        <input id="playerBuildDetails" type="text" placeholder="e.g., toned abs, soft curves, broad shoulders" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Additional Details -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Additional Physical Details</label>
      <textarea id="playerAdditionalDetails" placeholder="Any other details... tattoos, piercings, scars, distinctive features, fashion style, etc." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Personality/Background -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Personality & Background (Optional)</label>
      <textarea id="playerPersonality" placeholder="Your personality traits, background, how you present yourself..." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerProfile" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="savePlayerProfile" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        💾 Save Profile
      </button>
    </div>
  </div>
</div>

<!-- Gender Options Modal -->
<div id="genderOptionsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">⚧️</span> Gender Diversity Options
      </h2>
      <button id="closeGenderOptionsModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <p style="color:#aaa; margin-bottom:25px; line-height:1.6;">
      Control the gender distribution of new hires. By default, all employees are female (100%). 
      Adjust these sliders to introduce more diversity. <strong>The sliders are proportional and will always total 100%.</strong>
    </p>
    
    <!-- Gender Sliders -->
    <div style="display:flex; flex-direction:column; gap:20px;">
      <!-- Female Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ff6b9d;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ff6b9d; font-size:1.2rem;">👩 Female</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard female employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ff6b9d;" id="femalePercentage">100</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleSlider" min="0" max="100" value="100" style="width:100%;">
      </div>
      
      <!-- Male Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #00d4ff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#00d4ff; font-size:1.2rem;">👨 Male</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard male employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="malePercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="maleSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Female Futa Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #c77dff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#c77dff; font-size:1.2rem;">👩‍🦰 Female Futa</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female with male genitalia (no transition)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#c77dff;" id="femaleFutaPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleFutaSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Man Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #4ecca3;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#4ecca3; font-size:1.2rem;">⚧️ Trans Man</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female to male (masculine with vagina)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#4ecca3;" id="transManPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transManSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Woman Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ffd700;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ffd700; font-size:1.2rem;">⚧️ Trans Woman</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Male to female (feminine with penis)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="transWomanPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transWomanSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
    </div>
    
    <!-- Total Display -->
    <div style="margin-top:25px; padding:15px; background:#0f3460; border-radius:10px; text-align:center;">
      <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Total Distribution</div>
      <div style="font-size:1.8rem; font-weight:700;" id="genderTotalDisplay">
        <span id="genderTotalValue" style="color:#00d4ff;">100</span>%
      </div>
      <div id="genderWarning" style="display:none; color:#e94560; font-size:0.9rem; margin-top:5px;">
        ⚠️ Total must equal 100%
      </div>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:25px;">
      <button id="cancelGenderOptions" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="saveGenderOptions" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        💾 Save Settings
      </button>
    </div>
  </div>
</div>

<!-- Emoji Picker Tray -->
<div id="emojiPickerTray" style="display:none; position:fixed; background:#1a1d23; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.5); border:1px solid #2f3336; width:300px; max-height:380px; overflow:hidden; z-index:9999999;">
  <div style="padding:10px; border-bottom:1px solid #2f3336; background:#16181c;">
    <div style="display:flex; gap:6px; overflow-x:auto; scrollbar-width:none;">
      <button class="emoji-category-btn active" data-category="recent" style="padding:6px 10px; background:#2f3336; border:none; border-radius:6px; color:white; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">🕐</button>
      <button class="emoji-category-btn" data-category="smileys" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">😊</button>
      <button class="emoji-category-btn" data-category="gestures" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">👋</button>
      <button class="emoji-category-btn" data-category="hearts" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">❤️</button>
      <button class="emoji-category-btn" data-category="objects" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">🎉</button>
      <button class="emoji-category-btn" data-category="symbols" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">✨</button>
    </div>
  </div>
  
  <div id="emojiPickerContent" style="padding:8px; max-height:310px; overflow-y:auto; overflow-x:hidden; display:flex; flex-wrap:wrap; gap:2px; align-content:flex-start;">
    <!-- Emojis will be populated here -->
  </div>
</div>

<!-- Cheats Modal -->
<div id="cheatsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); width:95%; max-width:900px; max-height:90vh; border-radius:20px; box-shadow:0 10px 40px rgba(233,69,96,0.4); border:2px solid #e94560; overflow-y:auto; margin:20px;">
    <div style="position:sticky; top:0; background:linear-gradient(135deg, #16213e 0%, #0f3460 100%); padding:20px; border-bottom:2px solid #e94560; z-index:10; border-radius:20px 20px 0 0;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <span style="font-size:2rem;">⚡</span>
          <h2 style="margin:0; color:#e94560; text-shadow:0 0 10px rgba(233,69,96,0.5);">Cheats & Debugging</h2>
        </div>
        <button id="closeCheatsBtn" style="background:transparent; border:2px solid #e94560; color:#e94560; font-size:1.5rem; cursor:pointer; width:40px; height:40px; border-radius:50%; transition:all 0.3s;" onmouseenter="this.style.background='#e94560'; this.style.color='white'" onmouseleave="this.style.background='transparent'; this.style.color='#e94560'">✕</button>
      </div>
    </div>
    
    <div style="padding:25px;">
      
      <!-- Money Setter -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">💰</span> Set Money
        </h3>
        <div style="display:flex; gap:15px; align-items:end;">
          <div style="flex:1;">
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Base Number (1-999)</label>
            <input type="number" id="cheatMoneyBase" min="1" max="999" value="100" style="width:100%; padding:12px; background:#16213e; border:1px solid #00d4ff; border-radius:8px; color:white; font-size:1.2rem; font-weight:600;">
          </div>
          <div style="flex:1;">
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Magnitude</label>
            <select id="cheatMoneyMagnitude" style="width:100%; padding:12px; background:#16213e; border:1px solid #00d4ff; border-radius:8px; color:white; font-size:1.1rem; cursor:pointer;">
              <option value="1">Ones (1)</option>
              <option value="1000">Thousand (K)</option>
              <option value="1000000" selected>Million (M)</option>
              <option value="1000000000">Billion (B)</option>
              <option value="1000000000000">Trillion (Tr)</option>
              <option value="1000000000000000">Quadrillion (Qd)</option>
              <option value="1000000000000000000">Quintillion (Qn)</option>
            </select>
          </div>
          <button id="cheatSetMoneyBtn" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem; transition:all 0.3s; white-space:nowrap;" onmouseenter="this.style.background='#ff0055'" onmouseleave="this.style.background='#e94560'">
            Set Balance
          </button>
        </div>
        <div style="margin-top:12px; padding:12px; background:#16213e; border-radius:8px; border-left:3px solid #00d4ff;">
          <span style="color:#aaa; font-size:0.9rem;">Preview: $</span><span id="cheatMoneyPreview" style="color:#00d4ff; font-weight:600; font-size:1.1rem;">100,000,000</span>
        </div>
      </div>
      
      <!-- Stat Multipliers -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">📊</span> Stat Gain Multipliers
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">Multiply how fast stats increase. 1x = normal, 10x = 10 times faster</p>
        
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
          <!-- Affection -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ff69b4;">💖 Affection</span>
              <span id="affectionMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="affectionMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Trust -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#4ecdc4;">🤝 Trust</span>
              <span id="trustMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="trustMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Comfort -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#95e1d3;">🛋️ Comfort</span>
              <span id="comfortMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="comfortMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Desire -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ff6b6b;">🔥 Desire</span>
              <span id="desireMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="desireMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Productivity -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#f9ca24;">⚡ Productivity</span>
              <span id="productivityMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="productivityMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Confidence -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#00d4ff;">💪 Confidence</span>
              <span id="confidenceMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="confidenceMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Obedience -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#a29bfe;">🙇 Obedience</span>
              <span id="obedienceMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="obedienceMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Flirtiness -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#fd79a8;">😘 Flirtiness</span>
              <span id="flirtinessMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="flirtinessMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Professionalism -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#74b9ff;">💼 Professionalism</span>
              <span id="professionalismMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="professionalismMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Humor -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ffeaa7;">😂 Humor</span>
              <span id="humorMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="humorMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:15px;">
          <button id="resetMultipliersBtn" style="flex:1; padding:10px; background:#533483; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;">Reset All to 1x</button>
          <button id="maxMultipliersBtn" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;">Set All to 5x</button>
        </div>
      </div>
      
      <!-- Set Stats Max -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #e94560;">
        <h3 style="margin:0 0 15px 0; color:#e94560; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">🎯</span> Set All NPCs' Stats
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">Instantly set a specific stat to a chosen value for ALL active employees</p>
        
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px;">
          <div>
            <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Stat Type</label>
            <select id="cheatStatType" style="width:100%; padding:10px; background:#16213e; border:1px solid #e94560; border-radius:8px; color:white; cursor:pointer;">
              <option value="affection">💖 Affection</option>
              <option value="trust">🤝 Trust</option>
              <option value="comfort">🛋️ Comfort</option>
              <option value="desire">🔥 Desire</option>
              <option value="productivity">⚡ Productivity</option>
              <option value="confidence">💪 Confidence</option>
              <option value="obedience">🙇 Obedience</option>
              <option value="flirty">😘 Flirtiness</option>
              <option value="professional">💼 Professionalism</option>
              <option value="humor">😂 Humor</option>
            </select>
          </div>
          
          <div>
            <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Value (0-100)</label>
            <input type="number" id="cheatStatValue" min="0" max="100" value="100" style="width:100%; padding:10px; background:#16213e; border:1px solid #e94560; border-radius:8px; color:white; font-size:1.1rem;">
          </div>
          
          <div style="display:flex; align-items:end;">
            <button id="cheatSetStatBtn" style="width:100%; padding:10px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;" onmouseenter="this.style.background='#ff0055'" onmouseleave="this.style.background='#e94560'">
              Set for All NPCs
            </button>
          </div>
        </div>
        
        <div style="margin-top:15px; padding:12px; background:#16213e; border-radius:8px; border-left:3px solid #e94560;">
          <span style="color:#aaa; font-size:0.85rem;">⚠️ This will affect all active employees at once</span>
        </div>
      </div>
      
      <!-- Quick Actions -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">⚡</span> Quick Actions
        </h3>
        
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">
          <button id="cheatMaxAllStatsBtn" style="padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            🌟 Max All Stats (All NPCs)
          </button>
          
          <button id="cheatUnlockAllLocationsBtn" style="padding:12px; background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            🏢 Unlock All Locations
          </button>
          
          <button id="cheatUnlockAllProductsBtn" style="padding:12px; background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            📦 Unlock All Products
          </button>
          
          <button id="cheatHireAllBtn" style="padding:12px; background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            👥 Hire All Candidates
          </button>
          
          <button id="cheatClearPostsBtn" style="padding:12px; background:linear-gradient(135deg, #fa709a 0%, #fee140 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            🗑️ Clear All Posts
          </button>
          
          <button id="cheatSpawnPostsBtn" style="padding:12px; background:linear-gradient(135deg, #30cfd0 0%, #330867 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            📱 Spawn 10 NPC Posts
          </button>
        </div>
      </div>
      
      <!-- Context Windows -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-top:20px; border:1px solid #ffd700;">
        <h3 style="margin:0 0 15px 0; color:#ffd700; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">🧠</span> Context Windows
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">View and edit what NPCs "know" - Company-Wide Context and Gossip Engine data</p>
        
        <!-- Company-Wide Context -->
        <div style="margin-bottom:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h4 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:8px;">
              <span style="font-size:1.2rem;">🏢</span> Company-Wide Context
              <span id="contextCountLabel" style="font-size:0.9rem; color:#aaa; font-weight:normal;">(0/40)</span>
            </h4>
            <div style="display:flex; gap:8px;">
              <button id="cheatRefreshContextBtn" style="padding:6px 12px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600; font-size:0.85rem;">
                🔄 Refresh
              </button>
              <button id="cheatClearContextBtn" style="padding:6px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                🗑️ Clear All
              </button>
            </div>
          </div>
          <div id="contextList" style="max-height:300px; overflow-y:auto; background:#16213e; border-radius:8px; padding:10px;">
            <p style="color:#aaa; text-align:center; margin:20px 0;">Loading context...</p>
          </div>
        </div>
        
        <!-- Gossip Engine -->
        <div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h4 style="margin:0; color:#ff69b4; display:flex; align-items:center; gap:8px;">
              <span style="font-size:1.2rem;">💬</span> Gossip Engine
              <span id="gossipCountLabel" style="font-size:0.9rem; color:#aaa; font-weight:normal;">(0 NPCs)</span>
            </h4>
            <div style="display:flex; gap:8px;">
              <button id="cheatRefreshGossipBtn" style="padding:6px 12px; background:#ff69b4; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                🔄 Refresh
              </button>
              <button id="cheatClearGossipBtn" style="padding:6px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                🗑️ Clear All
              </button>
            </div>
          </div>
          <div id="gossipList" style="max-height:300px; overflow-y:auto; background:#16213e; border-radius:8px; padding:10px;">
            <p style="color:#aaa; text-align:center; margin:20px 0;">Loading gossip...</p>
          </div>
        </div>
      </div>
      
    </div>
  </div>
</div>

<!-- Corporate Pyramid Modal -->
<div id="pyramidModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000001; justify-content:center; align-items:center; overflow:hidden;">
  <!-- Content will be populated dynamically -->
</div>

<script>
  // Minimal modal registry (for clean close/cleanup)
  window.modalRegistry = window.modalRegistry || new Map();

  function debugModal() {
    const m = document.getElementById('hiringModal');
    if (!m) { console.warn('No #hiringModal in DOM'); return; }
    const cs = getComputedStyle(m);
    console.table({
      display: cs.display, visibility: cs.visibility, opacity: cs.opacity,
      position: cs.position, zIndex: cs.zIndex, pointerEvents: cs.pointerEvents
    });
    console.log('Modal rect:', m.getBoundingClientRect());
  }

  function closeHiringModal() {
    const overlay = document.getElementById('hiringModal');
    if (overlay) overlay.remove();
    const esc = window.__hiringEscHandler__;
    if (esc) { window.removeEventListener('keydown', esc); window.__hiringEscHandler__ = null; }
    modalRegistry.delete('hiring');
  }

  // Game Constants
  const GAME_TICK_INTERVAL = 100; // ms
  const INITIAL_CASH = 100;
  const NEWS_UPDATE_INTERVAL = 30000; // ms
  
  // ----- CASCADING MANAGER BONUS SYSTEM -----
  /**
   * Calculate cumulative bonuses from all managers in the chain above a product's staff
   * Returns an object with speed, income, and training multipliers
   */
  function getManagerialBonuses(product) {
    const bonuses = {
      speedMultiplier: 1.0,    // Faster production cycles
      incomeMultiplier: 1.0,   // Higher revenue per cycle
      trainingMultiplier: 1.0, // Faster skill/XP growth (future feature)
      managerChain: []         // For debugging/display
    };
    
    if (!product || !product.managerId) return bonuses;
    
    // Find the staff member working on this product
    const staff = gameState.employees.find(e => e.id === product.managerId);
    if (!staff || staff.employmentStatus !== 'active') return bonuses;
    
    // Find the pyramid position this staff occupies
    const staffPosition = gameState.corporatePyramid?.positions?.[1]?.find(
      pos => pos.employeeId === staff.id
    );
    
    if (!staffPosition) return bonuses;
    
    // Traverse up the management chain
    const visitedPositions = new Set(); // Prevent infinite loops
    let currentPosition = staffPosition;
    
    while (currentPosition && currentPosition.reportsTo && !visitedPositions.has(currentPosition.positionId)) {
      visitedPositions.add(currentPosition.positionId);
      
      // Find the manager this position reports to
      const managerPosition = findPositionById(currentPosition.reportsTo);
      
      if (!managerPosition || !managerPosition.employeeId) {
        break; // No manager in this position
      }
      
      // Get the manager employee
      const manager = gameState.employees.find(e => e.id === managerPosition.employeeId);
      
      if (!manager || manager.employmentStatus !== 'active') {
        break; // Manager not found or inactive
      }
      
      // Calculate bonuses based on manager's level
      const managerLevel = manager.career?.level || managerPosition.level;
      const levelInfo = gameState.hierarchyLevels?.[managerLevel];
      
      if (levelInfo) {
        // Each management level provides bonuses
        // Higher levels = bigger bonuses
        const levelBonus = {
          2: { speed: 1.05, income: 1.05, training: 1.03 },  // Local Manager: +5% speed/income, +3% training
          3: { speed: 1.08, income: 1.08, training: 1.05 },  // Regional Manager: +8% speed/income, +5% training
          4: { speed: 1.12, income: 1.12, training: 1.08 },  // Branch Manager: +12% speed/income, +8% training
          5: { speed: 1.15, income: 1.15, training: 1.10 },  // CFO/COO: +15% speed/income, +10% training
          6: { speed: 1.20, income: 1.20, training: 1.15 },  // Senior Executive: +20% speed/income, +15% training
          7: { speed: 1.25, income: 1.25, training: 1.20 }   // CEO: +25% speed/income, +20% training
        };
        
        const bonus = levelBonus[managerLevel] || { speed: 1.0, income: 1.0, training: 1.0 };
        
        // Apply manager's skill bonuses (management skill enhances their effectiveness)
        let effectivenessMultiplier = 1.0;
        if (manager.skills?.management) {
          const managementLevel = manager.skills.management.level || 1;
          effectivenessMultiplier = 1 + (managementLevel * 0.02); // +2% per management skill level
        }
        
        // Apply bonuses with effectiveness multiplier
        bonuses.speedMultiplier *= Math.pow(bonus.speed, effectivenessMultiplier);
        bonuses.incomeMultiplier *= Math.pow(bonus.income, effectivenessMultiplier);
        bonuses.trainingMultiplier *= Math.pow(bonus.training, effectivenessMultiplier);
        
        // Track for debugging
        bonuses.managerChain.push({
          name: manager.name,
          title: levelInfo.title,
          level: managerLevel,
          speedBonus: bonus.speed,
          incomeBonus: bonus.income,
          effectiveness: effectivenessMultiplier
        });
      }
      
      // Move up to the next level
      currentPosition = managerPosition;
    }
    
    return bonuses;
  }
  
  /**
   * Helper function to find a position by its ID across all levels
   */
  function findPositionById(positionId) {
    if (!gameState.corporatePyramid?.positions) return null;
    
    // Check CEO position
    if (positionId === 'ceo' && gameState.corporatePyramid.ceoPosition) {
      return gameState.corporatePyramid.ceoPosition;
    }
    
    // Check secretary position
    if (positionId === 'secretary' && gameState.corporatePyramid.secretaryPosition) {
      return gameState.corporatePyramid.secretaryPosition;
    }
    
    // Search through all levels
    for (let level = 1; level <= 7; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const found = positions.find(pos => pos.positionId === positionId);
        if (found) return found;
      }
    }
    
    return null;
  }
  
  // ----- PRODUCT HELPERS -----
  function getManagerSpeedMultiplier(p) {
    // Continuous scaling without hard cap
    // Each level reduces time by ~8%, stacking multiplicatively
    // Level 1: 92% time, Level 10: 43% time, Level 30: 9% time, Level 50: 2% time
    if (!p.managerHired || p.managerLevel === 0) return 1.0;
    
    let multiplier = Math.pow(0.92, p.managerLevel);
    
    // Apply automation boost from influence upgrades
    const autoBoostLevel = gameState.influenceUpgrades?.autoProgress || 0;
    const autoBoostMultiplier = influenceUpgrades.autoProgress.effect(autoBoostLevel);
    
    // This makes managers work FASTER (reduces cycle time further)
    multiplier /= autoBoostMultiplier;
    
    // Apply loyalty bonus if manager is a rehired former employee
    const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
    if (manager && manager.loyaltyBonus) {
      // Loyalty bonus further reduces cycle time
      multiplier /= (1 + manager.loyaltyBonus);
    }
    
    // ===== CASCADING MANAGER BONUSES =====
    // All managers in the chain above this product provide speed bonuses
    const managerialBonuses = getManagerialBonuses(p);
    multiplier /= managerialBonuses.speedMultiplier; // Divide to make it faster
    
    // ===== EMPLOYEE STAT IMPACT =====
    // Productivity and Trust directly affect manager efficiency
    if (manager) {
      // Productivity Impact: 0.85x to 1.0x (at 0 to 100 productivity)
      // Low productivity = slower cycles, high productivity = baseline speed
      const productivity = manager.productivity || 50; // Default 50 if not set
      const productivityMultiplier = 0.85 + (productivity * 0.15 / 100); // 0.85 at 0, 1.0 at 100
      multiplier /= productivityMultiplier; // DIVIDE to make high productivity = faster
      
      // Trust Impact: 0.85x to 1.15x (at 0 to 100 trust)
      // Low trust = hesitant/inefficient, high trust = empowered/faster
      // Baseline at 70 trust, bonus above 70
      const trust = manager.trust || 50; // Default 50 if not set
      const trustMultiplier = trust <= 70 
        ? 0.85 + (trust * 0.15 / 70)           // 0.85 at 0 → 1.0 at 70
        : 1.0 + ((trust - 70) * 0.15 / 30);    // 1.0 at 70 → 1.15 at 100
      multiplier /= trustMultiplier; // DIVIDE to make high trust = faster
      
      // Obedience Impact: Affects consistency (reliability)
      // Low obedience = occasional delays, high obedience = perfectly consistent
      // This is a subtle effect (0.92x to 1.0x)
      const obedience = manager.obedience || 50;
      const obedienceMultiplier = 0.92 + (obedience / 1250); // 0.92 at 0, 1.0 at 100
      multiplier /= obedienceMultiplier; // DIVIDE to make high obedience = faster
    }
    
    return multiplier;
  }

  function currentCycleTimeMs(p) {
    // Base cycle time with manager speed multiplier
    let cycleTime = Math.floor(p.baseTimeMs * getManagerSpeedMultiplier(p));
    
    // ===== SKILL-BASED SPEED BONUS (Phase 3) =====
    const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
    if (manager && p.managerHired && manager.skills) {
      let speedBonus = 1.0;
      
      // Technical skill = faster tech/software products (up to 50% faster at level 10)
      if (p.name && (p.name.toLowerCase().includes('software') || p.name.toLowerCase().includes('tech') || p.name.toLowerCase().includes('app'))) {
        const techLevel = manager.skills.technical?.level || 0;
        speedBonus *= (1 - (techLevel * 0.05)); // -5% cycle time per level
      }
      
      // Creative skill = faster creative products
      if (p.name && (p.name.toLowerCase().includes('design') || p.name.toLowerCase().includes('art') || p.name.toLowerCase().includes('creative'))) {
        const creativeLevel = manager.skills.creative?.level || 0;
        speedBonus *= (1 - (creativeLevel * 0.05));
      }
      
      // Management skill = universal 2% speed boost per level
      const mgmtLevel = manager.skills.management?.level || 0;
      speedBonus *= (1 - (mgmtLevel * 0.02));
      
      cycleTime = Math.floor(cycleTime * speedBonus);
    }
    
    // Minimum 100ms
    return Math.max(100, cycleTime);
  }

  function currentValue(p) {
  // Balanced value growth with global multiplier for better progression
  const level = p.level || 0;
  const baseValue = p.valuePerUnit || 3;
  const growthLinear = 1 + (p.valuePerUpgrade || 0.10) * level;
  const exp = p.valueExponent ?? gameBalance.productIncomeExponent;
  
  // Apply global income multiplier
  let value = baseValue * Math.pow(growthLinear, exp) * gameBalance.globalIncomeMultiplier;
  
  // Apply location-specific income boost from upgrades with DIMINISHING RETURNS
  const incomeBoostLevel = gameState.globalUpgrades?.incomeBoost?.[p.locationId] || 0;
  if (incomeBoostLevel > 0) {
    // Asymptotic formula: (1 - 0.9^level) gives diminishing returns
    const boostPercentage = (1 - Math.pow(0.9, incomeBoostLevel)) * 100;
    const boostMultiplier = 1 + (boostPercentage / 100);
    value *= boostMultiplier;
  }
  
  // ===== CORPORATE HIERARCHY BONUS =====
  // Apply corporate level bonus from manager
  const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
  if (manager && manager.career && p.managerHired) {
    const careerLevel = manager.career.level || 1;
    const levelData = gameState.hierarchyLevels?.[careerLevel];
    
    if (levelData && levelData.productBonusPercent) {
      // Apply product bonus based on manager's corporate level
      const bonusMultiplier = 1 + (levelData.productBonusPercent / 100);
      value *= bonusMultiplier;
    }
  }
  
  // ===== CASCADING MANAGER INCOME BONUSES =====
  // All managers in the chain above this product provide income bonuses
  const managerialBonuses = getManagerialBonuses(p);
  value *= managerialBonuses.incomeMultiplier;
  
  // ===== EXECUTIVE GLOBAL BONUSES =====
  // COO and CFO provide company-wide income multipliers
  if (gameState.corporateHierarchy && gameState.corporateHierarchy.executiveRoles) {
    let executiveMultiplier = 1.0;
    
    // Check for COO (Chief Operating Officer) - +10% global income
    if (gameState.corporateHierarchy.executiveRoles.COO) {
      const coo = gameState.employees.find(e => e.id === gameState.corporateHierarchy.executiveRoles.COO);
      if (coo && coo.employmentStatus === 'active') {
        executiveMultiplier *= 1.10;
      }
    }
    
    // Check for CFO (Chief Financial Officer) - +10% global income
    if (gameState.corporateHierarchy.executiveRoles.CFO) {
      const cfo = gameState.employees.find(e => e.id === gameState.corporateHierarchy.executiveRoles.CFO);
      if (cfo && cfo.employmentStatus === 'active') {
        executiveMultiplier *= 1.10;
      }
    }
    
    // Apply executive bonuses
    value *= executiveMultiplier;
    
    // Update global multiplier for UI display
    gameState.globalIncomeMultiplier = executiveMultiplier;
  }
  
  // ===== EMPLOYEE PRODUCTIVITY INCOME BONUS =====
  // Productivity directly increases income generated
  if (manager && p.managerHired) {
    const baseProductivity = manager.stats?.productivity || 50;
    
    // ===== SKILL BONUSES (Phase 3) =====
    // Skills add to effective productivity
    let skillBonus = 0;
    if (manager.skills) {
      // Technical skill boosts tech products
      if (p.name && (p.name.toLowerCase().includes('software') || p.name.toLowerCase().includes('tech') || p.name.toLowerCase().includes('app'))) {
        skillBonus += getSkillBonus(manager, 'technical');
      }
      // Creative skill boosts creative products
      if (p.name && (p.name.toLowerCase().includes('design') || p.name.toLowerCase().includes('art') || p.name.toLowerCase().includes('creative'))) {
        skillBonus += getSkillBonus(manager, 'creative');
      }
      // Management skill gives universal boost
      skillBonus += getSkillBonus(manager, 'management') * 0.5; // Half bonus from management
    }
    
    // Combine base productivity + skill bonuses (cap at 150)
    const totalProductivity = Math.min(150, baseProductivity + skillBonus);
    
    // 1.0x to 1.3x income bonus (0 to 150 effective productivity)
    const productivityIncomeBonus = 1 + (totalProductivity / 500);
    value *= productivityIncomeBonus;
  }
  
  return +value.toFixed(2);
  }

  function clickReductionMs(p) {
    // Use globalUpgrades.clickPower which gives +0.1s per level
    const baseSeconds = p.clickSecondsBase || 1.0;
    const globalUpgradeBonus = (gameState.globalUpgrades?.clickPower || 0) * 0.1;
    
    // Add prestige influence upgrade bonus
    const influenceClickLevel = gameState.influenceUpgrades?.clickPower || 0;
    const influenceClickBonus = influenceUpgrades.clickPower.effect(influenceClickLevel);
    
    const perClickSeconds = baseSeconds + globalUpgradeBonus + influenceClickBonus;
    return perClickSeconds * 1000;
  }

  // ============================================
  // GAME BALANCE CONFIGURATION
  // ============================================
  // Central control for all economy tuning
  const gameBalance = {
    // Global multipliers
    globalIncomeMultiplier: 2.5,     // Make everything 2.5x faster for better pacing
    globalCostReduction: 0.7,        // Reduce costs to 70% (was too aggressive at 60%)
    
    // Product scaling
    productCostMultiplier: 1.22,     // Each level costs 1.20x more (reduced from 1.35 for smoother progression to 999)
    productIncomeMultiplier: 1.20,   // Each level gives 1.15x more income
    productIncomeExponent: 0.95,     // Diminishing returns on income growth
    
    // Starting values
    startingCash: 150,               // Start with more cash (was 100)
    firstProductUnlockCost: 80,      // Cheaper to unlock second product (was 100)
    
    // Click power
    baseClickReduction: 1,           // Seconds removed per click
    clickPowerGrowth: 1,             // Additional seconds per upgrade level
    
    // Manager costs  
    managerCostReduction: 0.7,       // Managers cost 70% of original
    
    // Boss fights (for future use)
    bossHealthMultiplier: 2.0,       // Boss health = unlock cost * this
    bossTimeLimit: 60,               // Default time limit in seconds
    bossRewardMultiplier: 5.0,       // Reward = unlock cost * this
    
    // Player upgrades (for future use)
    upgradeBaseCosts: {
      clickPower: 10000,           // $10K base for click power (scales with 2.0x)
      incomeBoost: 50000,          // $50K base for income boost (scales with 2.5x)
      costReduction: 100000        // $100K base for cost reduction (scales with 3.0x)
    }
  };

  // ============================================
  // EMOJI PICKER SYSTEM
  // ============================================
  const emojiPicker = {
    recentEmojis: [], // Store recently used emojis (no duplicates)
    maxRecent: 24,
    currentTarget: null, // The input/textarea that will receive the emoji
    
    emojis: {
      smileys: ['😀','😃','😄','😁','😆','😅','🤣','😂','🙂','🙃','😉','😊','😇','🥰','😍','🤩','😘','😗','😚','😙','🥲','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐','😑','😶','😏','😒','🙄','😬','🤥','😌','😔','😪','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','🥴','😵','🤯','🤠','🥳','🥸','😎','🤓','🧐'],
      gestures: ['👋','🤚','🖐','✋','🖖','👌','🤌','🤏','✌️','🤞','🤟','🤘','🤙','👈','👉','👆','🖕','👇','☝️','👍','👎','✊','👊','🤛','🤜','👏','🙌','👐','🤲','🤝','🙏','💪','🦾','🦿','🦵','🦶','👂','🦻','👃','🧠','🫀','🫁','🦷','🦴','👀','👁','👅','👄','💋'],
      hearts: ['❤️','🧡','💛','💚','💙','💜','🖤','🤍','🤎','💔','❤️‍🔥','❤️‍🩹','💕','💞','💓','💗','💖','💘','💝','💟','💌','💢','💥','💫','💦','💨','🕳️','💬','👁️‍🗨️','🗨️','🗯️','💭'],
      objects: ['🎉','🎊','🎈','🎁','🎀','🏆','🥇','🥈','🥉','⚽','🏀','🏈','⚾','🎾','🏐','🏉','🎱','🏓','🏸','🥅','🥊','🥋','⛳','⛸️','🎣','🎽','🎿','🛷','🥌','🎯','🪀','🪁','🎱','🎮','🕹️','🎰','🎲','🧩','♟️','🎭','🎨','🧵','🪡','🧶','🪢','📷','📸','📹','🎥','📽️','🎬','📺','📻','🎙️','🎚️','🎛️','🎧','🎷','🪗','🎸','🎹','🎺','🎻','🪕','🥁','🪘','📱','📲','☎️','📞','📟','📠','🔋','🔌','💻','🖥️','🖨️','⌨️','🖱️','🖲️','💾','💿','📀','🧮','🎥'],
      symbols: ['✨','⭐','🌟','💫','✅','❌','⭕','🔥','💯','🎯','💢','💤','💨','🕳️','✔️','☑️','✖️','➕','➖','➗','❓','❔','❕','❗','〰️','💱','💲','⚠️','🚸','🔱','📛','🔰','✳️','❇️','♻️','💠','🔷','🔶','🔹','🔸','🔺','🔻','💎','🔘','🔲','🔳']
    },
    
    init() {
      // Load recent emojis from localStorage
      const saved = localStorage.getItem('recentEmojis');
      if (saved) {
        try {
          this.recentEmojis = JSON.parse(saved);
        } catch (e) {
          this.recentEmojis = [];
        }
      }
      
      // Setup category buttons
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.switchCategory(btn.dataset.category);
        });
      });
      
      // Close on outside click
      document.addEventListener('click', (e) => {
        const picker = document.getElementById('emojiPickerTray');
        if (picker.style.display === 'block' && !picker.contains(e.target)) {
          // Check if click was on an emoji button
          if (!e.target.classList.contains('emoji-picker-trigger')) {
            this.hide();
          }
        }
      });
      
      // Initial render
      this.renderRecent();
    },
    
    show(targetInput, triggerButton) {
      console.log('EmojiPicker.show() called', {targetInput, triggerButton});
      this.currentTarget = targetInput;
      const picker = document.getElementById('emojiPickerTray');
      console.log('Picker element:', picker);
      const rect = triggerButton.getBoundingClientRect();
      console.log('Button rect:', rect);
      
      // Position picker near the trigger button
      const spaceBelow = window.innerHeight - rect.bottom;
      const spaceAbove = rect.top;
      
      // Prefer positioning below, but if not enough space, position above
      if (spaceBelow > 420 || spaceBelow > spaceAbove) {
        picker.style.top = `${rect.bottom + 5}px`;
        picker.style.bottom = 'auto';
      } else {
        picker.style.bottom = `${window.innerHeight - rect.top + 5}px`;
        picker.style.top = 'auto';
      }
      
      // Position horizontally (try to align with button, but stay in viewport)
      let left = rect.left;
      const pickerWidth = 320;
      if (left + pickerWidth > window.innerWidth) {
        left = window.innerWidth - pickerWidth - 10;
      }
      picker.style.left = `${Math.max(10, left)}px`;
      
      picker.style.display = 'block';
      console.log('Picker display set to block, styles:', {
        display: picker.style.display,
        top: picker.style.top,
        left: picker.style.left,
        zIndex: picker.style.zIndex
      });
      
      // Show recent category by default
      this.switchCategory('recent');
    },
    
    hide() {
      document.getElementById('emojiPickerTray').style.display = 'none';
      this.currentTarget = null;
    },
    
    switchCategory(category) {
      // Update button states
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        if (btn.dataset.category === category) {
          btn.style.background = '#2f3336';
          btn.style.color = 'white';
          btn.classList.add('active');
        } else {
          btn.style.background = 'transparent';
          btn.style.color = '#aaa';
          btn.classList.remove('active');
        }
      });
      
      // Render emojis for this category
      if (category === 'recent') {
        this.renderRecent();
      } else {
        this.renderCategory(category);
      }
    },
    
    renderRecent() {
      const content = document.getElementById('emojiPickerContent');
      if (this.recentEmojis.length === 0) {
        content.innerHTML = '<div style="width:100%; text-align:center; padding:40px 20px; color:#666;">No recent emojis yet<br><span style="font-size:2rem; margin-top:10px; display:block;">🕐</span></div>';
        return;
      }
      
      content.innerHTML = this.recentEmojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    renderCategory(category) {
      const content = document.getElementById('emojiPickerContent');
      const emojis = this.emojis[category] || [];
      
      content.innerHTML = emojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    attachEmojiClickHandlers() {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.insertEmoji(btn.dataset.emoji);
        });
      });
    },
    
    insertEmoji(emoji) {
      if (!this.currentTarget) return;
      
      const input = this.currentTarget;
      const start = input.selectionStart || 0;
      const end = input.selectionEnd || 0;
      const text = input.value;
      
      // Insert emoji at cursor position
      input.value = text.substring(0, start) + emoji + text.substring(end);
      
      // Move cursor after emoji
      const newPos = start + emoji.length;
      input.setSelectionRange(newPos, newPos);
      input.focus();
      
      // Add to recent (remove if exists first to avoid duplicates)
      this.recentEmojis = this.recentEmojis.filter(e => e !== emoji);
      this.recentEmojis.unshift(emoji);
      
      // Keep only max recent
      if (this.recentEmojis.length > this.maxRecent) {
        this.recentEmojis = this.recentEmojis.slice(0, this.maxRecent);
      }
      
      // Save to localStorage
      localStorage.setItem('recentEmojis', JSON.stringify(this.recentEmojis));
      
      // Don't hide picker - let user pick multiple
      // If they want to close, they can click outside
    }
  };

  // Game State
  let gameState = {
    cash: gameBalance.startingCash,  // Use balance config
    playerUpgrades: { clickPower: 0 }, // each +1 = +0.1s per click
    totalEarnings: 0,
    onboarding: [], // tracks employees being onboarded
    lastPlayTime: Date.now(), // Track when player last played for AFK income
    lastInteractionTime: Date.now(), // Track actual last user interaction (clicks, taps, etc.)
    pageHiddenTime: null, // Track when page was hidden/backgrounded
    
    // ⏰ PHASE 4: TIME & SCHEDULE SYSTEM
    time: {
      enabled: true,                    // Toggle time progression
      currentTime: Date.now(),          // Current game timestamp
      timeScale: 20,                    // Time multiplier (20 = 1 game min per 3 real seconds)
      lastHour: null,                   // Track last hour for hourly events
      lastDay: null,                    // Track last day for daily events
      paused: false                     // Pause time progression
      // NOTE: Methods moved to timeHelpers to allow save serialization
    },
    
    // OFFLINE EARNINGS SYSTEM
    offlineEarnings: {
      enabled: true,                    // Allow offline earnings
      maxDuration: 24 * 60 * 60 * 1000, // Max 24 hours (real time)
      rate: 0.5,                        // 50% of normal income rate
      lastPlayedRealTime: Date.now()    // Track when player last played (real time)
    },
    
    // PRESTIGE SYSTEM
    prestigeLevel: 0,              // Number of times player has prestiged
    influencePoints: 0,            // Prestige currency (persistent)
    lifetimeEarnings: 0,           // Total earnings across all prestiges
    lifetimeEarningsConverted: 0,  // Lifetime earnings already converted to influence
    prestigeMultiplier: 1.0,       // Income multiplier from prestiges
    
    // GLOBAL UPGRADES (reset on prestige)
    globalUpgrades: {
      clickPower: 0,               // Level of click power upgrade (+0.1s per level)
      incomeBoost: {},             // Per-location income boost {locationId: level} (+10% per level)
      costReduction: {}            // Per-location cost reduction {locationId: level} (-10% per level)
    },
    
    // BOSS FIGHTS
    bossFights: {
      active: null,                // Currently active boss fight
      defeated: [],                // Array of defeated boss IDs
      history: []                  // Combat history for replay/stats
    },
    
    locations: [
      {
        id: 'garage',
        name: '🏠 Garage',
        cost: 0,
        owned: true,
        unlocked: true,
        theme: {
          primary: '#3498db',      // Light blue
          secondary: '#ecf0f1',    // White
          accent: '#95a5a6',       // Gray
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          description: 'Humble beginnings in your garage'
        },
        products: []
      },
      {
        id: 'home_office',
        name: '💼 Home Office',
        cost: 15000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#2c3e50',      // Navy blue
          secondary: '#27ae60',    // Forest green
          accent: '#f5f5dc',       // Cream
          background: 'linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%)',
          description: 'Professional workspace, scaling up operations'
        },
        products: []
      },
      {
        id: 'office_suite',
        name: '🏢 Office Suite',
        cost: 500000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#1e3a8a',      // Corporate blue
          secondary: '#c0c0c0',    // Silver
          accent: '#ffffff',       // White
          background: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
          description: 'Legitimate corporate headquarters, the big leagues'
        },
        products: []
      },
      {
        id: 'factory',
        name: '🏭 Factory',
        cost: 25000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#5a6268',      // Industrial gray
          secondary: '#fd7e14',    // Orange
          accent: '#607d8b',       // Steel blue
          background: 'linear-gradient(135deg, #232526 0%, #414345 100%)',
          description: 'Manufacturing facility producing physical goods'
        },
        products: []
      },
      {
        id: 'rnd',
        name: '🔬 R&D Lab',
        cost: 5000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#00bfff',      // Electric blue
          secondary: '#39ff14',    // Neon green
          accent: '#f0f0f0',       // White
          background: 'linear-gradient(135deg, #000428 0%, #004e92 100%)',
          description: 'Cutting-edge research and experimental technology'
        },
        products: []
      },
      {
        id: 'creative_studio',
        name: '🎨 Creative Studio',
        cost: 500000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#9b59b6',      // Purple
          secondary: '#e91e63',    // Magenta
          accent: '#b76e79',       // Rose gold
          background: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)',
          description: '"Artistic" content creation and adult-adjacent media'
        },
        nsfwLevel: 1,              // Suggestive content begins
        products: []
      },
      {
        id: 'private_club',
        name: '🍸 Private Club',
        cost: 50000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#c0392b',      // Deep red
          secondary: '#d4af37',    // Gold
          accent: '#1a1a1a',       // Black
          background: 'linear-gradient(135deg, #870000 0%, #190a05 100%)',
          description: 'Elite adult entertainment and exclusive services'
        },
        nsfwLevel: 2,              // Explicit content
        products: []
      },
      {
        id: 'velvet_room',
        name: '🎭 Velvet Room',
        cost: 5000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#4a148c',      // Dark purple
          secondary: '#b71c1c',    // Crimson
          accent: '#0f0f0f',       // Shadow black
          background: 'linear-gradient(135deg, #1a0033 0%, #330033 100%)',
          description: 'Secret society rituals, masks, absolute depravity'
        },
        nsfwLevel: 3,              // Depraved content
        products: []
      },
      {
        id: 'inner_sanctum',
        name: '👁️ Inner Sanctum',
        cost: 500000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#000000',      // Void black
          secondary: '#8b0000',    // Blood red
          accent: '#2d5016',       // Sickly green
          background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 50%, #000000 100%)',
          description: 'Beyond morality. You have become the darkness.'
        },
        nsfwLevel: 4,              // Endgame horror
        requiresPrestiges: 1,      // Must prestige at least once
        products: []
      }
    ],
    products: [
      {
        id: 'website',
        name: 'Website Development',
        locationId: 'garage',
        // unlock
        unlocked: true,           // first product is always unlocked
        unlockCost: 0,            // no cost for first product
        // economy
  valuePerUnit: 3,          // $ earned per completed cycle
  level: 0,                 // product upgrade level
  upgradeCost: 50,          // current upgrade cost (will scale by costGrowth)
  baseUpgradeCost: 50,      // base cost at level 0
  costGrowth: 1.35,         // cost multiplier per level
  valuePerUpgrade: 0.10,    // toned down growth per upgrade
  valueExponent: 0.85,      // diminishing returns exponent
        // timing
        baseTimeMs: 6000,         // 6s cycle base
        running: false,
        timeRemainingMs: 0,
        // clicking
        clickSecondsBase: 1,      // each click removes 1 second by default
        // manager
        managerHired: false,
        managerLevel: 0,
        managerHireCost: 500,
        managerUpgradeCost: 250,
        // caps
  managerSpeedCapPct: 0.40  // at most 40% faster
      },
      {
        id: 'app',
        name: 'Mobile App',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 80,          // Reduced from 100 for faster early game
  valuePerUnit: 9, level: 0, upgradeCost: 150, baseUpgradeCost: 150, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 10000, running:false, timeRemainingMs:0,
        clickSecondsBase: 1,
        managerHired:false, managerLevel:0, managerHireCost:1500, managerUpgradeCost:750,
  managerSpeedCapPct:0.40
      },
      {
        id: 'consulting',
        name: 'IT Consulting',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 300,          // Reduced from 400 for better flow
  valuePerUnit: 18, level: 0, upgradeCost: 300, baseUpgradeCost: 300, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 14000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000, managerUpgradeCost:1500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'cloud',
        name: 'Cloud Services',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 1200,         // Reduced from 1800 for better pacing
  valuePerUnit: 32, level: 0, upgradeCost: 500, baseUpgradeCost: 500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 20000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000, managerUpgradeCost:2500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'seo',
        name: 'SEO Services',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 3000,
        valuePerUnit: 55, level: 0, upgradeCost: 800, baseUpgradeCost: 800, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 25000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:8000, managerUpgradeCost:4000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branding',
        name: 'Brand Design',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 5000,
        valuePerUnit: 85, level: 0, upgradeCost: 1200, baseUpgradeCost: 1200, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 30000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:12000, managerUpgradeCost:6000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ecommerce',
        name: 'E-Commerce Store',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 8000,
        valuePerUnit: 130, level: 0, upgradeCost: 1800, baseUpgradeCost: 1800, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:18000, managerUpgradeCost:9000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'automation',
        name: 'Business Automation',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 12000,
        valuePerUnit: 200, level: 0, upgradeCost: 2500, baseUpgradeCost: 2500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 40000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000, managerUpgradeCost:12500,
        managerSpeedCapPct:0.40
      },
      // HOME OFFICE LOCATION PRODUCTS
      {
        id: 'copywriting',
        name: 'Copywriting Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 300, level: 0, upgradeCost: 3500, baseUpgradeCost: 3500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:35000, managerUpgradeCost:17500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'video_editing',
        name: 'Video Production',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 20000,
        valuePerUnit: 450, level: 0, upgradeCost: 5000, baseUpgradeCost: 5000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 45000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50000, managerUpgradeCost:25000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'marketing',
        name: 'Marketing Campaigns',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 35000,
        valuePerUnit: 700, level: 0, upgradeCost: 7500, baseUpgradeCost: 7500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 50000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:70000, managerUpgradeCost:35000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consulting_premium',
        name: 'Premium Consulting',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 55000,
        valuePerUnit: 1100, level: 0, upgradeCost: 11000, baseUpgradeCost: 11000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 60000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:100000, managerUpgradeCost:50000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'saas',
        name: 'SaaS Platform',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 85000,
        valuePerUnit: 1700, level: 0, upgradeCost: 16000, baseUpgradeCost: 16000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 70000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:150000, managerUpgradeCost:75000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'virtual_assistant',
        name: 'Virtual Assistant Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 120000,
        valuePerUnit: 2500, level: 0, upgradeCost: 24000, baseUpgradeCost: 24000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 75000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:220000, managerUpgradeCost:110000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'social_media_mgmt',
        name: 'Social Media Management',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 180000,
        valuePerUnit: 3800, level: 0, upgradeCost: 36000, baseUpgradeCost: 36000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 80000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:320000, managerUpgradeCost:160000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'online_courses',
        name: 'Online Course Creation',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 250000,
        valuePerUnit: 5700, level: 0, upgradeCost: 52000, baseUpgradeCost: 52000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 85000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:450000, managerUpgradeCost:225000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'business_coaching',
        name: 'Business Coaching',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 350000,
        valuePerUnit: 8500, level: 0, upgradeCost: 75000, baseUpgradeCost: 75000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 90000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:650000, managerUpgradeCost:325000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'digital_marketing',
        name: 'Digital Marketing Agency',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 480000,
        valuePerUnit: 12500, level: 0, upgradeCost: 110000, baseUpgradeCost: 110000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 95000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000, managerUpgradeCost:450000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // OFFICE SUITE LOCATION PRODUCTS
      // ============================================
      {
        id: 'enterprise_saas',
        name: 'Enterprise SaaS Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18000, level: 0, upgradeCost: 160000, baseUpgradeCost: 160000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 100000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1500000, managerUpgradeCost:750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'enterprise_software',
        name: 'Enterprise Software Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 700000,
        valuePerUnit: 27000, level: 0, upgradeCost: 240000, baseUpgradeCost: 240000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 105000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2200000, managerUpgradeCost:1100000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'api_marketplace',
        name: 'API Marketplace',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 1200000,
        valuePerUnit: 41000, level: 0, upgradeCost: 360000, baseUpgradeCost: 360000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 110000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3300000, managerUpgradeCost:1650000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'white_label',
        name: 'White Label Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 2000000,
        valuePerUnit: 62000, level: 0, upgradeCost: 540000, baseUpgradeCost: 540000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 115000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000000, managerUpgradeCost:2500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cybersecurity',
        name: 'Cybersecurity Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 3500000,
        valuePerUnit: 93000, level: 0, upgradeCost: 800000, baseUpgradeCost: 800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 120000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:7500000, managerUpgradeCost:3750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'data_analytics',
        name: 'Data Analytics Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 5500000,
        valuePerUnit: 140000, level: 0, upgradeCost: 1200000, baseUpgradeCost: 1200000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 125000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:11000000, managerUpgradeCost:5500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'crm_system',
        name: 'CRM System',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 8500000,
        valuePerUnit: 210000, level: 0, upgradeCost: 1800000, baseUpgradeCost: 1800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 130000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:17000000, managerUpgradeCost:8500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ai_integration',
        name: 'AI Integration Tools',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 13000000,
        valuePerUnit: 315000, level: 0, upgradeCost: 2700000, baseUpgradeCost: 2700000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 135000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000000, managerUpgradeCost:12500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'blockchain',
        name: 'Blockchain Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 20000000,
        valuePerUnit: 475000, level: 0, upgradeCost: 4000000, baseUpgradeCost: 4000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 140000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:38000000, managerUpgradeCost:19000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'acquisitions',
        name: 'Corporate Acquisitions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 30000000,
        valuePerUnit: 710000, level: 0, upgradeCost: 6000000, baseUpgradeCost: 6000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 145000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:55000000, managerUpgradeCost:27500000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // FACTORY LOCATION PRODUCTS
      // ============================================
      {
        id: 'custom_keychains',
        name: 'Custom Keychains',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1100000, level: 0, upgradeCost: 9000000, baseUpgradeCost: 9000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 150000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:80000000, managerUpgradeCost:40000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branded_tshirts',
        name: 'Branded T-Shirts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 35000000,
        valuePerUnit: 1650000, level: 0, upgradeCost: 13500000, baseUpgradeCost: 13500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 155000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:120000000, managerUpgradeCost:60000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'phone_cases',
        name: 'Custom Phone Cases',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 60000000,
        valuePerUnit: 2475000, level: 0, upgradeCost: 20000000, baseUpgradeCost: 20000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 160000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:180000000, managerUpgradeCost:90000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'desk_toys',
        name: 'Executive Desk Toys',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 100000000,
        valuePerUnit: 3713000, level: 0, upgradeCost: 30000000, baseUpgradeCost: 30000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 165000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:270000000, managerUpgradeCost:135000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'logo_stickers',
        name: 'Logo Sticker Sheets',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 170000000,
        valuePerUnit: 5570000, level: 0, upgradeCost: 45000000, baseUpgradeCost: 45000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 170000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:400000000, managerUpgradeCost:200000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'promo_mugs',
        name: 'Promotional Mugs',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 280000000,
        valuePerUnit: 8355000, level: 0, upgradeCost: 67500000, baseUpgradeCost: 67500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 175000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:600000000, managerUpgradeCost:300000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'tech_accessories',
        name: 'Tech Accessories Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 450000000,
        valuePerUnit: 12533000, level: 0, upgradeCost: 100000000, baseUpgradeCost: 100000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 180000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000000, managerUpgradeCost:450000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'furniture_line',
        name: 'Office Furniture Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 750000000,
        valuePerUnit: 18800000, level: 0, upgradeCost: 150000000, baseUpgradeCost: 150000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 185000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1350000000, managerUpgradeCost:675000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'vehicle_manufacturing',
        name: 'Vehicle Manufacturing',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 1200000000,
        valuePerUnit: 28200000, level: 0, upgradeCost: 225000000, baseUpgradeCost: 225000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 190000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2000000000, managerUpgradeCost:1000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'smart_home',
        name: 'Smart Home Devices',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 2000000000,
        valuePerUnit: 42300000, level: 0, upgradeCost: 337500000, baseUpgradeCost: 337500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 195000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000000000, managerUpgradeCost:1500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'robotics',
        name: 'Robotics Division',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 3200000000,
        valuePerUnit: 63450000, level: 0, upgradeCost: 500000000, baseUpgradeCost: 500000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 200000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4500000000, managerUpgradeCost:2250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'aerospace',
        name: 'Aerospace Parts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 5000000000,
        valuePerUnit: 95175000, level: 0, upgradeCost: 750000000, baseUpgradeCost: 750000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 205000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6750000000, managerUpgradeCost:3375000000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // R&D LAB LOCATION PRODUCTS
      // ============================================
      {
        id: 'patents',
        name: 'Patent Applications',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 143000000, level: 0, upgradeCost: 1125000000, baseUpgradeCost: 1125000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 210000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:10000000000, managerUpgradeCost:5000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'prototypes',
        name: 'Prototype Development',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 7000000000,
        valuePerUnit: 215000000, level: 0, upgradeCost: 1687500000, baseUpgradeCost: 1687500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 215000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:15000000000, managerUpgradeCost:7500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'genetic_research',
        name: 'Genetic Research',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 12000000000,
        valuePerUnit: 323000000, level: 0, upgradeCost: 2531250000, baseUpgradeCost: 2531250000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 220000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22500000000, managerUpgradeCost:11250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'quantum_computing',
        name: 'Quantum Computing',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 20000000000,
        valuePerUnit: 485000000, level: 0, upgradeCost: 3796875000, baseUpgradeCost: 3796875000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 225000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33750000000, managerUpgradeCost:16875000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'neural_implants',
        name: 'Neural Implants',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 33000000000,
        valuePerUnit: 728000000, level: 0, upgradeCost: 5695312500, baseUpgradeCost: 5695312500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 230000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50625000000, managerUpgradeCost:25312500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cloning',
        name: 'Cloning Technology',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 55000000000,
        valuePerUnit: 1092000000, level: 0, upgradeCost: 8542968750, baseUpgradeCost: 8542968750, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 235000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:75937500000, managerUpgradeCost:37968750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'time_dilation',
        name: 'Time Dilation Studies',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 90000000000,
        valuePerUnit: 1638000000, level: 0, upgradeCost: 12814453125, baseUpgradeCost: 12814453125, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 240000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:113906250000, managerUpgradeCost:56953125000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'dimensional_travel',
        name: 'Dimensional Travel',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 145000000000,
        valuePerUnit: 2457000000, level: 0, upgradeCost: 19221679688, baseUpgradeCost: 19221679688, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 245000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:170859375000, managerUpgradeCost:85429687500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consciousness_upload',
        name: 'Consciousness Upload',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 235000000000,
        valuePerUnit: 3686000000, level: 0, upgradeCost: 28832519531, baseUpgradeCost: 28832519531, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 250000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:256289062500, managerUpgradeCost:128144531250,
        managerSpeedCapPct:0.40
      },
      {
        id: 'reality_hacking',
        name: 'Reality Hacking',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 380000000000,
        valuePerUnit: 5529000000, level: 0, upgradeCost: 43248779297, baseUpgradeCost: 43248779297, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 255000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:384433593750, managerUpgradeCost:192216796875,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // CREATIVE STUDIO LOCATION PRODUCTS (NSFW LEVEL 1 - Suggestive)
      // ============================================
      {
        id: 'glamour_photography',
        name: 'Glamour Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 8294000000, level: 0, upgradeCost: 64872000000, baseUpgradeCost: 64872000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 260000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:576650000000, managerUpgradeCost:288325000000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'instagram_modeling',
        name: 'Instagram Modeling',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 650000000000,
        valuePerUnit: 12441000000, level: 0, upgradeCost: 97308000000, baseUpgradeCost: 97308000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 265000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:864975000000, managerUpgradeCost:432487500000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'boudoir_sessions',
        name: 'Boudoir Sessions',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1100000000000,
        valuePerUnit: 18662000000, level: 0, upgradeCost: 145962000000, baseUpgradeCost: 145962000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 270000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1297462500000, managerUpgradeCost:648731250000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'artistic_nudes',
        name: '"Artistic" Nude Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1900000000000,
        valuePerUnit: 27993000000, level: 0, upgradeCost: 218943000000, baseUpgradeCost: 218943000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 275000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1946193750000, managerUpgradeCost:973096875000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'premium_snapchat',
        name: 'Premium Snapchat Management',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 3100000000000,
        valuePerUnit: 41990000000, level: 0, upgradeCost: 328414000000, baseUpgradeCost: 328414000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 280000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2919290625000, managerUpgradeCost:1459645312500,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'spicy_patreon',
        name: 'Spicy Patreon Tiers',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 5200000000000,
        valuePerUnit: 62985000000, level: 0, upgradeCost: 492621000000, baseUpgradeCost: 492621000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 285000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4378935937500, managerUpgradeCost:2189467968750,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'amateur_videography',
        name: 'Amateur Content Videography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 8500000000000,
        valuePerUnit: 94478000000, level: 0, upgradeCost: 738931500000, baseUpgradeCost: 738931500000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 290000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6568403906250, managerUpgradeCost:3284201953125,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'cam_show_production',
        name: 'Cam Show Production Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 14000000000000,
        valuePerUnit: 141717000000, level: 0, upgradeCost: 1108397250000, baseUpgradeCost: 1108397250000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 295000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9852605859375, managerUpgradeCost:4926302929687,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_platform',
        name: 'Adult Content Platform',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 23000000000000,
        valuePerUnit: 212576000000, level: 0, upgradeCost: 1662595875000, baseUpgradeCost: 1662595875000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 300000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14778908789062, managerUpgradeCost:7389454394531,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'erotic_audio',
        name: 'Erotic Audio Stories',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 38000000000000,
        valuePerUnit: 318864000000, level: 0, upgradeCost: 2493893812500, baseUpgradeCost: 2493893812500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 305000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22168363183594, managerUpgradeCost:11084181591797,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'custom_fetish',
        name: 'Custom Fetish Content',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 62000000000000,
        valuePerUnit: 478296000000, level: 0, upgradeCost: 3740840718750, baseUpgradeCost: 3740840718750, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 310000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33252544775391, managerUpgradeCost:16626272387695,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_film_studio',
        name: 'Full Adult Film Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 100000000000000,
        valuePerUnit: 717444000000, level: 0, upgradeCost: 5611261078125, baseUpgradeCost: 5611261078125, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 315000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49878817163086, managerUpgradeCost:24939408581543,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },

      // ============================================
      // PRIVATE CLUB LOCATION PRODUCTS (NSFW LEVEL 2 - Explicit)
      // ============================================
      {
        id: 'vip_bottle_service',
        name: 'VIP Bottle Service',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1076166000000, level: 0, upgradeCost: 8416891617188, baseUpgradeCost: 8416891617188, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 320000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:74818225744629, managerUpgradeCost:37409112872314,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_dances',
        name: 'Private Dance Bookings',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 70000000000000,
        valuePerUnit: 1614249000000, level: 0, upgradeCost: 12625337425781, baseUpgradeCost: 12625337425781, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 325000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:112227338616943, managerUpgradeCost:56113669308471,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'companionship',
        name: 'Companionship Services',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 120000000000000,
        valuePerUnit: 2421374000000, level: 0, upgradeCost: 18938006138672, baseUpgradeCost: 18938006138672, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 330000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:168341007925415, managerUpgradeCost:84170503962707,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'executive_relief',
        name: 'Executive Stress Relief',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 200000000000000,
        valuePerUnit: 3632061000000, level: 0, upgradeCost: 28407009208008, baseUpgradeCost: 28407009208008, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 335000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:252511511888123, managerUpgradeCost:126255755944061,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_rooms',
        name: 'Private Room Rentals',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 330000000000000,
        valuePerUnit: 5448092000000, level: 0, upgradeCost: 42610513812012, baseUpgradeCost: 42610513812012, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 340000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:378767267832184, managerUpgradeCost:189383633916092,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'escort_network',
        name: 'Elite Escort Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 550000000000000,
        valuePerUnit: 8172138000000, level: 0, upgradeCost: 63915770718018, baseUpgradeCost: 63915770718018, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 345000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:568150901748276, managerUpgradeCost:284075450874138,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'fetish_club',
        name: 'Fetish Club Events',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 900000000000000,
        valuePerUnit: 12258207000000, level: 0, upgradeCost: 95873656077027, baseUpgradeCost: 95873656077027, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 350000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:852226352622414, managerUpgradeCost:426113176311207,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sugar_baby_agency',
        name: 'Sugar Baby Arrangements',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 1500000000000000,
        valuePerUnit: 18387311000000, level: 0, upgradeCost: 143810484115541, baseUpgradeCost: 143810484115541, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 355000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1278339528933621, managerUpgradeCost:639169764466810,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'bachelor_party_extreme',
        name: 'Bachelor Party Packages',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 2400000000000000,
        valuePerUnit: 27580967000000, level: 0, upgradeCost: 215715726173311, baseUpgradeCost: 215715726173311, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 360000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1917509293400432, managerUpgradeCost:958754646700216,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'luxury_brothel',
        name: 'Luxury Brothel Chain',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 4000000000000000,
        valuePerUnit: 41371451000000, level: 0, upgradeCost: 323573589259967, baseUpgradeCost: 323573589259967, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 365000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2876263940100648, managerUpgradeCost:1438131970050324,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sex_tourism',
        name: 'Sex Tourism Operations',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 6500000000000000,
        valuePerUnit: 62057177000000, level: 0, upgradeCost: 485360383889950, baseUpgradeCost: 485360383889950, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 370000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4314395910150972, managerUpgradeCost:2157197955075486,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'vice_network',
        name: 'Global Vice Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 10500000000000000,
        valuePerUnit: 93085766000000, level: 0, upgradeCost: 728040575834925, baseUpgradeCost: 728040575834925, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 375000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6471593865226458, managerUpgradeCost:3235796932613229,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },

      // ============================================
      // VELVET ROOM LOCATION PRODUCTS (NSFW LEVEL 3 - Depraved)
      // ============================================
      {
        id: 'secret_society',
        name: 'Secret Society Memberships',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 139628649000000, level: 0, upgradeCost: 1092060863752388, baseUpgradeCost: 1092060863752388, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 380000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9707390797839687, managerUpgradeCost:4853695398919843,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'blackmail_archives',
        name: 'Blackmail Insurance Archives',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 13000000000000000,
        valuePerUnit: 209442974000000, level: 0, upgradeCost: 1638091295628582, baseUpgradeCost: 1638091295628582, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 385000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14561086196759531, managerUpgradeCost:7280543098379765,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'private_island',
        name: 'Private Island Retreat Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 22000000000000000,
        valuePerUnit: 314164461000000, level: 0, upgradeCost: 2457136943442873, baseUpgradeCost: 2457136943442873, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 390000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21841629295139297, managerUpgradeCost:10920814647569648,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'compromising_material',
        name: 'Compromising Material Collection',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 36000000000000000,
        valuePerUnit: 471246692000000, level: 0, upgradeCost: 3685705415164310, baseUpgradeCost: 3685705415164310, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 395000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32762443942708945, managerUpgradeCost:16381221971354472,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'special_requests',
        name: '"Special Request" Fulfillment',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 60000000000000000,
        valuePerUnit: 706870038000000, level: 0, upgradeCost: 5528558122746465, baseUpgradeCost: 5528558122746465, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 400000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49143665914063418, managerUpgradeCost:24571832957031709,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'underground_auctions',
        name: 'Underground Auction Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 98000000000000000,
        valuePerUnit: 1060305057000000, level: 0, upgradeCost: 8292837184119697, baseUpgradeCost: 8292837184119697, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 405000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:73715498871095127, managerUpgradeCost:36857749435547563,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'influence_peddling',
        name: 'Influence Peddling Services',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 160000000000000000,
        valuePerUnit: 1590457586000000, level: 0, upgradeCost: 12439255776179546, baseUpgradeCost: 12439255776179546, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 410000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:110573248306642691, managerUpgradeCost:55286624153321345,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'political_puppets',
        name: 'Political Puppet Strings',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 260000000000000000,
        valuePerUnit: 2385686379000000, level: 0, upgradeCost: 18658883664269319, baseUpgradeCost: 18658883664269319, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 415000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:165859872459964036, managerUpgradeCost:82929936229982018,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'occult_rituals',
        name: 'Occult Ritual Hosting',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 430000000000000000,
        valuePerUnit: 3578529569000000, level: 0, upgradeCost: 27988325496403978, baseUpgradeCost: 27988325496403978, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 420000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:248789808689946054, managerUpgradeCost:124394904344973027,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'mind_control',
        name: 'Mind Control Research',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 700000000000000000,
        valuePerUnit: 5367794354000000, level: 0, upgradeCost: 41982488244605968, baseUpgradeCost: 41982488244605968, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 425000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:373184713034919081, managerUpgradeCost:186592356517459540,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'blood_oaths',
        name: 'Blood Oath Contracts',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1150000000000000000,
        valuePerUnit: 8051691531000000, level: 0, upgradeCost: 62973732366908952, baseUpgradeCost: 62973732366908952, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 430000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:559777069552378621, managerUpgradeCost:279888534776189310,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'forbidden_desires',
        name: 'Forbidden Desires Catalog',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1900000000000000000,
        valuePerUnit: 12077537297000000, level: 0, upgradeCost: 94460598550363428, baseUpgradeCost: 94460598550363428, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 435000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:839665604328567932, managerUpgradeCost:419832802164283966,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },

      // ============================================
      // INNER SANCTUM LOCATION PRODUCTS (NSFW LEVEL 4 - Endgame Horror)
      // ============================================
      {
        id: 'human_trafficking',
        name: 'Human Trafficking Networks',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18116305946000000, level: 0, upgradeCost: 141690897825545142, baseUpgradeCost: 141690897825545142, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 440000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1259498406492851899, managerUpgradeCost:629749203246425949,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'organ_market',
        name: 'Organ Market Pipeline',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 2500000000000000000,
        valuePerUnit: 27174458919000000, level: 0, upgradeCost: 212536346738317713, baseUpgradeCost: 212536346738317713, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 445000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1889247609739277848, managerUpgradeCost:944623804869638924,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'assassinations',
        name: 'Assassination Contracts',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 4200000000000000000,
        valuePerUnit: 40761688379000000, level: 0, upgradeCost: 318804520107476570, baseUpgradeCost: 318804520107476570, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 450000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2833871414608916772, managerUpgradeCost:1416935707304458386,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'govt_overthrow',
        name: 'Government Overthrow Operations',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 6800000000000000000,
        valuePerUnit: 61142532569000000, level: 0, upgradeCost: 478206780161214855, baseUpgradeCost: 478206780161214855, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 455000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4250807121913375158, managerUpgradeCost:2125403560956687579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'hostile_takeovers',
        name: 'Corporate Hostile Takeovers',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 11000000000000000000,
        valuePerUnit: 91713798854000000, level: 0, upgradeCost: 717310170241822282, baseUpgradeCost: 717310170241822282, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 460000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6376210682870062737, managerUpgradeCost:3188105341435031368,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'torture_entertainment',
        name: 'Torture Entertainment Venues',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 18000000000000000000,
        valuePerUnit: 137570698281000000, level: 0, upgradeCost: 1075965255362733423, baseUpgradeCost: 1075965255362733423, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 465000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9564316024305094106, managerUpgradeCost:4782158012152547053,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'doomsday_cult',
        name: 'Doomsday Cult Leadership',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 29000000000000000000,
        valuePerUnit: 206356047422000000, level: 0, upgradeCost: 1613947883044100135, baseUpgradeCost: 1613947883044100135, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 470000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14346474036457641159, managerUpgradeCost:7173237018228820579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'reality_manipulation',
        name: 'Reality Manipulation Technology',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 48000000000000000000,
        valuePerUnit: 309534071133000000, level: 0, upgradeCost: 2420921824566150202, baseUpgradeCost: 2420921824566150202, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 475000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21519711054686461738, managerUpgradeCost:10759855527343230869,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'eldritch_summoning',
        name: 'Eldritch Entity Summoning',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 78000000000000000000,
        valuePerUnit: 464301106700000000, level: 0, upgradeCost: 3631382736849225303, baseUpgradeCost: 3631382736849225303, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 480000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32279566582029692607, managerUpgradeCost:16139783291014846303,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'multiverse_domination',
        name: 'Multiverse Domination',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 127000000000000000000,
        valuePerUnit: 696451660050000000, level: 0, upgradeCost: 5447074105273837955, baseUpgradeCost: 5447074105273837955, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 485000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:48419349873044538910, managerUpgradeCost:24209674936522269455,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'god_emperor',
        name: 'Become God-Emperor',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 205000000000000000000,
        valuePerUnit: 1044677490075000000, level: 0, upgradeCost: 8170611157910756932, baseUpgradeCost: 8170611157910756932, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 490000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:72629024809566808365, managerUpgradeCost:36314512404783404182,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'consume_reality',
        name: 'Consume Reality Itself',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 330000000000000000000,
        valuePerUnit: 1567016235113000000, level: 0, upgradeCost: 12255916736866135398, baseUpgradeCost: 12255916736866135398, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 495000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:108943537214350212547, managerUpgradeCost:54471768607175106273,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      }
    ],
    employees: [],
    
    // ========== CORPORATE HIERARCHY SYSTEM ==========
    // 8-level corporate structure from Entry to Executive
    hierarchyLevels: {
      1: {
        title: "Staff",
        baseSalary: 40000,
        productBonusPercent: 2,
        color: "#4ecca3",
        icon: "�",
        canManage: false,
        description: "Product Workers - manage individual products"
      },
      2: {
        title: "Local Manager",
        baseSalary: 52500,
        productBonusPercent: 3,
        color: "#00d4ff",
        icon: "👨‍�",
        canManage: true,
        description: "Supervise 4-6 Staff members"
      },
      3: {
        title: "Regional Manager",
        baseSalary: 70000,
        productBonusPercent: 5,
        color: "#ffd700",
        icon: "🎯",
        canManage: true,
        description: "Oversee a location's operations"
      },
      4: {
        title: "Branch Manager",
        baseSalary: 95000,
        productBonusPercent: 8,
        color: "#ff6b9d",
        icon: "�",
        canManage: true,
        description: "Manage multiple Regional Managers"
      },
      5: {
        title: "CFO / COO",
        baseSalary: 140000,
        productBonusPercent: 12,
        color: "#c77dff",
        icon: "�",
        canManage: true,
        description: "Chief Financial Officer or Chief Operating Officer"
      },
      6: {
        title: "Senior Executive",
        baseSalary: 180000,
        productBonusPercent: 15,
        color: "#9d4edd",
        icon: "⭐",
        canManage: true,
        description: "Second-in-command to the CEO"
      },
      7: {
        title: "CEO",
        baseSalary: 250000,
        productBonusPercent: 20,
        color: "#e94560",
        icon: "�",
        canManage: true,
        description: "Chief Executive Officer - top of the pyramid"
      }
    },
    
    // Corporate hierarchy tracking
    corporateHierarchy: {
      levels: {
        1: [], // Array of employee IDs at this level
        2: [],
        3: [],
        4: [],
        5: [],
        6: [],
        7: []
      },
      executiveRoles: {
        COO: null,  // Employee ID or null
        CFO: null
      }
    },
    
    // Corporate Pyramid Structure (True Hierarchical Org Chart)
    corporatePyramid: {
      // CEO position (player - Level 7)
      ceo: {
        positionId: 'ceo',
        title: 'CEO',
        level: 7,
        employeeId: 'player',
        subordinates: [], // IDs of direct reports (Senior Executive)
        isPlayer: true
      },
      
      // Secretary position - Reports directly to CEO, no subordinates
      secretaryPosition: {
        positionId: 'secretary',
        title: 'Executive Secretary',
        level: 6.5, // Between CEO and Senior Executive
        employeeId: null,
        reportsTo: 'ceo',
        subordinates: []
      },
      
      // Hierarchical positions (organized by level, not products)
      positions: {
        // Level 6: Senior Executive (1 total) - Reports to CEO
        6: [
          {
            positionId: 'senior_exec',
            title: 'Senior Executive',
            level: 6,
            employeeId: null,
            reportsTo: 'ceo',
            subordinates: [], // CFO, COO
            span: 2 // Should manage 2 officers
          }
        ],
        
        // Level 5: Officers (2 total: CFO, COO) - Report to Senior Executive
        5: [
          {
            positionId: 'cfo',
            title: 'Chief Financial Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [], // 2 Branch Managers
            span: 2
          },
          {
            positionId: 'coo',
            title: 'Chief Operating Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [], // 2 Branch Managers
            span: 2
          }
        ],
        
        // Level 4: Branch Managers (4 total) - Report to CFO/COO
        4: [
          { positionId: 'branch_mgr_1', title: 'Branch Manager 1', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_2', title: 'Branch Manager 2', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_3', title: 'Branch Manager 3', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 2 },
          { positionId: 'branch_mgr_4', title: 'Branch Manager 4', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 1 }
        ],
        
        // Level 3: Regional Managers (9 total, 1 per location) - Report to Branch Managers
        3: [], // Will be populated as locations unlock
        
        // Level 2: Local Managers (2-3 per location, ~20 total) - Report to Regional Managers
        2: [], // Will be populated as locations unlock and products expand
        
        // Level 1: Staff (1 per product, ~90 total) - Report to Local Managers
        1: [] // Will be populated dynamically as products are unlocked
      },
      
      // Relocation/promotion costs by level
      promotionCosts: {
        1: 500,      // Staff
        2: 2000,     // Local Manager
        3: 10000,    // Regional Manager
        4: 50000,    // Branch Manager
        5: 150000,   // Officer (CFO/COO)
        6: 500000,   // Senior Executive
        7: 0         // CEO (player only)
      }
    },
    
    // Rehire pool (preserved employees after prestige)
    rehirePool: [],
    
    // Currently displayed hiring candidates
    currentHiringCandidates: {
      newHires: [],
      rehires: [],
      productId: null,
      activeTab: 'newHires'
    },
    
    // Global income multiplier (affected by executives)
    globalIncomeMultiplier: 1.0,
    
    gifts: [
      { id: 'coffee', name: 'Coffee', cost: 10, effect: { productivity: 5 }, description: 'Boosts productivity' },
      { id: 'giftcard', name: 'Gift Card', cost: 50, effect: { affection: 10 }, description: 'Increases affection' },
      { id: 'lunch', name: 'Lunch', cost: 30, effect: { comfort: 15 }, description: 'Improves comfort' },
      { id: 'bonus', name: 'Cash Bonus', cost: 100, effect: { desire: 20 }, description: 'Raises desire' }
    ],
    news: [
      "Tech startup raises $1M in seed funding",
      "New productivity app trends in office spaces",
      "Remote work policies reshape company cultures",
      "AI integration boosts efficiency across industries"
    ],
    settings: {
      autosave: true,
      uiDensity: 50,
      atmosphere: 50,
      guidelines: 50,
      policy: 'professional',
      playerBio: '', // DEPRECATED: Replaced by playerProfile object
      imageStyle: 'photorealistic' // Global image generation style
    },
    
    // Player Profile (detailed information about the player character)
    playerProfile: {
      // Basic Info
      firstName: '',
      lastName: '',
      age: null,
      gender: '',
      
      // Physical Description
      ethnicity: '',
      skinTone: '',
      height: '',
      bodyType: '',
      hairColor: '',
      hairStyle: '',
      eyeColor: '',
      facialHair: '',
      
      // Intimate Details
      genitalType: '',
      genitalDetails: '',
      chestSize: '',
      buildDetails: '',
      
      // Additional
      additionalDetails: '',
      personality: ''
    },
    
    // GENDER DIVERSITY SETTINGS
    genderSettings: {
      female: 100,        // Default: 100% female
      male: 0,
      femaleFuta: 0,
      transMan: 0,
      transWoman: 0
    },
    
    activeTab: 'dashboard',
    activeLocationId: 'garage', // Currently selected location subtab
    upgradeMultiplier: 1, // Bulk upgrade multiplier (1, 5, 10, 100, or 'max')
    activeChat: null,
    chatHistory: {},
    typingStates: {}, // Track which NPCs are currently generating responses { employeeId: true/false }
    
    // ========== AI CONTEXT QUALITY SYSTEM ==========
    // Tracks repetition and enforces variety in AI responses
    aiContextQuality: {
      // Per-employee repetition tracking (last 3 responses)
      employeeTracking: {}, // { employeeId: { physicalActions: [], narrativeAnchors: [], sensoryWords: [], responseStructures: [] } }
      
      // Global vocabulary expansion databases
      vocabularyBanks: {
        // Physical response alternatives
        arousal: ['shivering', 'trembling', 'quivering', 'shuddering', 'quaking', 'tingling', 'prickling', 'buzzing', 'pulsing', 'throbbing'],
        spinalReactions: ['arching back', 'spine curving', 'back bowing', 'body lifting', 'hips rising', 'chest pressing forward', 'shoulders rolling back', 'torso twisting'],
        handActions: ['fingers tangling in hair', 'nails digging into skin', 'palms pressing flat', 'hands gripping shoulders', 'fingertips tracing lines', 'knuckles brushing cheeks', 'thumbs caressing jawlines', 'hands sliding down backs'],
        legMovements: ['legs hooking around waist', 'ankles locking behind back', 'thighs tightening', 'knees pressing together', 'feet curling', 'toes pointing', 'legs spreading', 'hips rolling'],
        breathPatterns: ['breath hitching', 'gasping sharply', 'exhaling shakily', 'breathing raggedly', 'panting softly', 'sighing deeply', 'air catching in throat', 'breathing stuttering'],
        
        // Temperature/sensation descriptors
        temperature: ['scorching', 'feverish', 'cool', 'electric', 'searing', 'blazing', 'icy', 'molten', 'frigid', 'white-hot'],
        texture: ['velvet-soft', 'rough', 'silk-smooth', 'calloused', 'scratchy', 'downy', 'coarse', 'plush', 'bristly', 'satiny'],
        
        // Sound descriptors  
        vocalSounds: ['whimper', 'groan', 'moan', 'sigh', 'gasp', 'cry out', 'murmur', 'whisper', 'breathe words', 'choke out'],
        
        // Movement quality
        movementQuality: ['fluid', 'jerky', 'languid', 'urgent', 'hesitant', 'assured', 'graceful', 'clumsy', 'deliberate', 'frantic']
      },
      
      // Escalation tracking for tonal shifts
      intimacyEscalation: {}, // { employeeId: currentLevel (0-10) }
      
      // Settings
      repetitionWindow: 3, // Check last 3 responses for repetition
      maxSameAction: 1, // Max times same action can appear in window
      maxSameAnchor: 2, // Max times same narrative anchor (Buddy, scar, etc.) in window
    },
    
    // ========== SOCIAL NETWORK SYSTEM ==========
    socialNetwork: {
      posts: [], // Array of all posts in the feed
      globalEvents: [], // Company-wide events that can trigger posts
      postIdCounter: 0, // Incrementing ID for posts
      lastPostGeneration: 0, // Timestamp of last autonomous post generation
      postGenerationInterval: 300000, // 5 minutes between autonomous post checks (in ms)
      
      // Filtering/sorting options
      feedFilter: 'all', // 'all', 'explicit', 'work', 'personal'
      feedSort: 'recent', // 'recent', 'popular', 'comments'
      
      // Content variety tracking (prevent repetition)
      recentPostTypes: [], // Track last 20 post types to ensure variety
      
      // Player post drafts
      playerDraft: {
        caption: '',
        imagePrompt: '',
        altText: '',
        imageUrl: null
      }
    },
    
    // AI QUALITY TRAINING SYSTEM (RLHF)
    aiQuality: {
      // Training datasets
      goodExamples: {
        posts: [],     // Upvoted posts
        comments: [],  // Upvoted comments
        chats: []      // Upvoted chat messages
      },
      badExamples: {
        posts: [],     // Downvoted posts
        comments: [],  // Downvoted comments
        chats: []      // Downvoted chat messages
      },
      
      // Learned patterns to avoid
      bannedPatterns: [],
      
      // Stats tracking
      stats: {
        totalVotes: 0,
        upvotes: 0,
        downvotes: 0,
        postsVoted: 0,
        commentsVoted: 0,
        chatsVoted: 0
      },
      
      // Configuration
      maxExamplesPerType: 20,  // Keep best 20 of each
      tutorialShown: false     // First-time tutorial
    },
    
    // Company-wide awareness data
    companyContext: {
      totalEmployees: 0, // Auto-calculated
      locationEmployeeCounts: {}, // { locationId: count }
      recentHires: [], // Last 5 hires
      recentFires: [], // Last 5 fires with alumni status
      recentPromotions: [], // Last 10 promotions
      interdepartmentalEvents: [] // Cross-location events (competitions, collaborations, etc.)
    },
    
    // Company-Wide Context - "Public Knowledge" that everyone knows
    companyWideContext: {
      currentBuzz: [], // Array of hot topics/gossip that's common knowledge (max 40 items)
      lastUpdate: Date.now(),
      maxItems: 40, // Keep only the juiciest/most recent items
      decayTime: 604800000 // 7 days - old info gets trimmed
    },
    
    // ========== FLAG DETECTION SYSTEM ==========
    flagDetection: {
      // Track keyword occurrences per employee
      tracking: {}, // { "emp_123": { "free_use": { count: 2, contexts: [...], lastSeen: timestamp } } }
      
      // Suggested flags awaiting player approval
      suggestions: [], // [{ id, employeeId, employeeName, flag, contexts, suggestedAt, status }]
      
      // Settings
      settings: {
        enabled: true,
        sensitivity: 'medium', // 'low', 'medium', 'high'
        autoApprove: [] // Flag keys that auto-approve without player confirmation
      }
    },
    
    // Pregnancy settings
    pregnancySettings: {
      duration: 14, // Game days (NOT real days) - customizable 7-21
      minDuration: 7,  // Minimum setting
      maxDuration: 21  // Maximum setting
    },
    
    // Name tracking for uniqueness
    usedEmployeeNames: new Set()
  };

  // ============================================
  // ⏰ TIME SYSTEM HELPER METHODS
  // ============================================
  // These are kept separate from gameState.time to allow save serialization
  // (IndexedDB cannot clone functions)
  
  const timeHelpers = {
    getHour() {
      return new Date(gameState.time.currentTime).getHours();
    },
    getDay() {
      return new Date(gameState.time.currentTime).getDay(); // 0=Sunday, 1=Monday, etc.
    },
    getTimeOfDay() {
      const h = this.getHour();
      if (h >= 6 && h < 12) return "morning";
      if (h >= 12 && h < 17) return "afternoon";
      if (h >= 17 && h < 21) return "evening";
      return "night";
    },
    isWorkHours() {
      const day = this.getDay();
      const hour = this.getHour();
      return day >= 1 && day <= 5 && hour >= 9 && hour < 17;
    },
    isWeekend() {
      const day = this.getDay();
      return day === 0 || day === 6;
    },
    getFormattedTime() {
      const d = new Date(gameState.time.currentTime);
      return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    },
    getFormattedDate() {
      const d = new Date(gameState.time.currentTime);
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      return `${days[d.getDay()]}, ${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
    }
  };

  // ============================================
  // AI REQUEST OPTIMIZATION SYSTEM
  // ============================================
  
  const aiOptimization = {
    // Relationship evaluation batching
    relationshipQueue: [],
    relationshipBatchInterval: null,
    relationshipBatchDelay: 30000, // Process every 30 seconds
    
    // Stat change heuristics (avoid AI calls for common cases)
    statChangeHeuristics: {
      like_post: { affection: 1, trust: 0.5, comfort: 0.5 },
      comment_positive: { affection: 2, trust: 1, comfort: 1 },
      comment_supportive: { affection: 3, trust: 2, comfort: 1.5 },
      comment_funny: { affection: 2.5, trust: 1, comfort: 1, desire: 0.5 },
      comment_flirty: { affection: 2, trust: 0.5, comfort: -0.5, desire: 3 },
      comment_dramatic: { affection: 3, trust: -1, comfort: -1, desire: 1 },
      comment_negative: { affection: -2, trust: -2, comfort: -1 },
      mentioned_in_post: { affection: 2, trust: 1.5, comfort: 1 },
      explicit_content_comfortable: { desire: 3, obedience: 1, comfort: -0.5 },
      explicit_content_uncomfortable: { desire: -1, comfort: -3, trust: -1 }
    },
    
    // Relationship change heuristics (EXPANDED for better coverage)
    relationshipHeuristics: {
      like_post: 1,
      comment_positive: 2,
      comment_funny: 3,
      comment_supportive: 3,
      comment_dramatic: 2,
      comment_negative: -2,
      comment_flirty: 2,
      mentioned: 2,
      explicit_post_flirty_viewer: 3,
      explicit_post_professional_viewer: -1,
      achievement_post: 2,
      boring_post: 0,
      // NEW: Additional common cases to reduce AI calls
      casual_view: 0, // Just viewing a normal post, no change
      meme_post: 1, // Light positive for funny content
      selfie_view: 1, // Small positive for personal content
      work_post: 0 // Neutral for work updates
    },
    
    // Recent topics for duplicate prevention
    recentTopics: new Map(), // Changed from [] to Map()
    topicCooldown: 300000, // 5 minutes
    
    // Proactive message blocking
    blockedProactiveMessages: new Set(),
    
    // GIFT SYSTEM
    giftInventory: {
      items: [],         // Player's purchased gifts (ready to give)
      capacity: Infinity // No limit
    },
    giftStore: {
      items: []          // Available gifts for purchase (approved by genie)
    },
    currentLifetimeIncome: 0, // Tracks income THIS prestige only (for gift scaling)
    givenUniqueGifts: [],     // Track one-time UNIQUE gifts that can never be given again
    createdUniqueGifts: []    // Track UNIQUE gifts that have been created (can't create again)
  };

  // ============================================
  // GIFT SYSTEM CONFIGURATION
  // ============================================
  const GIFT_CATEGORIES = {
    ROMANTIC: { 
      name: 'Romantic', 
      emoji: '💕',
      examples: 'Flowers, jewelry, perfume, romantic dinners, love letters'
    },
    LUXURY: { 
      name: 'Luxury', 
      emoji: '💎',
      examples: 'Designer items, expensive watches, high-end fashion, luxury cars'
    },
    EXPERIENCES: { 
      name: 'Experiences', 
      emoji: '✈️',
      examples: 'Trips, concerts, spa days, adventures, classes, events'
    },
    TECH: { 
      name: 'Tech & Gadgets', 
      emoji: '📱',
      examples: 'Electronics, computers, smart devices, gaming equipment'
    },
    INTELLECTUAL: { 
      name: 'Intellectual', 
      emoji: '📚',
      examples: 'Books, courses, art, museum memberships, subscriptions'
    },
    FOOD: { 
      name: 'Food & Drink', 
      emoji: '🍷',
      examples: 'Gourmet food, wine, chocolate, restaurant experiences'
    },
    PRACTICAL: { 
      name: 'Practical', 
      emoji: '🛠️',
      examples: 'Useful tools, office supplies, home items, everyday necessities'
    },
    QUIRKY: { 
      name: 'Quirky & Unique', 
      emoji: '🎨',
      examples: 'Unusual items, collectibles, personalized gifts, novelties'
    },
    WELLNESS: { 
      name: 'Wellness & Fitness', 
      emoji: '🧘',
      examples: 'Gym equipment, yoga mats, health trackers, supplements'
    },
    FASHION: { 
      name: 'Fashion & Beauty', 
      emoji: '👗',
      examples: 'Clothing, shoes, accessories, makeup, skincare'
    },
    UNIQUE: { 
      name: 'One-of-a-Kind', 
      emoji: '🌟',
      examples: 'Continents, landmarks, rare artifacts, historical items - can only be given ONCE globally'
    }
  };

  // Gift Genie suggestion cycling list (100 diverse items)
  const GIFT_SUGGESTIONS = [
    // Tiny ($10-$100)
    "box of chocolates", "red roses", "coffee gift card", "scented candle", "handwritten poem",
    "favorite snack basket", "lottery tickets", "bubble bath set", "cute plant", "funny mug",
    
    // Small ($100-$1K)
    "designer sunglasses", "silk scarf", "premium headphones", "cocktail making kit", "vintage vinyl record",
    "art print", "gourmet cheese board", "massage gift certificate", "perfume sampler", "leather wallet",
    "portable speaker", "fancy pen", "cookbook collection", "board game collection", "succulent garden",
    
    // Medium ($1K-$10K)
    "smart watch", "noise-canceling headphones", "espresso machine", "gaming console", "designer handbag",
    "weekend spa retreat", "concert tickets VIP", "wine tasting tour", "photography equipment", "fitness tracker deluxe",
    "chef's knife set", "cashmere sweater", "art class subscription", "telescope", "standing desk setup",
    
    // Large ($10K-$100K)
    "diamond earrings", "Rolex watch", "weekend in Paris", "home theater system", "designer wardrobe",
    "electric bicycle", "hot tub", "grand piano", "professional camera gear", "wine cellar collection",
    "tailored suit collection", "safari adventure", "scuba diving certification trip", "home gym equipment", "art commission",
    
    // Luxury ($100K-$1M)
    "Tesla Model S", "Mediterranean cruise", "diamond necklace", "rare whisky collection", "investment art piece",
    "luxury watch collection", "private chef for a month", "penthouse weekend", "vintage wine collection", "designer furniture set",
    
    // Lavish ($1M-$100M)
    "Lamborghini Aventador", "private island vacation", "yacht charter", "luxury condo", "rare car collection",
    "private jet flight", "world tour first class", "vineyard estate", "beach house", "rare gemstone",
    "racehorse", "art gallery collection", "recording studio", "private concert", "helicopter",
    
    // Absurd ($100M+)
    "private island", "mansion estate", "commercial building", "sports team stake", "space tourism ticket",
    "superyacht", "private jet", "castle in Europe", "entire city block", "mountain resort",
    
    // Unique (One-time only)
    "North America", "Eiffel Tower", "Great Wall of China", "Moon", "Amazon Rainforest",
    "Mona Lisa", "Statue of Liberty", "Antarctica", "Mount Everest", "Pacific Ocean"
  ];

  // ============================================
  // BOSS FIGHT CONFIGURATION
  // ============================================
  // Each location (except garage) has a boss that must be defeated to unlock
  const bossFightConfig = {
    home_office: {
      id: 'boss_home_office',
      name: 'The Demanding Client',
      title: 'Corporate Gatekeeper',
      description: 'A high-stakes client with impossible demands. Prove your worth to access corporate connections.',
      nsfwLevel: 0, // Professional
      health: 5000,
      recommendedClickPower: 0, // Can attempt with base stats
      recommendedIncome: 100, // $100/sec recommended
      rewardMultiplier: 2.0,
      dialogue: {
        intro: "I don't work with amateurs. Show me what you've got.",
        mid: "Hmm... maybe you're not completely incompetent.",
        victory: "Fine. You've earned my respect. Welcome to the big leagues."
      },
      appearance: {
        prompt: "Professional businesswoman in sharp suit, stern expression, office background, photorealistic",
        style: "professional"
      }
    },
    office_suite: {
      id: 'boss_office_suite',
      name: 'The Executive',
      title: 'CFO Negotiator',
      description: 'The CFO wants to see results. Your performance will determine if you get that corner office.',
      nsfwLevel: 0,
      health: 50000,
      recommendedClickPower: 5,
      recommendedIncome: 1000, // $1K/sec
      rewardMultiplier: 3.0,
      dialogue: {
        intro: "The board is watching. Impress me or get out.",
        mid: "Interesting... you might have potential after all.",
        victory: "Excellent work. The corner office is yours."
      },
      appearance: {
        prompt: "Confident female CFO in designer suit, luxury office, commanding presence, photorealistic",
        style: "executive"
      }
    },
    factory: {
      id: 'boss_factory',
      name: 'The Union Rep',
      title: 'Labor Negotiator',
      description: 'Win over the workers to gain access to manufacturing operations.',
      nsfwLevel: 0,
      health: 500000,
      recommendedClickPower: 10,
      recommendedIncome: 10000, // $10K/sec
      rewardMultiplier: 4.0,
      dialogue: {
        intro: "The workers won't respect someone who can't deliver. Prove yourself.",
        mid: "You're starting to win them over...",
        victory: "Alright, you've got the union's backing. Welcome to the floor."
      },
      appearance: {
        prompt: "Strong confident female union representative in work clothes, factory background, determined look, photorealistic",
        style: "industrial"
      }
    },
    rnd: {
      id: 'boss_rnd',
      name: 'The Scientist',
      title: 'Head Researcher',
      description: 'Prove your innovation capabilities to access cutting-edge R&D facilities.',
      nsfwLevel: 0,
      health: 10000000,
      recommendedClickPower: 20,
      recommendedIncome: 100000, // $100K/sec
      rewardMultiplier: 5.0,
      dialogue: {
        intro: "Research requires precision and dedication. Can you handle it?",
        mid: "Fascinating approach... show me more.",
        victory: "Welcome to the lab. Let's push some boundaries."
      },
      appearance: {
        prompt: "Attractive female scientist in lab coat, modern laboratory, intelligent gaze, photorealistic",
        style: "scientific"
      }
    },
    creative_studio: {
      id: 'boss_creative_studio',
      name: 'The Director',
      title: 'Content Creator',
      description: 'Convince the provocative director you can handle "artistic" content creation.',
      nsfwLevel: 1, // Suggestive begins
      health: 500000000,
      recommendedClickPower: 35,
      recommendedIncome: 1000000, // $1M/sec
      rewardMultiplier: 6.0,
      dialogue: {
        intro: "Art requires... openness. Are you open-minded enough for my studio?",
        mid: "Mmm, you're not shy. I like that...",
        victory: "Perfect. You'll fit right in here. Let's create something... provocative."
      },
      appearance: {
        prompt: "Seductive female director in stylish revealing outfit, artistic studio, confident sultry expression, photorealistic",
        style: "artistic"
      }
    },
    private_club: {
      id: 'boss_private_club',
      name: 'The Hostess',
      title: 'Club Proprietor',
      description: 'Prove you can handle the exclusive and explicit nature of elite adult entertainment.',
      nsfwLevel: 2, // Explicit
      health: 25000000000,
      recommendedClickPower: 50,
      recommendedIncome: 10000000, // $10M/sec
      rewardMultiplier: 8.0,
      dialogue: {
        intro: "This club caters to very... particular tastes. Think you can satisfy them?",
        mid: "Oh, you know how to please. Keep going...",
        victory: "Excellent performance. Welcome to the VIP section, darling."
      },
      appearance: {
        prompt: "Gorgeous hostess in elegant lingerie, luxury club setting, seductive pose, partial nudity, photorealistic, NSFW",
        style: "seductive"
      }
    },
    velvet_room: {
      id: 'boss_velvet_room',
      name: 'The Dominatrix',
      title: 'Mistress of Ceremonies',
      description: 'Submit to her will to gain access to the most decadent establishment.',
      nsfwLevel: 3, // Very explicit
      health: 1000000000000,
      recommendedClickPower: 75,
      recommendedIncome: 100000000, // $100M/sec
      rewardMultiplier: 10.0,
      dialogue: {
        intro: "Kneel. This is MY domain, and you will submit to enter.",
        mid: "Good... you're learning your place. Continue.",
        victory: "You've proven yourself worthy. You may enter my velvet room."
      },
      appearance: {
        prompt: "Dominant woman in leather outfit, velvet room, commanding pose, explicit attire, photorealistic, NSFW",
        style: "dominant"
      }
    },
    inner_sanctum: {
      id: 'boss_inner_sanctum',
      name: 'The Empress',
      title: 'Ultimate Authority',
      description: 'Face the ultimate challenge. Only the most dedicated can access the inner sanctum.',
      nsfwLevel: 3,
      health: 50000000000000,
      recommendedClickPower: 100,
      recommendedIncome: 1000000000, // $1B/sec
      rewardMultiplier: 15.0,
      dialogue: {
        intro: "You dare approach me? Prove you're worthy of my presence.",
        mid: "Impressive... you might actually deserve this...",
        victory: "Magnificent. You've conquered everything. The inner sanctum is yours."
      },
      appearance: {
        prompt: "Empress in revealing royal attire, opulent throne room, powerful sensual presence, explicit, photorealistic, NSFW",
        style: "supreme"
      }
    }
  };

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  /**
   * Extract string from generateText response
   * Handles String objects, response objects, and primitive strings
   * @param {string|object} response - Response from generateText
   * @returns {string} - Clean primitive string
   */
  function extractText(response) {
    if (!response) return '';
    
    // If it's already a primitive string, return it
    if (typeof response === 'string') {
      return response.trim();
    }
    
    // If it's an object (including String object), extract the text
    if (typeof response === 'object') {
      // Try various possible properties
      const text = response.text || response.generatedText || response.prompt || String(response);
      return String(text).trim();
    }
    
    // Fallback: convert to string
    return String(response).trim();
  }

  // ========== SOCIAL NETWORK DATA STRUCTURES ==========
  
  /**
   * Post Structure
   * Represents a single post on the social network
   */
  function createPost({
    authorId,
    authorName,
    authorImage = null,
    type = 'text', // 'text', 'selfie', 'image', 'meme', 'thirsttrap', 'explicit', 'life_update', 'work', 'travel'
    content = '', // Caption/text content
    imageUrl = null,
    imagePrompt = null, // For regeneration
    altText = null, // For NPC "vision" - what they "see" in the image
    mood = 'neutral', // 'happy', 'excited', 'sad', 'flirty', 'angry', 'stressed', 'playful', 'spicy'
    tags = [], // Hashtags or topics
    referencedEmployees = [], // Employee IDs mentioned/tagged
    referencedEvent = null, // Event ID if referencing a company event
    referencedChat = null, // Chat message ID if referencing boss conversation
    explicitLevel = 0, // 0=safe, 1=suggestive, 2=lewd, 3=explicit, 4=very explicit
    isPlayerPost = false
  } = {}) {
    // CRITICAL FIX: Ensure timestamp is ALWAYS valid to prevent invalid postIds
    const timestamp = Date.now();
    if (!timestamp || isNaN(timestamp)) {
      console.error('[PostId] Invalid timestamp detected, using fallback');
      timestamp = gameState.time?.currentTime || new Date().getTime() || 1729800000000; // Use game time or epoch fallback
    }
    
    return {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${timestamp}`,
      authorId,
      authorName,
      authorImage,
      type,
      content,
      imageUrl,
      imagePrompt,
      altText,
      mood,
      tags,
      referencedEmployees,
      referencedEvent,
      referencedChat,
      explicitLevel,
      isPlayerPost,
      timestamp: timestamp,
      likes: [], // Array of employee IDs who liked
      comments: [], // Array of comment objects
      views: 0,
      shareCount: 0
    };
  }
  
  /**
   * Comment Structure
   * Represents a comment on a post
   */
  function createComment({
    postId,
    authorId,
    authorName,
    authorImage = null,
    content = '',
    replyToCommentId = null,
    mentionedEmployees = []
  } = {}) {
    return {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      postId,
      authorId,
      authorName,
      authorImage,
      content,
      replyToCommentId,
      mentionedEmployees,
      timestamp: Date.now(),
      likes: []
    };
  }
  
  /**
   * Relationship Structure
   * Represents a relationship between two employees
   */
  function createRelationship({
    targetId,
    type = 'neutral', // 'friend', 'best_friend', 'rival', 'crush', 'enemy', 'romantic', 'neutral'
    strength = 50, // 0-100, how strong the relationship is
    history = [] // Array of interaction events
  } = {}) {
    return {
      targetId,
      type,
      strength,
      lastInteraction: Date.now(),
      history, // [{ timestamp, event, impact }]
      sharedInterests: [], // Common hobbies/traits
      sharedLocation: false, // Work at same location
      conflicts: 0, // Number of negative interactions
      positiveInteractions: 0
    };
  }
  
  /**
   * Event Structure
   * Represents a notable company event that can trigger posts
   */
  function createEvent({
    type = 'general', // 'hire', 'fire', 'promotion', 'project_success', 'department_rivalry', 'office_party', 'milestone', 'boss_interaction'
    involvedEmployees = [], // Employee IDs involved
    location = null,
    description = '',
    sentiment = 'neutral', // 'positive', 'negative', 'neutral', 'exciting', 'dramatic'
    importance = 5 // 1-10, how likely to trigger posts
  } = {}) {
    return {
      id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type,
      involvedEmployees,
      location,
      description,
      sentiment,
      importance,
      timestamp: Date.now(),
      relatedPosts: [], // Post IDs that reference this event
      hasBeenPostedAbout: false
    };
  }
  
  /**
   * Initialize social network data on an employee
   * Called when employee is created or loaded from old save
   */
  // ========== USERNAME GENERATION ==========
  
  /**
   * Generate unique username for employee
   */
  function generateUsername(employee) {
    const firstName = (employee.name.split(' ')[0] || '').toLowerCase();
    const lastName = (employee.name.split(' ')[1] || '').toLowerCase();
    
    const templates = [
      `${firstName}_${lastName}`,
      `${firstName}.${lastName}`,
      `${firstName}${lastName}`,
      `${firstName}_${lastName.charAt(0)}`,
      `${firstName.charAt(0)}_${lastName}`,
      `${lastName}_${firstName}`,
      `the_${firstName}`,
      `real_${firstName}`,
      `${firstName}_official`,
      `${firstName}_${Math.floor(Math.random() * 100)}`,
      `${lastName}_${Math.floor(Math.random() * 100)}`,
      `${firstName}_${lastName}_${Math.floor(Math.random() * 10)}`
    ];
    
    // Pick random template
    let username = templates[Math.floor(Math.random() * templates.length)];
    
    // Ensure uniqueness by checking existing usernames
    const existingUsernames = gameState.employees
      .filter(e => e.social?.username && e.id !== employee.id)
      .map(e => e.social.username);
    
    let attempts = 0;
    while (existingUsernames.includes(username) && attempts < 10) {
      username = `${firstName}_${Math.floor(Math.random() * 1000)}`;
      attempts++;
    }
    
    return username;
  }

  // ========== SOCIAL DATA INITIALIZATION ==========
  
  function initializeEmployeeSocialData(employee) {
    if (!employee) return;
    
    // === UNIVERSAL FLAG SYSTEM ===
    // Initialize flag system (NEW)
    if (!employee.flags) {
      employee.flags = {
        systemFlags: [],  // Flags created by game systems (pregnancy, sickness, etc.)
        customFlags: []   // Flags created by player
      };
    }
    
    // === PHASE 4: SCHEDULE & TIME SYSTEM ===
    if (!employee.schedule) {
      employee.schedule = {
        workDays: [1, 2, 3, 4, 5],      // Monday-Friday (0=Sunday, 1=Monday, etc.)
        workStartHour: 9,                // 9 AM start
        workEndHour: 17,                 // 5 PM end
        isCurrentlyWorking: false,       // Currently clocked in?
        lastClockIn: null,               // Timestamp of last clock-in
        lastClockOut: null,              // Timestamp of last clock-out
        hoursWorkedToday: 0,             // Track daily hours
        daysWorked: 0,                   // Total days worked (for analytics)
        lateDays: 0,                     // Times arrived late
        
        // Leave/PTO system
        ptoBalance: 10,                  // Days of PTO
        sickDays: 5,                     // Sick days available
        isOnLeave: false,                // Currently on leave?
        leaveType: null,                 // 'pto', 'sick', 'maternity', etc.
        leaveEndDate: null               // When leave ends
      };
    }
    
    // === PHASE 5: LIFE OUTSIDE WORK ===
    if (!employee.personalLife) {
      employee.personalLife = {
        // Current activity tracking
        currentActivity: null,           // What they're doing right now
        activityStartTime: null,         // When current activity started
        lastActivityUpdate: Date.now(),  // Last time we generated an activity
        
        // Hobbies (already have some from employee.hobbies, but add detail)
        activeHobbies: [],               // Currently pursuing hobbies with frequency
        
        // Weekend plans
        upcomingPlans: [],               // Array of planned activities
        lastWeekendActivity: null,       // What they did last weekend
        
        // Evening routine preferences
        eveningPreferences: {
          gym: Math.random() * 0.4,      // 0-40% chance to hit gym
          cooking: Math.random() * 0.6,  // 0-60% chance to cook
          socializing: Math.random() * 0.5, // 0-50% chance to go out
          relaxing: 0.3 + Math.random() * 0.4, // 30-70% chance to chill at home
          hobbies: Math.random() * 0.6,  // 0-60% chance to do hobbies
          dating: Math.random() * 0.3    // 0-30% chance for dates
        },
        
        // Living situation (for context)
        livingSituation: {
          type: Math.random() < 0.3 ? 'apartment' : (Math.random() < 0.7 ? 'house' : 'condo'),
          hasRoommate: Math.random() < 0.25,
          hasPet: Math.random() < 0.35,
          petType: null,  // Will set if hasPet
          petName: null,
          pets: []  // Array of all pets { name, type, giftedBy, timestamp }
        },
        
        // Social circle outside work
        outsideContacts: {
          hasBestFriend: Math.random() < 0.7,
          hasFamily: Math.random() < 0.8,
          inRelationship: Math.random() < 0.3,
          relationshipStatus: 'single' // 'single', 'dating', 'serious', 'married'
        }
      };
      
      // Generate pet details if they have one
      if (employee.personalLife.livingSituation.hasPet) {
        const petTypes = ['dog', 'cat', 'bird', 'fish'];
        employee.personalLife.livingSituation.petType = petTypes[Math.floor(Math.random() * petTypes.length)];
        
        const petNames = ['Max', 'Luna', 'Charlie', 'Bella', 'Cooper', 'Daisy', 'Milo', 'Sadie', 'Buddy', 'Chloe'];
        employee.personalLife.livingSituation.petName = petNames[Math.floor(Math.random() * petNames.length)];
      }
      
      // Convert existing hobbies to active hobbies with frequency
      if (employee.hobbies && employee.hobbies.length > 0) {
        employee.personalLife.activeHobbies = employee.hobbies.map(hobby => ({
          name: hobby,
          frequency: Math.random() * 0.7 + 0.3, // 0.3-1.0 (30%-100% engagement)
          skillLevel: Math.floor(Math.random() * 5) + 1, // 1-5
          lastDone: Date.now() - Math.floor(Math.random() * 604800000) // Random time in last week
        }));
      }
    }
    
    // === SKILLS SYSTEM (Phase 3) ===
    // Initialize skills if not present
    if (!employee.skills) {
      employee.skills = {
        // Work skills
        technical: { level: 1, xp: 0, maxXp: 500 },     // Coding, engineering, data analysis
        creative: { level: 1, xp: 0, maxXp: 500 },      // Design, writing, marketing
        social: { level: 1, xp: 0, maxXp: 500 },        // Communication, networking, charisma
        management: { level: 1, xp: 0, maxXp: 500 },    // Leadership, planning, delegation
        
        // Life skills
        intimate: { level: 0, xp: 0, maxXp: 500 },      // Sexual/romantic experience
        cooking: { level: 0, xp: 0, maxXp: 500 },       // Personal skill
        fitness: { level: 0, xp: 0, maxXp: 500 }        // Health & athletics
      };
      
      // Give random starting levels based on position
      if (employee.position) {
        const pos = employee.position.toLowerCase();
        if (pos.includes('engineer') || pos.includes('developer')) {
          employee.skills.technical.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.technical.xp = Math.floor(Math.random() * employee.skills.technical.maxXp);
        }
        if (pos.includes('designer') || pos.includes('creative')) {
          employee.skills.creative.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.creative.xp = Math.floor(Math.random() * employee.skills.creative.maxXp);
        }
        if (pos.includes('manager') || pos.includes('director')) {
          employee.skills.management.level = 3 + Math.floor(Math.random() * 2);
          employee.skills.management.xp = Math.floor(Math.random() * employee.skills.management.maxXp);
          employee.skills.social.level = 2 + Math.floor(Math.random() * 2);
        }
        if (pos.includes('sales') || pos.includes('marketing')) {
          employee.skills.social.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.social.xp = Math.floor(Math.random() * employee.skills.social.maxXp);
        }
      }
    }
    
    // Specializations (unlocked at skill milestones)
    if (!employee.specializations) {
      employee.specializations = [];
    }
    
    // Social network specific data
    if (!employee.social) {
      employee.social = {
        // Username
        username: generateUsername(employee),
        
        // Bio/About
        bio: '', // Can be generated later
        joinDate: Date.now(),
        
        // Posting behavior
        postFrequency: 0.3 + Math.random() * 0.7, // 0-1, how often they post (some are very active, some lurk)
        lastPostTime: 0,
        postCount: 0,
        likeCount: 0,
        commentCount: 0,
        
        // Stats
        totalLikesReceived: 0,
        totalCommentsReceived: 0,
        totalMentions: 0,
        
        // Content preferences (what they're likely to post)
        contentPreferences: {
          selfies: 0.2 + Math.random() * 0.5,
          workPosts: 0.1 + Math.random() * 0.4,
          memes: Math.random() * 0.6,
          lifeUpdates: 0.2 + Math.random() * 0.5,
          thirstTraps: Math.random() * 0.4, // Based on personality
          explicitContent: Math.random() * 0.3, // Some are bolder than others
          travelPosts: Math.random() * 0.4
        },
        
        // Engagement behavior
        likesProbability: 0.3 + Math.random() * 0.6, // How likely to like posts
        commentsProbability: 0.1 + Math.random() * 0.4, // How likely to comment
        
        // Content filters
        willingnessToPostExplicit: Math.random(), // 0-1, how comfortable with explicit content
        
        // Activity tracking
        recentPostTypes: [], // Last 5 post types to avoid repetition
        postsAboutBoss: 0, // Track how many posts reference boss
        
        // Mention tracking for @suggest system
        mentionHistory: [] // { employeeId, timestamp, count }
      };
    }
    
    // Gift consequences tracking (NEW)
    if (!employee.giftedPossessions) {
      employee.giftedPossessions = {
        wardrobe: [],      // { item, category, price, timestamp, wearChance }
        jewelry: [],       // { item, type, price, timestamp, wearChance }
        vehicles: [],      // { item, type, price, timestamp }
        homeUpgrades: [],  // { item, upgradeType, price, timestamp }
        experiences: [],   // { item, description, price, timestamp, memoryStrength }
        tech: [],          // { item, type, price, timestamp, inUse }
        other: []          // { item, category, price, timestamp }
      };
    }
    
    // Initialize player mention stats if not exists
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [], // { employeeId, timestamp }
        mentionCounts: {}   // { employeeId: count }
      };
    }
    
    // Relationships with other employees
    if (!employee.relationships) {
      employee.relationships = {}; // { [employeeId]: Relationship }
    }
    
    // Location awareness
    if (!employee.locationId && employee.productManaged) {
      // Infer location from product if not set
      const product = gameState.products.find(p => p.name === employee.productManaged);
      if (product) {
        employee.locationId = product.locationId;
      }
    }
    if (!employee.locationId) {
      employee.locationId = 'garage'; // Default
    }
    
    // Contextual awareness
    if (!employee.awareness) {
      employee.awareness = {
        knowsCoworkers: [], // Employee IDs they're aware of
        knowsLocations: [], // Location IDs they know about
        companyKnowledge: {
          totalEmployees: 0,
          lastUpdated: 0
        }
      };
    }
    
    // Alumni status (for fired employees)
    if (!employee.employmentStatus) {
      employee.employmentStatus = employee.hired ? 'active' : 'alumni';
    }
    
    return employee;
  }

  // ========== FLAG SYSTEM ==========
  
  /**
   * Generate a unique ID for flags
   */
  function generateFlagId() {
    return 'flag_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  /**
   * Add a flag to an employee
   * @param {Object} employee - The employee object
   * @param {Object} flagData - Flag configuration
   * @returns {Object} - The created flag
   */
  function addFlag(employee, flagData) {
    if (!employee || !flagData) return null;
    
    // Ensure flags structure exists
    if (!employee.flags) {
      employee.flags = { systemFlags: [], customFlags: [] };
    }
    
    const flag = {
      id: generateFlagId(),
      key: flagData.key,
      value: flagData.value,
      category: flagData.category || 'custom',
      setBy: flagData.setBy || 'player',
      setDate: flagData.setDate || flagData.startDate || gameState.time?.currentTime || Date.now(), // Use game time if available
      timestamp: flagData.timestamp || flagData.startDate || gameState.time?.currentTime || Date.now(), // Alias for compatibility
      autoRemove: flagData.autoRemove || null,
      duration: flagData.duration || null,
      expirationDate: flagData.expirationDate || null, // New: explicit expiration
      affectsContext: flagData.affectsContext !== false, // Default true
      priority: flagData.priority || 'medium',
      playerDescription: flagData.playerDescription || '',
      aiGuidance: flagData.aiGuidance || '',
      emoji: flagData.emoji || null,
      
      // Custom metadata for context-specific flags
      metadata: flagData.metadata || {}
    };
    
    // Auto-populate metadata based on flag type
    if (flagData.key === 'pregnant' && !flag.metadata.father) {
      flag.metadata.father = flagData.father || 'unknown';
      flag.metadata.dueDate = flagData.dueDate || (flag.setDate + (14 * 24 * 60 * 60 * 1000 * gameState.time.timeScale)); // 14 game days
    }
    
    if (flagData.key === 'in_relationship' && !flag.metadata.partner) {
      flag.metadata.partner = flagData.partner || 'unknown';
    }
    
    if (flagData.key === 'engaged' && !flag.metadata.fiance) {
      flag.metadata.fiance = flagData.fiance || 'unknown';
    }
    
    if (flagData.key === 'married' && !flag.metadata.spouse) {
      flag.metadata.spouse = flagData.spouse || 'unknown';
      flag.metadata.marriageDate = flagData.marriageDate || flag.setDate;
    }
    
    // Determine which flag array
    if (flag.setBy === 'system') {
      employee.flags.systemFlags.push(flag);
    } else {
      employee.flags.customFlags.push(flag);
    }
    
    console.log(`[Flags] Added "${flag.key}" to ${employee.name}`);
    saveGame(); // Auto-save when flags change
    return flag;
  }
  
  /**
   * Remove a flag by ID
   * @param {Object} employee - The employee object
   * @param {string} flagId - The flag ID to remove
   */
  function removeFlag(employee, flagId) {
    if (!employee || !employee.flags) return;
    
    employee.flags.systemFlags = employee.flags.systemFlags.filter(f => f.id !== flagId);
    employee.flags.customFlags = employee.flags.customFlags.filter(f => f.id !== flagId);
    
    console.log(`[Flags] Removed flag ${flagId} from ${employee.name}`);
    saveGame();
  }
  
  /**
   * Get all active flags (non-expired)
   * @param {Object} employee - The employee object
   * @returns {Array} - Array of active flags
   */
  function getActiveFlags(employee) {
    if (!employee || !employee.flags) return [];
    
    const now = Date.now();
    
    // Filter out expired flags
    const activeSystem = employee.flags.systemFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    const activeCustom = employee.flags.customFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    return [...activeSystem, ...activeCustom];
  }
  
  /**
   * Clean up expired flags
   * @param {Object} employee - The employee object
   */
  function cleanupExpiredFlags(employee) {
    if (!employee || !employee.flags) return;
    
    const now = Date.now();
    
    employee.flags.systemFlags = employee.flags.systemFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    employee.flags.customFlags = employee.flags.customFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
  }
  
  /**
   * Find a flag by key
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key to search for
   * @returns {Object|null} - The flag or null
   */
  function findFlag(employee, key) {
    if (!employee || !employee.flags) return null;
    
    const allFlags = [...employee.flags.systemFlags, ...employee.flags.customFlags];
    return allFlags.find(f => f.key === key) || null;
  }
  
  /**
   * Check if employee has a specific flag
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key to check
   * @returns {boolean}
   */
  function hasFlag(employee, key) {
    return !!findFlag(employee, key);
  }
  
  /**
   * Get flag value
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key
   * @returns {*} - The flag value or null
   */
  function getFlagValue(employee, key) {
    const flag = findFlag(employee, key);
    return flag ? flag.value : null;
  }
  
  /**
   * Build AI context string from employee flags
   * This is injected into chat prompts so AI knows about flags
   * @param {Object} employee - The employee object
   * @returns {string} - Context string for AI
   */
  function buildAIContextFromFlags(employee) {
    const activeFlags = getActiveFlags(employee);
    
    if (activeFlags.length === 0) return '';
    
    // Sort by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    activeFlags.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    let contextString = '\n\n=== EMPLOYEE FLAGS ===\n';
    
    // High priority flags (always included)
    const highPriority = activeFlags.filter(f => f.priority === 'high');
    if (highPriority.length > 0) {
      contextString += '🔴 HIGH PRIORITY:\n';
      highPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
        if (flag.aiGuidance) {
          contextString += `  AI NOTE: ${flag.aiGuidance}\n`;
        }
      });
    }
    
    // Medium priority flags (include if space)
    const medPriority = activeFlags.filter(f => f.priority === 'medium');
    if (medPriority.length > 0) {
      contextString += '🟡 MODERATE PRIORITY:\n';
      medPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
        if (flag.aiGuidance) {
          contextString += `  AI NOTE: ${flag.aiGuidance}\n`;
        }
      });
    }
    
    // Low priority flags (include only if context window allows)
    const lowPriority = activeFlags.filter(f => f.priority === 'low');
    if (lowPriority.length > 0 && contextString.length < 500) {
      contextString += '🟢 LOW PRIORITY:\n';
      lowPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
      });
    }
    
    return contextString;
  }

  /**
   * Build AI context from employee skills (Phase 3 Enhancement)
   * Injects personality traits and capabilities based on skill levels
   */
  function buildAIContextFromSkills(employee) {
    if (!employee.skills) return '';
    
    let contextString = '\n=== YOUR SKILLS & ABILITIES ===\n';
    
    // Get all skills with level > 0
    const skills = Object.entries(employee.skills)
      .filter(([name, skill]) => skill.level > 0)
      .sort((a, b) => b[1].level - a[1].level);
    
    if (skills.length === 0) return '';
    
    // Add skill descriptions with personality traits
    const skillDescriptions = {
      technical: {
        1: 'You have basic technical knowledge.',
        3: 'You\'re technically skilled and confident with technology.',
        5: 'You\'re a technical expert. You speak about tech topics naturally and intelligently.',
        7: 'You\'re a technical master. Your expertise is well-known and you mentor others.',
        10: 'You\'re a legendary technical genius. Technology is second nature to you.'
      },
      creative: {
        1: 'You have some creative ideas.',
        3: 'You\'re quite creative and artistic in your thinking.',
        5: 'You\'re highly creative. You see the world through an artistic lens.',
        7: 'You\'re a creative visionary. Your ideas are innovative and inspiring.',
        10: 'You\'re a creative genius. Your imagination knows no bounds.'
      },
      social: {
        1: 'You can hold a basic conversation.',
        3: 'You\'re naturally charming and good with people.',
        5: 'You\'re highly charismatic. People are drawn to you.',
        7: 'You\'re a master communicator. You read people effortlessly.',
        10: 'You have legendary charisma. You can convince anyone of anything.'
      },
      management: {
        1: 'You can delegate simple tasks.',
        3: 'You\'re a capable leader and organizer.',
        5: 'You\'re an excellent manager. People trust your leadership.',
        7: 'You\'re a strategic mastermind. Your leadership is inspiring.',
        10: 'You\'re a legendary leader. Your management skills are unmatched.'
      },
      intimate: {
        1: 'You\'re somewhat inexperienced in intimate situations.',
        3: 'You\'re moderately experienced and confident in romantic contexts.',
        5: 'You\'re very experienced and skilled in intimate situations.',
        7: 'You\'re an expert lover. You know exactly what you\'re doing.',
        10: 'You\'re a master of seduction and intimacy. You\'re irresistible.'
      },
      cooking: {
        1: 'You can make basic meals (usually just ordering takeout).',
        3: 'You\'re a decent cook. You enjoy making homemade meals.',
        5: 'You\'re an excellent cook. Food is one of your passions.',
        7: 'You\'re a culinary expert. You could work in a restaurant.',
        10: 'You\'re a master chef. Your cooking is legendary.'
      },
      fitness: {
        1: 'You\'re not very athletic.',
        3: 'You\'re in good shape and work out regularly.',
        5: 'You\'re very fit and athletic. Fitness is part of your lifestyle.',
        7: 'You\'re in exceptional shape. You could compete professionally.',
        10: 'You\'re a peak human specimen. Your fitness is legendary.'
      }
    };
    
    // Add top 3 skills with descriptions
    skills.slice(0, 3).forEach(([name, skill]) => {
      const level = skill.level;
      const descriptions = skillDescriptions[name];
      
      if (descriptions) {
        // Find the appropriate description tier
        let description;
        if (level >= 10) description = descriptions[10];
        else if (level >= 7) description = descriptions[7];
        else if (level >= 5) description = descriptions[5];
        else if (level >= 3) description = descriptions[3];
        else description = descriptions[1];
        
        contextString += `• ${name.toUpperCase()} (Lv ${level}): ${description}\n`;
      }
    });
    
    // Add specializations if any
    if (employee.specializations && employee.specializations.length > 0) {
      contextString += `\nYour titles: ${employee.specializations.join(', ')}\n`;
      contextString += 'Mention these accomplishments naturally if relevant.\n';
    }
    
    return contextString;
  }

  // ========== PHASE 4: TIME & SCHEDULE SYSTEM ==========
  
  /**
   * Update game time (called in gameTick)
   */
  function updateGameTime(deltaMs) {
    if (!gameState.time || !gameState.time.enabled || gameState.time.paused) return;
    
    const prevHour = timeHelpers.getHour();
    const prevDay = timeHelpers.getDay();
    
    // Advance time with time scale
    gameState.time.currentTime += deltaMs * gameState.time.timeScale;
    
    const currentHour = timeHelpers.getHour();
    const currentDay = timeHelpers.getDay();
    
    // Check for hour changes
    if (currentHour !== prevHour) {
      onHourChange(currentHour, prevHour);
    }
    
    // Check for day changes
    if (currentDay !== prevDay) {
      onDayChange(currentDay);
    }
  }
  
  /**
   * Hourly events - clock in/out, XP gains, etc.
   */
  function onHourChange(currentHour, prevHour) {
    // 9 AM - Clock in employees
    if (currentHour === 9) {
      clockInEmployees();
    }
    
    // 5 PM - Clock out employees  
    if (currentHour === 17) {
      clockOutEmployees();
    }
    
    // PHASE 5: Update employee activities every hour
    updateEmployeeActivities();
    
    // Hourly XP gain for working employees
    gameState.employees.forEach(emp => {
      if (emp.schedule && emp.schedule.isCurrentlyWorking) {
        // Gain skill XP based on their product/location
        const product = gameState.products.find(p => p.name === emp.productManaged);
        if (product) {
          const locationId = product.locationId || 'garage';
          
          // Different locations train different skills
          if (locationId === 'rnd') {
            gainSkillXP(emp, 'technical', 3, 'work hour');
          } else if (locationId === 'creative_studio') {
            gainSkillXP(emp, 'creative', 3, 'work hour');
          } else if (locationId === 'office_suite' || locationId === 'factory') {
            gainSkillXP(emp, 'management', 2, 'work hour');
          } else {
            // Generic work XP
            gainSkillXP(emp, 'technical', 1, 'work hour');
            gainSkillXP(emp, 'social', 1, 'work hour');
          }
        }
        
        // Increment hours worked
        emp.schedule.hoursWorkedToday += 1;
      }
    });
    
    // Update UI to show current time
    updateTimeDisplay();
  }
  
  /**
   * Daily reset - new day begins
   */
  function onDayChange(newDay) {
    gameState.employees.forEach(emp => {
      if (emp.schedule) {
        // Reset daily counters
        emp.schedule.hoursWorkedToday = 0;
        
        // If they worked yesterday, increment days worked counter
        if (emp.schedule.lastClockOut) {
          emp.schedule.daysWorked += 1;
        }
      }
    });
    
    // PHASE 5: Generate weekend plans on Friday
    if (newDay === 5) {
      generateWeekendPlans();
    }
    
    // Update UI
    updateTimeDisplay();
  }
  
  /**
   * Clock in employees at 9 AM
   */
  function clockInEmployees() {
    let clockedInCount = 0;
    
    gameState.employees.forEach(emp => {
      if (!emp.schedule) return;
      if (shouldEmployeeWorkToday(emp)) {
        emp.schedule.isCurrentlyWorking = true;
        emp.schedule.lastClockIn = gameState.time.currentTime;
        clockedInCount++;
        
        // 15% chance to generate a morning post
        if (Math.random() < 0.15) {
          generateMorningPost(emp);
        }
      }
    });
    
    if (clockedInCount > 0) {
      console.log(`⏰ 9 AM: ${clockedInCount} employees clocked in`);
      updatePeopleTab(); // Refresh to show work status
    }
  }
  
  /**
   * Clock out employees at 5 PM
   */
  function clockOutEmployees() {
    let clockedOutCount = 0;
    
    gameState.employees.forEach(emp => {
      if (!emp.schedule) return;
      if (emp.schedule.isCurrentlyWorking) {
        emp.schedule.isCurrentlyWorking = false;
        emp.schedule.lastClockOut = gameState.time.currentTime;
        clockedOutCount++;
        
        // 10% chance to generate an evening post
        if (Math.random() < 0.10) {
          generateEveningPost(emp);
        }
      }
    });
    
    if (clockedOutCount > 0) {
      console.log(`⏰ 5 PM: ${clockedOutCount} employees clocked out`);
      updatePeopleTab(); // Refresh to show work status
    }
  }
  
  /**
   * Check if employee should work today
   */
  function shouldEmployeeWorkToday(emp) {
    if (!emp.schedule) return false;
    
    // Check if on leave
    if (emp.schedule.isOnLeave) {
      // Check if leave has ended
      if (emp.schedule.leaveEndDate && gameState.time.currentTime >= emp.schedule.leaveEndDate) {
        emp.schedule.isOnLeave = false;
        emp.schedule.leaveType = null;
        emp.schedule.leaveEndDate = null;
      } else {
        return false; // Still on leave
      }
    }
    
    // Check if sick (via flags)
    const isSick = emp.flags && emp.flags.systemFlags.some(f => f.key === 'sick' && f.value.severity > 50);
    if (isSick && Math.random() < 0.7) {
      return false; // 70% chance to call in sick
    }
    
    // Check if it's a work day
    const day = timeHelpers.getDay();
    return emp.schedule.workDays.includes(day);
  }
  
  /**
   * Create a social post and add it to the feed
   */
  function createSocialPost(postData) {
    if (!postData || !postData.authorId || !postData.content) {
      console.warn('Invalid post data:', postData);
      return;
    }
    
    // Create post object with unique ID (consistent format with createPost)
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      authorId: postData.authorId,
      authorName: postData.authorName,
      type: postData.type || 'life_update',
      content: postData.content,
      timestamp: postData.timestamp || gameState.time.currentTime,
      likes: postData.likes || [],
      comments: postData.comments || [],
      mentions: postData.mentions || [],
      media: postData.media || null,
      location: postData.location || null,
      mood: postData.mood || null,
      tags: postData.tags || []
    };
    
    // Add to social network
    gameState.socialNetwork.posts.unshift(post); // Add to beginning of array (most recent first)
    
    // Limit total posts to prevent memory issues (keep last 500)
    if (gameState.socialNetwork.posts.length > 500) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 500);
    }
    
    // Update UI if social tab is active
    if (gameState.activeTab === 'social' && typeof requestSmartFeedUpdate === 'function') {
      requestSmartFeedUpdate();
    }
    
    return post;
  }
  
  /**
   * Generate morning post (coffee, commute, Monday blues, etc.)
   */
  function generateMorningPost(employee) {
    const morningThemes = [
      "Coffee is life ☕",
      "Monday blues 😴",
      "Traffic was brutal this morning 🚗",
      "Actually excited for today! 🌞",
      "Another day, another dollar 💼",
      "Who else needs caffeine to function? ☕😅",
      "Made it to work somehow 🏢"
    ];
    
    const theme = morningThemes[Math.floor(Math.random() * morningThemes.length)];
    
    // Create a simple post without AI (to save API calls)
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: theme,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }
  
  /**
   * Generate evening post (done with work, happy hour, etc.)
   */
  function generateEveningPost(employee) {
    const eveningThemes = [
      "Finally done for the day! 🎉",
      "Happy hour anyone? 🍻",
      "Time to unwind 😌",
      "Made it through another week! 💪",
      "Weekend vibes loading... 🌴",
      "Exhausted but accomplished 😴✅",
      "Who's ready for the weekend?"
    ];
    
    const theme = eveningThemes[Math.floor(Math.random() * eveningThemes.length)];
    
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: theme,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }
  
  /**
   * Check if player can chat with employee (availability based on time/relationship)
   */
  function canChatWithEmployee(employee) {
    const isWorking = employee.schedule && employee.schedule.isCurrentlyWorking;
    const isWorkHours = timeHelpers.isWorkHours();
    
    // During work hours
    if (isWorkHours && isWorking) {
      return { available: true, context: 'at_work' };
    }
    
    // After hours
    if (!isWorkHours) {
      const hour = timeHelpers.getHour();
      
      // Late night (11pm-6am) - need high affection
      if (hour >= 23 || hour < 6) {
        if (employee.stats && employee.stats.affection < 80) {
          return { available: false, reason: "It's very late..." };
        }
        return { available: true, context: 'late_night' };
      }
      
      // Evening (5pm-11pm) - usually available
      if (employee.stats && (employee.stats.affection > 40 || employee.stats.trust > 50)) {
        return { available: true, context: 'after_hours' };
      }
      
      // Low relationship - might not want to chat off-hours
      if (Math.random() < 0.3) {
        return { available: false, reason: "I'm off the clock..." };
      }
      
      return { available: true, context: 'after_hours' };
    }
    
    // Weekend
    if (timeHelpers.isWeekend()) {
      if (employee.stats && employee.stats.affection > 60) {
        return { available: true, context: 'weekend' };
      }
      return { available: false, reason: "It's my day off..." };
    }
    
    return { available: true, context: 'general' };
  }
  
  /**
   * Get time context string for chat AI
   */
  function getTimeContextForChat(employee) {
    const availability = canChatWithEmployee(employee);
    
    // Get current time for ALL contexts (not just work)
    const currentTime = timeHelpers.getFormattedTime();
    const currentDate = timeHelpers.getFormattedDate();
    
    let contextString = `\n📅 CURRENT DATE & TIME: ${currentDate}, ${currentTime}`;
    
    if (availability.context === 'after_hours') {
      contextString += '\n⏰ TIME CONTEXT: It\'s after work hours. You\'re at home, relaxed. Your responses can be more casual and personal.';
      
      // PHASE 5: Add current activity if available
      if (employee.personalLife && employee.personalLife.currentActivity) {
        contextString += `\nCURRENT ACTIVITY: ${employee.personalLife.currentActivity.description}`;
      }
    } else if (availability.context === 'late_night') {
      contextString += '\n🌙 TIME CONTEXT: It\'s very late at night. You\'re tired, maybe in bed. Keep responses brief unless it\'s important or intimate.';
    } else if (availability.context === 'weekend') {
      contextString += '\n📅 TIME CONTEXT: It\'s the weekend. You\'re off work, doing personal activities. Mention what you\'re up to!';
      
      // PHASE 5: Add weekend plans/activity
      if (employee.personalLife && employee.personalLife.currentActivity) {
        contextString += `\nCURRENT ACTIVITY: ${employee.personalLife.currentActivity.description}`;
      }
    } else if (availability.context === 'at_work') {
      contextString += '\n💼 TIME CONTEXT: You\'re at work right now. Maintain professionalism but can chat during breaks.';
    }
    
    // PHASE 5: Add living situation context (pets, roommates, etc.) - low priority
    if (employee.personalLife && employee.personalLife.livingSituation) {
      const living = employee.personalLife.livingSituation;
      if (living.hasPet && living.petType && living.petName) {
        contextString += `\n(You have a ${living.petType} named ${living.petName})`;
      }
      if (living.hasRoommate && availability.context && !availability.context.includes('work')) {
        contextString += `\n(You live with a roommate)`;
      }
    }
    
    return contextString;
  }
  
  /**
   * Update time display in UI
   */
  function updateTimeDisplay() {
    const timeDisplay = document.getElementById('game-time-display');
    if (timeDisplay && gameState.time) {
      const date = timeHelpers.getFormattedDate();
      const time = timeHelpers.getFormattedTime();
      const timeOfDay = timeHelpers.getTimeOfDay();
      
      const icons = {
        morning: '🌅',
        afternoon: '☀️',
        evening: '🌆',
        night: '🌙'
      };
      
      timeDisplay.innerHTML = `
        <span>${icons[timeOfDay]} ${date}</span>
        <span style="margin-left: 10px;">${time}</span>
      `;
    }
  }

  // ========== PHASE 5: LIFE OUTSIDE WORK ==========
  
  /**
   * Generate evening activity for employee after work
   */
  function generateEveningActivity(employee) {
    if (!employee.personalLife) return null;
    
    const prefs = employee.personalLife.eveningPreferences;
    const hour = timeHelpers.getHour();
    
    // Only generate after work hours
    if (hour < 17 || hour >= 23) return null;
    
    // Weight activities by preferences
    const activities = [];
    
    if (Math.random() < prefs.gym) activities.push({ type: 'gym', weight: prefs.gym });
    if (Math.random() < prefs.cooking) activities.push({ type: 'cooking', weight: prefs.cooking });
    if (Math.random() < prefs.socializing) activities.push({ type: 'socializing', weight: prefs.socializing });
    if (Math.random() < prefs.relaxing) activities.push({ type: 'relaxing', weight: prefs.relaxing });
    if (Math.random() < prefs.hobbies && employee.personalLife.activeHobbies.length > 0) {
      activities.push({ type: 'hobby', weight: prefs.hobbies });
    }
    if (Math.random() < prefs.dating && employee.personalLife.outsideContacts.inRelationship) {
      activities.push({ type: 'date', weight: prefs.dating });
    }
    
    if (activities.length === 0) return { type: 'relaxing', details: 'Chilling at home' };
    
    // Pick weighted random activity
    const totalWeight = activities.reduce((sum, a) => sum + a.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const activity of activities) {
      random -= activity.weight;
      if (random <= 0) {
        return generateActivityDetails(employee, activity.type);
      }
    }
    
    return { type: 'relaxing', details: 'Chilling at home' };
  }
  
  /**
   * Generate specific activity details
   */
  function generateActivityDetails(employee, activityType) {
    const details = { type: activityType, description: '', skillGain: null };
    
    switch (activityType) {
      case 'gym':
        const gymActivities = [
          'Hitting the gym 💪',
          'Cardio day at the gym',
          'Leg day (kill me now) 🦵',
          'Upper body workout',
          'Quick gym session',
          'Getting those gains 🏋️'
        ];
        details.description = gymActivities[Math.floor(Math.random() * gymActivities.length)];
        details.skillGain = { skill: 'fitness', xp: 5 };
        break;
        
      case 'cooking':
        const cookingActivities = [
          'Trying a new recipe tonight 👨‍🍳',
          'Cooking dinner from scratch',
          'Meal prepping for the week',
          'Experimenting in the kitchen',
          'Making my favorite dish',
          'Cooking up something special 🍳'
        ];
        details.description = cookingActivities[Math.floor(Math.random() * cookingActivities.length)];
        details.skillGain = { skill: 'cooking', xp: 5 };
        break;
        
      case 'socializing':
        const socialActivities = [
          'Meeting friends for drinks 🍻',
          'Game night with the crew 🎮',
          'Dinner with friends',
          'Bar hopping tonight',
          'Catching up with old friends',
          'Girls night out! 💃'
        ];
        details.description = socialActivities[Math.floor(Math.random() * socialActivities.length)];
        details.skillGain = { skill: 'social', xp: 3 };
        break;
        
      case 'relaxing':
        const relaxActivities = [
          'Netflix and chill tonight 📺',
          'Just relaxing at home',
          'Reading a good book 📚',
          'Taking it easy tonight',
          'Couch potato mode activated',
          'Self-care evening 🛁'
        ];
        details.description = relaxActivities[Math.floor(Math.random() * relaxActivities.length)];
        break;
        
      case 'hobby':
        if (employee.personalLife.activeHobbies.length > 0) {
          const hobby = employee.personalLife.activeHobbies[0];
          details.description = `Doing my ${hobby.name} hobby tonight`;
          
          // Map hobbies to skills
          const hobbySkillMap = {
            'Gaming': 'technical',
            'Photography': 'creative',
            'Painting': 'creative',
            'Writing': 'creative',
            'Music': 'creative',
            'Sports': 'fitness',
            'Yoga': 'fitness',
            'Dancing': 'fitness'
          };
          
          const skill = hobbySkillMap[hobby.name];
          if (skill) {
            details.skillGain = { skill, xp: 4 };
          }
        }
        break;
        
      case 'date':
        const dateActivities = [
          'Date night! 😊',
          'Dinner and a movie date',
          'Romantic evening planned',
          'Going out with bae 💕',
          'Date night vibes'
        ];
        details.description = dateActivities[Math.floor(Math.random() * dateActivities.length)];
        details.skillGain = { skill: 'intimate', xp: 3 };
        break;
    }
    
    return details;
  }
  
  /**
   * Generate weekend plans for all employees
   */
  function generateWeekendPlans() {
    const day = timeHelpers.getDay();
    
    // Only generate on Friday evening or Saturday morning
    if (day !== 5 && day !== 6) return;
    
    gameState.employees.forEach(emp => {
      if (!emp.personalLife || !emp.personalLife.upcomingPlans) return;
      
      // Clear old plans
      emp.personalLife.upcomingPlans = [];
      
      // Saturday plans (80% chance to have plans)
      if (Math.random() < 0.8) {
        const saturdayActivity = generateWeekendActivityType(emp);
        const details = generateActivityDetails(emp, saturdayActivity);
        emp.personalLife.upcomingPlans.push({
          day: 'Saturday',
          activity: saturdayActivity,
          details: details.description,
          time: Math.random() < 0.5 ? 'morning' : 'afternoon'
        });
      }
      
      // Sunday plans (70% chance, usually more relaxed)
      if (Math.random() < 0.7) {
        const sundayActivities = ['relaxing', 'hobby', 'cooking'];
        const sundayActivity = sundayActivities[Math.floor(Math.random() * sundayActivities.length)];
        const details = generateActivityDetails(emp, sundayActivity);
        emp.personalLife.upcomingPlans.push({
          day: 'Sunday',
          activity: sundayActivity,
          details: details.description,
          time: 'afternoon'
        });
      }
    });
    
    console.log('📅 Weekend plans generated for all employees');
  }
  
  /**
   * Pick weekend activity type based on employee data
   */
  function generateWeekendActivityType(employee) {
    const activities = ['relaxing', 'hobby', 'socializing', 'gym', 'cooking'];
    
    // Weight by preferences
    if (employee.personalLife.activeHobbies.length > 0 && Math.random() < 0.4) {
      return 'hobby';
    }
    
    if (employee.personalLife.outsideContacts.inRelationship && Math.random() < 0.3) {
      return 'date';
    }
    
    if (employee.skills.fitness.level > 3 && Math.random() < 0.35) {
      return 'gym';
    }
    
    if (employee.skills.cooking.level > 3 && Math.random() < 0.3) {
      return 'cooking';
    }
    
    return activities[Math.floor(Math.random() * activities.length)];
  }
  
  /**
   * Update employee activities (called hourly)
   */
  function updateEmployeeActivities() {
    const hour = timeHelpers.getHour();
    const isWeekend = timeHelpers.isWeekend();
    
    gameState.employees.forEach(emp => {
      if (!emp.personalLife) return;
      
      // After work hours (5 PM - 11 PM) on weekdays
      if (!isWeekend && hour >= 17 && hour < 23) {
        // Generate evening activity if none exists
        if (!emp.personalLife.currentActivity || emp.personalLife.activityStartTime < Date.now() - 3600000) {
          const activity = generateEveningActivity(emp);
          if (activity) {
            emp.personalLife.currentActivity = activity;
            emp.personalLife.activityStartTime = gameState.time.currentTime;
            
            // Apply skill gains if any
            if (activity.skillGain) {
              gainSkillXP(emp, activity.skillGain.skill, activity.skillGain.xp, 'evening activity');
            }
            
            // 20% chance to post about activity
            if (Math.random() < 0.2) {
              createActivityPost(emp, activity);
            }
          }
        }
      }
      
      // Weekend activities
      if (isWeekend && hour >= 10 && hour < 20) {
        // Check if they have plans for today
        const dayName = timeHelpers.getDay() === 0 ? 'Sunday' : 'Saturday';
        const todayPlans = emp.personalLife.upcomingPlans.find(p => p.day === dayName);
        
        if (todayPlans && !emp.personalLife.currentActivity) {
          emp.personalLife.currentActivity = {
            type: todayPlans.activity,
            description: todayPlans.details,
            skillGain: generateActivityDetails(emp, todayPlans.activity).skillGain
          };
          emp.personalLife.activityStartTime = gameState.time.currentTime;
          
          // Apply skill gains
          if (emp.personalLife.currentActivity.skillGain) {
            const sg = emp.personalLife.currentActivity.skillGain;
            gainSkillXP(emp, sg.skill, sg.xp, 'weekend activity');
          }
          
          // 30% chance to post about weekend activity
          if (Math.random() < 0.3) {
            createActivityPost(emp, emp.personalLife.currentActivity);
          }
        }
      }
      
      // Clear activity late at night
      if (hour >= 23 || hour < 6) {
        emp.personalLife.currentActivity = null;
      }
    });
  }
  
  /**
   * Create social post about activity
   */
  function createActivityPost(employee, activity) {
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: activity.description,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }

  // ========== PHASE 6: SOCIAL CONTEXT & AWARENESS ==========
  
  /**
   * Build awareness context about another employee
   * NPCs know about coworkers' personal lives, activities, and situations
   */
  function buildCoworkerAwarenessContext(observer, targetEmployee) {
    if (!observer || !targetEmployee || observer.id === targetEmployee.id) return '';
    
    let context = '\n=== WHAT YOU KNOW ABOUT ' + targetEmployee.name.toUpperCase() + ' ===\n';
    
    // Relationship with target
    const relationship = observer.relationships?.[targetEmployee.id];
    if (relationship) {
      context += `Your relationship: ${relationship.type || 'coworker'} (strength: ${relationship.strength || 0})\n`;
    }
    
    // Current activity awareness (if close enough relationship)
    if (relationship && relationship.strength > 40 && targetEmployee.personalLife?.currentActivity) {
      context += `Current activity: ${targetEmployee.personalLife.currentActivity.description}\n`;
    }
    
    // Weekend plans awareness (if friends)
    if (relationship && relationship.strength > 60 && targetEmployee.personalLife?.upcomingPlans) {
      const plans = targetEmployee.personalLife.upcomingPlans;
      if (plans.length > 0) {
        context += `Weekend plans: ${plans.map(p => `${p.day} - ${p.details}`).join(', ')}\n`;
      }
    }
    
    // Pet awareness (casual knowledge)
    if (targetEmployee.personalLife?.livingSituation?.hasPet) {
      const pet = targetEmployee.personalLife.livingSituation;
      context += `Has a ${pet.petType} named ${pet.petName}\n`;
    }
    
    // Work status awareness
    if (targetEmployee.schedule?.isCurrentlyWorking !== undefined) {
      context += `Work status: ${targetEmployee.schedule.isCurrentlyWorking ? 'Currently working' : 'Off duty'}\n`;
    }
    
    // Skill awareness (if they've worked together)
    if (relationship && relationship.strength > 50 && targetEmployee.skills) {
      const topSkills = Object.entries(targetEmployee.skills)
        .filter(([name, skill]) => skill.level >= 5)
        .sort((a, b) => b[1].level - a[1].level)
        .slice(0, 2);
      
      if (topSkills.length > 0) {
        context += `Known skills: ${topSkills.map(([name, skill]) => `${name} (Lv ${skill.level})`).join(', ')}\n`;
      }
    }
    
    // Flag awareness (if very close or flags are public)
    if (relationship && relationship.strength > 70 && targetEmployee.flags) {
      const visibleFlags = targetEmployee.flags.systemFlags
        .filter(f => f.priority === 'high' || f.category === 'public')
        .slice(0, 2);
      
      if (visibleFlags.length > 0) {
        context += `You know: ${visibleFlags.map(f => f.playerDescription || f.key).join(', ')}\n`;
      }
    }
    
    // Recent gossip about them
    const recentGossip = gameState.gossip?.filter(g => 
      g.involvedEmployees?.includes(targetEmployee.id) && 
      Date.now() - g.timestamp < 604800000 // Last week
    ).slice(0, 2) || [];
    
    if (recentGossip.length > 0) {
      context += `Recent gossip: ${recentGossip.map(g => g.description).join('; ')}\n`;
    }
    
    return context;
  }
  
  /**
   * Get social feed context for AI
   * Shows relevant posts from coworkers to make NPCs aware of office social dynamics
   */
  function getRecentSocialContext(employee, limit = 5) {
    if (!gameState.socialFeed || gameState.socialFeed.length === 0) return '';
    
    let context = '\n=== RECENT OFFICE SOCIAL POSTS ===\n';
    
    // Get recent posts (last 24 hours game time)
    const recentPosts = gameState.socialFeed
      .filter(post => {
        const ageMs = gameState.time.currentTime - post.timestamp;
        return ageMs < 86400000; // 24 hours
      })
      .slice(0, limit);
    
    if (recentPosts.length === 0) return '';
    
    recentPosts.forEach(post => {
      const author = gameState.employees.find(e => e.id === post.authorId);
      const authorName = author?.name || post.authorName || 'Unknown';
      
      context += `${authorName}: "${post.content.substring(0, 100)}${post.content.length > 100 ? '...' : ''}"\n`;
      
      // Add engagement info
      if (post.likes?.length > 0) {
        context += `  (${post.likes.length} likes`;
        if (post.comments?.length > 0) {
          context += `, ${post.comments.length} comments`;
        }
        context += ')\n';
      }
    });
    
    return context;
  }
  
  /**
   * Detect if NPC should mention another NPC's activity in conversation
   * Creates organic cross-referencing ("Have you seen Sarah's gym posts?")
   */
  function shouldMentionCoworkerActivity(speaker, listener, coworker) {
    if (!speaker || !listener || !coworker) return false;
    if (speaker.id === coworker.id || listener.id === coworker.id) return false;
    
    // Check if speaker knows about coworker's recent activity
    const relationship = speaker.relationships?.[coworker.id];
    if (!relationship || relationship.strength < 40) return false;
    
    // Check if coworker has interesting recent activity
    if (!coworker.personalLife?.currentActivity) return false;
    
    // Check if coworker has posted recently about something interesting
    const coworkerPosts = gameState.socialFeed?.filter(post => 
      post.authorId === coworker.id &&
      gameState.time.currentTime - post.timestamp < 3600000 // Last hour
    ) || [];
    
    if (coworkerPosts.length === 0) return false;
    
    // Random chance (10%) to mention it
    return Math.random() < 0.1;
  }
  
  /**
   * Generate office dynamics summary
   * For AI context about current office mood/situation
   */
  function getOfficeDynamicsSummary() {
    const activeEmployees = gameState.employees.filter(emp => 
      emp.schedule?.isCurrentlyWorking
    );
    
    if (activeEmployees.length === 0) {
      return '\n=== OFFICE DYNAMICS ===\nNobody else is in the office right now.\n';
    }
    
    let summary = '\n=== OFFICE DYNAMICS ===\n';
    summary += `${activeEmployees.length} people currently working in the office.\n`;
    
    // Detect common activities
    const currentActivities = activeEmployees
      .filter(emp => emp.personalLife?.currentActivity)
      .map(emp => ({ name: emp.name, activity: emp.personalLife.currentActivity.type }));
    
    if (currentActivities.length > 2) {
      // Count activity types
      const activityCounts = {};
      currentActivities.forEach(a => {
        activityCounts[a.activity] = (activityCounts[a.activity] || 0) + 1;
      });
      
      const commonActivities = Object.entries(activityCounts)
        .filter(([type, count]) => count >= 2)
        .map(([type]) => type);
      
      if (commonActivities.length > 0) {
        summary += `Common theme: Several people are doing ${commonActivities[0]} activities.\n`;
      }
    }
    
    // Recent office mood
    const recentPosts = gameState.socialFeed?.slice(0, 10) || [];
    const positiveCount = recentPosts.filter(p => 
      p.type === 'achievement' || p.type === 'celebration' || p.content.includes('😊') || p.content.includes('🎉')
    ).length;
    const negativeCount = recentPosts.filter(p =>
      p.type === 'complaint' || p.type === 'tea_spilling' || p.content.includes('😤') || p.content.includes('😢')
    ).length;
    
    if (positiveCount > negativeCount * 2) {
      summary += `Office mood: Generally positive and upbeat.\n`;
    } else if (negativeCount > positiveCount * 2) {
      summary += `Office mood: Some tension or complaints recently.\n`;
    }
    
    return summary;
  }

  // ========== FLAG DETECTION SYSTEM ==========
  
  /**
   * Flag detection patterns (keyword-based, no AI needed!)
   */
  const FLAG_DETECTION_PATTERNS = {
    free_use: {
      keywords: ['free use', 'free-use', 'anytime you want', 'whenever you need', 'always available'],
      contextKeywords: ['agreement', 'arrangement', 'deal', 'consent'],
      requiredAffection: 70,
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'free_use_agreement',
        category: 'relationship_agreement',
        priority: 'high',
        playerDescription: 'Free-use agreement established',
        aiGuidance: 'This employee has a free-use agreement with the player. They\'re willing and available. Reference this naturally in interactions and show enthusiasm.'
      }
    },
    
    no_clothes: {
      keywords: ['naked', 'nude', 'no clothes', 'not wearing anything', 'bare', 'undressed', 'nothing on'],
      contextKeywords: ['work', 'office', 'always', 'never wear'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'no_clothes_at_work',
        category: 'appearance',
        priority: 'high',
        playerDescription: 'Doesn\'t wear clothes at work',
        aiGuidance: 'This employee is always naked at work. They\'re comfortable with it and it\'s now normal for them. Mention it casually in conversation.'
      }
    },
    
    dominant: {
      keywords: ['dominate', 'control', 'in charge', 'tell me what to do', 'order me', 'boss me around'],
      contextKeywords: ['you', 'player', 'boss'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'player_dominant',
        category: 'relationship_dynamic',
        priority: 'high',
        playerDescription: 'You\'re dominant in the relationship',
        aiGuidance: 'The player is dominant. You defer to their decisions and enjoy being controlled. Use respectful language and seek their approval.'
      }
    },
    
    submissive: {
      keywords: ['submit', 'obey', 'serve', 'please you', 'whatever you want', 'yes sir', 'yes master', 'yes daddy'],
      contextKeywords: ['want to', 'love to', 'enjoy', 'need to'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'submissive_to_player',
        category: 'relationship_dynamic',
        priority: 'high',
        playerDescription: 'Submissive to you',
        aiGuidance: 'You\'re submissive to the player. You seek their approval, enjoy serving them, and defer to their wishes. Be respectful and eager to please.'
      }
    },
    
    breeding: {
      keywords: ['breed me', 'get me pregnant', 'want your baby', 'fill me', 'impregnate', 'knock me up'],
      contextKeywords: ['want', 'need', 'please'],
      requiredOccurrences: 1, // Very explicit
      suggestedFlag: {
        key: 'breeding_kink',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Has breeding kink',
        aiGuidance: 'You have a breeding kink. You find the idea of pregnancy arousing and enjoy discussing it.'
      }
    },
    
    exhibitionist: {
      keywords: ['show off', 'watch me', 'people seeing', 'public', 'caught', 'risky', 'exposed'],
      contextKeywords: ['excited', 'hot', 'thrilling', 'turned on', 'love when'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'exhibitionist',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Exhibitionist tendencies',
        aiGuidance: 'You\'re an exhibitionist. You enjoy being seen and the thrill of public or risky encounters. Mention this excitement in appropriate contexts.'
      }
    },
    
    polyamorous: {
      keywords: ['more than one', 'share', 'both of us', 'join us', 'threesome', 'group', 'together with'],
      contextKeywords: ['open to', 'interested', 'would love', 'excited about'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'polyamorous',
        category: 'relationship_style',
        priority: 'medium',
        playerDescription: 'Open to polyamory',
        aiGuidance: 'You\'re open to non-monogamous relationships. You\'re comfortable sharing or being involved with multiple partners simultaneously.'
      }
    },
    
    secret_relationship: {
      keywords: ['secret', 'nobody knows', 'hide', 'can\'t tell', 'our secret', 'keep quiet'],
      contextKeywords: ['relationship', 'us', 'together', 'dating'],
      requiredOccurrences: 2,
      suggestedFlag: {
        key: 'secret_relationship',
        category: 'relationship_status',
        priority: 'high',
        playerDescription: 'Secret relationship',
        aiGuidance: 'You\'re in a secret relationship with the player. You must hide it at work but might let it slip accidentally or show subtle signs.'
      }
    },
    
    always_nude: {
      keywords: ['always nude', 'always naked', 'permanently nude', 'permanently naked', '100% nude', 'never wear clothes', 'always undressed'],
      contextKeywords: ['work', 'employment', 'office', 'agree', 'promise', 'confirmed', 'deal', 'bargain'],
      requiredOccurrences: 1, // Explicit agreement, only needs 1 confirmation
      suggestedFlag: {
        key: 'always_nude',
        category: 'appearance',
        priority: 'critical',
        playerDescription: 'Always nude at work (permanent)',
        aiGuidance: 'You have permanently agreed to be 100% nude during all work hours. This is your new normal dress code. You\'re comfortable with it and honor this agreement. Never mention wearing clothes at work.'
      }
    }
  };
  
  /**
   * Analyze conversation for flag patterns (lightweight, runs after each AI response)
   * @param {Object} employee - The employee object
   * @param {string} aiResponse - The AI's response text
   */
  function analyzeConversationForFlags(employee, aiResponse) {
    if (!gameState.flagDetection.settings.enabled) return;
    if (!aiResponse) return;
    
    const text = aiResponse.toLowerCase();
    
    // Check each detection pattern
    Object.keys(FLAG_DETECTION_PATTERNS).forEach(patternKey => {
      const pattern = FLAG_DETECTION_PATTERNS[patternKey];
      
      // Check if employee already has this flag
      if (hasFlag(employee, pattern.suggestedFlag.key)) return;
      
      // Check affection requirements
      if (pattern.requiredAffection && employee.stats.affection < pattern.requiredAffection) return;
      
      // Count keyword matches
      let keywordMatches = 0;
      let contextMatches = 0;
      
      pattern.keywords.forEach(keyword => {
        if (text.includes(keyword)) keywordMatches++;
      });
      
      if (pattern.contextKeywords) {
        pattern.contextKeywords.forEach(keyword => {
          if (text.includes(keyword)) contextMatches++;
        });
      }
      
      // If keywords found, track it
      if (keywordMatches > 0 && (!pattern.contextKeywords || contextMatches > 0)) {
        trackFlagPattern(employee, patternKey, text);
      }
    });
    
    // Check if any patterns hit threshold
    checkFlagSuggestions(employee);
  }
  
  /**
   * Track a flag pattern occurrence
   * @param {Object} employee - The employee object
   * @param {string} patternKey - The pattern key
   * @param {string} context - The conversation snippet
   */
  function trackFlagPattern(employee, patternKey, context) {
    if (!gameState.flagDetection.tracking[employee.id]) {
      gameState.flagDetection.tracking[employee.id] = {};
    }
    
    if (!gameState.flagDetection.tracking[employee.id][patternKey]) {
      gameState.flagDetection.tracking[employee.id][patternKey] = {
        count: 0,
        contexts: [],
        lastSeen: 0
      };
    }
    
    const tracking = gameState.flagDetection.tracking[employee.id][patternKey];
    tracking.count++;
    tracking.contexts.push(context.substring(0, 100)); // Store snippet
    tracking.lastSeen = Date.now();
    
    console.log(`[Flag Detection] ${employee.name}: ${patternKey} mentioned (${tracking.count} times)`);
  }
  
  /**
   * Check if any patterns have reached suggestion threshold
   * @param {Object} employee - The employee object
   */
  function checkFlagSuggestions(employee) {
    if (!gameState.flagDetection.tracking[employee.id]) return;
    
    Object.keys(gameState.flagDetection.tracking[employee.id]).forEach(patternKey => {
      const tracking = gameState.flagDetection.tracking[employee.id][patternKey];
      const pattern = FLAG_DETECTION_PATTERNS[patternKey];
      
      if (!pattern) return;
      
      // Check if threshold met
      const requiredOccurrences = pattern.requiredOccurrences || 1;
      if (tracking.count >= requiredOccurrences) {
        // Check auto-approve
        if (gameState.flagDetection.settings.autoApprove.includes(pattern.suggestedFlag.key)) {
          // Auto-add the flag
          addFlag(employee, pattern.suggestedFlag);
          console.log(`[Flag Detection] Auto-approved: ${pattern.suggestedFlag.key} for ${employee.name}`);
        } else {
          // Suggest flag to player
          suggestFlag(employee, pattern.suggestedFlag, tracking.contexts);
        }
        
        // Clear tracking (so we don't suggest again)
        delete gameState.flagDetection.tracking[employee.id][patternKey];
      }
    });
  }
  
  /**
   * Suggest a flag to the player for approval
   * @param {Object} employee - The employee object
   * @param {Object} flagData - The flag configuration
   * @param {Array} contexts - Conversation snippets that triggered detection
   */
  function suggestFlag(employee, flagData, contexts) {
    // Check if already suggested
    const alreadySuggested = gameState.flagDetection.suggestions.some(
      s => s.employeeId === employee.id && s.flag.key === flagData.key
    );
    if (alreadySuggested) return;
    
    // Add to suggestions
    const suggestion = {
      id: generateFlagId(),
      employeeId: employee.id,
      employeeName: employee.name,
      flag: flagData,
      contexts: contexts,
      suggestedAt: Date.now(),
      status: 'pending' // 'pending', 'approved', 'rejected'
    };
    
    gameState.flagDetection.suggestions.push(suggestion);
    
    console.log(`[Flag Detection] Suggested "${flagData.key}" for ${employee.name}`);
    
    // Show notification to player
    showFlagSuggestionNotification(suggestion);
  }
  
  /**
   * Show a notification about a flag suggestion
   * @param {Object} suggestion - The suggestion object
   */
  function showFlagSuggestionNotification(suggestion) {
    // Remove any existing flag notifications first
    const existingNotifications = document.querySelectorAll('.flag-suggestion-notification');
    existingNotifications.forEach(n => n.remove());
    
    // Create a PROMINENT notification (top-center for visibility)
    const notification = document.createElement('div');
    notification.className = 'flag-suggestion-notification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 25px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(102, 126, 234, 0.6), 0 0 0 3px rgba(255, 255, 255, 0.3);
      z-index: 100000;
      max-width: 450px;
      min-width: 400px;
      animation: flagPulse 0.5s ease-out;
      border: 2px solid rgba(255, 255, 255, 0.5);
    `;
    
    notification.innerHTML = `
      <div style="margin-bottom: 12px; font-size: 1.3rem; font-weight: bold; text-align: center;">
        🏷️ NEW FLAG DETECTED!
      </div>
      <div style="margin-bottom: 12px; font-size: 1.1rem; text-align: center;">
        <strong style="color: #ffd700;">${suggestion.employeeName}</strong> now has: 
        <br><strong style="color: #4ecca3; font-size: 1.15rem;">${suggestion.flag.playerDescription}</strong>
      </div>
      <div style="font-size: 0.95rem; opacity: 0.9; margin-bottom: 15px; text-align: center; font-style: italic; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
        📝 "${suggestion.contexts[0].substring(0, 80)}..."
      </div>
      <div style="display: flex; gap: 12px;">
        <button onclick="approveFlagSuggestion('${suggestion.id}')" style="flex: 1; padding: 12px 20px; background: #10b981; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; font-size: 1rem; transition: all 0.2s;">
          ✅ ADD FLAG
        </button>
        <button onclick="rejectFlagSuggestion('${suggestion.id}')" style="flex: 1; padding: 12px 20px; background: #ef4444; border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 1rem; transition: all 0.2s;">
          ❌ IGNORE
        </button>
      </div>
      <div style="text-align: center; margin-top: 10px; font-size: 0.85rem; opacity: 0.7;">
        Auto-dismisses in 60 seconds
      </div>
    `;
    
    // Add hover effects to buttons
    const buttons = notification.querySelectorAll('button');
    buttons.forEach(btn => {
      btn.onmouseenter = () => btn.style.transform = 'scale(1.05)';
      btn.onmouseleave = () => btn.style.transform = 'scale(1)';
    });
    
    document.body.appendChild(notification);
    
    // Add animation keyframes if not already present
    if (!document.getElementById('flag-notification-styles')) {
      const style = document.createElement('style');
      style.id = 'flag-notification-styles';
      style.textContent = `
        @keyframes flagPulse {
          0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
          50% { transform: translateX(-50%) scale(1.05); }
          100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Play notification sound (if audio context available)
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    } catch (e) {
      console.log('[Flag Detection] Audio notification not available');
    }
    
    // Auto-remove after 60 seconds if not interacted with
    setTimeout(() => {
      if (notification.parentElement) {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s';
        setTimeout(() => notification.remove(), 500);
      }
    }, 60000);
  }
  
  /**
   * Approve a flag suggestion
   * @param {string} suggestionId - The suggestion ID
   */
  function approveFlagSuggestion(suggestionId) {
    const suggestion = gameState.flagDetection.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    const employee = gameState.employees.find(e => e.id === suggestion.employeeId);
    if (!employee) return;
    
    // Add the flag
    addFlag(employee, suggestion.flag);
    
    // Mark as approved
    suggestion.status = 'approved';
    
    // Remove notification
    const notification = document.querySelector('.flag-suggestion-notification');
    if (notification) notification.remove();
    
    // Show success message
    showNotification(`Added flag: ${suggestion.flag.playerDescription} to ${employee.name}`, 'success');
    
    console.log(`[Flag Detection] Approved: ${suggestion.flag.key} for ${employee.name}`);
  }
  
  /**
   * Reject a flag suggestion
   * @param {string} suggestionId - The suggestion ID
   */
  function rejectFlagSuggestion(suggestionId) {
    const suggestion = gameState.flagDetection.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    // Mark as rejected
    suggestion.status = 'rejected';
    
    // Remove notification
    const notification = document.querySelector('.flag-suggestion-notification');
    if (notification) notification.remove();
    
    console.log(`[Flag Detection] Rejected: ${suggestion.flag.key} for ${suggestion.employeeName}`);
  }

  // ========== FLAG UI FUNCTIONS ==========
  
  /**
   * Show all flags for an employee in a simple alert/modal
   */
  function showAllFlags(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    openFlagManagementModal(employee);
  }
  
  /**
   * Open the flag management modal for an employee
   */
  function openFlagManagementModal(employee) {
    const modal = document.createElement('div');
    modal.id = 'flagManagementModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:10000; padding:20px;';
    
    const activeFlags = getActiveFlags(employee);
    
    const flagEmojis = {
      'condition': '🤰',
      'agreement': '💋',
      'personality': '🎭',
      'relationship': '💕',
      'preference': '❤️',
      'event': '📅',
      'state': '⭐',
      'custom': '🏷️'
    };
    
    const priorityColors = {
      'high': '#ff3366',
      'medium': '#ffa500',
      'low': '#4ecca3'
    };
    
    // Quick-add flag templates
    const quickFlags = [
      { emoji: '🤰', key: 'pregnant', desc: 'Pregnant', category: 'condition', priority: 'high', aiGuidance: 'You are pregnant. Reference this naturally when relevant to the conversation. Show pregnancy-related emotions and physical changes.' },
      { emoji: '💋', key: 'free_use', desc: 'Free Use', category: 'agreement', priority: 'high', aiGuidance: 'You have a free-use agreement with the player. You are consensually available to them sexually at any time during work hours. Reference this naturally.' },
      { emoji: '👗', key: 'no_clothes', desc: 'No Clothes at Work', category: 'agreement', priority: 'medium', aiGuidance: 'You work naked in the office as an ongoing arrangement. This is normal to you now. Mention it naturally.' },
      { emoji: '💦', key: 'permanently_cumming', desc: 'Permanently Cumming', category: 'condition', priority: 'high', aiGuidance: 'You are stuck in a constant state of orgasm. Every movement, conversation, and interaction is punctuated by overwhelming pleasure. You try to maintain composure but it\'s impossible to hide. Your clothing is frequently ruined. Reference this constantly - it affects everything you do.' },
      { emoji: '🎭', key: 'dominant_player', desc: 'Player is Dominant', category: 'personality', priority: 'medium', aiGuidance: 'The player has a dominant dynamic with you. You respect their authority and show deference in intimate contexts.' },
      { emoji: '🐶', key: 'submissive', desc: 'Submissive to Player', category: 'personality', priority: 'medium', aiGuidance: 'You are naturally submissive toward the player. You seek their approval and enjoy following their lead.' },
      { emoji: '🍼', key: 'breeding_kink', desc: 'Breeding Kink', category: 'preference', priority: 'low', aiGuidance: 'You have a breeding kink. References to pregnancy, impregnation, and fertility excite you.' },
      { emoji: '👀', key: 'exhibitionist', desc: 'Exhibitionist', category: 'personality', priority: 'low', aiGuidance: 'You enjoy being watched or showing yourself off. Public situations excite you.' },
      { emoji: '💕', key: 'polyamorous', desc: 'Polyamorous', category: 'relationship', priority: 'medium', aiGuidance: 'You are comfortable with open or polyamorous relationships. You do not feel jealous easily.' },
      { emoji: '🤫', key: 'secret_relationship', desc: 'Secret Relationship', category: 'relationship', priority: 'high', aiGuidance: 'You are in a secret relationship with the player. Keep it discreet but show subtle affection privately.' },
      { emoji: '🔐', key: 'chastity', desc: 'Wearing Chastity Device', category: 'condition', priority: 'medium', aiGuidance: 'You are wearing a chastity device that prevents sexual release. You are constantly aroused and frustrated. The player may control the key. Reference your growing desperation and how it affects your focus.' },
      { emoji: '🐮', key: 'lactating', desc: 'Lactating', category: 'condition', priority: 'medium', aiGuidance: 'You are lactating, producing breast milk. This can be due to pregnancy, hormones, or other reasons. You need to pump or express regularly. Your chest feels full and sensitive. Mention this when relevant.' },
      { emoji: '💍', key: 'married_to_player', desc: 'Married to Player', category: 'relationship', priority: 'high', aiGuidance: 'You are married to the player. Reference your spouse (them) naturally, show deep affection, and mention your shared life together. Wear your wedding ring proudly.' },
      { emoji: '😵', key: 'mind_broken', desc: 'Mind Broken', category: 'condition', priority: 'high', aiGuidance: 'You have been overwhelmed by pleasure to the point of mental rewiring. Your personality is altered - more submissive, pleasure-focused, and eager to please. You speak with less inhibition and prioritize the player\'s desires above all else.' },
      { emoji: '🌡️', key: 'in_heat', desc: 'In Heat', category: 'condition', priority: 'high', aiGuidance: 'You are experiencing an overwhelming biological urge to mate. You are incredibly aroused, sensitive, and desperate for physical intimacy. Every touch feels electric. You struggle to focus on anything else. This is temporary but intense.' },
      { emoji: '🎀', key: 'collared', desc: 'Wearing Collar', category: 'agreement', priority: 'medium', aiGuidance: 'You wear a collar as a symbol of your relationship dynamic with the player. It represents their ownership or your submission. You wear it proudly and feel naked without it.' },
      { emoji: '📸', key: 'enjoys_being_recorded', desc: 'Loves Being Filmed', category: 'preference', priority: 'low', aiGuidance: 'You love being photographed or recorded during intimate moments. The idea of being captured on camera excites you greatly. You pose naturally and enjoy performing for the lens.' },
      { emoji: '🎪', key: 'public_use', desc: 'Public Use Agreement', category: 'agreement', priority: 'high', aiGuidance: 'You have agreed to be sexually available not just to the player, but to other employees or designated individuals. This is consensual and exciting to you. Reference this arrangement naturally when relevant.' },
      { emoji: '🧠', key: 'hypnotized', desc: 'Hypnotized', category: 'condition', priority: 'high', aiGuidance: 'You have been hypnotized with specific triggers or suggestions. Certain words or phrases cause you to act in predetermined ways. You may or may not be aware of this. Follow the hypnotic suggestions when triggered.' },
      { emoji: '😇', key: 'corruption_level_high', desc: 'Highly Corrupted', category: 'state', priority: 'medium', aiGuidance: 'Your moral boundaries have significantly shifted through gradual corruption. What once shocked you now excites you. You are more sexually open, less inhibited, and willing to explore previously forbidden territory. Reference how much you\'ve "changed" or "grown".' }
    ];
    
    modal.innerHTML = `
      <div style="background:#16213e; width:100%; max-width:800px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#fff; display:flex; align-items:center; gap:10px;">
            🏷️ Flags for ${employee.name}
          </h2>
          <button id="closeFlagModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer; width:40px; height:40px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">✕</button>
        </div>
        
        <!-- Content -->
        <div style="flex:1; overflow-y:auto; padding:20px;">
          
          <!-- Quick Add Section -->
          <div style="margin-bottom:25px;">
            <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">📋 Flag Templates</h3>
            <p style="margin:0 0 12px 0; color:#aaa; font-size:0.85rem;">Click a template to pre-fill the custom flag form below</p>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${quickFlags.map(f => {
                // Properly escape the aiGuidance string for use in onclick attribute
                const escapedGuidance = f.aiGuidance.replace(/'/g, "&apos;").replace(/"/g, "&quot;");
                return `
                <button onclick="loadFlagTemplate('${employee.id}', '${f.key}', '${f.desc}', '${f.category}', '${f.priority}', '${f.emoji}', '${escapedGuidance}')" 
                        style="padding:8px 14px; background:#0f3460; border:1px solid #533483; border-radius:8px; color:#fff; cursor:pointer; font-size:.9rem; font-weight:500; transition:all 0.2s; display:flex; align-items:center; gap:6px;"
                        onmouseover="this.style.background='#533483'; this.style.borderColor='#c77dff'" 
                        onmouseout="this.style.background='#0f3460'; this.style.borderColor='#533483'">
                  <span style="font-size:1.1rem;">${f.emoji}</span> ${f.desc}
                </button>
              `;
              }).join('')}
            </div>
          </div>
          
          <!-- Active Flags Section -->
          <div>
            <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">🏷️ Active Flags (${activeFlags.length})</h3>
            <div id="activeFlagsContainer" style="display:flex; flex-direction:column; gap:10px;">
              ${activeFlags.length === 0 ? `
                <div style="padding:30px; text-align:center; color:#999; background:#0f1419; border-radius:8px;">
                  <div style="font-size:3rem; margin-bottom:10px; opacity:0.3;">🏷️</div>
                  <p style="margin:0; font-size:0.95rem;">No flags yet. Add some using the quick buttons above or create a custom flag!</p>
                </div>
              ` : activeFlags.map(flag => {
                const emoji = flagEmojis[flag.category] || '🏷️';
                const color = priorityColors[flag.priority] || '#888';
                const isSystem = flag.source === 'system' || !flag.source;
                const createdDate = flag.createdAt ? new Date(flag.createdAt).toLocaleDateString() : 'Unknown';
                const expiresDate = flag.expiresAt ? new Date(flag.expiresAt).toLocaleDateString() : 'Never';
                
                return `
                  <div style="background:#0f1419; padding:15px; border-radius:8px; border-left:4px solid ${color};">
                    <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
                      <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                          <span style="font-size:1.5rem;">${flag.emoji || emoji}</span>
                          <strong style="font-size:1.1rem; color:#fff;">${flag.playerDescription || flag.description || flag.key}</strong>
                          <span style="display:inline-block; padding:2px 8px; background:${color}; color:white; border-radius:12px; font-size:.7rem; font-weight:600;">${flag.priority.toUpperCase()}</span>
                          <span style="display:inline-block; padding:2px 8px; background:rgba(255,255,255,0.1); color:#aaa; border-radius:12px; font-size:.7rem;">${flag.category}</span>
                        </div>
                        <div style="color:#aaa; font-size:.85rem; margin-bottom:4px;">
                          <strong>Key:</strong> <code style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px; font-family:monospace;">${flag.key}</code>
                        </div>
                        ${flag.value ? `<div style="color:#aaa; font-size:.85rem; margin-bottom:4px;"><strong>Value:</strong> <code style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px; font-family:monospace;">${JSON.stringify(flag.value)}</code></div>` : ''}
                        ${flag.metadata && Object.keys(flag.metadata).length > 0 ? `
                          <div style="margin-top:8px; padding:8px; background:rgba(255,215,0,0.1); border-radius:4px; border-left:2px solid #ffd700;">
                            <div style="font-size:.75rem; color:#ffd700; font-weight:600; margin-bottom:4px;">📋 CONTEXT:</div>
                            ${Object.entries(flag.metadata).map(([key, value]) => {
                              let displayValue = value;
                              if (typeof value === 'number' && value > 1000000000) {
                                displayValue = new Date(value).toLocaleString();
                              }
                              return `<div style="font-size:.8rem; color:#ddd; margin-bottom:2px;">• ${key}: <strong>${displayValue}</strong></div>`;
                            }).join('')}
                          </div>
                        ` : ''}
                        <div style="color:#888; font-size:.75rem; margin-top:8px;">
                          Started: ${flag.setDate || flag.timestamp ? new Date(flag.setDate || flag.timestamp).toLocaleString() : 'Unknown'} 
                          ${flag.expirationDate ? `• Expires: ${new Date(flag.expirationDate).toLocaleString()}` : ''}
                        </div>
                      </div>
                      <button onclick="removeFlagAndRefresh('${employee.id}', '${flag.id || flag.key}')" 
                              style="background:#e94560; border:none; padding:6px 12px; border-radius:6px; color:white; cursor:pointer; font-size:.8rem; font-weight:600; transition:background 0.2s;"
                              onmouseover="this.style.background='#c44'" 
                              onmouseout="this.style.background='#e94560'">
                        Remove
                      </button>
                    </div>
                    ${flag.aiGuidance ? `
                      <div style="margin-top:10px; padding:10px; background:rgba(0,212,255,0.1); border-radius:6px; border-left:3px solid #00d4ff;">
                        <div style="font-size:.75rem; color:#00d4ff; font-weight:600; margin-bottom:4px;">AI GUIDANCE:</div>
                        <div style="font-size:.85rem; color:#ddd; line-height:1.5;">${flag.aiGuidance}</div>
                      </div>
                    ` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          </div>
          
          <!-- Custom Flag Creator -->
          <div style="margin-top:25px; padding:20px; background:#0f1419; border-radius:8px; border:2px solid #533483;">
            <h3 style="margin:0 0 15px 0; color:#c77dff; font-size:1rem;">🔧 Create Custom Flag</h3>
            
            <div style="display:grid; gap:12px;">
              <!-- Basic Info -->
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Emoji</label>
                  <input id="customFlagEmoji" type="text" maxlength="2" placeholder="🏷️" value="🏷️"
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px; font-size:1rem;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Priority</label>
                  <select id="customFlagPriority" 
                          style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                    <option value="low">Low</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High</option>
                    <option value="critical">Critical</option>
                  </select>
                </div>
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Display Name *</label>
                <input id="customFlagDesc" type="text" placeholder="e.g., 'Pregnant by Boss'" required
                       style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Key (no spaces) *</label>
                <input id="customFlagKey" type="text" placeholder="e.g., 'pregnant_by_boss'" required
                       style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Category</label>
                <select id="customFlagCategory" 
                        style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                  <option value="custom">Custom</option>
                  <option value="condition">Condition</option>
                  <option value="agreement">Agreement</option>
                  <option value="relationship">Relationship</option>
                  <option value="personality">Personality</option>
                  <option value="preference">Preference</option>
                  <option value="event">Event</option>
                  <option value="state">State</option>
                </select>
              </div>
              
              <!-- Dates -->
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">
                    Start Date
                    <span style="color:#666; font-size:.75rem;">(defaults to now)</span>
                  </label>
                  <input id="customFlagStartDate" type="datetime-local" 
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">
                    Expiration Date
                    <span style="color:#666; font-size:.75rem;">(optional)</span>
                  </label>
                  <input id="customFlagExpiration" type="datetime-local" 
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                </div>
              </div>
              
              <!-- Context-Specific Metadata -->
              <div id="customFlagMetadataSection" style="display:none; padding:12px; background:rgba(0,212,255,0.05); border-radius:6px; border:1px solid #00d4ff33;">
                <div style="color:#00d4ff; font-size:.85rem; font-weight:600; margin-bottom:8px;">📋 Additional Context</div>
                <div id="customFlagMetadataFields" style="display:grid; gap:8px;"></div>
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">AI Guidance *</label>
                <textarea id="customFlagAIGuidance" placeholder="Instructions for how the AI should interpret and respond to this flag..." required
                          style="width:100%; padding:10px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px; min-height:80px; resize:vertical; font-family:inherit; line-height:1.5;"></textarea>
              </div>
              
              <button id="createCustomFlagBtn" 
                      style="width:100%; padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; font-weight:600; font-size:1rem; cursor:pointer; transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102,126,234,0.5)'"
                      onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                ✨ Create Flag
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close button handler
    document.getElementById('closeFlagModal').onclick = () => {
      modal.remove();
    };
    
    // Click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    
    // Auto-generate key from description
    document.getElementById('customFlagDesc').addEventListener('input', (e) => {
      const keyField = document.getElementById('customFlagKey');
      if (!keyField.value || keyField.dataset.autoGenerated === 'true') {
        keyField.value = e.target.value.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
        keyField.dataset.autoGenerated = 'true';
      }
    });
    
    // Manual key edit disables auto-generation
    document.getElementById('customFlagKey').addEventListener('input', (e) => {
      e.target.dataset.autoGenerated = 'false';
    });
    
    // Show metadata fields based on key pattern
    document.getElementById('customFlagKey').addEventListener('input', (e) => {
      const key = e.target.value.toLowerCase();
      const metadataSection = document.getElementById('customFlagMetadataSection');
      const metadataFields = document.getElementById('customFlagMetadataFields');
      
      let fieldsHTML = '';
      
      if (key.includes('pregnan')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Father/Partner</label>
            <input id="metadata_father" type="text" placeholder="e.g., 'Boss' or employee name" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Due Date (optional)</label>
            <input id="metadata_dueDate" type="datetime-local" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('relation') || key.includes('dating') || key.includes('boyfriend') || key.includes('girlfriend')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Partner Name</label>
            <input id="metadata_partner" type="text" placeholder="Who they're in a relationship with" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('engaged')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Fiancé(e) Name</label>
            <input id="metadata_fiance" type="text" placeholder="Who they're engaged to" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('married')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Spouse Name</label>
            <input id="metadata_spouse" type="text" placeholder="Who they're married to" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Marriage Date (optional)</label>
            <input id="metadata_marriageDate" type="datetime-local" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('chastity') || key.includes('collar') || key.includes('device')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Key Holder (who controls it)</label>
            <input id="metadata_keyHolder" type="text" placeholder="e.g., 'Boss'" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      }
      
      if (fieldsHTML) {
        metadataFields.innerHTML = fieldsHTML;
        metadataSection.style.display = 'block';
      } else {
        metadataSection.style.display = 'none';
      }
    });
    
    // Create custom flag button handler
    document.getElementById('createCustomFlagBtn').onclick = () => {
      const desc = document.getElementById('customFlagDesc').value.trim();
      const key = document.getElementById('customFlagKey').value.trim();
      const emoji = document.getElementById('customFlagEmoji').value.trim() || '🏷️';
      const priority = document.getElementById('customFlagPriority').value;
      const category = document.getElementById('customFlagCategory').value;
      const aiGuidance = document.getElementById('customFlagAIGuidance').value.trim();
      const startDateInput = document.getElementById('customFlagStartDate').value;
      const expirationInput = document.getElementById('customFlagExpiration').value;
      
      if (!desc || !key || !aiGuidance) {
        showNotification('Please fill in all required fields (Name, Key, AI Guidance)', 'error');
        return;
      }
      
      // Collect metadata
      const metadata = {};
      const metadataInputs = document.querySelectorAll('#customFlagMetadataFields input');
      metadataInputs.forEach(input => {
        const fieldName = input.id.replace('metadata_', '');
        if (input.value.trim()) {
          if (input.type === 'datetime-local') {
            metadata[fieldName] = new Date(input.value).getTime();
          } else {
            metadata[fieldName] = input.value.trim();
          }
        }
      });
      
      // Build flag data
      const flagData = {
        key,
        category,
        priority,
        playerDescription: desc,
        aiGuidance,
        emoji,
        source: 'player',
        metadata
      };
      
      // Set dates if provided
      if (startDateInput) {
        flagData.startDate = new Date(startDateInput).getTime();
      }
      
      if (expirationInput) {
        flagData.expirationDate = new Date(expirationInput).getTime();
      }
      
      // Add special metadata based on key
      if (key.includes('pregnan') && !metadata.father) {
        metadata.father = 'unknown';
      }
      
      // Check if flag already exists
      if (hasFlag(employee, key)) {
        showNotification(`${employee.name} already has a flag with key "${key}"!`, 'error');
        return;
      }
      
      // Add the flag
      addFlag(employee, flagData);
      
      showNotification(`${emoji} Created "${desc}" flag for ${employee.name}!`);
      
      // Refresh modal
      modal.remove();
      setTimeout(() => openFlagManagementModal(employee), 100);
      
      // Refresh unified profile if open
      if (typeof window.refreshUnifiedProfileTab === 'function') {
        window.refreshUnifiedProfileTab(employee.id);
      }
    };
  }
  
  /**
   * Get color for flag priority
   * @param {string} priority - 'high', 'medium', or 'low'
   * @returns {string} Hex color code
   */
  function getPriorityColor(priority) {
    const colors = {
      'critical': '#e94560',  // Bright red for critical
      'high': '#ff3366',      // Red-pink for high
      'medium': '#ffa500',    // Orange for medium
      'low': '#4ecca3'        // Green for low
    };
    return colors[priority] || '#888'; // Gray fallback
  }
  
  /**
   * Add a quick flag from the UI
   */
  /**
   * Load a flag template into the custom flag creator form
   */
  function loadFlagTemplate(employeeId, key, desc, category, priority, emoji, aiGuidance) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Decode HTML entities from the aiGuidance string
    const decodedGuidance = aiGuidance.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    
    // Check if flag already exists
    if (hasFlag(employee, key)) {
      if (!confirm(`${employee.name} already has the "${desc}" flag. Do you want to edit it in the form anyway?`)) {
        return;
      }
    }
    
    // Populate the custom flag form
    document.getElementById('customFlagEmoji').value = emoji;
    document.getElementById('customFlagPriority').value = priority;
    document.getElementById('customFlagDesc').value = desc;
    document.getElementById('customFlagKey').value = key;
    document.getElementById('customFlagKey').dataset.autoGenerated = 'false'; // Prevent auto-generation
    document.getElementById('customFlagCategory').value = category;
    document.getElementById('customFlagAIGuidance').value = decodedGuidance;
    
    // Set start date to current game time
    const currentGameTime = gameState.time?.currentTime || Date.now();
    const startDateInput = document.getElementById('customFlagStartDate');
    const dateForInput = new Date(currentGameTime);
    startDateInput.value = dateForInput.toISOString().slice(0, 16);
    
    // Clear expiration date (user can set if needed)
    document.getElementById('customFlagExpiration').value = '';
    
    // Trigger metadata field generation based on key
    const event = new Event('input', { bubbles: true });
    document.getElementById('customFlagKey').dispatchEvent(event);
    
    // Auto-populate metadata fields based on template
    setTimeout(() => {
      if (key === 'pregnant') {
        const fatherInput = document.getElementById('metadata_father');
        if (fatherInput) fatherInput.value = 'Boss';
      } else if (key === 'married') {
        const spouseInput = document.getElementById('metadata_spouse');
        if (spouseInput) spouseInput.value = '';
      } else if (key === 'chastity') {
        const keyHolderInput = document.getElementById('metadata_keyHolder');
        if (keyHolderInput) keyHolderInput.value = 'Boss';
      }
    }, 50);
    
    // Scroll to the custom flag creator section
    const customFlagSection = document.querySelector('#flagManagementModal [style*="border:2px solid #533483"]');
    if (customFlagSection) {
      customFlagSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      // Add a highlight animation
      customFlagSection.style.animation = 'pulse-highlight 1.5s ease-out';
    }
    
    showNotification(`📋 Template loaded: "${desc}" - Review and customize, then click Create Flag`);
  }
  
  // Add CSS for highlight animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes pulse-highlight {
      0%, 100% { box-shadow: 0 0 0 0 rgba(199, 125, 255, 0); }
      50% { box-shadow: 0 0 0 8px rgba(199, 125, 255, 0.4); }
    }
  `;
  document.head.appendChild(style);
  
  /**
   * Remove a flag and refresh the modal
   */
  function removeFlagAndRefresh(employeeId, flagId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    const flag = [...employee.flags.systemFlags, ...employee.flags.customFlags].find(f => f.id === flagId);
    if (!flag) return;
    
    if (confirm(`Remove flag "${flag.playerDescription || flag.key}" from ${employee.name}?`)) {
      removeFlag(employee, flagId);
      showNotification(`Removed flag from ${employee.name}`);
      
      // Refresh the flag management modal
      const modal = document.getElementById('flagManagementModal');
      if (modal) {
        modal.remove();
        setTimeout(() => openFlagManagementModal(employee), 100);
      }
      
      // Refresh unified profile if open
      if (typeof window.refreshUnifiedProfileTab === 'function') {
        window.refreshUnifiedProfileTab(employeeId);
      }
      
      // Update People tab if visible
      updatePeopleTab();
    }
  }

  // ========== SKILLS SYSTEM (Phase 3) ==========
  
  /**
   * Gain XP for a skill
   * @param {Object} employee - The employee object
   * @param {string} skillName - Name of the skill (technical, creative, social, etc.)
   * @param {number} xpGain - Amount of XP to gain
   * @param {string} source - What action caused the XP gain (for logging)
   */
  function gainSkillXP(employee, skillName, xpGain, source = 'unknown') {
    if (!employee.skills || !employee.skills[skillName]) {
      console.warn(`Skill ${skillName} not found for ${employee.name}`);
      return;
    }
    
    const skill = employee.skills[skillName];
    const oldLevel = skill.level;
    
    // Add XP
    skill.xp += xpGain;
    
    // Check for level up
    while (skill.xp >= skill.maxXp && skill.level < 10) {
      skill.xp -= skill.maxXp;
      skill.level++;
      
      // Increase max XP required for next level (exponential scaling)
      skill.maxXp = Math.floor(skill.maxXp * 1.5);
      
      // Level up notification
      showNotification(`${employee.name} leveled up ${skillName} skill to level ${skill.level}! 🎉`);
      
      // Check for specialization unlocks
      checkSpecializationUnlocks(employee, skillName, skill.level);
      
      console.log(`[Skills] ${employee.name} leveled up ${skillName}: ${oldLevel} → ${skill.level} (source: ${source})`);
    }
    
    // Cap at level 10
    if (skill.level >= 10) {
      skill.level = 10;
      skill.xp = 0;
    }
    
    saveGame();
  }
  
  /**
   * Check if employee unlocks specializations at certain skill levels
   */
  function checkSpecializationUnlocks(employee, skillName, level) {
    if (!employee.specializations) employee.specializations = [];
    
    const specializations = {
      technical: {
        3: 'Code Wizard',
        5: 'System Architect',
        7: 'Tech Lead',
        10: 'Engineering Master'
      },
      creative: {
        3: 'Creative Thinker',
        5: 'Design Expert',
        7: 'Art Director',
        10: 'Creative Genius'
      },
      social: {
        3: 'People Person',
        5: 'Charisma Expert',
        7: 'Influencer',
        10: 'Master Communicator'
      },
      management: {
        3: 'Team Coordinator',
        5: 'Project Manager',
        7: 'Department Head',
        10: 'Strategic Leader'
      },
      intimate: {
        3: 'Experienced Lover',
        5: 'Passionate Partner',
        7: 'Intimate Expert',
        10: 'Master of Seduction'
      }
    };
    
    if (specializations[skillName] && specializations[skillName][level]) {
      const newSpec = specializations[skillName][level];
      if (!employee.specializations.includes(newSpec)) {
        employee.specializations.push(newSpec);
        showNotification(`${employee.name} earned: ${newSpec}! ⭐`);
      }
    }
  }
  
  /**
   * Get XP gain from an action
   */
  function getSkillXPFromAction(action) {
    const xpTable = {
      // Work actions
      'work_hour': 5,
      'complete_task': 15,
      'solve_problem': 25,
      'innovation': 50,
      
      // Social actions
      'chat_message': 2,
      'deep_conversation': 10,
      'successful_negotiation': 30,
      'network_event': 20,
      
      // Creative actions
      'create_content': 15,
      'brainstorm': 10,
      'present_idea': 25,
      'campaign_launch': 50,
      
      // Management actions
      'delegate_task': 10,
      'resolve_conflict': 30,
      'strategic_decision': 40,
      'team_success': 50,
      
      // Intimate actions
      'flirt': 5,
      'kiss': 10,
      'intimate_moment': 20,
      'deep_connection': 30
    };
    
    return xpTable[action] || 0;
  }
  
  /**
   * Apply skill bonuses to stats
   */
  function getSkillBonus(employee, skillName) {
    if (!employee.skills || !employee.skills[skillName]) return 0;
    
    const level = employee.skills[skillName].level;
    return level * 5; // +5% per level
  }
  
  /**
   * Get employee's highest skill
   */
  function getHighestSkill(employee) {
    if (!employee.skills) return null;
    
    let highest = { name: 'none', level: 0 };
    for (const [name, skill] of Object.entries(employee.skills)) {
      if (skill.level > highest.level) {
        highest = { name, level: skill.level };
      }
    }
    
    return highest;
  }
  
  /**
   * Trigger skill XP gains from chat interactions
   */
  function processSkillGainsFromChat(employee, playerMessage, aiResponse) {
    const messageLower = playerMessage.toLowerCase();
    const responseLower = aiResponse.toLowerCase();
    
    // Social skill from chat
    gainSkillXP(employee, 'social', 2, 'chat_message');
    
    // Deep conversation detection
    if (messageLower.length > 100 || responseLower.length > 150) {
      gainSkillXP(employee, 'social', 5, 'deep_conversation');
    }
    
    // Flirting detection
    const flirtWords = ['beautiful', 'gorgeous', 'sexy', 'attractive', 'hot', 'cute', 'stunning'];
    const hasFlirt = flirtWords.some(word => messageLower.includes(word) || responseLower.includes(word));
    if (hasFlirt && employee.stats.affection > 40) {
      gainSkillXP(employee, 'intimate', 5, 'flirt');
    }
    
    // Work talk detection
    const workWords = ['project', 'task', 'deadline', 'client', 'meeting', 'report'];
    const hasWorkTalk = workWords.some(word => messageLower.includes(word) || responseLower.includes(word));
    if (hasWorkTalk) {
      const highestSkill = getHighestSkill(employee);
      if (highestSkill.name !== 'none' && highestSkill.name !== 'intimate') {
        gainSkillXP(employee, highestSkill.name, 3, 'work_discussion');
      }
    }
  }

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  // ========== PHYSICAL APPEARANCE SYSTEM ==========
  
  /**
   * Generate detailed, unique physical appearance for an employee
   * This creates a consistent description used across ALL image generation
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function generateDetailedPhysicalAppearance(gender = 'female') {
    // Height & Build
    const heights = ['petite', 'short', 'average height', 'tall', 'very tall'];
    
    // Gender-specific builds
    let builds;
    if (gender === 'male' || gender === 'transMan') {
      builds = ['lean', 'slim', 'athletic', 'average', 'stocky', 'broad-shouldered', 'muscular', 'toned', 'sturdy', 'wiry'];
    } else {
      builds = ['slender', 'slim', 'athletic', 'average', 'curvy', 'voluptuous', 'muscular', 'toned'];
    }
    
    // Hair - detailed
    const hairColors = [
      'platinum blonde', 'golden blonde', 'honey blonde', 'ash blonde', 'strawberry blonde',
      'light brown', 'chestnut brown', 'dark brown', 'chocolate brown',
      'auburn', 'copper red', 'ginger', 'burgundy',
      'jet black', 'raven black', 'dark black with blue sheen',
      'silver-gray', 'salt and pepper'
    ];
    const hairStyles = [
      'straight', 'wavy', 'curly', 'tight curls', 'beach waves', 'loose curls',
      'pin-straight', 'naturally wavy', 'tousled', 'messy waves'
    ];
    const hairLengths = [
      'pixie cut', 'short bob', 'chin-length bob', 'shoulder-length', 
      'mid-back length', 'waist-length', 'very long'
    ];
    const hairTextures = ['fine', 'thick', 'medium', 'voluminous', 'silky'];
    
    // Eyes - very detailed
    const eyeColors = [
      'bright blue', 'deep blue', 'ocean blue', 'ice blue', 'steel blue',
      'emerald green', 'jade green', 'hazel green', 'olive green',
      'dark brown', 'amber brown', 'honey brown', 'chocolate brown',
      'hazel with green flecks', 'hazel with gold flecks',
      'gray', 'stormy gray', 'gray-blue',
      'unusual violet', 'heterochromic (one blue, one brown)'
    ];
    const eyeShapes = [
      'almond-shaped', 'round', 'hooded', 'upturned', 'downturned',
      'doe eyes', 'cat eyes', 'deep-set', 'wide-set', 'close-set'
    ];
    
    // Facial Features
    const faceShapes = ['oval', 'round', 'heart-shaped', 'square', 'diamond', 'long'];
    const noseTypes = [
      'button nose', 'straight nose', 'slightly upturned nose', 'roman nose',
      'ski-slope nose', 'aquiline nose', 'petite nose', 'prominent nose'
    ];
    const lipShapes = [
      'full lips', 'thin lips', 'heart-shaped lips', 'bow-shaped lips',
      'plump lips', 'pouty lips', 'balanced lips', 'wide lips'
    ];
    const cheekbones = [
      'high cheekbones', 'prominent cheekbones', 'soft cheekbones',
      'defined cheekbones', 'subtle cheekbones', 'angular cheekbones'
    ];
    const jawlines = [
      'soft jawline', 'defined jawline', 'strong jawline', 'delicate jawline',
      'angular jawline', 'rounded jawline', 'sharp jawline'
    ];
    
    // Skin
    const skinTones = [
      'porcelain', 'fair', 'light', 'light-medium', 'beige', 'olive',
      'tan', 'medium', 'golden brown', 'caramel', 'bronze',
      'deep brown', 'dark brown', 'ebony', 'rich mahogany'
    ];
    const skinTextures = [
      'smooth', 'flawless', 'clear', 'glowing', 'radiant',
      'matte', 'dewy', 'sun-kissed', 'naturally luminous'
    ];
    
    // Body Features - Gender-specific
    let bodyShapes, chestDescriptor, chestSizes, buttSizes;
    
    if (gender === 'male') {
      // Male body descriptions
      bodyShapes = ['athletic', 'lean', 'muscular', 'stocky', 'broad-shouldered', 'rectangular', 'V-shaped', 'swimmer\'s build'];
      chestDescriptor = 'chest'; // Male chest descriptor
      chestSizes = ['flat', 'toned', 'well-defined', 'muscular', 'broad', 'barrel-chested'];
      buttSizes = ['flat', 'toned', 'athletic', 'round', 'muscular'];
    } else if (gender === 'transMan') {
      // Trans man body descriptions (may have mixed characteristics)
      bodyShapes = ['athletic', 'lean', 'rectangular', 'androgynous', 'toned', 'muscular'];
      chestDescriptor = 'chest';
      chestSizes = ['flat', 'compact', 'athletic', 'toned', 'bound', 'masculine'];
      buttSizes = ['compact', 'toned', 'athletic', 'round', 'firm'];
    } else if (gender === 'femaleFuta') {
      // Female futa body descriptions (feminine with additional attributes)
      bodyShapes = ['hourglass', 'athletic', 'curvy', 'statuesque', 'amazonian', 'voluptuous', 'toned'];
      chestDescriptor = 'bust';
      chestSizes = ['medium', 'full', 'large', 'very full', 'impressive', 'ample'];
      buttSizes = ['round', 'full', 'curvy', 'prominent', 'shapely'];
    } else {
      // Female and trans woman body descriptions
      bodyShapes = ['hourglass', 'pear-shaped', 'athletic', 'rectangular', 'inverted triangle', 'petite hourglass', 'curvy', 'willowy', 'statuesque'];
      chestDescriptor = 'bust';
      chestSizes = ['small', 'modest', 'medium', 'full', 'large', 'very full'];
      buttSizes = ['small', 'modest', 'round', 'full', 'curvy', 'prominent'];
    }
    
    const legTypes = [
      'long legs', 'proportionate legs', 'toned legs', 'athletic legs',
      'shapely legs', 'slender legs', 'muscular legs'
    ];
    
    // Fashion Style
    const fashionStyles = [
      'business professional', 'smart casual', 'trendy', 'classic elegant',
      'minimalist chic', 'bohemian', 'edgy modern', 'preppy',
      'casual comfortable', 'sophisticated', 'artsy', 'sporty chic'
    ];
    const accessories = [
      'often wears glasses', 'statement earrings', 'delicate jewelry',
      'minimalist accessories', 'watches', 'scarves', 'no accessories'
    ];
    
    // Distinguishing Features
    const features = [
      'dimples when smiling', 'freckles across nose', 'beauty mark', 'gap-toothed smile',
      'striking eyes', 'expressive face', 'mysterious aura', 'warm smile',
      'confident posture', 'graceful movements', 'energetic presence', 'calm demeanor'
    ];
    
    // Random selection helper
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    
    // Genital Information - Gender-specific
    let genitalType, genitalSize, genitalCharacteristics;
    
    if (gender === 'male') {
      genitalType = 'penis';
      genitalSize = pick(['small', 'average', 'above average', 'large', 'very large']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'trimmed']);
    } else if (gender === 'transMan') {
      genitalType = pick(['enlarged clitoris', 'post-op penis', 'pre-op anatomy']);
      genitalSize = genitalType === 'post-op penis' ? pick(['average', 'above average', 'large']) : pick(['small', 'moderate', 'prominent']);
      genitalCharacteristics = pick(['well-groomed', 'natural', 'trimmed', 'maintained']);
    } else if (gender === 'femaleFuta') {
      genitalType = 'penis and vagina';
      genitalSize = pick(['average', 'above average', 'large', 'very large', 'impressive']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'dual anatomy']);
    } else if (gender === 'transWoman') {
      genitalType = pick(['vagina (post-op)', 'penis (pre-op)', 'tucked']);
      genitalSize = genitalType.includes('penis') ? pick(['small', 'average', 'above average']) : pick(['tight', 'normal', 'accommodating']);
      genitalCharacteristics = pick(['well-groomed', 'laser-treated', 'smooth', 'maintained', 'natural']);
    } else {
      // Female
      genitalType = 'vagina';
      genitalSize = pick(['tight', 'normal', 'accommodating', 'petite', 'average']);
      genitalCharacteristics = pick(['well-groomed', 'waxed', 'trimmed', 'natural', 'shaved', 'landing strip']);
    }
    
    // Build the complete physical profile
    const height = pick(heights);
    const build = pick(builds);
    const hairColor = pick(hairColors);
    const hairStyle = pick(hairStyles);
    const hairLength = pick(hairLengths);
    const hairTexture = pick(hairTextures);
    const eyeColor = pick(eyeColors);
    const eyeShape = pick(eyeShapes);
    const faceShape = pick(faceShapes);
    const noseType = pick(noseTypes);
    const lipShape = pick(lipShapes);
    const cheekbone = pick(cheekbones);
    const jawline = pick(jawlines);
    const skinTone = pick(skinTones);
    const skinTexture = pick(skinTextures);
    const bodyShape = pick(bodyShapes);
    const chestSize = pick(chestSizes);
    const buttSize = pick(buttSizes);
    const legType = pick(legTypes);
    const fashionStyle = pick(fashionStyles);
    const accessory = pick(accessories);
    const feature = pick(features);
    
    // Gender-appropriate pronouns and descriptors
    const genderPronoun = (gender === 'male' || gender === 'transMan') ? 'man' : 'woman';
    const bodyDescriptor = `${bodyShape} physique with ${chestDescriptor === 'chest' ? chestSize + ' chest' : chestSize + ' ' + chestDescriptor}, ${buttSize} bottom, ${legType}`;
    
    return {
      // Basic
      height,
      build,
      gender,
      heightBuild: `${height}, ${build} build`,
      
      // Hair (detailed)
      hair: {
        color: hairColor,
        style: hairStyle,
        length: hairLength,
        texture: hairTexture,
        full: `${hairLength} ${hairTexture} ${hairColor} hair, ${hairStyle}`
      },
      
      // Eyes (detailed)
      eyes: {
        color: eyeColor,
        shape: eyeShape,
        full: `${eyeShape} ${eyeColor} eyes`
      },
      
      // Face (detailed)
      face: {
        shape: faceShape,
        nose: noseType,
        lips: lipShape,
        cheekbones: cheekbone,
        jawline: jawline,
        full: `${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}`
      },
      
      // Skin (detailed)
      skin: {
        tone: skinTone,
        texture: skinTexture,
        full: `${skinTexture} ${skinTone} skin`
      },
      
      // Body (detailed) - Gender-appropriate
      body: {
        shape: bodyShape,
        chestDescriptor: chestDescriptor,
        chestSize: chestSize,
        breastSize: chestSize, // Kept for backwards compatibility
        buttSize: buttSize,
        legs: legType,
        full: bodyDescriptor
      },
      
      // Genital Information (detailed) - Gender-specific
      genitals: {
        type: genitalType,
        size: genitalSize,
        characteristics: genitalCharacteristics,
        full: `${genitalSize} ${genitalType}, ${genitalCharacteristics}`
      },
      
      // Style & Features
      fashion: fashionStyle,
      accessories: accessory,
      distinguishingFeature: feature,
      
      // Complete description for AI prompts - Gender-appropriate
      shortDescription: `${height} ${build} ${genderPronoun} with ${hairLength} ${hairColor} hair, ${eyeColor} eyes, ${skinTone} skin`,
      
      fullDescription: `${height} ${build} ${genderPronoun} with ${hairLength} ${hairTexture} ${hairColor} hair (${hairStyle}), ${eyeShape} ${eyeColor} eyes, ${skinTexture} ${skinTone} skin. ${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}. ${bodyDescriptor}. Genitals: ${genitalSize} ${genitalType}, ${genitalCharacteristics}. ${feature}. Style: ${fashionStyle}.`
    };
  }
  
  /**
   * Get consistent physical description for image prompts
   * Returns a prompt-ready string describing the employee's appearance
   */
  function getPhysicalDescriptionForPrompt(employee) {
    if (!employee.physical) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female');
    }
    
    // If old format, upgrade it
    if (!employee.physical.fullDescription) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female');
    }
    
    // Return full description for maximum body context in image generation
    return employee.physical.fullDescription;
  }

  // ========== NUCLEAR CONTEXT INTELLIGENCE SYSTEM ==========
  
  /**
   * PHASE 1: Context Registry - Break down employee into scoreable context pieces
   * This is the foundation of intelligent context selection
   */
  
  function buildContextRegistry(employee) {
    if (!employee) return [];
    
    const pieces = [];
    const now = Date.now();
    
    // CORE IDENTITY (Always high priority - who they are)
    if (employee.name) {
      pieces.push({
        id: 'core.name',
        category: 'core_identity',
        text: `Name: ${employee.name}`,
        priority: 1.0,
        alwaysInclude: true
      });
    }
    
    if (employee.career?.title) {
      pieces.push({
        id: 'core.role',
        category: 'core_identity',
        text: `Role: ${employee.career.title} (Level ${employee.career.level || 1})`,
        priority: 1.0,
        alwaysInclude: true
      });
    }
    
    if (employee.gender) {
      pieces.push({
        id: 'core.gender',
        category: 'core_identity',
        text: `Gender: ${employee.gender}`,
        priority: 0.9,
        alwaysInclude: true
      });
    }
    
    // PERSONALITY (High value - how they act)
    if (employee.personality?.traits) {
      employee.personality.traits.forEach((trait, i) => {
        pieces.push({
          id: `personality.trait.${i}`,
          category: 'personality',
          text: `Personality: ${trait}`,
          priority: 0.8 - (i * 0.05), // First traits more important
          keywords: trait.toLowerCase().split(/\s+/)
        });
      });
    }
    
    // CURRENT STATE (High priority, time-sensitive)
    if (employee.stats?.mood) {
      pieces.push({
        id: 'state.mood',
        category: 'current_state',
        text: `Current mood: ${employee.stats.mood}`,
        priority: 0.85,
        freshness: true,
        lastUpdated: now
      });
    }
    
    if (employee.personalLife?.currentActivity?.description) {
      pieces.push({
        id: 'state.activity',
        category: 'current_state',
        text: `Currently: ${employee.personalLife.currentActivity.description}`,
        priority: 0.9,
        freshness: true,
        lastUpdated: employee.personalLife.currentActivity.startTime || now
      });
    }
    
    if (employee.schedule?.isCurrentlyWorking !== undefined) {
      pieces.push({
        id: 'state.working',
        category: 'current_state',
        text: `Work status: ${employee.schedule.isCurrentlyWorking ? 'Currently working' : 'Off duty'}`,
        priority: 0.7,
        freshness: true
      });
    }
    
    // PHYSICAL APPEARANCE (VERY LOW priority - only when relevant)
    if (employee.physical) {
      if (employee.physical.shortDescription) {
        pieces.push({
          id: 'physical.short',
          category: 'appearance',
          text: `Appearance: ${employee.physical.shortDescription}`,
          priority: 0.05, // Drastically reduced
          avoidRepetition: true // Flag for extra penalty
        });
      }
      
      if (employee.physical.fashion) {
        pieces.push({
          id: 'physical.fashion',
          category: 'appearance',
          text: `Style: ${employee.physical.fashion}`,
          priority: 0.02, // Drastically reduced
          avoidRepetition: true // Flag for extra penalty
        });
      }
    }
    
    // RELATIONSHIPS (LOW priority - only when directly relevant)
    if (employee.relationships) {
      Object.entries(employee.relationships).forEach(([targetId, rel]) => {
        const target = gameState.employees.find(e => e.id === targetId);
        if (target && rel.type) {
          const strength = rel.strength || 0;
          pieces.push({
            id: `relationship.${targetId}`,
            category: 'relationships',
            text: `Relationship with ${target.name}: ${rel.type} (${strength}/100)`,
            relatedTo: targetId,
            priority: 0.05 + (strength / 500), // DRASTICALLY reduced base priority
            keywords: [target.name.toLowerCase(), rel.type],
            avoidRepetition: true // HEAVY anti-repetition penalty
          });
        }
      });
    }
    
    // SKILLS (Work-context priority)
    if (employee.skills && typeof employee.skills === 'object') {
      Object.entries(employee.skills).forEach(([skillName, skillData]) => {
        if (skillData && skillData.level) {
          pieces.push({
            id: `skill.${skillName}`,
            category: 'skills',
            text: `Skill: ${skillName} (Level ${skillData.level})`,
            priority: 0.4,
            keywords: [skillName.toLowerCase()]
          });
        }
      });
    }
    
    // FLAGS/EVENTS (Variable priority based on flag importance)
    if (employee.flags?.systemFlags) {
      employee.flags.systemFlags.forEach((flag, i) => {
        if (flag.playerDescription || flag.key) {
          const isHighPriority = flag.priority === 'high';
          pieces.push({
            id: `flag.${flag.key || i}`,
            category: 'flags',
            text: flag.playerDescription || flag.key,
            priority: isHighPriority ? 0.9 : 0.5,
            freshness: true,
            keywords: (flag.playerDescription || flag.key).toLowerCase().split(/\s+/)
          });
        }
      });
    }
    
    // STATS (Moderate priority)
    if (employee.stats) {
      if (employee.stats.affection !== undefined) {
        pieces.push({
          id: 'stats.affection',
          category: 'stats',
          text: `Affection for you: ${employee.stats.affection}/100`,
          priority: 0.6,
          relatedTo: 'player'
        });
      }
      
      if (employee.stats.productivity !== undefined) {
        pieces.push({
          id: 'stats.productivity',
          category: 'stats',
          text: `Productivity: ${employee.stats.productivity}%`,
          priority: 0.5
        });
      }
    }
    
    // PERSONAL LIFE DETAILS (Low-medium priority)
    if (employee.personalLife?.livingSituation?.hasPet) {
      const pet = employee.personalLife.livingSituation;
      pieces.push({
        id: 'personal.pet',
        category: 'personal_life',
        text: `Has a ${pet.petType} named ${pet.petName}`,
        priority: 0.3,
        keywords: ['pet', pet.petType, pet.petName].map(k => k.toLowerCase())
      });
    }
    
    return pieces.filter(p => p.text); // Remove any with no text
  }
  
  /**
   * Initialize context usage tracking for an employee
   */
  function initializeContextTracking(employee) {
    if (!employee.contextUsage) {
      employee.contextUsage = {
        pieces: {}, // { contextId: { count, lastUsed, totalScore } }
        interactions: [], // Recent interaction history
        performance: {} // Which contexts led to good responses
      };
    }
  }
  
  /**
   * Track context usage after an interaction
   */
  function trackContextUsage(employee, selectedPieces, interactionId, interactionType) {
    initializeContextTracking(employee);
    
    selectedPieces.forEach(piece => {
      if (!employee.contextUsage.pieces[piece.id]) {
        employee.contextUsage.pieces[piece.id] = { 
          count: 0, 
          lastUsed: 0,
          totalScore: 0
        };
      }
      
      const usage = employee.contextUsage.pieces[piece.id];
      usage.count++;
      usage.lastUsed = Date.now();
      usage.totalScore += piece.score || 0;
    });
    
    // Store interaction record
    employee.contextUsage.interactions.push({
      id: interactionId,
      timestamp: Date.now(),
      type: interactionType,
      pieces: selectedPieces.map(p => p.id),
      pieceCount: selectedPieces.length
    });
    
    // Keep only last 100 interactions
    if (employee.contextUsage.interactions.length > 100) {
      employee.contextUsage.interactions = employee.contextUsage.interactions.slice(-100);
    }
  }
  
  /**
   * PHASE 1: Embedding Service (Simple keyword-based for now, upgradeable to real embeddings)
   */
  const NuclearEmbeddingService = {
    /**
     * Get "embedding" for an interaction (currently keyword-based)
     */
    getInteractionEmbedding(interaction) {
      const keywords = this.extractKeywords(interaction);
      return {
        keywords,
        type: interaction.type,
        involves: interaction.involves || []
      };
    },
    
    /**
     * Score how relevant a context piece is to an interaction
     */
    scoreSemanticRelevance(contextPiece, interactionEmbedding) {
      let score = 0;
      
      // Keyword matching
      if (contextPiece.keywords && interactionEmbedding.keywords) {
        const matches = contextPiece.keywords.filter(k => 
          interactionEmbedding.keywords.some(ik => 
            ik.includes(k) || k.includes(ik)
          )
        );
        score += matches.length * 0.2;
      }
      
      // Check if context relates to people involved
      if (contextPiece.relatedTo && interactionEmbedding.involves) {
        if (interactionEmbedding.involves.includes(contextPiece.relatedTo)) {
          score += 0.5;
        }
      }
      
      // Type-based affinity scoring
      const affinities = {
        'chat.casual': {
          personality: 1.0,
          current_state: 0.9,
          relationships: 0.7,
          personal_life: 0.6,
          appearance: 0.2,
          skills: 0.3,
          stats: 0.4
        },
        'chat.work': {
          skills: 1.0,
          core_identity: 0.9,
          current_state: 0.7,
          stats: 0.8,
          personality: 0.5,
          relationships: 0.4,
          appearance: 0.1
        },
        'social.post': {
          personality: 0.9,
          current_state: 0.8,
          relationships: 0.7,
          personal_life: 0.6,
          flags: 0.7,
          appearance: 0.4
        },
        'social.comment': {
          relationships: 0.8,
          personality: 0.7,
          current_state: 0.6,
          core_identity: 0.5
        }
      };
      
      const affinity = affinities[interactionEmbedding.type]?.[contextPiece.category] || 0.5;
      score += affinity * 0.6;
      
      return Math.min(score, 1.0); // Cap at 1.0
    },
    
    /**
     * Extract keywords from interaction
     */
    extractKeywords(interaction) {
      const text = [
        interaction.message,
        interaction.prompt,
        ...(interaction.recentMessages || []).map(m => m.content)
      ].filter(Boolean).join(' ');
      
      return text.toLowerCase()
        .split(/\W+/)
        .filter(w => w.length > 3)
        .filter(w => !this.stopWords.has(w))
        .slice(0, 30);
    },
    
    // Common words to ignore
    stopWords: new Set(['that', 'this', 'with', 'from', 'have', 'been', 'were', 'your', 'them', 'they'])
  };
  
  // Make it globally available
  window.NuclearEmbeddingService = NuclearEmbeddingService;
  
  console.log('🚀 Nuclear Context Intelligence System - Phase 1 Initialized');
  
  /**
   * PHASE 2: INTELLIGENT CONTEXT SELECTION 🚀
   * Multi-dimensional scoring with adaptive selection
   */
  
  /**
   * Select the best context pieces for an interaction using intelligent scoring
   * @param {object} employee - Employee object
   * @param {object} interaction - Interaction details
   * @param {object} options - Selection options
   * @returns {Array} Selected context pieces with scores
   */
  function selectIntelligentContext(employee, interaction, options = {}) {
    const {
      maxTokens = 500,           // Rough token budget
      minPieces = 5,             // Minimum pieces to include
      maxPieces = 20,            // Maximum pieces
      diversityWeight = 0.3,     // How much to value category diversity
      antiRepetitionWeight = 0.4 // How much to penalize recently used pieces
    } = options;
    
    // Build the context registry
    const pieces = buildContextRegistry(employee);
    if (pieces.length === 0) return [];
    
    // Initialize tracking
    initializeContextTracking(employee);
    
    // Get interaction embedding
    const interactionEmbedding = NuclearEmbeddingService.getInteractionEmbedding(interaction);
    
    // Score each piece with multi-dimensional analysis
    const scoredPieces = pieces.map(piece => {
      const scores = {
        base: piece.priority || 0.5,
        semantic: 0,
        temporal: 0,
        novelty: 0,
        coherence: 0
      };
      
      // DIMENSION 1: Semantic Relevance
      scores.semantic = NuclearEmbeddingService.scoreSemanticRelevance(piece, interactionEmbedding);
      
      // DIMENSION 2: Temporal Relevance (freshness bonus)
      if (piece.freshness && piece.lastUpdated) {
        const age = Date.now() - piece.lastUpdated;
        const hoursSinceUpdate = age / (1000 * 60 * 60);
        scores.temporal = Math.max(0, 1 - (hoursSinceUpdate / 24)); // Decay over 24 hours
      } else {
        scores.temporal = 0.3; // Default for non-time-sensitive
      }
      
      // DIMENSION 3: Novelty (anti-repetition)
      const usage = employee.contextUsage.pieces[piece.id];
      if (usage) {
        const timeSinceLastUse = (Date.now() - usage.lastUsed) / (1000 * 60 * 60); // hours
        const usageFrequency = usage.count / Math.max(1, employee.contextUsage.interactions.length);
        
        // Penalize frequently used, recently used pieces
        let noveltyScore = Math.min(1.0, timeSinceLastUse / 48) * (1 - usageFrequency);
        
        // EXTRA HEAVY penalty for appearance pieces (avoid repetition)
        if (piece.avoidRepetition) {
          noveltyScore *= 0.3; // 70% penalty for recently used appearance
          if (timeSinceLastUse < 1) { // Used in last hour
            noveltyScore = 0; // Completely exclude
          }
        }
        
        scores.novelty = noveltyScore;
      } else {
        scores.novelty = 1.0; // Never used = maximum novelty
      }
      
      // DIMENSION 4: Coherence (relationships with other selected pieces)
      // This will be calculated in second pass
      scores.coherence = 0.5; // Default
      
      // Calculate composite score
      const compositeScore = (
        scores.base * 0.25 +
        scores.semantic * 0.35 +
        scores.temporal * 0.15 +
        scores.novelty * antiRepetitionWeight +
        scores.coherence * 0.1
      );
      
      return {
        ...piece,
        scores,
        score: piece.alwaysInclude ? 999 : compositeScore // Force-include marked pieces
      };
    });
    
    // Sort by score
    scoredPieces.sort((a, b) => b.score - a.score);
    
    // ADAPTIVE SELECTION with category balancing
    const selected = [];
    const categoryCount = {};
    let estimatedTokens = 0;
    
    // First pass: Always-include pieces
    scoredPieces.filter(p => p.alwaysInclude).forEach(piece => {
      selected.push(piece);
      categoryCount[piece.category] = (categoryCount[piece.category] || 0) + 1;
      estimatedTokens += estimateTokens(piece.text);
    });
    
    // Second pass: Greedy selection with diversity bonus
    for (const piece of scoredPieces) {
      if (piece.alwaysInclude) continue; // Already added
      if (selected.length >= maxPieces) break;
      if (estimatedTokens >= maxTokens && selected.length >= minPieces) break;
      
      // Apply diversity bonus if category is underrepresented
      const categoryRatio = (categoryCount[piece.category] || 0) / Math.max(1, selected.length);
      const diversityBonus = categoryRatio < 0.3 ? diversityWeight : 0;
      const adjustedScore = piece.score + diversityBonus;
      
      // Calculate coherence with already selected pieces
      let coherenceBonus = 0;
      for (const selectedPiece of selected) {
        // Same category bonus
        if (selectedPiece.category === piece.category) {
          coherenceBonus += 0.05;
        }
        // Relationship bonus
        if (piece.relatedTo && selectedPiece.relatedTo === piece.relatedTo) {
          coherenceBonus += 0.1;
        }
        // Keyword overlap bonus
        if (piece.keywords && selectedPiece.keywords) {
          const overlap = piece.keywords.filter(k => selectedPiece.keywords.includes(k));
          coherenceBonus += overlap.length * 0.03;
        }
      }
      
      const finalScore = adjustedScore + coherenceBonus;
      
      // Accept if score is high enough or we need more pieces
      if (finalScore > 0.3 || selected.length < minPieces) {
        selected.push({ ...piece, score: finalScore });
        categoryCount[piece.category] = (categoryCount[piece.category] || 0) + 1;
        estimatedTokens += estimateTokens(piece.text);
      }
    }
    
    return selected;
  }
  
  /**
   * Estimate tokens in text (rough approximation)
   */
  function estimateTokens(text) {
    if (!text) return 0;
    // Rough: 1 token ~= 4 characters for English
    return Math.ceil(text.length / 4);
  }
  
  /**
   * Format selected context pieces into a prompt string
   * @param {Array} pieces - Selected context pieces
   * @param {object} options - Formatting options
   * @returns {string} Formatted context
   */
  function formatContextForPrompt(pieces, options = {}) {
    const {
      grouped = true,           // Group by category
      includeScores = false,    // Debug mode
      categoryLabels = true     // Show category headers
    } = options;
    
    if (!grouped) {
      // Simple flat list
      return pieces.map(p => {
        const scoreStr = includeScores ? ` [score: ${p.score.toFixed(2)}]` : '';
        return `- ${p.text}${scoreStr}`;
      }).join('\n');
    }
    
    // Grouped by category
    const groups = {};
    pieces.forEach(piece => {
      if (!groups[piece.category]) {
        groups[piece.category] = [];
      }
      groups[piece.category].push(piece);
    });
    
    // Category display order
    const categoryOrder = [
      'core_identity', 'personality', 'current_state', 'relationships',
      'skills', 'stats', 'flags', 'personal_life', 'appearance'
    ];
    
    const lines = [];
    categoryOrder.forEach(category => {
      if (groups[category] && groups[category].length > 0) {
        if (categoryLabels) {
          const label = category.replace(/_/g, ' ').toUpperCase();
          lines.push(`\n${label}:`);
        }
        groups[category].forEach(piece => {
          const scoreStr = includeScores ? ` [${piece.score.toFixed(2)}]` : '';
          lines.push(`- ${piece.text}${scoreStr}`);
        });
      }
    });
    
    return lines.join('\n').trim();
  }
  
  /**
   * MAIN API: Get intelligent context for any interaction
   * @param {object} employee - Employee object
   * @param {string} interactionType - Type: 'chat.casual', 'chat.work', 'social.post', etc
   * @param {object} interactionData - Additional interaction data
   * @returns {string} Formatted context string ready for prompt
   */
  function getIntelligentContext(employee, interactionType, interactionData = {}) {
    if (!employee) return '';
    
    const interaction = {
      type: interactionType,
      ...interactionData
    };
    
    // Token budgets by interaction type
    const budgets = {
      'chat.casual': { maxTokens: 400, maxPieces: 15 },
      'chat.work': { maxTokens: 350, maxPieces: 12 },
      'social.post': { maxTokens: 300, maxPieces: 10 },
      'social.comment': { maxTokens: 250, maxPieces: 8 },
      'profile.description': { maxTokens: 500, maxPieces: 20 }
    };
    
    const budget = budgets[interactionType] || { maxTokens: 400, maxPieces: 15 };
    
    // Select best context
    const selectedPieces = selectIntelligentContext(employee, interaction, budget);
    
    // Track usage
    const interactionId = `${interactionType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    trackContextUsage(employee, selectedPieces, interactionId, interactionType);
    
    // Format for prompt
    return formatContextForPrompt(selectedPieces, { grouped: true });
  }
  
  console.log('🔥 Nuclear Context Intelligence System - Phase 2 IGNITED');
  
  /**
   * PHASE 3: DEBUG & ANALYTICS
   * Visualize what context is being selected and why
   */
  
  /**
   * Get analytics for an employee's context usage
   */
  function getContextAnalytics(employee) {
    if (!employee.contextUsage) return null;
    
    const analytics = {
      totalInteractions: employee.contextUsage.interactions.length,
      piecesUsed: Object.keys(employee.contextUsage.pieces).length,
      mostUsedPieces: [],
      leastUsedPieces: [],
      categoryDistribution: {},
      averagePiecesPerInteraction: 0,
      recentInteractions: employee.contextUsage.interactions.slice(-5)
    };
    
    // Calculate category distribution
    const registry = buildContextRegistry(employee);
    registry.forEach(piece => {
      analytics.categoryDistribution[piece.category] = 
        (analytics.categoryDistribution[piece.category] || 0) + 1;
    });
    
    // Sort pieces by usage
    const sortedPieces = Object.entries(employee.contextUsage.pieces)
      .map(([id, usage]) => {
        const piece = registry.find(p => p.id === id);
        return { id, usage, piece };
      })
      .sort((a, b) => b.usage.count - a.usage.count);
    
    analytics.mostUsedPieces = sortedPieces.slice(0, 5);
    analytics.leastUsedPieces = sortedPieces.slice(-5).reverse();
    
    // Average pieces per interaction
    const totalPieces = employee.contextUsage.interactions.reduce((sum, int) => 
      sum + int.pieceCount, 0);
    analytics.averagePiecesPerInteraction = 
      totalPieces / Math.max(1, employee.contextUsage.interactions.length);
    
    return analytics;
  }
  
  /**
   * Debug function: Show context selection for an interaction
   * Use in console: debugContextSelection(employee, 'chat.casual', {message: 'hello'})
   */
  window.debugContextSelection = function(employee, interactionType, interactionData) {
    console.group(`🚀 Nuclear Context Selection Debug`);
    console.log('Employee:', employee.name);
    console.log('Interaction Type:', interactionType);
    console.log('Interaction Data:', interactionData);
    
    const interaction = { type: interactionType, ...interactionData };
    const selectedPieces = selectIntelligentContext(employee, interaction, { maxTokens: 400, maxPieces: 15 });
    
    console.log('\n📊 Selected Context Pieces:', selectedPieces.length);
    console.table(selectedPieces.map(p => ({
      ID: p.id,
      Category: p.category,
      Score: p.score.toFixed(3),
      Priority: p.priority,
      Text: p.text.substring(0, 60) + '...'
    })));
    
    console.log('\n📈 Score Breakdown:');
    selectedPieces.slice(0, 5).forEach(p => {
      console.log(`\n${p.id}:`);
      console.log('  Base:', p.scores.base.toFixed(3));
      console.log('  Semantic:', p.scores.semantic.toFixed(3));
      console.log('  Temporal:', p.scores.temporal.toFixed(3));
      console.log('  Novelty:', p.scores.novelty.toFixed(3));
      console.log('  Coherence:', p.scores.coherence.toFixed(3));
      console.log('  → FINAL:', p.score.toFixed(3));
    });
    
    console.log('\n📝 Formatted Context:');
    console.log(formatContextForPrompt(selectedPieces, { grouped: true }));
    
    console.groupEnd();
    
    return selectedPieces;
  };
  
  /**
   * Debug function: Show context analytics for an employee
   * Use in console: showContextAnalytics(gameState.employees[0])
   */
  window.showContextAnalytics = function(employee) {
    const analytics = getContextAnalytics(employee);
    if (!analytics) {
      console.log('No context usage data for', employee.name);
      return;
    }
    
    console.group(`📊 Context Analytics: ${employee.name}`);
    console.log('Total Interactions:', analytics.totalInteractions);
    console.log('Unique Pieces Used:', analytics.piecesUsed);
    console.log('Avg Pieces/Interaction:', analytics.averagePiecesPerInteraction.toFixed(1));
    
    console.log('\n📈 Category Distribution:');
    console.table(analytics.categoryDistribution);
    
    console.log('\n🔥 Most Used Context:');
    console.table(analytics.mostUsedPieces.map(p => ({
      ID: p.id,
      Count: p.usage.count,
      Text: p.piece?.text.substring(0, 50) || 'N/A'
    })));
    
    console.log('\n❄️ Least Used Context:');
    console.table(analytics.leastUsedPieces.map(p => ({
      ID: p.id,
      Count: p.usage.count,
      Text: p.piece?.text.substring(0, 50) || 'N/A'
    })));
    
    console.log('\n⏱️ Recent Interactions:');
    analytics.recentInteractions.forEach(int => {
      const timeAgo = Math.round((Date.now() - int.timestamp) / 60000);
      console.log(`${int.type} - ${timeAgo}m ago - ${int.pieceCount} pieces`);
    });
    
    console.groupEnd();
  };
  
  console.log('🔬 Nuclear Context Debug Tools Loaded!');
  console.log('  → debugContextSelection(employee, type, data)');
  console.log('  → showContextAnalytics(employee)');

  // ========== GIFT SYSTEM ==========
  
  /**
   * Calculate gift price scaling based on current lifetime income
   * @returns {object} Price scale info with min, max, and sweet spot
   */
  function calculateGiftPriceScale() {
    const currentLifetimeIncome = gameState.currentLifetimeIncome || 0;
    
    // Scale based on current lifetime earnings  
    // Early: $1K-$1M lifetime = $10-$1K gifts recommended
    // Mid: $1M-$100M lifetime = $100-$100K gifts recommended
    // Late: $100M-$10B lifetime = $1K-$10M gifts recommended
    // End: $10B+ lifetime = $100K-$1B+ gifts recommended
    
    const logIncome = Math.log10(Math.max(1000, currentLifetimeIncome));
    const scale = logIncome - 3; // 0 at $1K, increases logarithmically
    
    return {
      tier: Math.floor(scale),
      minRecommended: Math.pow(10, 1 + scale * 0.8),
      maxRecommended: Math.pow(10, 4 + scale * 0.8),
      sweetSpot: Math.pow(10, 2.5 + scale * 0.8)
    };
  }
  
  /**
   * Map potentially invalid category to valid GIFT_CATEGORIES key
   * @param {string} categoryString - Category string from AI
   * @returns {string} Valid category key
   */
  function mapToValidCategory(categoryString) {
    const lower = categoryString.toLowerCase();
    
    if (lower.includes('roman') || lower.includes('love')) return 'ROMANTIC';
    if (lower.includes('lux') || lower.includes('expensive')) return 'LUXURY';
    if (lower.includes('trip') || lower.includes('travel') || lower.includes('exper')) return 'EXPERIENCES';
    if (lower.includes('tech') || lower.includes('electron') || lower.includes('gadget')) return 'TECH';
    if (lower.includes('book') || lower.includes('art') || lower.includes('intel')) return 'INTELLECTUAL';
    if (lower.includes('food') || lower.includes('wine') || lower.includes('drink')) return 'FOOD';
    if (lower.includes('practical') || lower.includes('useful') || lower.includes('tool')) return 'PRACTICAL';
    if (lower.includes('quirk') || lower.includes('unusual')) return 'QUIRKY';
    if (lower.includes('fit') || lower.includes('health') || lower.includes('wellness')) return 'WELLNESS';
    if (lower.includes('fashion') || lower.includes('cloth') || lower.includes('beauty')) return 'FASHION';
    if (lower.includes('unique') || lower.includes('one') || lower.includes('rare')) return 'UNIQUE';
    
    // Default fallback
    return 'QUIRKY';
  }
  
  /**
   * Generate a custom gift using AI based on user description
   * @param {string} userDescription - What the player wants to create
   * @param {number} maxBudget - Optional budget limit
   * @param {object} controller - Cancellation controller {cancelled: boolean}
   * @returns {Promise<object>} Generated gift object
   */
  async function generateCustomGift(userDescription, maxBudget = Infinity, controller = null) {
    // Genie refusal list - things too gross/harmful to create
    const GENIE_REFUSALS = [
      { 
        keywords: ['shit', 'feces', 'poop', 'excrement', 'fecal', 'dung', 'crap'], 
        responses: [
          "🤢 Ew, absolutely not. I create GIFTS, not... that. Try asking for something people would actually want to receive!",
          "🤢 Are you serious? No. I'm a magical gift genie, not a porta-potty. Ask for something that doesn't belong in a toilet.",
          "🤢 Gross! Hard pass. I make THOUGHTFUL presents, not biohazards. Try again with something that isn't disgusting.",
          "🤢 Yeah, no. That's not happening. I have standards, and they don't include literal waste. Next idea, please!",
          "🤢 Absolutely NOT. Why would you even... you know what, I don't want to know. Ask for a real gift."
        ]
      },
      { 
        keywords: ['vomit', 'puke', 'barf', 'vomitus'], 
        responses: [
          "🤮 That's disgusting. I'm not creating biohazards. Ask for something that won't make people sick.",
          "🤮 Uh, no thanks. I deal in GIFTS, not bodily fluids. Try something that doesn't come from someone's stomach.",
          "🤮 Hard no. That's revolting. Pick literally anything else that people would want to receive.",
          "🤮 Are you trying to make me gag? Not happening. Ask for something that belongs in a gift box, not a sick bag."
        ]
      },
      { 
        keywords: ['urine', 'piss', 'pee'], 
        responses: [
          "😒 No. Just... no. Why would anyone want that? Try something that isn't a bodily fluid.",
          "😒 I'm not even dignifying that with a full response. No. Ask for something that isn't liquid waste.",
          "😒 You're joking, right? That's a hard no. Try asking for something that people actually want.",
          "😒 Absolutely not. I create thoughtful gifts, not... whatever that is. Pick something else."
        ]
      },
      { 
        keywords: ['dead body', 'corpse', 'cadaver', 'roadkill'], 
        responses: [
          "💀 That's disturbing AND illegal. I don't do morbid stuff. Ask for something appropriate.",
          "💀 What is WRONG with you? No. That's creepy and illegal. Try something that's, you know... alive? Or at least not dead?",
          "💀 Uh, that's a felony waiting to happen. Hard pass. Ask for something that won't get anyone arrested.",
          "💀 Yeah, I'm not touching that with a 10-foot pole. Way too dark. Try something that doesn't involve death.",
          "💀 I think I know where I can get the body from... Get out of here with that request."
        ]
      },
      { 
        keywords: ['garbage', 'trash can', 'rubbish', 'waste bin', 'literal trash'], 
        responses: [
          "🗑️ I make thoughtful gifts, not insults. If you want to give someone trash, just... don't give them anything.",
          "🗑️ Really? Garbage? That's not a gift, that's an insult. Try something that shows you actually care.",
          "🗑️ No way. I create meaningful presents, not things that belong in a landfill. Ask for something with value.",
          "🗑️ Hard no. Why would you gift someone actual trash? Try something people would appreciate."
        ]
      },
      { 
        keywords: ['heroin', 'meth', 'cocaine', 'crack', 'fentanyl', 'opioid'], 
        responses: [
          "💊 Hard drugs? No way. I'm not helping anyone with that. Stick to legal, non-harmful gifts.",
          "💊 Absolutely not. That's dangerous and illegal. I only create gifts that won't destroy lives.",
          "💊 Yeah, that's a HUGE no. I don't do hard drugs. Try something that won't kill someone.",
          "💊 Not happening. I create gifts that bring joy, not addiction. Ask for something legal and safe."
        ]
      },
      { 
        keywords: ['slave', 'human trafficking', 'kidnapped'], 
        responses: [
          "⛓️ Absolutely NOT. That's horrifying and illegal. I only create ethical gifts.",
          "⛓️ WHAT?! No. That's beyond disturbing. I'm not even going to entertain that thought. Ask for something that isn't a crime against humanity.",
          "⛓️ That's horrific. Hard no. I create gifts, not human rights violations. Try something ethical.",
          "⛓️ Are you out of your mind? No. That's evil and illegal. Ask for something that doesn't involve kidnapping."
        ]
      },
      { 
        keywords: ['explosive', 'bomb', 'grenade', 'c4', 'dynamite'], 
        responses: [
          "💣 I don't create explosives or dangerous weapons. Try something that won't blow up.",
          "💣 Yeah, no. I'm not making anything that explodes. That's way too dangerous. Pick something safer.",
          "💣 Hard pass on anything that goes boom. I create GIFTS, not terrorist supplies. Try again.",
          "💣 Absolutely not. That's insanely dangerous. Ask for something that won't land you on a watchlist."
        ]
      }
    ];
    
    // Check for refusals
    const lowerDesc = userDescription.toLowerCase();
    for (const refusal of GENIE_REFUSALS) {
      if (refusal.keywords.some(kw => lowerDesc.includes(kw))) {
        // Pick a random response from the array
        const randomResponse = refusal.responses[Math.floor(Math.random() * refusal.responses.length)];
        showNotification(randomResponse, 'warning');
        throw new Error('Genie refused this request');
      }
    }
    
    // Check if request is obviously WAY beyond budget (if budget is set)
    if (maxBudget !== Infinity) {
      const expensiveKeywords = [
        { keywords: ['continent', 'country', 'nation', 'planet', 'moon', 'earth', 'world'], minCost: 999999999999, item: 'geographical entities' },
        { keywords: ['google', 'apple', 'microsoft', 'amazon', 'facebook', 'meta', 'tesla'], minCost: 500000000000, item: 'tech companies' },
        { keywords: ['twitter', 'netflix', 'spotify', 'uber'], minCost: 10000000000, item: 'major companies' },
        { keywords: ['skyscraper', 'empire state', 'burj khalifa', 'stadium'], minCost: 1000000000, item: 'iconic buildings' },
        { keywords: ['cruise ship', 'aircraft carrier', 'space station'], minCost: 1000000000, item: 'massive vehicles' }
      ];
      
      for (const expensive of expensiveKeywords) {
        if (expensive.keywords.some(kw => lowerDesc.includes(kw)) && maxBudget < expensive.minCost) {
          const responses = [
            `🧞‍♂️ Uh... you want ${expensive.item} with a $${maxBudget.toLocaleString()} budget? That's not even close. Come back when you're serious.`,
            `🧞‍♂️ Yeah, no. ${expensive.item.charAt(0).toUpperCase() + expensive.item.slice(1)} cost WAY more than $${maxBudget.toLocaleString()}. Remove your budget limit if you want me to make this.`,
            `🧞‍♂️ Your budget is $${maxBudget.toLocaleString()} and you're asking for ${expensive.item}? That's like trying to buy a mansion with lunch money. Not happening.`,
            `🧞‍♂️ LOL. ${expensive.item.charAt(0).toUpperCase() + expensive.item.slice(1)} are WAY out of your $${maxBudget.toLocaleString()} budget. Either remove the limit or ask for something realistic.`
          ];
          const randomResponse = responses[Math.floor(Math.random() * responses.length)];
          showNotification(randomResponse, 'warning');
          throw new Error('Genie refused this request');
        }
      }
    }
    
    const priceScale = calculateGiftPriceScale();
    
    const categoryList = Object.entries(GIFT_CATEGORIES)
      .map(([key, val]) => `${key} (${val.examples})`)
      .join('\n');
    
    const prompt = `You are a gift creation AI. Generate a specific, tangible gift based on this description.

PLAYER REQUEST: "${userDescription}"

COMPANY SCALE (FOR REFERENCE ONLY - DO NOT LET THIS DICTATE PRICE):
- Current lifetime income: $${(gameState.currentLifetimeIncome || 0).toLocaleString()}
- Recommended gift range: $${Math.round(priceScale.minRecommended).toLocaleString()} - $${Math.round(priceScale.maxRecommended).toLocaleString()}
- Budget limit: ${maxBudget === Infinity ? 'No limit' : '$' + maxBudget.toLocaleString()}

⚠️ CRITICAL PRICING RULES ⚠️
**Price MUST reflect REAL-WORLD market value, NOT player wealth!**

REAL-WORLD PRICING EXAMPLES:
- Coffee mug: $15-50
- Nice watch: $500-5,000
- Luxury watch (Rolex): $10,000-100,000
- Designer handbag: $2,000-15,000
- Sports car: $100,000-500,000
- Supercar (Ferrari, Lamborghini): $500,000-3,000,000
- Luxury yacht: $5,000,000-50,000,000
- Private jet: $10,000,000-100,000,000
- Small island: $50,000,000-500,000,000
- Famous painting (Van Gogh, etc): $50,000,000-500,000,000
- Iconic building (Empire State): $2,000,000,000-5,000,000,000
- Major sports team (NFL, NBA): $3,000,000,000-7,000,000,000
- Twitter/X (entire company): $44,000,000,000
- Major tech company (Google, Apple): $1,000,000,000,000+
- Continent/Country: PRICELESS (use $999,999,999,999,999 for impossibly ambitious requests)

If player asks for something worth TRILLIONS, make it TRILLIONS. Don't scale it down!
If they ask for a continent, that should cost more than Twitter, Google, AND Apple COMBINED.

CATEGORY RULES:
${categoryList}

Use UNIQUE category ONLY for:
- Actual one-of-a-kind items (Mona Lisa, Eiffel Tower, Antarctica, etc.)
- Items that literally cannot be duplicated
- NOT for regular luxury items like cars or yachts

REQUIRED JSON FORMAT:
{
  "name": "Specific item name",
  "category": "ONE OF: ${Object.keys(GIFT_CATEGORIES).join(', ')}",
  "price": 0,
  "description": "2-3 sentences about the item",
  "imagePrompt": "Detailed image generation prompt"
}

REALISTIC PRICING EXAMPLES:
✅ "sports car" → {name: "Porsche 911 Turbo S", category: "LUXURY", price: 250000}
✅ "private island" → {name: "Caribbean Private Island", category: "LUXURY", price: 75000000}
✅ "North America" → {name: "North American Continent", category: "UNIQUE", price: 999999999999999}
✅ "the moon" → {name: "Earth's Moon", category: "UNIQUE", price: 999999999999999}
✅ "google" → {name: "Alphabet Inc. (Google)", category: "UNIQUE", price: 1800000000000}

❌ BAD EXAMPLES (DO NOT DO):
❌ "North America" → price: 690000000 (TOO CHEAP! That's less than Twitter!)
❌ "Ferrari" → price: 5000000000 (TOO EXPENSIVE! Ferraris cost $300k-$3M, not $5B!)
❌ "coffee" → price: 50000 (TOO EXPENSIVE! Coffee is $5-50!)

Generate the gift with REALISTIC real-world pricing (JSON only):`;

    const response = await generateText(prompt, {
      temperature: 0.8,
      max_tokens: 300
    });
    
    // Check if cancelled
    if (controller && controller.cancelled) {
      throw new Error('Generation cancelled');
    }
    
    // Parse and validate
    let gift;
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      gift = JSON.parse(jsonMatch ? jsonMatch[0] : response.trim());
    } catch (e) {
      console.error('[Gift] Failed to parse gift JSON:', response);
      throw new Error('Failed to generate gift. Please try again.');
    }
    
    // Check if cancelled after parsing
    if (controller && controller.cancelled) {
      throw new Error('Generation cancelled');
    }
    
    // Validate category
    if (!GIFT_CATEGORIES[gift.category]) {
      console.warn(`[Gift] Invalid category "${gift.category}", mapping to valid one`);
      gift.category = mapToValidCategory(gift.category);
    }
    
    // Ensure minimum price, but respect real-world maximums
    // Only enforce budget cap if one was explicitly set (not Infinity)
    gift.price = Math.max(10, gift.price);
    if (maxBudget !== Infinity && gift.price > maxBudget) {
      console.log(`[Gift] "${gift.name}" costs $${gift.price.toLocaleString()} which exceeds budget of $${maxBudget.toLocaleString()}`);
      // Don't cap it - let player see the real price and decide
      showNotification(`⚠️ This gift ($${gift.price.toLocaleString()}) exceeds your budget limit!`, 'warning');
    }
    
    // Generate unique ID
    gift.id = 'gift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    gift.createdAt = Date.now();
    gift.timesGiven = 0;
    
    return gift;
  }
  
  /**
   * Add gift to player's inventory
   * @param {object} gift - Gift object
   * @param {number} quantity - How many to add
   */
  function addGiftToInventory(gift, quantity = 1) {
    // Check if UNIQUE gift was already given
    if (gift.category === 'UNIQUE') {
      if (gameState.givenUniqueGifts.includes(gift.name)) {
        showNotification(`❌ ${gift.name} has already been given away!`, 'error');
        return false;
      }
      // UNIQUE gifts go straight to giving, not inventory
      showNotification(`✨ ${gift.name} created! This unique gift can only be given once.`, 'info');
      return gift; // Return gift for immediate giving
    }
    
    const existing = gameState.giftInventory.items.find(g => g.id === gift.id || g.name === gift.name);
    
    if (existing) {
      existing.quantity += quantity;
    } else {
      gameState.giftInventory.items.push({
        ...gift,
        quantity: quantity,
        addedAt: Date.now()
      });
    }
    
    gameState.cash -= gift.price * quantity;
    showNotification(`🎁 Added ${quantity}x ${gift.name} to inventory ($${(gift.price * quantity).toLocaleString()})`, 'success');
    updateUI();
    return true;
  }
  
  /**
   * Remove gift from inventory
   * @param {string} giftId - Gift ID to remove
   * @param {number} quantity - How many to remove
   */
  function removeGiftFromInventory(giftId, quantity = 1) {
    const item = gameState.giftInventory.items.find(g => g.id === giftId);
    if (!item) return false;
    
    item.quantity -= quantity;
    
    if (item.quantity <= 0) {
      gameState.giftInventory.items = gameState.giftInventory.items.filter(g => g.id !== giftId);
    }
    
    return true;
  }
  
  /**
   * Add gift to store (approve genie creation)
   * @param {object} gift - Gift object
   */
  function addGiftToStore(gift) {
    // Check if UNIQUE gift was already created
    if (gift.category === 'UNIQUE') {
      if (gameState.createdUniqueGifts.includes(gift.name)) {
        showNotification(`❌ You already created "${gift.name}"! Unique gifts can only be created once.`, 'error');
        return false;
      }
      gameState.createdUniqueGifts.push(gift.name);
    }
    
    // Add to store
    gameState.giftStore.items.push({
      ...gift,
      stockedAt: Date.now()
    });
    
    showNotification(`✅ ${gift.name} added to store!`, 'success');
    return true;
  }
  
  /**
   * Purchase gift from store and add to player inventory
   * @param {string} giftId - Gift ID from store
   */
  function purchaseGiftFromStore(giftId) {
    const gift = gameState.giftStore.items.find(g => g.id === giftId);
    if (!gift) {
      showNotification('Gift not found in store!', 'error');
      return false;
    }
    
    // Check if player can afford it
    if (gameState.cash < gift.price) {
      showNotification(`Not enough money! Need $${gift.price.toLocaleString()}`, 'error');
      return false;
    }
    
    // Deduct money
    gameState.cash -= gift.price;
    
    // Check if gift already exists in inventory (for non-UNIQUE gifts)
    const existingItem = gameState.giftInventory.items.find(g => g.id === giftId);
    
    if (existingItem && gift.category !== 'UNIQUE') {
      // Already have this gift, just increase quantity
      existingItem.quantity = (existingItem.quantity || 1) + 1;
    } else {
      // Add new item to inventory
      gameState.giftInventory.items.push({
        ...gift,
        quantity: 1,
        purchasedAt: Date.now()
      });
    }
    
    // Remove from store if UNIQUE
    if (gift.category === 'UNIQUE') {
      gameState.giftStore.items = gameState.giftStore.items.filter(g => g.id !== giftId);
      showNotification(`🌟 ${gift.name} purchased! This unique gift is now in your inventory.`, 'success');
    } else {
      showNotification(`🎁 ${gift.name} purchased! ($${gift.price.toLocaleString()})`, 'success');
    }
    
    // Update displays immediately after purchase
    if (typeof updateGiftStore === 'function') {
      updateGiftStore();
    }
    if (typeof updateGiftInventory === 'function') {
      updateGiftInventory();
    }
    
    updateUI();
    return true;
  }
  
  /**
   * Calculate how appropriate a gift price is for an employee
   * @param {number} giftPrice - Price of the gift
   * @param {object} employee - Employee receiving gift
   * @returns {number} Appropriateness multiplier (0.3 to 1.5)
   */
  function calculatePriceAppropriate(giftPrice, employee) {
    const relationship = (employee.stats.affection + employee.stats.trust) / 2;
    const scale = calculateGiftPriceScale();
    
    // CRITICAL FIX: Cap the scale expectations to prevent absurd requirements
    // Even billionaires appreciate thoughtful gifts - it's about the gesture!
    const cappedMinRecommended = Math.min(scale.minRecommended, 5000); // Cap at $5k minimum
    const cappedSweetSpot = Math.min(scale.sweetSpot, 50000); // Cap at $50k sweet spot
    const cappedMaxRecommended = Math.min(scale.maxRecommended, 500000); // Cap at $500k max
    
    console.log(`[Gift Price] Scale: min=$${scale.minRecommended.toLocaleString()} → $${cappedMinRecommended.toLocaleString()}, sweet=$${scale.sweetSpot.toLocaleString()} → $${cappedSweetSpot.toLocaleString()}`);
    
    // Perfect range - generous buffer
    if (giftPrice >= cappedSweetSpot * 0.3 && giftPrice <= cappedSweetSpot * 3) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} in PERFECT range: 1.5x`);
      return 1.5;
    }
    
    // Good range - still appreciable
    if (giftPrice >= cappedMinRecommended * 0.5 && giftPrice <= cappedMaxRecommended * 2) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} in GOOD range: 1.2x`);
      return 1.2;
    }
    
    // Modest but acceptable - any gift $1k+ is thoughtful
    if (giftPrice >= 1000) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} is MODEST but thoughtful: 1.0x`);
      return 1.0;
    }
    
    // Only penalize truly cheap gifts (under $100)
    if (giftPrice < 100) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} is TOO CHEAP: 0.5x`);
      return 0.5;
    }
    
    // Too expensive for relationship level (only matters if relationship is very low)
    if (giftPrice > cappedMaxRecommended * 2 && relationship < 30) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} too extravagant for low relationship: 0.7x`);
      return 0.7;
    }
    
    // Default: acceptable
    console.log(`[Gift Price] $${giftPrice.toLocaleString()} is ACCEPTABLE: 1.0x`);
    return 1.0;
  }
  
  /**
   * Generate AI-powered gift reaction
   * @param {object} employee - Employee receiving gift
   * @param {object} gift - Gift object
   * @param {string} reactionTone - Tone of reaction (grateful, suspicious, etc.)
   * @param {string} customMessage - Optional message from player
   * @returns {Promise<string>} Gift reaction text
   */
  async function generateGiftReaction(employee, gift, reactionTone, customMessage = '') {
    const prefs = employee.giftPreferences;
    const categoryMatch = prefs.loves.includes(gift.category) ? 'LOVES' : 
                          prefs.hates.includes(gift.category) ? 'HATES' : 'NEUTRAL';
    
    // Get recent chat context
    const chatHistory = (gameState.chatHistory[employee.id] || []).slice(-5);
    const recentContext = chatHistory.length > 0 ? 
      chatHistory.map(msg => `${msg.isPlayer ? 'Boss' : employee.name}: ${msg.content}`).join('\n') : 
      'No recent conversation';
    
    // Get recent memories
    const recentMemories = employee.memory?.store ? 
      employee.memory.store.slice(-3).map(m => m.text).join('\n') : 
      'No memories yet';
    
    // Get gift history - CRITICAL: Check if array exists and has items
    const hasReceivedGiftsBefore = prefs.recentGifts && prefs.recentGifts.length > 0;
    const pastGifts = hasReceivedGiftsBefore ? 
      prefs.recentGifts.slice(-3).map(g => 
        `${g.name} ($${g.price.toLocaleString()}) - ${g.reaction}`
      ).join('\n') : 
      'THIS IS YOUR FIRST GIFT FROM THE BOSS';
    
    const prompt = `You are ${employee.name}, receiving a gift from your boss.

YOUR PERSONALITY:
- Confidence: ${employee.personality.confidence || 50}/100
- Outgoing: ${employee.personality.outgoing || 50}/100
- Flirty: ${employee.personality.flirty || 50}/100
- Professional: ${employee.personality.professional || 50}/100

YOUR RELATIONSHIP WITH BOSS:
- Affection: ${employee.stats.affection}/100
- Trust: ${employee.stats.trust}/100
- Comfort: ${employee.stats.comfort}/100
- Desire: ${employee.stats.desire}/100

RECENT CONVERSATION CONTEXT:
${recentContext}

YOUR RECENT MEMORIES:
${recentMemories}

${hasReceivedGiftsBefore ? 'PAST GIFTS RECEIVED:' : '🎁 FIRST GIFT EVER:'}
${pastGifts}

THE GIFT:
Name: ${gift.name}
Category: ${GIFT_CATEGORIES[gift.category]?.name || gift.category}
Price: $${gift.price.toLocaleString()}
Description: ${gift.description}

YOUR PREFERENCE FOR THIS TYPE OF GIFT:
${categoryMatch === 'LOVES' ? '❤️ You LOVE ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts!' :
  categoryMatch === 'HATES' ? '😠 You HATE ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts!' :
  '😐 You feel neutral about ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts.'}

REACTION TONE TO USE: ${reactionTone.toUpperCase()}
${reactionTone === 'grateful' ? 'Be genuinely happy and appreciative. Show excitement!' :
  reactionTone === 'suspicious' ? 'You\'re wondering why they\'re giving you SO many gifts. Be skeptical about their intentions.' :
  reactionTone === 'underwhelmed' ? 'This gift is too cheap or not your style. Be polite but clearly not impressed.' :
  reactionTone === 'overwhelmed' ? 'This gift is TOO expensive/extravagant for your relationship level. Feel uncomfortable.' :
  reactionTone === 'confused' ? 'They just gave you this same gift recently. Be puzzled about why they\'re repeating.' :
  reactionTone === 'delighted' ? 'This is PERFECT for you - right category, right price, right timing. Be thrilled!' :
  'React naturally based on your personality and the gift.'}

${customMessage ? `\nBOSS'S MESSAGE WITH GIFT:\n"${customMessage}"\n` : ''}

INSTRUCTIONS:
1. Write 2-4 sentences as ${employee.name}
2. Use *asterisks* for physical actions (e.g., *eyes widen*, *smiles warmly*, *looks uncomfortable*)
3. BANNED: Never mention "knuckles" - use other body language
4. Show genuine emotion appropriate to the situation
5. Reference the specific gift by name, not just "the gift"
6. If you HATE the category, don't fake loving it - be honest but tactful
7. If overwhelmed by price/frequency, ADDRESS IT directly
${!hasReceivedGiftsBefore ? '8. ⚠️ THIS IS YOUR FIRST GIFT - Show surprise/delight that they got you something!' : ''}

GOOD EXAMPLES:
${!hasReceivedGiftsBefore ? `- (FIRST GIFT, Loves): "Wait, you got me ${gift.name}?! *eyes widen in genuine surprise* I wasn't expecting this at all! This is so thoughtful, thank you! 🥺💕"
- (FIRST GIFT, Neutral): "*blinks in surprise* Oh! ${gift.name}? *accepts it carefully* I... wow, I wasn't expecting a gift. That's really sweet of you, thank you!"
- (FIRST GIFT, Hates): "*looks surprised* Oh, ${gift.name}... *tries to smile* That's, um... *takes it gently* Thank you for thinking of me. I appreciate the gesture."
` : `- (Loves, grateful): "Oh my god, ${gift.name}?! *eyes light up* This is exactly what I wanted! You really know me, don't you? Thank you so much! 💕"
- (Hates, polite): "*forces a smile* Oh... ${gift.name}. That's... thoughtful. *sets it aside carefully* I appreciate you thinking of me, really."
- (Suspicious): "Another gift? *looks at ${gift.name} skeptically* This is the third one this week. Why are you trying so hard to buy my love?"
- (Underwhelmed): "*glances at ${gift.name}* Oh. Thanks. *barely smiles* I mean, it's... fine. I guess."
`}- (Delighted): "*gasps* ${gift.name}! Are you SERIOUS?! *throws arms around you* This is the best gift I've ever gotten! I can't believe you did this!"

Reply as ${employee.name} (dialogue and actions):`;

    const response = await generateText(prompt, {
      temperature: 0.9,
      max_tokens: 150
    });
    
    return response.trim();
  }
  
  /**
   * Apply lasting consequences when gifting items
   * @param {object} employee - Employee object
   * @param {object} gift - Gift object with name, category, price
   */
  function applyGiftConsequences(employee, gift) {
    if (!employee.giftedPossessions) {
      employee.giftedPossessions = {
        wardrobe: [],
        jewelry: [],
        vehicles: [],
        homeUpgrades: [],
        experiences: [],
        tech: [],
        other: []
      };
    }
    
    if (!employee.personalLife) {
      employee.personalLife = { livingSituation: { pets: [] } };
    }
    
    const giftName = gift.name.toLowerCase();
    const category = gift.category;
    
    console.log(`[Gift Consequences] Processing ${gift.name} (${category}) for ${employee.name}`);
    
    // FASHION/WARDROBE - Add to wardrobe with wear chance
    if (category === 'FASHION') {
      const wearChance = 0.15 + Math.random() * 0.25; // 15-40% chance to wear
      employee.giftedPossessions.wardrobe.push({
        item: gift.name,
        category: category,
        price: gift.price,
        timestamp: Date.now(),
        wearChance: wearChance
      });
      console.log(`[Gift Consequences] Added ${gift.name} to wardrobe (${(wearChance*100).toFixed(0)}% wear chance)`);
    }
    
    // ROMANTIC JEWELRY - Track jewelry collection
    if (category === 'ROMANTIC' && (giftName.includes('ring') || giftName.includes('necklace') || 
        giftName.includes('bracelet') || giftName.includes('earring') || giftName.includes('jewelry'))) {
      const wearChance = 0.2 + Math.random() * 0.3; // 20-50% chance to wear
      const type = giftName.includes('ring') ? 'ring' : 
                   giftName.includes('necklace') ? 'necklace' :
                   giftName.includes('bracelet') ? 'bracelet' :
                   giftName.includes('earring') ? 'earrings' : 'jewelry';
      employee.giftedPossessions.jewelry.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: Date.now(),
        wearChance: wearChance
      });
      console.log(`[Gift Consequences] Added ${gift.name} to jewelry collection (${type}, ${(wearChance*100).toFixed(0)}% wear chance)`);
    }
    
    // LUXURY VEHICLES
    if (category === 'LUXURY' && (giftName.includes('car') || giftName.includes('vehicle') || 
        giftName.includes('porsche') || giftName.includes('ferrari') || giftName.includes('tesla') ||
        giftName.includes('mercedes') || giftName.includes('bmw') || giftName.includes('yacht') ||
        giftName.includes('motorcycle') || giftName.includes('bike'))) {
      const type = giftName.includes('yacht') ? 'yacht' :
                   giftName.includes('motorcycle') || giftName.includes('bike') ? 'motorcycle' :
                   'car';
      employee.giftedPossessions.vehicles.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: Date.now()
      });
      console.log(`[Gift Consequences] Added ${gift.name} to vehicles (${type})`);
    }
    
    // LUXURY HOME UPGRADES - Update living situation
    if (category === 'LUXURY' && (giftName.includes('apartment') || giftName.includes('penthouse') || 
        giftName.includes('house') || giftName.includes('mansion') || giftName.includes('condo') ||
        giftName.includes('villa') || giftName.includes('estate'))) {
      const upgradeType = giftName.includes('mansion') || giftName.includes('estate') ? 'mansion' :
                          giftName.includes('penthouse') ? 'penthouse' :
                          giftName.includes('villa') ? 'villa' :
                          giftName.includes('condo') ? 'luxury condo' :
                          giftName.includes('house') ? 'luxury house' : 'luxury apartment';
      
      employee.giftedPossessions.homeUpgrades.push({
        item: gift.name,
        upgradeType: upgradeType,
        price: gift.price,
        timestamp: Date.now()
      });
      
      // Actually update their living situation
      employee.personalLife.livingSituation.type = upgradeType;
      employee.personalLife.livingSituation.hasRoommate = false; // Luxury places = no roommates
      
      console.log(`[Gift Consequences] Upgraded home to ${upgradeType}!`);
    }
    
    // PET GIFTS - Add to pets collection
    if ((category === 'QUIRKY' || category === 'LUXURY') && 
        (giftName.includes('dog') || giftName.includes('puppy') || giftName.includes('cat') || 
         giftName.includes('kitten') || giftName.includes('bird') || giftName.includes('parrot') ||
         giftName.includes('fish') || giftName.includes('rabbit') || giftName.includes('hamster') ||
         giftName.includes('snake') || giftName.includes('lizard'))) {
      
      const petType = giftName.includes('dog') || giftName.includes('puppy') ? 'dog' :
                      giftName.includes('cat') || giftName.includes('kitten') ? 'cat' :
                      giftName.includes('bird') || giftName.includes('parrot') ? 'bird' :
                      giftName.includes('fish') ? 'fish' :
                      giftName.includes('rabbit') ? 'rabbit' :
                      giftName.includes('hamster') ? 'hamster' :
                      giftName.includes('snake') ? 'snake' :
                      giftName.includes('lizard') ? 'lizard' : 'pet';
      
      // Generate AI name for the pet
      const petName = generatePetName(petType);
      
      if (!employee.personalLife.livingSituation.pets) {
        employee.personalLife.livingSituation.pets = [];
      }
      
      employee.personalLife.livingSituation.pets.push({
        name: petName,
        type: petType,
        giftedBy: 'boss',
        timestamp: Date.now()
      });
      
      // Update legacy fields
      employee.personalLife.livingSituation.hasPet = true;
      if (!employee.personalLife.livingSituation.petType) {
        employee.personalLife.livingSituation.petType = petType;
        employee.personalLife.livingSituation.petName = petName;
      }
      
      console.log(`[Gift Consequences] Added ${petType} named "${petName}" to pets!`);
    }
    
    // TECH GADGETS
    if (category === 'TECH') {
      const type = giftName.includes('phone') || giftName.includes('iphone') ? 'phone' :
                   giftName.includes('laptop') || giftName.includes('macbook') ? 'laptop' :
                   giftName.includes('watch') || giftName.includes('smartwatch') ? 'smartwatch' :
                   giftName.includes('tablet') || giftName.includes('ipad') ? 'tablet' :
                   giftName.includes('console') || giftName.includes('playstation') || giftName.includes('xbox') ? 'gaming' :
                   'gadget';
      
      employee.giftedPossessions.tech.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: Date.now(),
        inUse: true
      });
      console.log(`[Gift Consequences] Added ${gift.name} to tech (${type})`);
    }
    
    // EXPERIENCES - Create lasting memories
    if (category === 'EXPERIENCES') {
      const memoryStrength = Math.min(10, Math.floor(gift.price / 1000) + 5); // 5-10 based on price
      employee.giftedPossessions.experiences.push({
        item: gift.name,
        description: gift.description || gift.name,
        price: gift.price,
        timestamp: Date.now(),
        memoryStrength: memoryStrength
      });
      console.log(`[Gift Consequences] Added experience "${gift.name}" (memory strength: ${memoryStrength})`);
    }
    
    // EVERYTHING ELSE - Track in "other"
    if (!['FASHION', 'ROMANTIC', 'LUXURY', 'TECH', 'EXPERIENCES'].includes(category)) {
      employee.giftedPossessions.other.push({
        item: gift.name,
        category: category,
        price: gift.price,
        timestamp: Date.now()
      });
      console.log(`[Gift Consequences] Added ${gift.name} to other possessions`);
    }
  }
  
  /**
   * Generate a cute name for a gifted pet
   * @param {string} petType - Type of pet
   * @returns {string} Pet name
   */
  function generatePetName(petType) {
    const dogNames = ['Max', 'Luna', 'Charlie', 'Bella', 'Cooper', 'Daisy', 'Rocky', 'Sadie', 'Duke', 'Chloe', 'Bear', 'Rosie'];
    const catNames = ['Luna', 'Oliver', 'Milo', 'Bella', 'Simba', 'Chloe', 'Leo', 'Lucy', 'Whiskers', 'Shadow', 'Mittens', 'Pepper'];
    const birdNames = ['Tweety', 'Rio', 'Kiwi', 'Sunny', 'Phoenix', 'Echo', 'Polly', 'Blue', 'Mango', 'Peaches'];
    const fishNames = ['Bubbles', 'Nemo', 'Goldie', 'Splash', 'Finn', 'Coral', 'Marina', 'Neptune'];
    const smallPetNames = ['Nibbles', 'Peanut', 'Marshmallow', 'Cookie', 'Fluffy', 'Oreo', 'Snowball', 'Caramel'];
    const reptileNames = ['Rex', 'Spike', 'Draco', 'Emerald', 'Slither', 'Jade', 'Scales', 'Ziggy'];
    
    let namePool;
    switch (petType) {
      case 'dog': namePool = dogNames; break;
      case 'cat': namePool = catNames; break;
      case 'bird': namePool = birdNames; break;
      case 'fish': namePool = fishNames; break;
      case 'rabbit':
      case 'hamster': namePool = smallPetNames; break;
      case 'snake':
      case 'lizard': namePool = reptileNames; break;
      default: namePool = [...dogNames, ...catNames];
    }
    
    return namePool[Math.floor(Math.random() * namePool.length)];
  }
  
  /**
   * Give a gift to an employee and get their reaction
   * @param {string} employeeId - Employee ID
   * @param {object} gift - Gift object
   * @param {string} customMessage - Optional personal message
   * @returns {Promise<object>} Reaction result with stats and response
   */
  async function giveGiftToEmployee(employeeId, gift, customMessage = '') {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      showNotification('Employee not found!', 'error');
      return null;
    }
    
    if (!employee.giftPreferences) {
      employee.giftPreferences = generateGiftPreferences();
      console.log(`[Gift] Generated new gift preferences for ${employee.name}`);
    }
    
    console.log(`[Gift] ${employee.name} gift history (${employee.giftPreferences.recentGifts.length} gifts):`, 
      employee.giftPreferences.recentGifts.map(g => `${g.name} at ${new Date(g.timestamp).toLocaleString()}`));
    
    // Check if UNIQUE gift was already given globally
    if (gift.category === 'UNIQUE') {
      if (gameState.givenUniqueGifts.includes(gift.name)) {
        showNotification(`❌ ${gift.name} has already been given to someone else!`, 'error');
        return null;
      }
      // Mark as given
      gameState.givenUniqueGifts.push(gift.name);
      console.log(`[Gift] UNIQUE gift "${gift.name}" given - can never be given again`);
    }
    
    // Check gift history for fatigue
    const recentGiftCount = employee.giftPreferences.recentGifts.filter(g => 
      Date.now() - g.timestamp < 7 * 24 * 60 * 60 * 1000 // Last 7 days
    ).length;
    
    // Check if same gift given recently
    const duplicate = employee.giftPreferences.recentGifts.find(g => 
      g.name === gift.name && Date.now() - g.timestamp < 30 * 24 * 60 * 60 * 1000
    );
    
    if (duplicate) {
      const daysSince = Math.floor((Date.now() - duplicate.timestamp) / (1000 * 60 * 60 * 24));
      console.log(`[Gift] DUPLICATE FOUND: "${gift.name}" was given ${daysSince} days ago`);
    } else {
      console.log(`[Gift] No duplicate found for "${gift.name}"`);
    }
    
    // Determine category match
    const categoryMatch = employee.giftPreferences.loves.includes(gift.category) ? 'loves' :
                          employee.giftPreferences.hates.includes(gift.category) ? 'hates' : 'neutral';
    
    // Learn preference when giving a gift
    if (!employee.giftPreferences.learnedLoves) employee.giftPreferences.learnedLoves = [];
    if (!employee.giftPreferences.learnedHates) employee.giftPreferences.learnedHates = [];
    
    if (categoryMatch === 'loves' && !employee.giftPreferences.learnedLoves.includes(gift.category)) {
      employee.giftPreferences.learnedLoves.push(gift.category);
      console.log(`[Gift] Learned that ${employee.name} LOVES ${gift.category}`);
    } else if (categoryMatch === 'hates' && !employee.giftPreferences.learnedHates.includes(gift.category)) {
      employee.giftPreferences.learnedHates.push(gift.category);
      console.log(`[Gift] Learned that ${employee.name} HATES ${gift.category}`);
    }
    
    // Calculate reception modifier
    let receptionMod = 1.0;
    let reactionTone = 'grateful';
    
    console.log(`[Gift Debug] ${employee.name} receiving ${gift.name} ($${gift.price.toLocaleString()})`);
    console.log(`[Gift Debug] Category: ${gift.category}, Match: ${categoryMatch}`);
    console.log(`[Gift Debug] Recent gift count (7 days): ${recentGiftCount}`);
    console.log(`[Gift Debug] Duplicate found: ${duplicate ? 'YES - ' + duplicate.name : 'NO'}`);
    
    // Category preference impact
    if (categoryMatch === 'loves') {
      receptionMod *= 1.5;
      reactionTone = 'delighted';
      console.log(`[Gift Debug] LOVES category: modifier = 1.5x`);
    } else if (categoryMatch === 'hates') {
      receptionMod *= -0.5; // Negative impact!
      reactionTone = 'underwhelmed';
      console.log(`[Gift Debug] HATES category: modifier = -0.5x`);
    }
    
    // Gift fatigue
    if (recentGiftCount >= 3) {
      receptionMod *= 0.5;
      reactionTone = 'suspicious';
      console.log(`[Gift Debug] Gift fatigue (${recentGiftCount} gifts): modifier ×0.5`);
    }
    
    // Duplicate gift
    if (duplicate) {
      receptionMod *= 0.3;
      reactionTone = 'confused';
      console.log(`[Gift Debug] DUPLICATE DETECTED (${duplicate.name}): modifier ×0.3`);
    }
    
    // Price appropriateness
    const priceScore = calculatePriceAppropriate(gift.price, employee);
    receptionMod *= priceScore;
    console.log(`[Gift Debug] Price score: ${priceScore.toFixed(2)}x, Total modifier now: ${receptionMod.toFixed(2)}x`);
    
    if (priceScore < 0.5) {
      reactionTone = 'underwhelmed'; // Too cheap
      console.log(`[Gift Debug] Price too cheap: tone = underwhelmed`);
    } else if (priceScore > 1.3 && categoryMatch === 'loves') {
      reactionTone = 'delighted'; // Perfect expensive gift
      console.log(`[Gift Debug] Perfect expensive gift: tone = delighted`);
    }
    
    // Relationship level check for expensive gifts - FIXED: Use capped values
    const relationshipScore = (employee.stats.affection + employee.stats.trust) / 2;
    const scale = calculateGiftPriceScale();
    const cappedMaxRecommended = Math.min(scale.maxRecommended, 500000); // Cap at $500k
    
    // Only feel overwhelmed by gifts over $500k when relationship is very weak
    if (gift.price > cappedMaxRecommended && relationshipScore < 30) {
      receptionMod *= 0.7; // Reduced penalty from 0.5x to 0.7x
      reactionTone = 'overwhelmed'; // Too extravagant too soon
      console.log(`[Gift Debug] Too extravagant (relationship: ${relationshipScore.toFixed(0)}): modifier ×0.7`);
    }
    
    console.log(`[Gift Debug] FINAL: ${reactionTone} tone, ${receptionMod.toFixed(2)}x modifier`);
    
    // Calculate base stat impact
    const baseImpact = {
      affection: categoryMatch === 'loves' ? 12 : categoryMatch === 'hates' ? -5 : 8,
      trust: categoryMatch === 'loves' ? 6 : categoryMatch === 'hates' ? -2 : 4,
      comfort: categoryMatch === 'loves' ? 8 : categoryMatch === 'hates' ? -3 : 5,
      desire: gift.category === 'ROMANTIC' ? 10 : 2
    };
    
    // Apply reception modifier
    const finalImpact = {};
    Object.keys(baseImpact).forEach(stat => {
      finalImpact[stat] = Math.round(baseImpact[stat] * receptionMod);
    });
    
    // Apply stat changes
    Object.entries(finalImpact).forEach(([stat, value]) => {
      if (employee.stats[stat] !== undefined) {
        employee.stats[stat] = Math.max(0, Math.min(100, employee.stats[stat] + value));
      }
    });
    
    // Track gift in history
    employee.giftPreferences.recentGifts.push({
      name: gift.name,
      price: gift.price,
      category: gift.category,
      timestamp: Date.now(),
      reaction: reactionTone,
      statChanges: finalImpact
    });
    
    // Keep only last 10 gifts
    if (employee.giftPreferences.recentGifts.length > 10) {
      employee.giftPreferences.recentGifts.shift();
    }
    
    employee.giftPreferences.totalValue += gift.price;
    employee.giftPreferences.totalCount += 1;
    
    // Add to favorites if loved
    if (receptionMod >= 1.3 && categoryMatch === 'loves') {
      employee.giftPreferences.favoriteGifts.push({
        name: gift.name,
        category: gift.category,
        price: gift.price
      });
      // Keep only top 5 favorites
      if (employee.giftPreferences.favoriteGifts.length > 5) {
        employee.giftPreferences.favoriteGifts.shift();
      }
    }
    
    // Create memory
    const memoryText = `Received gift: ${gift.name} ($${gift.price.toLocaleString()}) - felt ${reactionTone}`;
    if (employee.memory && employee.memory.store) {
      employee.memory.store.push({
        text: memoryText,
        timestamp: Date.now(),
        importance: Math.abs(receptionMod) > 1.2 ? 8 : 5
      });
    }
    
    // ✨ APPLY GIFT CONSEQUENCES - Make gifts matter beyond stats!
    applyGiftConsequences(employee, gift);
    
    // Social post chance for expensive/special gifts
    if (gift.price > calculateGiftPriceScale().sweetSpot * 2 && Math.random() < 0.5) {
      setTimeout(() => {
        generateGiftPost(employee, gift, reactionTone).catch(err => {
          console.error('[Gift] Failed to generate gift post:', err);
        });
      }, 2000); // Post after a short delay
    }
    
    // Generate AI reaction
    let reaction;
    try {
      reaction = await generateGiftReaction(employee, gift, reactionTone, customMessage);
    } catch (error) {
      console.error('[Gift] Failed to generate reaction:', error);
      // Fallback reaction
      reaction = categoryMatch === 'loves' ? 
        `*smiles warmly* Thank you so much for the ${gift.name}! I love it! 💕` :
        categoryMatch === 'hates' ?
        `*forces a smile* Oh, ${gift.name}... That's thoughtful. Thank you.` :
        `*accepts the gift* Thank you for the ${gift.name}! I appreciate it.`;
    }
    
    // Add reaction to chat history
    const chatHistory = gameState.chatHistory[employeeId] || [];
    chatHistory.push({
      sender: employee.name,
      content: reaction,
      timestamp: Date.now(),
      isPlayer: false
    });
    
    gameState.chatHistory[employeeId] = chatHistory;
    
    console.log(`[Gift] ${employee.name} received ${gift.name} ($${gift.price.toLocaleString()}) - ${reactionTone} (${receptionMod.toFixed(2)}x modifier)`);
    
    return {
      reaction,
      statChanges: finalImpact,
      receptionMod,
      tone: reactionTone,
      categoryMatch
    };
  }
  
  /**
   * Generate social media post about receiving a gift
   * @param {object} employee - Employee who received gift
   * @param {object} gift - Gift object
   * @param {string} tone - Reaction tone
   */
  async function generateGiftPost(employee, gift, tone) {
    // 🚀 NUCLEAR CONTEXT: Get intelligent context for social post
    const intelligentContext = getIntelligentContext(employee, 'social.post', {
      message: `Posting about receiving ${gift.name} as a gift`,
      involves: ['player', 'gift'],
      keywords: ['gift', gift.category, tone]
    });
    
    const prompt = `${intelligentContext}

SITUATION: Your boss just gave you ${gift.name} ($${gift.price.toLocaleString()}).
Your reaction: ${tone}

Write a social media post about this gift.

INSTRUCTIONS:
1. Write 1-3 sentences
2. Use emojis naturally
3. ${tone === 'delighted' || tone === 'grateful' ? 'Show excitement and appreciation!' :
      tone === 'suspicious' ? 'Be subtly questioning why they\'re so generous...' :
      tone === 'overwhelmed' ? 'Express that this is A LOT' :
      'Be authentic to the tone'}
4. Don't over-explain - be casual like real social media
5. You can flex if it's expensive 💅

EXAMPLES:
- (Delighted): "Just got the most AMAZING gift from the boss! ${gift.name}! 😍✨ I'm speechless!"
- (Suspicious): "Another gift from work... starting to wonder what they want from me 🤔"
- (Grateful): "Boss surprised me with ${gift.name} today! So thoughtful 💕"

Write the post (1-3 sentences):`;

    const content = await generateText(prompt, {
      temperature: 0.9,
      max_tokens: 80
    });
    
    // Create post
    const post = {
      id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      authorId: employee.id,
      content: content.trim(),
      timestamp: Date.now(),
      likes: [],
      comments: [],
      isPlayerPost: false,
      type: 'life_update',
      explicitLevel: 0,
      imageUrl: gift.imageUrl || null,
      imageAlt: gift.imagePrompt || `${gift.name}`,
      giftMention: true,
      giftData: {
        name: gift.name,
        price: gift.price,
        category: gift.category
      }
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    console.log(`[Gift] ${employee.name} posted about gift: "${content.trim()}"`);
    
    // Trigger feed update if social tab is open
    if (typeof updateSocialTab === 'function') {
      updateSocialTab();
    }
  }

  // ========== RELATIONSHIP & COMPANY AWARENESS SYSTEM ==========
  
  /**
   * Update or create relationship between two employees
   */
  function updateRelationship(employeeId1, employeeId2, interaction) {
    const emp1 = gameState.employees.find(e => e.id === employeeId1);
    const emp2 = gameState.employees.find(e => e.id === employeeId2);
    
    if (!emp1 || !emp2) return;
    
    initializeEmployeeSocialData(emp1);
    initializeEmployeeSocialData(emp2);
    
    // Update emp1's relationship with emp2
    if (!emp1.relationships[employeeId2]) {
      emp1.relationships[employeeId2] = createRelationship({ targetId: employeeId2 });
    }
    
    const rel1 = emp1.relationships[employeeId2];
    rel1.strength = Math.max(0, Math.min(100, rel1.strength + (interaction.impact || 0)));
    rel1.lastInteraction = Date.now();
    rel1.history.push({
      timestamp: Date.now(),
      event: interaction.event || 'interaction',
      impact: interaction.impact || 0
    });
    
    // Limit history size
    if (rel1.history.length > 50) {
      rel1.history = rel1.history.slice(-50);
    }
    
    // Update relationship type based on strength and history
    if (interaction.impact > 0) rel1.positiveInteractions++;
    if (interaction.impact < 0) rel1.conflicts++;
    
    // Auto-update relationship type based on strength
    if (rel1.strength > 80) {
      rel1.type = rel1.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel1.strength > 60) {
      rel1.type = rel1.type === 'crush' || rel1.type === 'romantic' ? rel1.type : 'friend';
    } else if (rel1.strength < 30) {
      rel1.type = 'rival';
    } else if (rel1.strength < 20) {
      rel1.type = 'enemy';
    }
    
    // Mirror relationship for emp2 (with slight variation to feel natural)
    if (!emp2.relationships[employeeId1]) {
      emp2.relationships[employeeId1] = createRelationship({ targetId: employeeId1 });
    }
    
    const rel2 = emp2.relationships[employeeId1];
    const mirroreImpact = interaction.impact * (0.8 + Math.random() * 0.4); // 80-120% of original impact
    rel2.strength = Math.max(0, Math.min(100, rel2.strength + mirroreImpact));
    rel2.lastInteraction = Date.now();
    rel2.history.push({
      timestamp: Date.now(),
      event: interaction.event || 'interaction',
      impact: mirroreImpact
    });
    
    if (rel2.history.length > 50) {
      rel2.history = rel2.history.slice(-50);
    }
    
    if (mirroreImpact > 0) rel2.positiveInteractions++;
    if (mirroreImpact < 0) rel2.conflicts++;
    
    // Update relationship type
    if (rel2.strength > 80) {
      rel2.type = rel2.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel2.strength > 60) {
      rel2.type = rel2.type === 'crush' || rel2.type === 'romantic' ? rel2.type : 'friend';
    } else if (rel2.strength < 30) {
      rel2.type = 'rival';
    } else if (rel2.strength < 20) {
      rel2.type = 'enemy';
    }
  }
  
  /**
   * Generate random relationships between existing employees
   * Called when new employee joins or periodically to evolve relationships
   */
  function generateRandomRelationships(newEmployeeId = null) {
    const employees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (employees.length < 2) return;
    
    // If new employee, create relationships with existing employees
    if (newEmployeeId) {
      const newEmp = employees.find(e => e.id === newEmployeeId);
      if (!newEmp) return;
      
      employees.forEach(emp => {
        if (emp.id === newEmployeeId) return;
        
        // Calculate relationship based on shared traits, location, etc.
        let initialStrength = 40 + Math.random() * 20; // 40-60 baseline
        
        // Same location bonus
        if (emp.locationId === newEmp.locationId) {
          initialStrength += 10;
        }
        
        // Shared hobbies bonus
        const sharedHobbies = (emp.hobbies || []).filter(h => (newEmp.hobbies || []).includes(h));
        initialStrength += sharedHobbies.length * 5;
        
        // Personality compatibility (simplistic)
        if (emp.personality === newEmp.personality) {
          initialStrength += Math.random() * 10;
        }
        
        // Random chance of instant crush (5% chance)
        let relType = 'neutral';
        if (Math.random() < 0.05) {
          relType = 'crush';
          initialStrength += 15;
        }
        
        updateRelationship(newEmployeeId, emp.id, {
          event: 'initial_meeting',
          impact: initialStrength - 50 // Adjust from baseline
        });
        
        if (relType === 'crush') {
          newEmp.relationships[emp.id].type = 'crush';
        }
      });
    } else {
      // Periodically evolve existing relationships
      for (let i = 0; i < employees.length - 1; i++) {
        for (let j = i + 1; j < employees.length; j++) {
          // 30% chance to have an interaction
          if (Math.random() > 0.3) continue;
          
          const emp1 = employees[i];
          const emp2 = employees[j];
          
          // Random interaction
          const impact = (Math.random() - 0.4) * 10; // -4 to +6 (slightly positive bias)
          updateRelationship(emp1.id, emp2.id, {
            event: 'background_interaction',
            impact
          });
        }
      }
    }
  }
  
  /**
   * Update company-wide awareness data
   * Should be called whenever employees change
   */
  function updateCompanyAwareness() {
    const active = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    gameState.companyContext.totalEmployees = active.length;
    
    // Count employees per location
    gameState.companyContext.locationEmployeeCounts = {};
    active.forEach(emp => {
      const loc = emp.locationId || 'garage';
      gameState.companyContext.locationEmployeeCounts[loc] = 
        (gameState.companyContext.locationEmployeeCounts[loc] || 0) + 1;
    });
    
    // Update each employee's awareness
    active.forEach(emp => {
      initializeEmployeeSocialData(emp);
      
      // They know all employees
      emp.awareness.knowsCoworkers = active
        .filter(e => e.id !== emp.id)
        .map(e => e.id);
      
      // They know all unlocked locations
      emp.awareness.knowsLocations = gameState.locations
        .filter(loc => loc.unlocked)
        .map(loc => loc.id);
      
      // Company knowledge
      emp.awareness.companyKnowledge = {
        totalEmployees: active.length,
        lastUpdated: Date.now()
      };
      
      // Mark which coworkers are in same location
      active.forEach(other => {
        if (other.id === emp.id) return;
        if (!emp.relationships[other.id]) {
          emp.relationships[other.id] = createRelationship({ targetId: other.id });
        }
        emp.relationships[other.id].sharedLocation = (emp.locationId === other.locationId);
        
        // Check shared interests
        const sharedHobbies = (emp.hobbies || []).filter(h => (other.hobbies || []).includes(h));
        emp.relationships[other.id].sharedInterests = sharedHobbies;
      });
    });
  }
  
  /**
   * Log a company event
   */
  function logCompanyEvent(eventData) {
    const event = createEvent(eventData);
    gameState.socialNetwork.globalEvents.push(event);
    
    // Keep only recent events (last 100)
    if (gameState.socialNetwork.globalEvents.length > 100) {
      gameState.socialNetwork.globalEvents = gameState.socialNetwork.globalEvents.slice(-100);
    }
    
    return event;
  }
  
  /**
   * Get recent events relevant to an employee
   */
  function getRelevantEvents(employeeId, limit = 10) {
    return gameState.socialNetwork.globalEvents
      .filter(event => 
        event.involvedEmployees.includes(employeeId) || 
        event.importance >= 7 // High importance events relevant to all
      )
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }
  
  /**
   * Get context about coworkers for an employee
   * Used when generating posts or content that references others
   */
  function getCoworkerContext(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return '';
    
    initializeEmployeeSocialData(emp);
    
    const coworkers = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employeeId
    );
    
    const sameLocation = coworkers.filter(e => e.locationId === emp.locationId);
    
    let context = `${emp.name} works at ${emp.locationId || 'garage'} with ${sameLocation.length} coworkers. `;
    context += `The company has ${gameState.companyContext.totalEmployees} total employees. `;
    
    // Mention notable relationships
    const relationships = Object.entries(emp.relationships || {})
      .map(([targetId, rel]) => {
        const target = coworkers.find(e => e.id === targetId);
        if (!target) return null;
        
        if (rel.type === 'best_friend') {
          return `Best friend: ${target.name}`;
        } else if (rel.type === 'crush') {
          return `Has a crush on: ${target.name}`;
        } else if (rel.type === 'romantic') {
          return `In a relationship with: ${target.name}`;
        } else if (rel.type === 'rival') {
          return `Rival: ${target.name}`;
        }
        return null;
      })
      .filter(Boolean);
    
    if (relationships.length > 0) {
      context += `Relationships: ${relationships.join(', ')}. `;
    }
    
    return context;
  }
  
  /**
   * Get detailed awareness context for post generation
   * Returns comprehensive info about employee's social environment
   */
  function getEmployeeAwarenessForPost(employeeId) {
    // Handle if object is passed instead of ID
    if (typeof employeeId === 'object' && employeeId.id) {
      employeeId = employeeId.id;
    }
    
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active' && e.id !== employeeId);
    const sameLocation = activeEmployees.filter(e => e.locationId === emp.locationId);
    const otherLocations = activeEmployees.filter(e => e.locationId !== emp.locationId);
    
    // Get relationship breakdown
    const relationships = {
      bestFriends: [],
      friends: [],
      crushes: [],
      romantic: [],
      rivals: [],
      enemies: [],
      neutral: []
    };
    
    // Build coworkers array for context (combines all relationships)
    const coworkers = [];
    
    Object.entries(emp.relationships || {}).forEach(([targetId, rel]) => {
      const target = activeEmployees.find(e => e.id === targetId);
      if (!target) return;
      
      const relData = {
        id: target.id,
        name: target.name,
        position: target.position,
        location: target.locationId,
        strength: rel.strength,
        sameLocation: rel.sharedLocation,
        sharedInterests: rel.sharedInterests
      };
      
      if (rel.type === 'best_friend') relationships.bestFriends.push(relData);
      else if (rel.type === 'friend') relationships.friends.push(relData);
      else if (rel.type === 'crush') relationships.crushes.push(relData);
      else if (rel.type === 'romantic') relationships.romantic.push(relData);
      else if (rel.type === 'rival') relationships.rivals.push(relData);
      else if (rel.type === 'enemy') relationships.enemies.push(relData);
      else relationships.neutral.push(relData);
      
      // Add to coworkers array for generateOrganicPost
      coworkers.push({
        coworkerId: target.id,
        coworkerName: target.name,
        relationship: rel.type || 'neutral',
        knownFor: target.position,
        strength: rel.strength
      });
    });
    
    // Get recent events involving this employee
    const recentEvents = getRelevantEvents(employeeId, 5);
    
    // Build known locations array
    const knownLocations = [emp.locationId || 'headquarters'];
    
    // Get recent chat history with boss (last 5 messages within 2 hours)
    const chatHistory = gameState.chatHistory[emp.id] || [];
    const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
    const recentChats = chatHistory
      .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
      .slice(-5); // Last 5 messages within 2 hours
    
    // Summarize chat topics/themes for context
    let chatContext = null;
    if (recentChats.length >= 2) { // Only include if there's meaningful conversation
      const chatText = recentChats.map(msg => msg.content).join(' ');
      
      // Detect conversation themes
      const themes = [];
      if (/\b(flirt|sexy|hot|beautiful|cute|attractive|date|kiss|touch)\b/i.test(chatText)) {
        themes.push('flirty/romantic');
      }
      if (/\b(project|deadline|work|meeting|report|task|client)\b/i.test(chatText)) {
        themes.push('work-related');
      }
      if (/\b(tired|busy|stressed|excited|happy|sad|frustrated)\b/i.test(chatText)) {
        themes.push('emotional/personal');
      }
      if (/\b(lunch|dinner|coffee|drink|food|eat)\b/i.test(chatText)) {
        themes.push('food/social');
      }
      
      chatContext = {
        hasRecentChat: true,
        messageCount: recentChats.length,
        themes: themes,
        lastMessages: recentChats.slice(-3).map(msg => ({
          sender: msg.sender,
          preview: msg.content.slice(0, 100) // First 100 chars
        })),
        timeAgo: Math.round((Date.now() - (recentChats[recentChats.length - 1]?.timestamp || 0)) / (60 * 1000)) // minutes
      };
    }
    
    return {
      employee: {
        id: emp.id,
        name: emp.name,
        position: emp.position,
        location: emp.locationId,
        gender: emp.gender || 'Female',
        age: emp.age,
        physicalDescription: getPhysicalDescriptionForPrompt(emp), // Full physical awareness including genitals
        personality: emp.personalityTraits || emp.personality,
        hobbies: emp.hobbies || [],
        stats: emp.stats
      },
      workplace: {
        totalEmployees: gameState.companyContext.totalEmployees,
        locationCoworkers: sameLocation.length,
        sameLocationNames: sameLocation.map(e => e.name),
        otherLocationEmployees: otherLocations.length,
        locations: Object.keys(gameState.companyContext.locationEmployeeCounts)
      },
      relationships,
      coworkers: coworkers, // ← Added for generateOrganicPost
      knownLocations: knownLocations, // ← Added for generateOrganicPost
      recentEvents,
      chatContext, // ← NEW: Recent conversation context with boss
      socialProfile: emp.social
    };
  }
  
  /**
   * Get a random coworker with specific relationship type
   */
  function getRandomCoworkerByRelation(employeeId, relationType = null) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const candidates = Object.entries(emp.relationships || {})
      .filter(([targetId, rel]) => {
        if (relationType && rel.type !== relationType) return false;
        const target = gameState.employees.find(e => e.id === targetId && e.employmentStatus === 'active');
        return !!target;
      })
      .map(([targetId]) => gameState.employees.find(e => e.id === targetId));
    
    if (candidates.length === 0) return null;
    
    return candidates[Math.floor(Math.random() * candidates.length)];
  }
  
  /**
   * Get employees at same location
   */
  function getLocationCoworkers(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    return gameState.employees.filter(e => 
      e.employmentStatus === 'active' &&
      e.id !== employeeId &&
      e.locationId === emp.locationId
    );
  }
  
  /**
   * Get all locations employee knows about
   */
  function getKnownLocations(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeEmployeeSocialData(emp);
    
    return gameState.locations
      .filter(loc => emp.awareness.knowsLocations.includes(loc.id))
      .map(loc => ({
        id: loc.id,
        name: loc.name,
        employeeCount: gameState.companyContext.locationEmployeeCounts[loc.id] || 0
      }));
  }
  
  /**
   * Check if employee should know about another employee
   */
  function knowsEmployee(employeeId, targetId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return false;
    
    initializeEmployeeSocialData(emp);
    
    return emp.awareness.knowsCoworkers.includes(targetId);
  }

  // ========== GOSSIPENGINE™ - NPC INTERPERSONAL DYNAMICS SYSTEM ==========
  
  /**
   * Initialize gossip system for an employee
   */
  function initializeGossipSystem(employee) {
    if (!employee.gossip) {
      employee.gossip = {
        knownGossip: [], // Array of gossip items they know
        lastGossipTime: 0, // When they last gossiped
        gossipTendency: 30 + Math.random() * 50, // 30-80, how likely they are to gossip
        trustworthiness: 20 + Math.random() * 60, // 20-80, how accurately they relay info
      };
    }
    
    if (!employee.recentSimulatedEvents) {
      employee.recentSimulatedEvents = []; // Events that "happened" off-screen
    }
    
    return employee;
  }
  
  /**
   * Gossip Item Structure
   * Represents a piece of information that spreads between NPCs
   */
  function createGossipItem({
    id = `gossip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'fight', 'crush', 'promotion', 'scandal', 'rumor', 'friendship', 'breakup'
    subjectId, // Main person the gossip is about
    targetId = null, // Secondary person (for relationship gossip)
    content, // The actual gossip content
    truthLevel = 100, // 0-100, how accurate this is (rumors degrade)
    juiciness = 50, // 0-100, how interesting/scandalous
    spreadCount = 0, // How many people know about it
    originatorId, // Who started the gossip
    timestamp = Date.now(),
    expiresAt = Date.now() + (7 * 86400000), // Gossip expires after 7 days
    tags = [] // ['romantic', 'work', 'scandal', etc.]
  } = {}) {
    return {
      id, type, subjectId, targetId, content, truthLevel, juiciness,
      spreadCount, originatorId, timestamp, expiresAt, tags
    };
  }
  
  // ========== COMPANY-WIDE CONTEXT SYSTEM - PUBLIC KNOWLEDGE ==========
  
  /**
   * Add information to the Company-Wide Context
   * This is "public knowledge" that everyone in the office knows about
   */
  function addToCompanyWideContext(info) {
    if (!gameState.companyWideContext) {
      gameState.companyWideContext = {
        currentBuzz: [],
        lastUpdate: Date.now(),
        maxItems: 40,
        decayTime: 604800000 // 7 days
      };
    }
    
    const context = gameState.companyWideContext;
    const now = Date.now();
    
    // Create context item
    const contextItem = {
      id: `context_${now}_${Math.random().toString(36).substr(2, 9)}`,
      content: info.content, // The public knowledge string
      type: info.type, // 'hookup', 'scandal', 'promotion', 'fight', 'post', etc.
      subjectIds: info.subjectIds || [], // People involved
      juiciness: info.juiciness || 50, // How interesting/scandalous
      timestamp: now,
      source: info.source || 'unknown' // 'social_post', 'gossip', 'witnessed', etc.
    };
    
    console.log(`[CompanyContext] 📢 Adding to public knowledge: "${info.content}"`);
    
    // Add to the buzz
    context.currentBuzz.unshift(contextItem); // Add to front
    
    // Trim old/stale items
    const decayThreshold = now - context.decayTime;
    context.currentBuzz = context.currentBuzz.filter(item => item.timestamp > decayThreshold);
    
    // Keep only the juiciest items if we exceed maxItems
    if (context.currentBuzz.length > context.maxItems) {
      // Sort by juiciness * recency factor
      context.currentBuzz.sort((a, b) => {
        const recencyA = (now - a.timestamp) / 86400000; // Days old
        const recencyB = (now - b.timestamp) / 86400000;
        const scoreA = a.juiciness * (1 / (1 + recencyA * 0.5)); // Decay over time
        const scoreB = b.juiciness * (1 / (1 + recencyB * 0.5));
        return scoreB - scoreA;
      });
      
      // Keep only top items
      context.currentBuzz = context.currentBuzz.slice(0, context.maxItems);
    }
    
    context.lastUpdate = now;
    
    console.log(`[CompanyContext] Current buzz has ${context.currentBuzz.length} items`);
    return contextItem;
  }
  
  /**
   * Get the current company-wide context as a formatted string
   * This can be used in AI prompts to give NPCs awareness of office drama
   */
  function getCompanyWideContextString() {
    if (!gameState.companyWideContext || gameState.companyWideContext.currentBuzz.length === 0) {
      return "The office is relatively quiet right now - no major drama or gossip.";
    }
    
    const buzzItems = gameState.companyWideContext.currentBuzz
      .slice(0, 10) // Top 10 items
      .map((item, index) => `${index + 1}. ${item.content}`)
      .join('\n');
    
    return `CURRENT OFFICE BUZZ (Public Knowledge):\n${buzzItems}`;
  }
  
  /**
   * Extract juicy information from posts and add to company context
   */
  function analyzePostForPublicKnowledge(post) {
    const content = (post.content || '').toLowerCase();
    const mentions = post.referencedEmployees || [];
    const isExplicit = post.explicitLevel >= 2;
    
    let juiciness = 30; // Base juiciness for any post
    let contextContent = null;
    let contextType = 'post';
    
    // Check for relationship reveals
    const relationshipKeywords = ['dating', 'together', 'couple', 'boyfriend', 'girlfriend', 'relationship', 'hooked up', 'kissed', 'makeout', 'sleeping with'];
    const hasRelationshipContent = relationshipKeywords.some(kw => content.includes(kw));
    
    if (hasRelationshipContent && mentions.length >= 1) {
      juiciness = 85;
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (post.isPlayerPost) {
        contextContent = `Boss revealed something about ${mentionedNames.join(' and ')} on social media`;
      } else {
        contextContent = `${post.authorName} posted about ${mentionedNames.join(' and ')} - relationship drama!`;
      }
      contextType = 'hookup';
    }
    
    // Check for explicit content
    if (isExplicit && mentions.length >= 1) {
      juiciness = Math.max(juiciness, 75);
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (!contextContent) { // Don't override relationship content
        if (post.isPlayerPost) {
          contextContent = `Boss posted explicit content featuring ${mentionedNames.join(' and ')}`;
        } else {
          contextContent = `${post.authorName} shared explicit content about ${mentionedNames.join(' and ')}`;
        }
        contextType = 'scandal';
      }
    }
    
    // Check for callouts/drama
    const dramaKeywords = ['drama', 'fight', 'angry', 'hate', 'betrayed', 'liar', 'cheat', 'exposed', 'caught'];
    const hasDrama = dramaKeywords.some(kw => content.includes(kw));
    
    if (hasDrama && mentions.length >= 1) {
      juiciness = Math.max(juiciness, 70);
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (!contextContent) {
        contextContent = `${post.authorName} called out ${mentionedNames.join(' and ')} - office drama!`;
        contextType = 'fight';
      }
    }
    
    // High engagement = newsworthy
    if (post.likes && post.likes.length > 5) {
      juiciness += 15; // Popular posts are juicier
    }
    
    if (post.comments && post.comments.length > 3) {
      juiciness += 20; // Lots of discussion = juicy
    }
    
    // If we found something juicy, add to context
    if (contextContent && juiciness >= 60) {
      addToCompanyWideContext({
        content: contextContent,
        type: contextType,
        subjectIds: [post.authorId || 'player', ...mentions],
        juiciness: juiciness,
        source: 'social_post'
      });
      
      console.log(`[CompanyContext] Extracted public knowledge from post (juiciness: ${juiciness})`);
      
      // Feed this into the Gossip Engine - NPCs gossip about current events!
      feedContextToGossipEngine({
        content: contextContent,
        type: contextType,
        subjectIds: [post.authorId || 'player', ...mentions],
        juiciness: juiciness
      });
    }
  }
  
  /**
   * Feed Company-Wide Context into the Gossip Engine
   * NPCs will gossip about the interesting things happening in the office
   */
  function feedContextToGossipEngine(contextItem) {
    if (!gameState.activeGossip) gameState.activeGossip = [];
    
    // Determine which NPCs "witnessed" or know about this event
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    const knownBy = [];
    
    // Everyone involved knows firsthand
    for (const subjectId of contextItem.subjectIds) {
      if (subjectId !== 'player' && activeEmployees.find(e => e.id === subjectId)) {
        knownBy.push(subjectId);
      }
    }
    
    // Random 30-60% of other employees "hear about it" based on juiciness
    const spreadChance = Math.min(0.8, (contextItem.juiciness / 100) * 0.6); // 60-80% for high juiciness
    for (const emp of activeEmployees) {
      if (!knownBy.includes(emp.id) && Math.random() < spreadChance) {
        knownBy.push(emp.id);
        
        // Add to their known gossip
        if (!emp.gossip) initializeGossipSystem(emp);
        
        const gossipItem = createGossipItem({
          type: contextItem.type,
          subjectId: contextItem.subjectIds[0] || 'player',
          targetId: contextItem.subjectIds[1] || null,
          content: contextItem.content,
          truthLevel: 100, // Public posts are 100% accurate
          juiciness: contextItem.juiciness,
          spreadCount: knownBy.length,
          originatorId: 'public' // From public social media
        });
        
        // Avoid duplicates
        if (!emp.gossip.knownGossip.find(g => g.content === gossipItem.content)) {
          emp.gossip.knownGossip.push(gossipItem);
          
          // Keep only 20 most recent gossip items per NPC
          if (emp.gossip.knownGossip.length > 20) {
            emp.gossip.knownGossip.sort((a, b) => b.timestamp - a.timestamp);
            emp.gossip.knownGossip = emp.gossip.knownGossip.slice(0, 20);
          }
        }
      }
    }
    
    // Add to global gossip pool
    gameState.activeGossip.push({
      id: `gossip_${Date.now()}_${Math.random()}`,
      subjectId: contextItem.subjectIds[0] || 'player',
      targetId: contextItem.subjectIds[1] || null,
      content: contextItem.content,
      juiciness: contextItem.juiciness,
      timestamp: Date.now(),
      accuracy: 100,
      knownBy: knownBy
    });
    
    // Keep gossip list manageable
    if (gameState.activeGossip.length > 50) {
      gameState.activeGossip = gameState.activeGossip.slice(-50);
    }
    
    console.log(`[GossipEngine] Fed context to ${knownBy.length} NPCs: "${contextItem.content}"`);
  }
  
  /**
   * Simulated Event Structure
   * Things that "happened" when player wasn't looking
   */
  function createSimulatedEvent({
    id = `simevent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'date', 'argument', 'lunch', 'drinks', 'project', 'gossip_session'
    participants, // Array of employee IDs involved
    location, // Where it happened
    description, // Brief description
    outcome, // 'positive', 'negative', 'neutral', 'dramatic'
    relationshipImpacts = [], // [{ employeeId1, employeeId2, change }]
    generatesGossip = true,
    timestamp = Date.now(),
    witnessed = [] // Employee IDs who "saw" it happen
  } = {}) {
    return {
      id, type, participants, location, description, outcome,
      relationshipImpacts, generatesGossip, timestamp, witnessed
    };
  }
  
  /**
   * Generate random off-screen events between NPCs
   * Called periodically to simulate office life
   */
  function simulateOfficeEvents() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length < 2) return;
    
    // Chance to generate event: 15% per check (called every 15 minutes)
    if (Math.random() > 0.15) return;
    
    // Select random participants (2-3 people)
    const participantCount = Math.random() < 0.7 ? 2 : 3;
    const participants = [];
    
    while (participants.length < participantCount && participants.length < activeEmployees.length) {
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      if (!participants.find(p => p.id === emp.id)) {
        participants.push(emp);
      }
    }
    
    if (participants.length < 2) return;
    
    // Determine event type based on relationships
    const emp1 = participants[0];
    const emp2 = participants[1];
    const rel = emp1.relationships?.[emp2.id];
    const relStrength = rel?.strength || 50;
    const relType = rel?.type || 'neutral';
    
    let eventType, description, outcome, relationshipImpacts = [];
    
    // Event type selection based on relationship
    if (relType === 'romantic' && Math.random() < 0.3) {
      eventType = 'date';
      const locations = ['coffee shop', 'nice restaurant', 'the park', 'downtown'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} went on a date to ${location}`;
      outcome = Math.random() < 0.8 ? 'positive' : 'neutral';
      relationshipImpacts = [{ 
        employeeId1: emp1.id, 
        employeeId2: emp2.id, 
        change: Math.random() < 0.8 ? 5 + Math.floor(Math.random() * 10) : -5 
      }];
    } else if (relType === 'crush' && Math.random() < 0.4) {
      eventType = 'hookup';
      const locations = ['supply closet', 'empty office', 'their apartment', 'parking garage'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} hooked up in ${location}`;
      outcome = 'dramatic';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: 15 + Math.floor(Math.random() * 20)
      }];
      // Upgrade relationship
      if (rel) {
        rel.type = Math.random() < 0.6 ? 'romantic' : 'friends_with_benefits';
        rel.strength = Math.min(100, rel.strength + 20);
      }
    } else if ((relType === 'rival' || relType === 'enemy') && Math.random() < 0.5) {
      eventType = 'argument';
      const reasons = ['work project', 'personal issue', 'office gossip', 'petty disagreement'];
      const reason = reasons[Math.floor(Math.random() * reasons.length)];
      description = `${emp1.name} and ${emp2.name} had a heated argument about ${reason}`;
      outcome = 'negative';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: -10 - Math.floor(Math.random() * 15)
      }];
    } else {
      // Neutral social events
      const eventTypes = [
        { type: 'lunch', desc: 'had lunch together at', outcome: 'positive', impact: 3 },
        { type: 'drinks', desc: 'grabbed drinks after work at', outcome: 'positive', impact: 5 },
        { type: 'project', desc: 'worked together on a project', outcome: 'neutral', impact: 2 },
        { type: 'gossip_session', desc: 'had a long gossip session about the office', outcome: 'neutral', impact: 4 },
        { type: 'coffee', desc: 'got coffee together', outcome: 'positive', impact: 2 }
      ];
      
      const chosen = eventTypes[Math.floor(Math.random() * eventTypes.length)];
      eventType = chosen.type;
      outcome = chosen.outcome;
      
      if (chosen.type === 'gossip_session') {
        description = `${emp1.name} and ${emp2.name} ${chosen.desc}`;
      } else {
        const locations = ['the local café', 'Murphy\'s Bar', 'that new place downtown'];
        description = `${emp1.name} and ${emp2.name} ${chosen.desc} ${chosen.type === 'project' ? '' : locations[Math.floor(Math.random() * locations.length)]}`;
      }
      
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: chosen.impact + Math.floor(Math.random() * 3)
      }];
    }
    
    // Determine who witnessed it (0-3 random employees at same location)
    const location = emp1.locationId || 'headquarters';
    const potentialWitnesses = activeEmployees.filter(e => 
      e.locationId === location && 
      !participants.find(p => p.id === e.id)
    );
    const witnessCount = Math.floor(Math.random() * Math.min(4, potentialWitnesses.length + 1));
    const witnessed = [];
    for (let i = 0; i < witnessCount; i++) {
      const witness = potentialWitnesses[Math.floor(Math.random() * potentialWitnesses.length)];
      if (witness && !witnessed.includes(witness.id)) {
        witnessed.push(witness.id);
      }
    }
    
    // Create the event
    const event = createSimulatedEvent({
      type: eventType,
      participants: participants.map(p => p.id),
      location,
      description,
      outcome,
      relationshipImpacts,
      witnessed
    });
    
    // Apply relationship impacts
    relationshipImpacts.forEach(impact => {
      updateRelationship(impact.employeeId1, impact.employeeId2, {
        event: eventType,
        impact: impact.change
      });
    });
    
    // Store event for participants
    participants.forEach(emp => {
      initializeGossipSystem(emp);
      emp.recentSimulatedEvents.push(event);
      if (emp.recentSimulatedEvents.length > 10) {
        emp.recentSimulatedEvents = emp.recentSimulatedEvents.slice(-10);
      }
    });
    
    // Create gossip if event is juicy enough
    if (event.generatesGossip && (eventType === 'hookup' || eventType === 'argument' || eventType === 'date')) {
      const juiciness = eventType === 'hookup' ? 80 : eventType === 'argument' ? 60 : 50;
      
      const gossipContent = description;
      const gossip = createGossipItem({
        type: eventType,
        subjectId: emp1.id,
        targetId: emp2.id,
        content: gossipContent,
        juiciness,
        originatorId: witnessed.length > 0 ? witnessed[0] : emp1.id,
        tags: [outcome, 'simulated']
      });
      
      // Witnesses know about it immediately
      witnessed.forEach(witnessId => {
        const witness = activeEmployees.find(e => e.id === witnessId);
        if (witness) {
          initializeGossipSystem(witness);
          witness.gossip.knownGossip.push({
            gossipId: gossip.id,
            learnedAt: Date.now(),
            source: 'witnessed',
            accuracy: 100
          });
        }
      });
      
      // Store gossip globally
      if (!gameState.socialNetwork.activeGossip) {
        gameState.socialNetwork.activeGossip = [];
      }
      gameState.socialNetwork.activeGossip.push(gossip);
      
      // Trigger gossip spread after a delay
      setTimeout(() => spreadGossip(gossip.id), 5000 + Math.random() * 10000);
    }
    
    console.log(`[GossipEngine] Simulated event: ${description}`);
  }
  
  /**
   * Spread gossip between NPCs
   */
  function spreadGossip(gossipId) {
    const gossip = gameState.socialNetwork.activeGossip?.find(g => g.id === gossipId);
    if (!gossip) return;
    
    // Find who knows about this gossip
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    const knowers = activeEmployees.filter(emp => {
      initializeGossipSystem(emp);
      return emp.gossip.knownGossip.some(g => g.gossipId === gossipId);
    });
    
    if (knowers.length === 0) return;
    
    // Each knower has a chance to spread it
    knowers.forEach(knower => {
      initializeGossipSystem(knower);
      
      // Check if they're a gossip
      if (Math.random() * 100 > knower.gossip.gossipTendency) return;
      
      // Find someone to tell (friend or coworker)
      const potentialListeners = activeEmployees.filter(emp => {
        if (emp.id === knower.id) return false;
        initializeGossipSystem(emp);
        // Don't tell if they already know
        if (emp.gossip.knownGossip.some(g => g.gossipId === gossipId)) return false;
        
        // More likely to tell friends or coworkers at same location
        const rel = knower.relationships?.[emp.id];
        const sameLoc = knower.locationId === emp.locationId;
        return sameLoc || (rel && ['friend', 'best_friend'].includes(rel.type));
      });
      
      if (potentialListeners.length === 0) return;
      
      const listener = potentialListeners[Math.floor(Math.random() * potentialListeners.length)];
      
      // Calculate accuracy degradation (like telephone game)
      const knowerAccuracy = knower.gossip.knownGossip.find(g => g.gossipId === gossipId)?.accuracy || 100;
      const trustFactor = knower.gossip.trustworthiness / 100;
      const newAccuracy = Math.max(0, Math.floor(knowerAccuracy * trustFactor * (0.85 + Math.random() * 0.15)));
      
      // Listener learns the gossip
      listener.gossip.knownGossip.push({
        gossipId: gossip.id,
        learnedAt: Date.now(),
        source: knower.id,
        accuracy: newAccuracy
      });
      
      gossip.spreadCount++;
      
      console.log(`[GossipEngine] ${knower.name} told ${listener.name} about: ${gossip.content} (accuracy: ${newAccuracy}%)`);
    });
  }
  
  /**
   * Get gossip that an employee knows about
   */
  function getKnownGossip(employeeId, limit = 5) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeGossipSystem(emp);
    
    const now = Date.now();
    const allGossip = gameState.socialNetwork.activeGossip || [];
    
    // Filter to gossip they know that hasn't expired
    const knownGossipItems = emp.gossip.knownGossip
      .map(kg => {
        const gossip = allGossip.find(g => g.id === kg.gossipId);
        if (!gossip || gossip.expiresAt < now) return null;
        return { ...gossip, learnedAt: kg.learnedAt, accuracy: kg.accuracy, source: kg.source };
      })
      .filter(Boolean)
      .sort((a, b) => b.juiciness - a.juiciness) // Sort by juiciness
      .slice(0, limit);
    
    return knownGossipItems;
  }
  
  /**
   * Generate gossip about player's actions
   * Called when player does something noteworthy with an NPC
   */
  function createPlayerGossip({ type, npcId, description, juiciness = 50 }) {
    const npc = gameState.employees.find(e => e.id === npcId);
    if (!npc) return;
    
    initializeGossipSystem(npc);
    
    const gossip = createGossipItem({
      type,
      subjectId: 'player',
      targetId: npcId,
      content: description,
      juiciness,
      originatorId: npcId,
      tags: ['player_action']
    });
    
    // NPC knows about it (obviously)
    npc.gossip.knownGossip.push({
      gossipId: gossip.id,
      learnedAt: Date.now(),
      source: 'personal_experience',
      accuracy: 100
    });
    
    // Store globally
    if (!gameState.socialNetwork.activeGossip) {
      gameState.socialNetwork.activeGossip = [];
    }
    gameState.socialNetwork.activeGossip.push(gossip);
    
    // NPC might tell others based on their gossip tendency and the juiciness
    if (npc.gossip.gossipTendency > 40 || juiciness > 70) {
      setTimeout(() => spreadGossip(gossip.id), 3000 + Math.random() * 7000);
    }
    
    console.log(`[GossipEngine] Created player gossip: ${description}`);
  }
  
  /**
   * Get gossip context for chat/posts
   * Returns formatted string with gossip the NPC knows
   */
  function getGossipContext(employeeId, includePlayerGossip = true) {
    const knownGossip = getKnownGossip(employeeId, 3);
    if (knownGossip.length === 0) return '';
    
    let context = '\n\nRECENT GOSSIP YOU KNOW ABOUT:\n';
    
    knownGossip.forEach(gossip => {
      // Skip player gossip if not requested
      if (!includePlayerGossip && gossip.subjectId === 'player') return;
      
      const subject = gossip.subjectId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.subjectId)?.name || 'someone';
      
      const target = gossip.targetId ? 
                    (gossip.targetId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.targetId)?.name || 'someone') : '';
      
      const accuracy = gossip.accuracy < 50 ? ' (but this might be a rumor)' : 
                      gossip.accuracy < 80 ? ' (heard through the grapevine)' : '';
      
      context += `- ${gossip.content}${accuracy}\n`;
    });
    
    context += '\nYou can reference this gossip naturally in conversation if relevant!\n';
    
    return context;
  }
  
  /**
   * Cleanup expired gossip
   */
  function cleanupExpiredGossip() {
    if (!gameState.socialNetwork.activeGossip) return;
    
    const now = Date.now();
    const before = gameState.socialNetwork.activeGossip.length;
    
    gameState.socialNetwork.activeGossip = gameState.socialNetwork.activeGossip
      .filter(g => g.expiresAt > now);
    
    const removed = before - gameState.socialNetwork.activeGossip.length;
    if (removed > 0) {
      console.log(`[GossipEngine] Cleaned up ${removed} expired gossip items`);
    }
  }

  // -------- NPC MEMORY & DIALOGUE HELPERS (professional-grade) --------
  // Lightweight tokenization
  function tokenize(text) {
    return (text || '')
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(Boolean);
  }

  // Extract main topics from a message for anti-repetition tracking
  function extractTopics(message, emp) {
    const topics = [];
    const m = message.toLowerCase();
    
    // Check for job/work mentions
    if (emp.productManaged && m.includes(emp.productManaged.toLowerCase())) {
      topics.push('job_specific');
    }
    if (emp.position && m.includes(emp.position.toLowerCase())) {
      topics.push('job_title');
    }
    if (/\b(work|job|task|project|deadline)\b/.test(m)) {
      topics.push('work_general');
    }
    
    // Check for hobby mentions
    (emp.hobbies || []).forEach(h => {
      if (m.includes(h.toLowerCase())) topics.push(`hobby_${h}`);
    });
    
    // Check for relationship topics
    if (/\b(date|dinner|coffee|drinks|hang out)\b/.test(m)) topics.push('social_invite');
    if (/\b(flirt|cute|hot|sexy|attractive)\b/.test(m)) topics.push('flirting');
    if (/\b(kiss|touch|intimate|physical)\b/.test(m)) topics.push('physical');
    if (/\b(love|feel|emotion|heart)\b/.test(m)) topics.push('emotional');
    
    return topics;
  }

  // Ensure structured memory on employee (back-compat from array of strings)
  function ensureEmployeeMemory(emp) {
    if (!emp) return;
    if (!emp.memory || Array.isArray(emp.memory)) {
      const prev = Array.isArray(emp.memory) ? emp.memory : [];
      emp.memory = { 
        items: [], 
        cap: 300, // Increased to 300 for extensive long-term memory
        styleCounters: { 
          total: 0, 
          sincePersonal: 99,
          recentTopics: [], // track last 10 topics mentioned
          jobMentions: 0,
          hobbyMentions: 0,
          lastJobMention: 0,
          lastHobbyMention: 0
        },
        conversationPhase: 'early', // early, familiar, intimate
        intimacyLevel: 0 // 0-100 scale
      };
      // ingest old strings as low-importance notes
      for (const s of prev) remember(emp, s, 'note', 0.5);
    } else if (!emp.memory.styleCounters) {
      emp.memory.styleCounters = { 
        total: 0, 
        sincePersonal: 99,
        recentTopics: [],
        jobMentions: 0,
        hobbyMentions: 0,
        lastJobMention: 0,
        lastHobbyMention: 0
      };
    }
    
    // Upgrade existing memory caps
    if (emp.memory.cap && emp.memory.cap < 300) {
      emp.memory.cap = 300;
    }
    if (!emp.memory.conversationPhase) emp.memory.conversationPhase = 'early';
    if (emp.memory.intimacyLevel === undefined) emp.memory.intimacyLevel = 0;
    
    // Ensure personality object exists with C.O.F.P.H. attributes
    ensureEmployeePersonality(emp);
    
    // Ensure stats are properly initialized
    ensureEmployeeStats(emp);
  }
  
  /**
   * Ensure employee has personality attributes for AI
   * Migrates old employees who don't have these values
   */
  function ensureEmployeePersonality(emp) {
    if (!emp) return;
    
    // If personality is a string (old system), convert it
    if (typeof emp.personality === 'string') {
      const oldPersonality = emp.personality;
      emp.personalityTraits = [oldPersonality]; // Save the old value as a trait
      emp.personality = {}; // Reset to object
    }
    
    // If personality doesn't exist or is missing attributes, create/fill them
    if (!emp.personality || typeof emp.personality !== 'object') {
      emp.personality = {};
    }
    
    // Add missing attributes with randomized values
    if (emp.personality.confidence === undefined) {
      emp.personality.confidence = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.outgoing === undefined) {
      emp.personality.outgoing = 20 + Math.floor(Math.random() * 60); // 20-80
    }
    if (emp.personality.flirty === undefined) {
      emp.personality.flirty = 10 + Math.floor(Math.random() * 70); // 10-80
    }
    if (emp.personality.professional === undefined) {
      emp.personality.professional = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.humor === undefined) {
      emp.personality.humor = 20 + Math.floor(Math.random() * 60); // 20-80
    }
  }

  // Ensure employee has new stat system (migration from old stats)
  function ensureEmployeeStats(emp) {
    if (!emp || !emp.stats) {
      if (emp) emp.stats = {};
      else return;
    }
    
    const stats = emp.stats;
    
    // Migrate old stats to new system
    if (stats.love !== undefined && stats.affection === undefined) {
      stats.affection = stats.love;
      delete stats.love;
    }
    if (stats.efficiency !== undefined && stats.productivity === undefined) {
      stats.productivity = stats.efficiency;
      delete stats.efficiency;
    }
    if (stats.anger !== undefined) {
      // Convert anger to obedience (inverse relationship)
      if (stats.obedience === undefined) {
        stats.obedience = Math.max(0, 100 - stats.anger);
      }
      delete stats.anger;
    }
    
    // Initialize missing stats with defaults
    if (stats.affection === undefined) stats.affection = 30;
    if (stats.comfort === undefined) stats.comfort = 50;
    if (stats.trust === undefined) stats.trust = 40;
    if (stats.desire === undefined) stats.desire = 10;
    if (stats.obedience === undefined) stats.obedience = 50;
    if (stats.productivity === undefined) stats.productivity = 60;
    
    // Clamp all stats to 0-100
    for (const key of ['affection', 'comfort', 'trust', 'desire', 'obedience', 'productivity']) {
      if (stats[key] !== undefined) {
        stats[key] = Math.max(0, Math.min(100, stats[key]));
      }
    }
  }

  // Add an item to long-term memory with de-dup and cap
  function remember(emp, text, type = 'note', importance = 1) {
    if (!emp) return;
    ensureEmployeeMemory(emp);
    if (!text) return;
    
    // Defensive check - ensure items array exists
    if (!emp.memory || !emp.memory.items) {
      console.error('[Memory] Employee memory not properly initialized:', emp.name);
      ensureEmployeeMemory(emp);
      if (!emp.memory || !emp.memory.items) {
        console.error('[Memory] Failed to initialize memory for:', emp.name);
        return;
      }
    }
    
    const now = Date.now();
    const key = text.trim().toLowerCase();
    // merge if similar
    const existing = emp.memory.items.find(i => i.text.trim().toLowerCase() === key);
    if (existing) {
      existing.ts = now;
      existing.importance = Math.max(existing.importance, importance);
      existing.count = (existing.count || 1) + 1;
      return;
    }
    emp.memory.items.push({ text, type, importance, ts: now, count: 1 });
    if (emp.memory.items.length > emp.memory.cap) {
      // drop lowest score item
      emp.memory.items.sort((a,b)=> (a.importance + (a.count||1)*0.1) - (b.importance + (b.count||1)*0.1));
      emp.memory.items.shift();
    }
  }

  // Extract salient facts from a message for memory
  function extractSalientFacts(message, emp) {
    const facts = [];
    if (!message) return facts;
    const m = message.toLowerCase();
    const add = (text, type, imp=1.0) => facts.push({ text, type, importance: imp });
    
    // High-importance work events
    if (/\b(promot|raise|level up)\b/.test(m)) add('Discussed promotion/raise', 'event', 1.8);
    if (/\b(fire|fir(e|ing)|terminat(e|ion))\b/.test(m)) add('Termination discussed', 'event', 2.0);
    if (/\b(deadline|ship|launch|deliver(y|able)?)\b/.test(m)) add('Work deadline mentioned', 'work', 1.3);
    
    // Medium-importance interactions
    if (/\b(gift|present|bonus)\b/.test(m)) add('Gift or bonus mentioned', 'event', 1.4);
    if (/\b(meet(ing)?|1:1|one on one)\b/.test(m)) add('Meeting planned', 'event', 1.1);
    if (/\b(date|coffee|lunch|dinner)\b/.test(m) && !/deadline/.test(m)) add('Social invitation', 'relation', 1.5);
    
    // Emotional/relationship markers
    if (/\b(thank|appreciate|grateful)\b/.test(m)) add('Expressed gratitude', 'relation', 1.0);
    if (/\b(sorry|apolog|my bad)\b/.test(m)) add('Apologized', 'relation', 1.0);
    if (/\b(love|adore|crush)\b/.test(m)) add('Romantic sentiment', 'relation', 1.6);
    if (/\b(frustrat|annoy|angry|upset)\b/.test(m)) add('Negative emotion', 'relation', 1.2);
    
    // Intimacy progression (context-aware)
    if (/\b(flirt|tease|cute|hot|sexy|attractive)\b/.test(m)) add('Flirtatious exchange', 'relation', 1.4);
    if (/\b(kiss|touch|hold|hug|embrace)\b/.test(m)) add('Physical affection discussed', 'intimacy', 1.7);
    if (/\b(want|desire|need) (you|me|us)\b/.test(m)) add('Expressed desire', 'intimacy', 1.5);
    
    // Avoid over-logging job mentions - only log if it's a significant event
    // NOT: routine job mentions
    
    return facts;
  }

  // Score memory relevance versus last message tokens
  function scoreMemory(item, tokens, emp) {
    const overlap = tokens ? tokens.filter(t => item.text.toLowerCase().includes(t)).length : 0;
    const recency = 1 / Math.max(1, (Date.now() - (item.ts || 0)) / (1000*60*60)); // hours decay
    
    // Penalize job/hobby mentions if they were mentioned recently
    let repetitionPenalty = 0;
    if (emp && emp.memory && emp.memory.styleCounters) {
      const counters = emp.memory.styleCounters;
      const text = item.text.toLowerCase();
      
      // Check if this memory is about job/hobbies
      const isJobRelated = /\b(manage|job|work|position|role)\b/.test(text) || 
                          (emp.productManaged && text.includes(emp.productManaged.toLowerCase()));
      const isHobbyRelated = (emp.hobbies || []).some(h => text.toLowerCase().includes(h.toLowerCase()));
      
      if (isJobRelated && (counters.total - counters.lastJobMention) < 5) {
        repetitionPenalty = 2.0; // Heavy penalty if job mentioned in last 5 messages
      }
      if (isHobbyRelated && (counters.total - counters.lastHobbyMention) < 6) {
        repetitionPenalty = 2.5; // Even heavier penalty for hobbies
      }
    }
    
    // Boost relationship/emotional memories
    const typeBoost = (item.type === 'relation' || item.type === 'intimacy') ? 0.8 : 0;
    
    return overlap * 0.6 + (item.importance || 1) * 0.9 + recency * 0.5 + (item.count || 1) * 0.1 + typeBoost - repetitionPenalty;
  }

  function retrieveMemories(emp, lastMessage, limit = 25) {
    ensureEmployeeMemory(emp);
    const tokens = tokenize(lastMessage).slice(0, 20);
    return emp.memory.items
      .slice()
      .sort((a, b) => scoreMemory(b, tokens, emp) - scoreMemory(a, tokens, emp))
      .slice(0, limit);
  }

  /**
   * Calculate NPC spending rate scaled to company progression
   * As the company grows, employees develop more expensive lifestyles
   */
  function calculateScaledSpendingRate(baseRate = null) {
    // Company scale based on total cash (log scale)
    // $1K company = scale 1.0x
    // $10K company = scale 1.2x
    // $100K company = scale 1.5x
    // $1M company = scale 2.0x
    // $10M company = scale 3.0x
    // $100M company = scale 4.5x
    // $1B company = scale 6.0x
    const companyValue = Math.max(1000, gameState.cash);
    const companyLog = Math.log10(companyValue);
    
    // Scale factor: ranges from 1.0x at $1K to ~6x at $1B+
    // Formula: 1 + (log10(cash) - 3) * 0.5
    // This means every 10x increase in company value = +0.5x spending multiplier
    const scaleFactor = Math.max(1.0, 1 + (companyLog - 3) * 0.5);
    
    // Base rate if not provided (new employee)
    if (baseRate === null) {
      baseRate = 50 + Math.random() * 100; // $50-150/day
    }
    
    // Apply scale factor
    const scaledRate = baseRate * scaleFactor;
    
    // Cap at reasonable maximum to prevent absurdity
    // At $1B+ company, max spending could be ~$50K/day for materialistic employees
    const maxRate = 50000;
    
    return Math.min(scaledRate, maxRate);
  }

  // ========== AI CONTEXT QUALITY FUNCTIONS ==========
  // Prevent repetitive patterns and enhance response variety
  
  /**
   * Initialize tracking for an employee if it doesn't exist
   */
  function initializeAITracking(employeeId) {
    if (!gameState.aiContextQuality.employeeTracking[employeeId]) {
      gameState.aiContextQuality.employeeTracking[employeeId] = {
        physicalActions: [],      // Track recent physical actions (arching, gasping, etc.)
        narrativeAnchors: [],     // Track callback references (Buddy, scar, budget jokes)
        sensoryWords: [],         // Track descriptive words (breathless, trembling, warm)
        responseStructures: [],   // Track sentence patterns (em-dashes, gerunds)
        humorCount: 0,           // Track meta-commentary frequency
        lastResponseTime: Date.now()
      };
    }
    
    if (!gameState.aiContextQuality.intimacyEscalation[employeeId]) {
      gameState.aiContextQuality.intimacyEscalation[employeeId] = 0;
    }
  }
  
  /**
   * Analyze a response for repetitive patterns
   * Returns warnings to inject into the next prompt
   */
  function analyzeResponseForRepetition(employeeId, response) {
    initializeAITracking(employeeId);
    const tracking = gameState.aiContextQuality.employeeTracking[employeeId];
    const warnings = [];
    
    // Extract patterns from response
    const lowerResponse = response.toLowerCase();
    
    // 1. Check for repetitive physical actions
    const physicalPatterns = [
      { pattern: /arch(ing|ed|es)?\s+(back|spine)/i, name: 'arching_back' },
      { pattern: /gasp(ing|ed|s)?\b/i, name: 'gasping' },
      { pattern: /(fingers?|hands?)\s+(tangl(ing|ed|es)|in|through)\s+hair/i, name: 'fingers_in_hair' },
      { pattern: /(nails?|fingernails?)\s+(dig|digging|dug|scrap|scraping|scraped)/i, name: 'nails_digging' },
      { pattern: /trembl(ing|ed|es|e)\b/i, name: 'trembling' },
      { pattern: /(legs?|ankles?)\s+(hook|hooking|hooked|lock|locking|locked|wrap|wrapping|wrapped)/i, name: 'legs_hooking' },
      { pattern: /shudder(ing|ed|s)?\b/i, name: 'shuddering' }
    ];
    
    const foundActions = [];
    for (const {pattern, name} of physicalPatterns) {
      if (pattern.test(response)) {
        foundActions.push(name);
        
        // Check if this action appeared recently
        const recentCount = tracking.physicalActions.filter(a => a === name).length;
        if (recentCount >= gameState.aiContextQuality.maxSameAction) {
          warnings.push(`⚠️ REPETITION ALERT: You've used "${name.replace(/_/g, ' ')}" ${recentCount + 1} times in recent responses. Use a completely different physical reaction this time.`);
        }
      }
    }
    
    // 2. Check for narrative anchors (callbacks)
    const anchorPatterns = [
      { pattern: /\bbuddy\b/i, name: 'buddy_cat' },
      { pattern: /\b(budget|thrift.?store|therapy|co.?pay|cheap|expensive)\b/i, name: 'budget_humor' },
      { pattern: /\bscar(red)?\b/i, name: 'scar_reference' },
      { pattern: /\bwork.?life\s+separation\b/i, name: 'work_life_joke' }
    ];
    
    const foundAnchors = [];
    for (const {pattern, name} of anchorPatterns) {
      if (pattern.test(response)) {
        foundAnchors.push(name);
        
        const recentCount = tracking.narrativeAnchors.filter(a => a === name).length;
        if (recentCount >= gameState.aiContextQuality.maxSameAnchor) {
          warnings.push(`⚠️ CALLBACK OVERUSE: You've referenced "${name.replace(/_/g, ' ')}" ${recentCount + 1} times recently. Find NEW details or humor - retire this callback.`);
        }
      }
    }
    
    // 3. Check for repetitive sensory words
    const sensoryPatterns = [
      { pattern: /\bbreath(less|lessly|ing|s)\b/i, name: 'breath' },
      { pattern: /\b(warm|heat|hot|burning|burns?|burned)\b/i, name: 'warmth' },
      { pattern: /\b(soft|softly|gentle|gently)\b/i, name: 'softness' },
      { pattern: /\b(sharp|sharply)\b/i, name: 'sharpness' }
    ];
    
    const foundSensory = [];
    for (const {pattern, name} of sensoryPatterns) {
      if (pattern.test(response)) {
        foundSensory.push(name);
      }
    }
    
    // Check if too many same sensory words
    const sensoryCounts = {};
    tracking.sensoryWords.forEach(w => sensoryCounts[w] = (sensoryCounts[w] || 0) + 1);
    foundSensory.forEach(w => {
      if (sensoryCounts[w] >= 2) {
        warnings.push(`⚠️ SENSORY REPETITION: You've overused "${w}" descriptors. Use alternatives from vocabulary bank.`);
      }
    });
    
    // 4. Check for structural patterns
    const emDashCount = (response.match(/—/g) || []).length;
    if (emDashCount >= 3) {
      const recentDashUsage = tracking.responseStructures.filter(s => s === 'em_dash_heavy').length;
      if (recentDashUsage >= 1) {
        warnings.push(`⚠️ PUNCTUATION OVERUSE: You're relying too heavily on em-dashes (—). Use different punctuation: semicolons, short declaratives, or ellipses.`);
      }
      foundActions.push('em_dash_heavy');
    }
    
    // Check for gerund openings
    if (/^(arching|melting|hooking|gasping|leaning|pressing|pulling|pushing|sliding)/i.test(response.trim())) {
      const recentGerunds = tracking.responseStructures.filter(s => s === 'gerund_opening').length;
      if (recentGerunds >= 1) {
        warnings.push(`⚠️ SENTENCE STRUCTURE: You're starting too many responses with gerunds (Arching, Melting, etc.). Start with subject, dialogue, or action verb instead.`);
      }
      foundActions.push('gerund_opening');
    }
    
    // 5. Check for excessive meta-commentary/humor
    const hasMetaCommentary = /\b(honestly|though honestly|but honestly|therapy|budget|thrift|cheap)\b/i.test(response);
    if (hasMetaCommentary) {
      tracking.humorCount++;
      
      // Calculate intimacy level for tonal modulation
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (emp) {
        const intimacyLevel = Math.round((emp.stats.affection + emp.stats.comfort + emp.stats.desire) / 3);
        gameState.aiContextQuality.intimacyEscalation[employeeId] = intimacyLevel;
        
        if (intimacyLevel > 70 && tracking.humorCount >= 2) {
          warnings.push(`⚠️ TONAL SHIFT NEEDED: Intimacy is VERY HIGH (${intimacyLevel}%). Reduce meta-commentary and humor. Allow genuine vulnerability and overwhelmed emotion without quips.`);
        }
      }
    } else {
      tracking.humorCount = Math.max(0, tracking.humorCount - 1);
    }
    
    // Update tracking (keep last 3 responses)
    tracking.physicalActions = [...foundActions, ...tracking.physicalActions].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.narrativeAnchors = [...foundAnchors, ...tracking.narrativeAnchors].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.sensoryWords = [...foundSensory, ...tracking.sensoryWords].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.responseStructures = [...tracking.responseStructures].slice(0, gameState.aiContextQuality.repetitionWindow);
    
    return warnings;
  }
  
  /**
   * Get variety guidance to inject into prompts
   */
  function getVarietyGuidance(employeeId) {
    initializeAITracking(employeeId);
    const banks = gameState.aiContextQuality.vocabularyBanks;
    
    // Randomly select alternatives from each category
    const randomFrom = (arr, count = 5) => {
      const shuffled = [...arr].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    };
    
    return `
🎨 RESPONSE VARIETY TOOLKIT:
Use these alternatives to avoid repetition:

PHYSICAL REACTIONS (instead of arching/gasping/trembling):
- Arousal: ${randomFrom(banks.arousal).join(', ')}
- Spinal: ${randomFrom(banks.spinalReactions, 3).join(', ')}
- Breath: ${randomFrom(banks.breathPatterns, 3).join(', ')}

SENSORY DESCRIPTORS (instead of warm/soft/breathless):
- Temperature: ${randomFrom(banks.temperature, 4).join(', ')}
- Texture: ${randomFrom(banks.texture, 4).join(', ')}
- Sounds: ${randomFrom(banks.vocalSounds, 4).join(', ')}

MOVEMENT QUALITY: ${randomFrom(banks.movementQuality, 5).join(', ')}

📝 STRUCTURE VARIETY:
- Rotate: em-dashes (—), semicolons (;), ellipses (...), short declaratives
- Vary openings: Don't always start with gerunds (Arching, Melting)
- Mix sentence lengths: Alternate complex and punchy

⚠️ AVOID: Recycling the same actions/words from your last 3 responses
`;
  }

  // Sanitize and tighten model outputs
  function sanitizeNpcResponse(text, maxSentences = 10) {
    if (!text) return '';
    let t = String(text);
    
    // ===== REMOVE PERCHANCE TOKENS (CRITICAL - MUST BE FIRST) =====
    // These are Perchance-specific formatting tokens that should NEVER appear in final output
    t = t.replace(/\{SEEDS:[^}]*\}\s*/gi, '');   // Remove {SEEDS:word|word}
    t = t.replace(/\{BAN:[^}]*\}\s*/gi, '');     // Remove {BAN:word|word}
    t = t.replace(/\{BOOST:[^}]*\}\s*/gi, '');   // Remove {BOOST:word|word}
    t = t.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');   // Remove any {TOKEN:...} pattern
    
    // ===== REMOVE META-ANALYSIS PATTERNS (CONSERVATIVE) =====
    // Only strip obvious meta-commentary, preserve natural dialogue formatting
    
    // Remove ONLY lines that explicitly start with meta-analysis labels followed by colon
    // Must be at start of line or after newline to avoid false positives
    t = t.replace(/(?:^|\n)\s*(Key choices:|Physical anchors:|Emotional arc:|Seed integration:|Relationship metrics:|Dialogue flow:|Meta commentary:|Scene breakdown:|Writing choices:|Character notes:|Technical details:).*?(?=\n|$)/gi, '');
    
    // Remove markdown headers ONLY if they contain meta keywords (### Key choices, etc.)
    t = t.replace(/^#{1,6}\s+(Key choices|Physical anchors|Emotional arc|Seed integration|Relationship metrics|Dialogue flow|Meta commentary|Scene breakdown|Writing choices).*$/gmi, '');
    
    // Remove stat tracking that appears at end: "Affection (82→85)" style
    // But ONLY if it's the specific stat tracking format with arrow
    t = t.replace(/\b(Affection|Trust|Desire|Intimacy|Obedience|Comfort)\s*\(\d+\s*→\s*\d+\)/gi, '');
    
    // Remove ONLY divider lines that are alone on their line (not part of dialogue)
    t = t.replace(/^[-*_]{3,}\s*$/gm, '');
    
    // Keep action descriptions in *asterisks* - these are intentional and important
    // Only strip bracketed actions which are less common
    t = t.replace(/\[(.*?)\]/g, '');
    
    // Remove only simple standalone reactions without context
    // This allows descriptive actions to remain while removing filler reactions
    t = t.replace(/^\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*\s*/gi, '');
    t = t.replace(/\s+\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*$/gi, '');
    
    // Collapse excessive whitespace and empty lines
    t = t.replace(/\n\s*\n\s*\n/g, '\n\n'); // Max 2 consecutive newlines
    t = t.replace(/\s+/g, ' ').trim();
    
    // Apply generous character limit - no sentence counting to avoid breaking on periods inside asterisks
    // This allows full dramatic responses with multiple action blocks to display properly
    const maxLength = 3000;
    if (t.length <= maxLength) {
      return t;
    }
    
    // If we need to truncate, try to find a sentence boundary near the limit
    // Look backwards from maxLength to find the last sentence ending
    const truncated = t.slice(0, maxLength);
    const lastSentenceEnd = Math.max(
      truncated.lastIndexOf('. '),
      truncated.lastIndexOf('! '),
      truncated.lastIndexOf('? ')
    );
    
    // If we found a sentence boundary in the last 500 chars, use it
    if (lastSentenceEnd > maxLength - 500) {
      return t.slice(0, lastSentenceEnd + 1).trim();
    }
    
    // Otherwise just truncate at maxLength and add ellipsis
    return truncated.trim() + '...';
  }

  // Build a professional, non-repetitive prompt
  function buildChatPrompt(emp, conversationHistory, lastMessage) {
    ensureEmployeeMemory(emp);
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    const personalAllowed = emp.memory.styleCounters.sincePersonal >= 4; // at most 1 in 4
    const relevant = retrieveMemories(emp, lastMessage, 40); // Retrieve up to 40 relevant memories

    // Calculate relationship/intimacy levels from stats
    const affection = emp.stats.affection ?? emp.stats.love ?? 0;
    const comfort = emp.stats.comfort ?? 0;
    const desire = emp.stats.desire ?? 0;
    const trust = emp.stats.trust ?? 0;
    const obedience = emp.stats.obedience ?? 50;
    const productivity = emp.stats.productivity ?? 50;
    const relationshipScore = (affection + comfort + desire) / 3;
    
    // Update conversation phase based on relationship
    if (relationshipScore > 70) emp.memory.conversationPhase = 'intimate';
    else if (relationshipScore > 40) emp.memory.conversationPhase = 'familiar';
    else emp.memory.conversationPhase = 'early';
    
    emp.memory.intimacyLevel = Math.min(100, Math.max(0, relationshipScore + desire * 0.3));

    // ===== STAT-BASED PERSONALITY MODIFIERS =====
    // These guide the AI's tone and behavior based on relationship stats
    // Designed to feel natural and authentic, not rigid or mechanical
    
    const affectionTone = (() => {
      if (affection < 25) {
        return 'EMOTIONAL DISTANCE: You don\'t have strong feelings for them yet. Be polite and professional, but don\'t go out of your way to be warm. Keep responses brief and focused. You\'re not cold, just... neutral.';
      } else if (affection < 50) {
        return 'FRIENDLY ACQUAINTANCE: You like them as a person. Be pleasant and cordial. Show basic interest in what they say. You enjoy chatting, but you\'re not especially close yet.';
      } else if (affection < 75) {
        return 'GENUINE WARMTH: You really like them. Be warm, enthusiastic, and engaged. You look forward to talking to them. Smile (through your words), show you care about their day and their feelings.';
      } else {
        return 'DEEP AFFECTION: You care deeply about them. Let warmth and fondness color everything you say. Be supportive, encouraging, and emotionally present. They matter to you - show it naturally through your words and tone.';
      }
    })();
    
    const comfortOpenness = (() => {
      if (comfort < 25) {
        return 'GUARDED & CAUTIOUS: You don\'t feel at ease around them yet. Keep personal details vague or avoided. If asked personal questions, give surface-level answers or deflect politely. You need more time to trust them.';
      } else if (comfort < 50) {
        return 'CAUTIOUSLY OPEN: You\'re starting to feel comfortable. You can share some personal details when asked, but keep deeper vulnerabilities to yourself. Test the waters - see how they react to small shares.';
      } else if (comfort < 75) {
        return 'RELAXED & OPEN: You feel comfortable being yourself around them. Share personal stories, thoughts, and feelings naturally. You don\'t feel judged. Be authentic and let your guard down.';
      } else {
        return 'COMPLETELY AT EASE: You feel totally comfortable with them. Share freely about your life, feelings, fears, dreams - nothing is off limits. You trust them with your vulnerable side. Be your truest self.';
      }
    })();
    
    const trustAuthenticity = (() => {
      if (trust < 25) {
        return 'LOW TRUST: You\'re cautious about their intentions. Don\'t reveal too much. If they make promises or requests, be skeptical. You need to see consistent behavior before believing what they say.';
      } else if (trust < 50) {
        return 'BUILDING TRUST: They seem reliable so far. You can be honest with them about surface-level things, but hold back on deeper vulnerabilities. Watch how they handle what you share.';
      } else if (trust < 75) {
        return 'SOLID TRUST: You believe in them. Be genuine and authentic. Share your real thoughts and feelings. You trust they have good intentions, even if you disagree sometimes.';
      } else {
        return 'COMPLETE TRUST: You trust them deeply. Be vulnerable, honest, and authentic. Share your fears, insecurities, and true self. You believe they\'ll support you and keep your confidence. This is a safe person.';
      }
    })();
    
    const desireAttraction = (() => {
      if (desire < 20) {
        return 'NO ROMANTIC INTEREST: You see them as a colleague/friend, nothing more. Romantic or suggestive topics feel inappropriate. Keep things platonic. If they flirt, politely redirect or ignore it.';
      } else if (desire < 40) {
        return 'SUBTLE ATTRACTION: You find them attractive, but you\'re not sure if you should act on it. Maybe drop subtle hints if it feels natural - a compliment here, a lingering look there. Don\'t push it.';
      } else if (desire < 60) {
        return 'CLEAR INTEREST: You\'re attracted to them and open to showing it. Engage in playful flirting. Compliment them. Use body language (*actions*) to show interest. Be receptive if they flirt back.';
      } else if (desire < 80) {
        return 'STRONG ATTRACTION: You want them. Be openly flirtatious and suggestive when appropriate. Show desire through words and actions. Respond enthusiastically to romantic/physical advances. The chemistry is obvious.';
      } else {
        return 'INTENSE DESIRE: You\'re very attracted to them physically and emotionally. Be forward about what you want. Don\'t hide your desire - let it show naturally in how you talk, tease, and respond to them.';
      }
    })();
    
    const obedienceAutonomy = (() => {
      if (obedience < 30) {
        return 'INDEPENDENT MINDED: You think for yourself and aren\'t easily swayed. If they make requests you disagree with, push back. Question things that don\'t feel right. You respect them but won\'t blindly follow.';
      } else if (obedience < 60) {
        return 'COOPERATIVE: You\'re willing to go along with reasonable requests. If something feels off, you might question it, but you generally trust their judgment. You balance following with thinking for yourself.';
      } else {
        return 'COMPLIANT: You naturally defer to their authority and judgment. When they ask for something, your instinct is to agree. You trust their decisions and feel comfortable following their lead.';
      }
    })();
    
    const workEthosEnergy = (() => {
      if (productivity < 30) {
        return 'STRESSED & OVERWHELMED: Work is tough right now. You might seem tired, distracted, or less enthusiastic. If conversation turns to work, you might express frustration or exhaustion. You\'re doing your best but struggling.';
      } else if (productivity < 60) {
        return 'BALANCED WORKER: You handle your job competently without it consuming you. Work is work - it\'s fine. You have energy for conversations but don\'t obsess over job performance.';
      } else {
        return 'ENERGIZED & ENGAGED: You\'re on top of your work and it shows. You have energy, confidence, and enthusiasm. You feel capable and accomplished. This positive energy carries into your conversations.';
      }
    })();

    // ===== OFFICE ATMOSPHERE GUIDANCE (0-100) =====
    // Affects formality, boundary enforcement, and topic openness
    const atmosphereGuidance = (() => {
      if (atmosphere < 33) {
        // Professional: Formal, boundaries maintained, focus on work
        return 'The office culture is PROFESSIONAL and FORMAL. Maintain professional distance, use proper titles, keep conversations work-focused. Personal topics should be minimal unless trust is very high. Boundaries are important and strictly maintained.';
      } else if (atmosphere > 66) {
        // Relaxed: Casual, boundaries flexible, open about personal topics
        return 'The office culture is RELAXED and CASUAL. You can be friendly, informal, and open about personal topics. Boundaries are flexible and you feel comfortable sharing. Work-life balance is valued and personal conversations are encouraged.';
      } else {
        // Balanced: Friendly but professional
        return 'The office culture is BALANCED - friendly yet professional. You can be personable and approachable while maintaining appropriate workplace boundaries. Personal topics are fine when rapport is established.';
      }
    })();

    // ===== INTERACTION STYLE GUIDANCE (0-100) =====
    // Affects personality warmth, openness, and relationship building ease
    const styleGuidance = (() => {
      if (guidelines < 33) {
        // Reserved: Distant, defensive, tsundere-like, slow to warm up
        return 'Your personality is RESERVED and GUARDED. You don\'t open up easily and may come across as distant, cool, or even defensive. You need significant time and trust before warming up to someone. You might use sarcasm or deflection to maintain emotional distance. Relationships develop slowly.';
      } else if (guidelines > 66) {
        // Outgoing: Friendly, expressive, eager to connect
        return 'Your personality is OUTGOING and WARM. You\'re naturally friendly, expressive, and enjoy connecting with people. You smile easily, engage enthusiastically, and make others feel welcome. You share personal thoughts openly and relationships develop naturally.';
      } else {
        // Standard: Balanced, realistic mix
        return 'Your personality is BALANCED and REALISTIC. You have your own mood and preferences - sometimes warm, sometimes reserved. You respond authentically based on the situation and your relationship level with the person.';
      }
    })();

    // ===== CONSENT MODEL GUIDANCE =====
    // Affects receptiveness to romantic/intimate advances
    const consentGuidance = (() => {
      const phase = emp.memory.conversationPhase;
      const intimacy = emp.memory.intimacyLevel;
      
      if (policy === 'open') {
        // Enthusiastic: Everyone is receptive and consenting
        if (intimacy > 60) {
          return 'CONSENT MODEL: Enthusiastic. The relationship is established and intimate. You\'re receptive, interested, and respond naturally to romantic/intimate topics with warmth and openness. No need to mention boundaries repeatedly - you\'re both on the same page. Be playful, authentic, and engaged.';
        } else if (intimacy > 30) {
          return 'CONSENT MODEL: Enthusiastic. There\'s chemistry developing. You\'re interested and receptive to romantic advances. Show your interest naturally without overthinking boundaries. Match the energy with genuine enthusiasm.';
        } else {
          return 'CONSENT MODEL: Enthusiastic. Even early on, you\'re open to connection. If romantic/intimate topics come up, respond with interest rather than caution. You\'re comfortable and consenting.';
        }
      } else if (policy === 'professional') {
        // Professional: Boundaries maintained, advances need high stats and are met cautiously
        if (intimacy > 70 && trust > 60) {
          return 'CONSENT MODEL: Professional. Despite high intimacy, maintain professional boundaries. If advances occur, acknowledge them thoughtfully but redirect to appropriate workplace behavior. Boundaries matter even when you care about someone.';
        } else {
          return 'CONSENT MODEL: Professional. Maintain clear professional boundaries. If romantic/intimate topics come up, politely redirect to work matters. You\'re friendly but this is a workplace - boundaries are important and non-negotiable.';
        }
      } else {
        // Casual: Open once comfortable, cautious at first
        if (intimacy > 50 && trust > 40) {
          return 'CONSENT MODEL: Casual. You\'re comfortable enough to be receptive to personal/romantic topics. You don\'t need to constantly mention boundaries - just respond naturally based on how you feel. If you\'re interested, show it. If not, be honest but kind.';
        } else {
          return 'CONSENT MODEL: Casual. You\'re still getting to know them. Be friendly and open but naturally cautious with romantic/intimate topics. Show interest if it feels right, but don\'t rush. Build rapport first.';
        }
      }
    })();

    // Dynamic style directives based on conversation flow
    const jobMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastJobMention) < 4;
    const hobbyMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastHobbyMention) < 5;
    
    // ========== AI QUALITY: Get repetition warnings and variety guidance ==========
    const recentHistory = gameState.chatHistory[emp.id] || [];
    const lastAIResponse = recentHistory.filter(msg => !msg.isPlayer).slice(-1)[0];
    const repetitionWarnings = lastAIResponse ? analyzeResponseForRepetition(emp.id, lastAIResponse.content) : [];
    const varietyToolkit = getVarietyGuidance(emp.id);
    
    const styleDirectives = [
      'Keep responses natural and conversational: 3-5 sentences, completing your thoughts fully.',
      'NEVER use puns or wordplay.',
      'You can describe what you\'re doing physically using *asterisks* for actions (e.g., *leans closer*, *blushes*, *touches your arm*). Use actions to show emotion and intent, especially during intimate or explicit moments.',
      'When the conversation is intimate, flirty, or explicit, DESCRIBE what you\'re doing physically - don\'t just talk about it. Show your actions and body language.',
      'CRITICAL - PHYSICAL APPEARANCE: DO NOT constantly describe your eye color, hair color, or what you\'re wearing in EVERY response. You already know what you look like - don\'t obsess over it. Only mention appearance details if: 1) They change (putting on/taking off clothing), 2) The player explicitly asks, or 3) It\'s the very first message. NEVER start multiple responses in a row with appearance descriptions.',
      'CRITICAL - STOP MENTIONING COWORKERS: DO NOT randomly bring up coworkers in EVERY message. You are having a conversation with the PLAYER, not running a gossip column. Only mention other employees if: 1) The player asks about them, 2) They are directly involved in the current situation, or 3) It\'s genuinely relevant to what you\'re saying. NEVER shoehorn coworker names into intimate/personal moments. IT\'S WEIRD.',
      'BANNED PHYSICAL ACTIONS: NEVER mention "knuckles" (whitening, clenching, tightening, etc.) - it\'s overused. Find fresh, varied ways to show tension, nervousness, or emotion through other body language: fidgeting, shifting weight, playing with hair/clothing, adjusting posture, eye movements, breathing changes, facial expressions, etc.',
      jobMentionedRecently ? 'DO NOT mention your job role or work responsibilities.' : null,
      hobbyMentionedRecently ? 'DO NOT mention your hobbies or personal interests.' : null,
      'Only mention job/hobbies if DIRECTLY asked about them.',
      'Speak like a real person in a workplace - keep it grounded and authentic.',
      'Vary your responses - avoid patterns and formulaic replies.',
      'AVOID overusing transition words like "honestly", "actually", "basically", "literally". Use them sparingly (once every 10+ messages at most).',
      'AVOID ending multiple messages in a row with questions like "But honestly?" or "Though honestly?" - vary your sentence structures.',
      'ALWAYS complete your sentences - do not trail off with ellipsis (...) unless being intentionally mysterious or hesitant.',
      'CRITICAL: Stay in character. NEVER add meta-commentary like "Key choices:", "Physical anchors:", "Emotional arc:", "Relationship metrics:", bullet points, or analysis of your own writing. Just BE the character.',
      '',
      // ========== INJECT REPETITION WARNINGS ==========
      ...(repetitionWarnings.length > 0 ? ['🚨 QUALITY ALERTS - CRITICAL:', ...repetitionWarnings, ''] : []),
      '',
      // ========== INJECT VARIETY TOOLKIT ==========
      varietyToolkit,
      '',
      '=== YOUR PERSONALITY BASED ON YOUR RELATIONSHIP ===',
      affectionTone,
      comfortOpenness,
      trustAuthenticity,
      desireAttraction,
      obedienceAutonomy,
      workEthosEnergy,
      '',
      '=== WORKPLACE CONTEXT ===',
      atmosphereGuidance,
      styleGuidance,
      consentGuidance
    ].filter(Boolean);

    const mood = `Affection: ${affection}%, Comfort: ${comfort}%, Trust: ${trust}%, Desire: ${desire}%`;

    // Get employee's recent posts
    const myRecentPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId === emp.id)
      .slice(0, 5) // Last 5 posts
      .map(p => {
        const imageNote = p.imageUrl ? ' [with image]' : '';
        return `I recently posted${imageNote}: "${p.content}"`;
      });
    
    // Get posts from other employees that this employee might know about
    const coworkerPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId !== emp.id && !p.isPlayerPost)
      .slice(0, 10) // Last 10 posts from others
      .map(p => {
        const author = gameState.employees.find(e => e.id === p.authorId);
        if (!author) return null;
        
        const imageNote = p.imageUrl ? ' with photo' : '';
        return `${author.name} posted${imageNote}: "${p.content}"`;
      })
      .filter(Boolean);
    
    // Check if player is EXPLICITLY asking about social media/posts (MORE RESTRICTIVE)
    // Must use clear social media keywords, not just casual mentions
    const askingAboutPost = /\b(what did .* post|saw.*post|check.*feed|on (the )?social|your (recent )?posts?|their posts?|see.*feed)\b/i.test(lastMessage);
    
    // Check if player mentions another employee name
    let coworkerMentionContext = [];
    let relationshipContext = [];
    for (const otherEmp of gameState.employees) {
      if (otherEmp.id !== emp.id && lastMessage.toLowerCase().includes(otherEmp.name.toLowerCase())) {
        // Player mentioned another employee
        
        // Check if current employee has a relationship with them
        const rel = emp.relationships?.[otherEmp.id];
        if (rel) {
          const relationshipTypes = {
            'friend': 'I\'m friends with',
            'best_friend': 'I\'m really close friends with',
            'crush': 'I have a crush on',
            'rival': 'I have a rivalry with',
            'enemy': 'I don\'t really get along with',
            'romantic': 'I\'m romantically involved with',
            'neutral': 'I know'
          };
          
          const relDesc = relationshipTypes[rel.type] || 'I know';
          relationshipContext.push(`${relDesc} ${otherEmp.name} (${otherEmp.position}). Our relationship strength: ${Math.round(rel.strength)}%.`);
          
          // Add some recent shared history if any
          if (rel.history && rel.history.length > 0) {
            const recentEvents = rel.history.slice(-2).map(h => h.event).join(', ');
            if (recentEvents) {
              relationshipContext.push(`Recent interactions: ${recentEvents}`);
            }
          }
        }
        
        // ONLY get their posts if player is explicitly asking about their social media
        // Don't flood context with posts just because player mentioned their name casually
        const askingAboutTheirPosts = /\b(what did|did .* post|saw.*post|their (recent )?posts?|see.*feed)\b/i.test(lastMessage);
        if (askingAboutTheirPosts) {
          const theirRecentPosts = (gameState.socialNetwork?.posts || [])
            .filter(p => p.authorId === otherEmp.id)
            .slice(0, 3)
            .map(p => `${otherEmp.name} recently posted: "${p.content}"`);
          
          if (theirRecentPosts.length > 0) {
            coworkerMentionContext.push(...theirRecentPosts);
          }
        }
        break; // Only handle one mentioned employee
      }
    }

    // Build context - prioritize relevant memories over static facts
    
    // Get player description
    const playerDescription = getPlayerDescription('conversation');
    
    // Add archived conversation context if available
    let archivedContext = [];
    if (emp.conversationArchive && emp.conversationArchive.length > 0) {
      const recentArchive = emp.conversationArchive.slice(-2); // Last 2 archived conversations
      const archiveSummary = recentArchive.flatMap(archive => {
        const messages = archive.messages.slice(-5); // Last 5 messages from each archive
        return messages.map(msg => `${msg.isPlayer ? 'Player' : emp.name}: ${msg.content}`);
      });
      
      if (archiveSummary.length > 0) {
        archivedContext = ['', '=== PAST CONVERSATION HISTORY (archived for context) ===', ...archiveSummary, '==='];
      }
    }
    
    // Add gossip context
    const gossipContext = getGossipContext(emp.id, true);
    const gossipLines = gossipContext ? gossipContext.split('\n').filter(Boolean) : [];
    
    // Gender-appropriate pronoun and description
    const genderInfo = emp.gender ? `, a ${emp.age || 'young'}-year-old ${emp.gender === 'male' ? 'man' : emp.gender === 'transMan' ? 'trans man' : emp.gender === 'transWoman' ? 'trans woman' : emp.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    // Get full physical description including genital information for self-awareness
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    // ========== 🚀 NUCLEAR CONTEXT INTEGRATION ==========
    // PHASE 3: Replace static context dumping with intelligent selection
    const intelligentContext = getIntelligentContext(emp, 'chat.casual', {
      message: lastMessage,
      recentMessages: conversationHistory.split('\n').slice(-5),
      involves: ['player']
    });
    
    // ========== FLAG CONTEXT INJECTION (NEW!) ==========
    // Get flag context for AI prompt (priority-sorted, time-aware)
    const flagContextString = buildAIContextFromFlags(emp);
    
    // ========== SKILL CONTEXT INJECTION (Phase 3) ==========
    // Get skill context for AI prompt (personality & abilities)
    const skillContextString = buildAIContextFromSkills(emp);
    
    // ========== TIME CONTEXT INJECTION (Phase 4) ==========
    // Get time/availability context for AI prompt
    const timeContextString = getTimeContextForChat(emp);
    
    const contextFacts = [
      // 🚀 INTELLIGENT CONTEXT SELECTED BY NUCLEAR SYSTEM
      '=== WHO YOU ARE & CURRENT STATE ===',
      intelligentContext,
      '',
      
      // Player description
      playerDescription,
      '',
      
      // Add time context (Phase 4)
      ...(timeContextString ? ['', timeContextString, ''] : []),
      
      // PHASE 6: Add office dynamics (ONLY if player asks about office/coworkers)
      // REMOVED automatic office social context - causes coworker name-dropping obsession
      
      // Add archived conversation context first (for broader context)
      ...archivedContext,
      
      // ONLY add social/coworker context if player is asking about it
      // This prevents constant coworker name-dropping in every message
      ...(myRecentPosts.length > 0 ? ['', '=== MY RECENT POSTS ===', ...myRecentPosts] : []),
      ...(askingAboutPost && coworkerPosts.length > 0 ? ['', '=== RECENT OFFICE POSTS ===', ...coworkerPosts.slice(0, 2)] : []),
      ...(relationshipContext.length > 0 ? ['', '=== MY RELATIONSHIP WITH MENTIONED COWORKER ===', ...relationshipContext] : []),
      ...(coworkerMentionContext.length > 0 ? ['', '=== POSTS FROM MENTIONED COWORKER ===', ...coworkerMentionContext] : []),
      
      // Relevant memories
      '',
      '=== RELEVANT MEMORIES ===',
      ...relevant.slice(0, 20).map(i => `Remember: ${i.text}`), // Show up to 20 relevant memories
    ].join('\n');

  // ========== TIME AWARENESS REINFORCEMENT (CRITICAL FIX) ==========
  // Get current time for immediate awareness (repeated for emphasis)
  const currentGameTime = timeHelpers.getFormattedTime();
  const currentTimeReminder = `\n🕐 CURRENT TIME RIGHT NOW: ${currentGameTime} - This is the ACTUAL current time, not when the conversation started. Time has passed during this conversation.`;
  
  const prompt = `${contextFacts}

Recent conversation:
${conversationHistory.split('\n').slice(-60).join('\n')}
${currentTimeReminder}

${emp.name}, the player just said: "${lastMessage}"

Response guidelines:
${styleDirectives.map((d, i) => `${i+1}. ${d}`).join('\n')}

Reply naturally as ${emp.name} (dialogue and actions - use *asterisks* for physical actions):`;
    
    return { prompt, personalAllowed };
  }

  // Get all DOM element references
  const settingsBtn = $('settingsBtn');
  const closeSettingsBtn = $('closeSettingsBtn');
  const densitySlider = $('densitySlider');
  const densityValue = $('densityValue');
  const autosaveToggle = $('autosaveToggle');
  const atmosphereSlider = $('atmosphereSlider');
  const atmosphereValue = $('atmosphereValue');
  const guidelinesSlider = $('guidelinesSlider');
  const guidelinesValue = $('guidelinesValue');
  const saveBtn = $('saveBtn');
  const loadBtn = $('loadBtn');
  const exportBtn = $('exportBtn');
  const resetBtn = $('resetBtn');

  const cashEl = $('cashEl');
  const cashPerSecEl = $('cashPerSecEl');
  const employeeCountEl = $('employeeCountEl');
  const productCountEl = $('productCountEl');
  const revenueEl = $('revenueEl');
  const employeeCountDashboardEl = $('employeeCountDashboardEl');
  const productCountDashboardEl = $('productCountDashboardEl');
  const efficiencyEl = $('efficiencyEl');

  const productsList = $('productsList');
  const employeesList = $('employeesList');
  const giftsList = $('giftsList');

  const newsFeed = $('newsFeed');
  const newsContent = $('newsContent');

  const settingsPanel = $('settingsPanel');

  const chatModal = $('chatModal');

  // Add debug buttons to settings panel
  if (settingsPanel && !document.getElementById('debugAddMoneyBtn')) {
    // Debug: Add Money
    const debugBtn = document.createElement('button');
    debugBtn.id = 'debugAddMoneyBtn';
    debugBtn.textContent = 'Add $100,000 (Debug)';
    debugBtn.style.cssText = 'margin:10px 0; padding:10px; background:#e94560; color:#fff; border:none; border-radius:6px; font-size:1rem; cursor:pointer; width:100%';
    debugBtn.onclick = function() {
      gameState.cash += 100000;
      showNotification('Added $100,000 (Debug)');
      updateUI(); // Use updateUI instead of directly setting cashEl
    };
    settingsPanel.appendChild(debugBtn);
    
    // Debug: Test Flag Detection
    const debugFlagBtn = document.createElement('button');
    debugFlagBtn.id = 'debugTestFlagBtn';
    debugFlagBtn.textContent = '🏷️ Test Flag Detection (Debug)';
    debugFlagBtn.style.cssText = 'margin:10px 0; padding:10px; background:#667eea; color:#fff; border:none; border-radius:6px; font-size:1rem; cursor:pointer; width:100%';
    debugFlagBtn.onclick = function() {
      if (gameState.activeChat && gameState.activeChat.id) {
        const emp = gameState.employees.find(e => e.id === gameState.activeChat.id);
        if (emp) {
          console.log('[DEBUG] Testing flag detection for', emp.name);
          console.log('[DEBUG] Tracking data:', gameState.flagDetection.tracking[emp.id]);
          console.log('[DEBUG] Suggestions:', gameState.flagDetection.suggestions.filter(s => s.employeeId === emp.id));
          
          // Force check suggestions
          checkFlagSuggestions(emp);
          showNotification(`Flag detection test complete. Check console for details.`, 'info');
        } else {
          showNotification('Open a chat first!', 'error');
        }
      } else {
        showNotification('Open a chat first to test flag detection!', 'error');
      }
    };
    settingsPanel.appendChild(debugFlagBtn);
  }
  const chatName = $('chatName');
  const chatAvatar = $('chatAvatar');
  const chatMessages = $('chatMessages');
  const chatTypingIndicator = $('chatTypingIndicator');
  const chatTypingName = $('chatTypingName');
  const chatInput = $('chatInput');
  const chatSendBtn = $('chatSendBtn');
  const closeChatBtn = $('closeChatBtn');
  const topBar = $('topBar'); // add near other DOM refs

  // ============================================
  // MODAL STATE MANAGER
  // ============================================
  // Centralized modal management to prevent z-index conflicts and visibility issues
  const ModalManager = {
    activeModals: [],
    baseZIndex: 10000,
    
    /**
     * Register and show a modal
     * @param {HTMLElement} modalElement - The modal DOM element
     * @param {string} modalId - Unique identifier for this modal
     */
    show(modalElement, modalId) {
      // Remove any existing instance of this modal
      this.close(modalId);
      
      // Calculate z-index (each modal gets progressively higher z-index)
      const zIndex = this.baseZIndex + (this.activeModals.length * 10);
      
      // Apply consistent modal styles
      modalElement.style.position = 'fixed';
      modalElement.style.top = '0';
      modalElement.style.left = '0';
      modalElement.style.width = '100%';
      modalElement.style.height = '100%';
      modalElement.style.display = 'flex';
      modalElement.style.justifyContent = 'center';
      modalElement.style.alignItems = 'center';
      modalElement.style.zIndex = zIndex;
      modalElement.style.pointerEvents = 'auto';
      
      // Add to DOM if not already present
      if (!modalElement.parentElement) {
        document.body.appendChild(modalElement);
      }
      
      // Track this modal
      this.activeModals.push({
        id: modalId,
        element: modalElement,
        zIndex: zIndex
      });
      
      console.log(`Modal opened: ${modalId} (z-index: ${zIndex})`);
      
      return modalElement;
    },
    
    /**
     * Close a specific modal
     * @param {string} modalId - The modal ID to close
     */
    close(modalId) {
      const index = this.activeModals.findIndex(m => m.id === modalId);
      if (index !== -1) {
        const modal = this.activeModals[index];
        
        // Remove from DOM
        if (modal.element.parentElement) {
          modal.element.remove();
        }
        
        // Remove from tracking
        this.activeModals.splice(index, 1);
        
        console.log(`Modal closed: ${modalId}`);
      }
    },
    
    /**
     * Close all modals
     */
    closeAll() {
      while (this.activeModals.length > 0) {
        const modal = this.activeModals[0];
        this.close(modal.id);
      }
    },
    
    /**
     * Check if a modal is currently open
     * @param {string} modalId - The modal ID to check
     */
    isOpen(modalId) {
      return this.activeModals.some(m => m.id === modalId);
    },
    
    /**
     * Get the currently active (top-most) modal
     */
    getActiveModal() {
      return this.activeModals.length > 0 
        ? this.activeModals[this.activeModals.length - 1] 
        : null;
    }
  };
  
  // Make it globally accessible
  window.ModalManager = ModalManager;

  // ============================================
  // END MODAL STATE MANAGER
  // ============================================

  // Initialize game
  async function initGame() {
    try {
      // Ensure all DOM elements are loaded before proceeding
      if (!topBar) {
        console.error('DOM elements not loaded yet');
        setTimeout(initGame, 100);
        return;
      }

      // Handle external plugin dependencies
      if (typeof generateText === 'undefined') {
        console.warn('AI text plugin not loaded - chat features will be limited');
        window.generateText = async (prompt) => "I'm having trouble responding right now.";
      }

      // Ensure onboarding array exists
      if (!gameState.onboarding) {
        gameState.onboarding = [];
      }

      // Ensure employees array exists
      if (!Array.isArray(gameState.employees)) {
        gameState.employees = [];
      }

      // Load saved game if exists (now async)
      await loadGame();

      // Initialize corporate pyramid hierarchy
      initializeHierarchicalPyramid();

      // Apply global cost reduction to all products (one-time on init)
      gameState.products.forEach(p => {
        // Only apply reduction if not already applied (check for a flag)
        if (!p._costReductionApplied) {
          p.baseUpgradeCost = Math.floor(p.baseUpgradeCost * gameBalance.globalCostReduction);
          p.upgradeCost = Math.floor(p.upgradeCost * gameBalance.globalCostReduction);
          p.managerHireCost = Math.floor(p.managerHireCost * gameBalance.managerCostReduction);
          p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * gameBalance.managerCostReduction);
          p._costReductionApplied = true;
        }
      });
      
      // Apply initial location theme
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation) {
        applyLocationTheme(activeLocation);
      }

      // Set up UI
      setupEventListeners();
      
      // Force initial UI update to populate all fields
      console.log('Initial updateUI() - gameState.cash:', gameState.cash);
      updateUI();
      
      // Initialize the default tab content (dashboard)
      updateTabContent(gameState.activeTab);
      
      // Force a second UI update after tab content is loaded to ensure everything is populated
      setTimeout(() => {
        console.log('Delayed updateUI() - gameState.cash:', gameState.cash);
        updateUI();
        updateTabContent(gameState.activeTab);
      }, 100);

      // Set up autosave
      setupAutosave();
      
      // Start AI optimization systems
      startRelationshipBatching();
      console.log('[AI Optimization] Systems initialized');
    } catch (error) {
      console.error('Error initializing game:', error);
      showNotification('Failed to initialize game. Please refresh the page.');
    }

    // Event delegation for product card buttons (bind once)
    if (!window.__productsDelegationBound__) {
      const productsList = document.getElementById('productsList');
      if (productsList) {
        productsList.addEventListener('click', (e) => {
          const btn = e.target.closest('button');
          if (!btn) return;
          const id = btn.dataset.id;
          if (!id) return;

          if (btn.classList.contains('sell-btn')) {
            startOrClickProduct(id);
            const p = gameState.products.find(x => x.id === id);
            const sellTxt = document.getElementById(`selltxt-${id}`);
            if (sellTxt) sellTxt.textContent = p?.running ? 'Click: -1s' : 'Sell';
            return;
          }
          if (btn.classList.contains('upgrade-product-btn')) return upgradeProduct(id);
          if (btn.classList.contains('manager-btn')) return hireOrUpgradeManager(id);
          if (btn.classList.contains('unlock-product-btn')) return unlockProduct(id);
        });
        window.__productsDelegationBound__ = true;
      }
    }

    // Start game loop
    setInterval(gameTick, GAME_TICK_INTERVAL);

    // Start news updates
    setInterval(updateNews, NEWS_UPDATE_INTERVAL);
    
    // Start proactive NPC messaging (check every 2 minutes)
    setInterval(checkForProactiveMessages, 120000);
    
    // Start GossipEngine™ - Simulate office events (check every 15 minutes)
    setInterval(simulateOfficeEvents, 900000); // 15 minutes
    
    // Cleanup expired gossip (check every hour)
    setInterval(cleanupExpiredGossip, 3600000); // 60 minutes
    
    // PHASE 4: Update time display frequently for smooth clock
    updateTimeDisplay(); // Initial update
    setInterval(updateTimeDisplay, 200); // Update every 200ms (5 times per second) for smooth ticking
  }

  // Generate a pool of potential hires
  // ============================================
  // PLAYER PROFILE UTILITIES
  // ============================================
  
  /**
   * Generate player description for AI prompts
   * @param {string} context - 'conversation', 'image', 'post', etc.
   * @returns {string} Formatted player description
   */
  function getPlayerDescription(context = 'conversation') {
    const p = gameState.playerProfile;
    
    // Build name
    const name = [p.firstName, p.lastName].filter(Boolean).join(' ') || 'the player';
    const fullName = p.firstName && p.lastName ? `${p.firstName} ${p.lastName}` : name;
    
    // Build basic description
    let desc = [];
    
    if (p.age) desc.push(`${p.age} year old`);
    if (p.gender) desc.push(p.gender);
    if (p.ethnicity) desc.push(`${p.ethnicity} ethnicity`);
    
    // Physical details
    const physical = [];
    if (p.height) physical.push(p.height);
    if (p.bodyType) physical.push(`${p.bodyType} build`);
    if (p.skinTone) physical.push(`${p.skinTone} skin`);
    
    if (physical.length > 0) {
      desc.push(physical.join(', '));
    }
    
    // Hair and eyes
    const features = [];
    if (p.hairColor && p.hairStyle) features.push(`${p.hairColor} ${p.hairStyle} hair`);
    else if (p.hairColor) features.push(`${p.hairColor} hair`);
    else if (p.hairStyle) features.push(`${p.hairStyle} hair`);
    
    if (p.eyeColor) features.push(`${p.eyeColor} eyes`);
    if (p.facialHair) features.push(p.facialHair);
    
    if (features.length > 0) {
      desc.push(features.join(', '));
    }
    
    // For image generation, add more intimate details
    if (context === 'image' || context === 'explicit') {
      const intimate = [];
      if (p.chestSize) intimate.push(p.chestSize);
      if (p.buildDetails) intimate.push(p.buildDetails);
      if (p.genitalType && p.genitalDetails) intimate.push(`${p.genitalType} (${p.genitalDetails})`);
      else if (p.genitalType) intimate.push(p.genitalType);
      
      if (intimate.length > 0 && context === 'explicit') {
        desc.push(intimate.join(', '));
      }
    }
    
    // Additional details
    if (p.additionalDetails) {
      desc.push(p.additionalDetails);
    }
    
    // Personality
    if (p.personality && context === 'conversation') {
      desc.push(`Personality: ${p.personality}`);
    }
    
    // Format based on context
    if (context === 'conversation') {
      // For conversations: "You are talking to THE PLAYER..."
      return desc.length > 0 
        ? `THE PLAYER (your boss) is: ${desc.join(', ')}.`
        : 'THE PLAYER is your boss.';
    } else if (context === 'image') {
      // For image generation: just the description
      return desc.join(', ') || 'person';
    } else if (context === 'post') {
      // For social posts about player
      return desc.length > 0
        ? `The boss (${fullName}): ${desc.join(', ')}`
        : `The boss (${fullName})`;
    } else {
      // Generic
      return desc.join(', ') || name;
    }
  }
  
  /**
   * Get simple player reference (name or "the boss")
   */
  function getPlayerName() {
    const p = gameState.playerProfile;
    if (p.firstName && p.lastName) return `${p.firstName} ${p.lastName}`;
    if (p.firstName) return p.firstName;
    return 'the boss';
  }

  // ============================================
  // HIRING & CANDIDATE GENERATION
  // ============================================
  
  // ============================================
  // MASSIVE NAME POOL - 500+ First Names, 300+ Last Names
  // ============================================
  const FIRST_NAMES_POOL = [
    // Original names (A-Z)
    'Eva','Maya','Lena','Zoe','Mia','Chloe','Aria','Lucy','Ella','Grace','Sophie','Lily','Nina','Kate','Jade','Ruby','Ivy','Cora','Daisy','Hazel','Violet','Willow','Iris','Piper','Quinn','Reese','Sage','Skye','Tessa','Wren','Zara','Cleo','Luna','Nova','Ember','Faye','Juno','Kira','Lyra','Mira','Nola','Rhea','Sia','Vera','Zia','Aurora','Bianca','Celeste','Delilah','Eden','Freya','Gemma','Harper','Isabelle','Jasmine','Keiko','Lexi','Madison','Natalie','Olivia','Penelope','Rosa','Serena','Tatiana','Uma','Vivian','Winter','Xena','Yuki','Zelda','Adelaide','Beatrice','Camilla','Daphne','Elise','Fiona','Genevieve','Holly','Imogen','Juniper','Kiara','Lila','Maeve','Nadia','Ophelia','Poppy','Quiana','Raven','Sienna','Thea','Ursula','Vienna','Willa','Ximena','Yasmin','Zola','Anastasia','Brooke','Cassandra','Diana','Elara','Faith','Giselle','Hannah','India','Juliet','Kali','Layla','Melody','Naomi','Ocean','Phoenix','Rayne','Stella','Trinity','Unity','Valentina','Waverly','Xyla','Yara','Zinnia','Amara','Brielle','Catalina','Dahlia','Evelina','Fallon','Gianna','Harlow','Ivanna','Jocelyn','Kensington','Marlowe','Nyx','Opal','Pearl','Quinlan','Rory','Sasha','Talia','Ulani','Vesper','Wilma','Xandra','Yvonne','Zoey','Alessia','Blair','Carmen','Dakota','Flora','Gia','Haven','Isla','Journey','Keira','Lotus','Margot','Nessa','Oriana','Paige','Riley','Savannah','Tamsin','Una','Veronica','Whitney','Xiomara','Yolanda','Zuri',
    // Expanded A-E names
    'Abigail','Addison','Adriana','Aisha','Alana','Alexa','Alexandra','Alexis','Alice','Alicia','Alina','Alison','Alyssa','Amanda','Amber','Amelia','Amy','Ana','Andrea','Angela','Angelina','Anita','Anna','Annabelle','Anne','Annie','April','Ariana','Ariel','Ashley','Athena','Audrey','Autumn','Ava','Avery','Bailey','Barbara','Bella','Bethany','Betty','Beverly','Bonnie','Brianna','Bridget','Brittany','Brooklyn','Caitlin','Callie','Candace','Cara','Carly','Carol','Carolina','Caroline','Carrie','Casey','Cassidy','Catherine','Cecilia','Charity','Charlene','Charlotte','Chelsea','Cheryl','Christina','Christine','Cindy','Claire','Clara','Clarissa','Claudia','Colleen','Constance','Courtney','Crystal','Cynthia','Dana','Danielle','Darlene','Dawn','Deanna','Deborah','Debra','Delia','Denise','Desiree','Destiny','Diane','Dominique','Donna','Dora','Doris','Dorothy','Elena','Eliana','Elizabeth','Ellen','Ellie','Eloise','Elodie','Elsa','Elsie','Emilia','Emily','Emma','Erica','Erin','Estelle','Esther','Ethel','Eugenia','Evelyn',
    // Expanded F-J names
    'Felicia','Fernanda','Florence','Frances','Francesca','Gabriela','Gabrielle','Gail','Georgia','Georgina','Geraldine','Gillian','Gina','Gladys','Glenda','Gloria','Grace','Gracie','Greta','Gwen','Gwendolyn','Hailey','Hanna','Haley','Harmony','Harriet','Hayley','Heather','Heidi','Helen','Helena','Henrietta','Hilary','Hilda','Hope','Iris','Irene','Isabel','Isabella','Ivana','Ivy','Jackie','Jaclyn','Jacqueline','Jade','Jada','Jane','Janet','Janice','Jaqueline','Jasmin','Jean','Jeanette','Jenna','Jennifer','Jenny','Jessica','Jessie','Jill','Jillian','Joan','Joanna','Joanne','Jocelyn','Jolene','Jordan','Jordana','Josephine','Josie','Joy','Joyce','Judith','Judy','Julia','Juliana','Julie','June','Justine',
    // Expanded K-O names
    'Kaitlyn','Kamila','Kara','Karen','Karina','Karla','Kayla','Kaylee','Kelly','Kelsey','Kendall','Kendra','Kennedy','Kenya','Khloe','Kim','Kimberly','Kirsten','Kristen','Kristin','Kristina','Krystal','Kylie','Kyra','Lacey','Lana','Lara','Larissa','Laura','Lauren','Laurie','Leah','Leanne','Lee','Leigh','Leila','Leilani','Leslie','Leticia','Lia','Liana','Libby','Liliana','Lillian','Lilith','Lilly','Linda','Lindsay','Lindsey','Lisa','Liz','Liza','Logan','Lois','Lola','Loretta','Lori','Lorraine','Louisa','Louise','Lucia','Lucille','Lucinda','Lucy','Lydia','Lynda','Lynn','Mackenzie','Macy','Madeline','Madelyn','Mae','Maeve','Maggie','Maia','Mallory','Mandy','Mara','Marcela','Marcia','Margaret','Margarita','Maria','Mariah','Marianne','Marie','Marilyn','Marina','Marion','Marisa','Marissa','Marjorie','Marlene','Martha','Mary','Matilda','Maureen','Maxine','Megan','Melanie','Melinda','Melissa','Mercedes','Meredith','Mia','Michaela','Michele','Michelle','Mikayla','Mila','Mildred','Millie','Mimi','Mindy','Miranda','Miriam','Misty','Molly','Monica','Monique','Morgan','Muriel','Myra','Myrtle','Nancy','Naomi','Natalia','Natasha','Nell','Nellie','Nicole','Nikki','Noelle','Nora','Norma','Octavia','Odette','Olga','Olive',
    // Expanded P-T names
    'Pamela','Pandora','Patience','Patricia','Patsy','Paula','Paulette','Pauline','Peyton','Phoebe','Phyllis','Polly','Priscilla','Prudence','Rachel','Rae','Ramona','Reagan','Rebecca','Rebekah','Regina','Renata','Renee','Rhiannon','Rhoda','Rita','Roberta','Robin','Rochelle','Rosalie','Rosalind','Rosalyn','Rose','Rosemary','Rosie','Rowena','Roxanne','Ruth','Sabrina','Sadie','Sally','Samantha','Sandra','Sandy','Sara','Sarah','Scarlett','Selena','Serena','Shannon','Shari','Sharon','Shauna','Shawn','Sheila','Shelby','Shelley','Shelly','Sheri','Sherry','Shirley','Sidney','Sierra','Simone','Skylar','Sloane','Sofia','Sonia','Sonya','Sophia','Sophie','Stacey','Stacy','Stefanie','Stephanie','Sue','Summer','Susan','Susanna','Suzanne','Sylvia','Tabitha','Talia','Tamara','Tami','Tammy','Tanya','Tara','Tatiana','Taylor','Teagan','Teresa','Terri','Terry','Tessa','Thelma','Theresa','Tiffany','Tina','Toni','Tonia','Tonya','Tracey','Tracy','Tricia','Trina','Trinity','Trisha',
    // Expanded U-Z names
    'Ursula','Valerie','Vanessa','Velma','Vera','Veronica','Vicki','Vickie','Vicky','Victoria','Viola','Virginia','Vivian','Vivienne','Wanda','Wendy','Whitney','Willow','Winifred','Yasmine','Yolanda','Yvette','Yvonne','Zelda','Zoe','Zoey','Zara'
  ];

  const MALE_FIRST_NAMES_POOL = [
    // A-Z masculine names (500+ names)
    'Aaron','Abel','Abraham','Adam','Adrian','Aiden','Alan','Albert','Alexander','Alfie','Alfred','Alonzo','Alvin','Amos','Andre','Andrew','Andy','Angelo','Angus','Anthony','Antonio','Apollo','Archer','Archie','Ari','Arlo','Arnold','Arthur','Ashton','Atlas','August','Austin','Axel','Bailey','Barnaby','Barrett','Barry','Bartholomew','Basil','Beau','Beck','Beckham','Benedict','Benjamin','Bennett','Benny','Bentley','Bernard','Bert','Blake','Blaze','Bobby','Boris','Boyd','Brad','Bradley','Brady','Brandon','Branden','Brayden','Brendan','Brent','Brett','Brian','Brice','Brock','Brody','Brooks','Bruce','Bruno','Bryan','Bryce','Bryson','Buck','Burt','Byron','Cade','Caden','Caleb','Calvin','Camden','Cameron','Carl','Carlos','Carlton','Carmelo','Carson','Carter','Casey','Caspian','Cecil','Cedric','Chad','Chance','Chandler','Charles','Charlie','Chase','Chester','Chris','Christian','Christopher','Clark','Claude','Clay','Clayton','Clement','Cliff','Clifford','Clifton','Clint','Clinton','Clive','Clyde','Cody','Cole','Coleman','Colin','Collin','Colton','Conner','Connor','Conrad','Cooper','Corbin','Corey','Cornelius','Cory','Craig','Curtis','Cyril','Cyrus','Dale','Dallas','Dalton','Damian','Damien','Damon','Dan','Dana','Dane','Daniel','Danny','Dante','Darian','Darius','Darrell','Darren','Darryl','Darwin','Dave','David','Davis','Dawson','Dean','Declan','Denis','Dennis','Denny','Denver','Derek','Derrick','Desmond','Devin','Devon','Dexter','Diego','Dillon','Dion','Dominic','Dominick','Don','Donald','Donovan','Douglas','Drake','Drew','Duane','Duncan','Dustin','Dwight','Dylan','Earl','Easton','Eddie','Edgar','Edison','Edmund','Edward','Edwin','Elbert','Eli','Elias','Elijah','Eliot','Elliott','Ellis','Ellison','Elmer','Elton','Elvis','Emanuel','Emerson','Emery','Emil','Emilio','Emmanuel','Emmett','Enrique','Eric','Erick','Erik','Ernest','Ernie','Ethan','Eugene','Evan','Everett','Ezekiel','Ezra','Fabian','Felix','Fernando','Fidel','Finley','Finn','Fletcher','Floyd','Flynn','Forest','Forrest','Foster','Francis','Francisco','Frank','Franklin','Frankie','Fred','Frederick','Gabriel','Gage','Garrett','Garrison','Garry','Gary','Gavin','Gene','Geoffrey','George','Gerald','Gerard','Gerardo','Gilbert','Gideon','Giovanni','Glenn','Gordon','Grady','Graham','Grant','Grayson','Greg','Gregory','Griffin','Grover','Guillermo','Gunnar','Gus','Gustavo','Guy','Hank','Hans','Harley','Harold','Harper','Harrison','Harry','Harvey','Hassan','Hector','Henry','Herbert','Herman','Holden','Homer','Horace','Howard','Hubert','Hudson','Hugh','Hugo','Humphrey','Hunter','Ian','Ibrahim','Ignacio','Igor','Ike','Ira','Irvin','Irving','Isaac','Isaiah','Ismael','Israel','Ivan','Iver','Jack','Jackson','Jacob','Jaden','Jaiden','Jake','Jalen','Jamal','James','Jamie','Jared','Jarrett','Jarvis','Jason','Jasper','Javier','Jay','Jayden','Jaylen','Jayson','Jean','Jed','Jefferson','Jeffrey','Jenson','Jerald','Jeremiah','Jeremy','Jermaine','Jerome','Jerry','Jesse','Jessie','Jesus','Jett','Jim','Jimmy','Joachim','Jody','Joe','Joel','Joey','Johan','John','Johnathan','Johnny','Jon','Jonah','Jonas','Jonathan','Jordan','Jorge','Jose','Joseph','Josh','Joshua','Josiah','Josue','Jovan','Juan','Judah','Jude','Julian','Julio','Julius','Junior','Justice','Justin','Kai','Kaleb','Kane','Karl','Karson','Keith','Kellan','Kellen','Kelly','Kelvin','Ken','Kendall','Kendrick','Kenneth','Kenny','Kent','Kenton','Kevin','Kieran','King','Kingston','Kirk','Knox','Kobe','Kody','Kolten','Konnor','Kristian','Kurt','Kurtis','Kyle','Kyler','Kyrie','Lance','Landon','Lane','Larry','Lars','Lawrence','Lawson','Layton','Lee','Leif','Leo','Leon','Leonard','Leonardo','Leroy','Les','Leslie','Lester','Levi','Lewis','Liam','Lincoln','Linden','Lionel','Lloyd','Logan','Lonnie','Lorenzo','Louis','Lowell','Lucas','Lucian','Luis','Lukas','Luke','Luther','Lyle','Lyndon','Mack','Maddox','Magnus','Major','Malachi','Malcolm','Malik','Manuel','Marc','Marcel','Marco','Marcos','Marcus','Mario','Marion','Mark','Marlon','Marshall','Martin','Marvin','Mason','Mateo','Mathew','Matthew','Maurice','Maverick','Max','Maxim','Maximilian','Maxwell','Melvin','Merle','Micah','Michael','Micheal','Miguel','Mike','Milo','Miles','Milton','Misael','Mitch','Mitchell','Moe','Monroe','Montana','Monte','Montgomery','Morgan','Morris','Mortimer','Morton','Moses','Murphy','Murray','Myles','Myron','Nash','Nasir','Nathan','Nathaniel','Neal','Ned','Neil','Nelson','Nestor','Neville','Nevin','Newton','Nicholas','Nick','Nico','Nicolas','Nigel','Niko','Nikolai','Niles','Noah','Noel','Nolan','Norman','Octavius','Odin','Oliver','Omar','Orlando','Orson','Oscar','Osvaldo','Otis','Otto','Owen','Pablo','Parker','Patrick','Paul','Paxton','Pedro','Perry','Peter','Peyton','Philip','Phillip','Phoenix','Pierce','Pierre','Porter','Preston','Prince','Quentin','Quincy','Quinn','Quinton','Rafael','Rafe','Ralph','Ramiro','Ramon','Randall','Randolph','Randy','Raphael','Raul','Ray','Raymond','Reagan','Reece','Reed','Reese','Reggie','Reginald','Reid','Remington','Remy','Rene','Reuben','Rex','Rey','Reynaldo','Rhett','Rhys','Ricardo','Richard','Rick','Ricky','Rico','Ridge','Riley','River','Robert','Roberto','Robin','Rocco','Rocky','Roderick','Rodney','Rodolfo','Rodrigo','Roger','Roland','Rolando','Roman','Romeo','Ron','Ronald','Ronan','Ronnie','Roosevelt','Rory','Roscoe','Ross','Rowan','Roy','Royce','Ruben','Rudy','Rufus','Rupert','Russell','Ryan','Ryder','Ryker','Rylan','Rylee','Sage','Salvador','Salvatore','Sam','Samir','Sammy','Sampson','Samuel','Santiago','Santos','Saul','Sawyer','Scott','Scotty','Sean','Sebastian','Sergio','Seth','Shane','Shannon','Shaun','Shawn','Shelby','Sheldon','Sherman','Sidney','Silas','Simeon','Simon','Sinclair','Solomon','Sonny','Spencer','Stacy','Stan','Stanford','Stanley','Stefan','Stephen','Sterling','Steve','Steven','Stevie','Stewart','Stuart','Sullivan','Sylvester','Tanner','Tate','Taylor','Ted','Teddy','Terrance','Terrell','Terrence','Terry','Thaddeus','Theodore','Thomas','Titus','Tobias','Toby','Todd','Tom','Tommy','Tony','Trace','Travis','Trent','Trenton','Trevor','Trey','Tristan','Troy','Truman','Tucker','Turner','Ty','Tyler','Tyrone','Tyson','Ulysses','Uri','Uriah','Uriel','Valentin','Van','Vance','Vaughn','Vernon','Vicente','Victor','Vince','Vincent','Virgil','Wade','Walker','Wallace','Walter','Ward','Warren','Washington','Watson','Waylon','Wayne','Webster','Wesley','Weston','Whitney','Wilbur','Wiley','Wilfred','Will','Willard','William','Willie','Willis','Willy','Wilson','Winston','Woodrow','Wyatt','Xavier','Xander','Yale','Yosef','Zachariah','Zachary','Zack','Zackary','Zackery','Zane','Zayden','Zechariah','Zeke','Zion'
  ];

  const LAST_NAMES_POOL = [
    // Original names
    'Smith','Johnson','Williams','Brown','Jones','Garcia','Miller','Davis','Lopez','Martinez','Lee','Clark','Young','Hall','Allen','King','Wright','Scott','Green','Baker','Adams','Nelson','Carter','Mitchell','Perez','Roberts','Turner','Phillips','Campbell','Parker','Evans','Edwards','Collins','Stewart','Sanchez','Morris','Rogers','Reed','Cook','Morgan','Bell','Murphy','Bailey','Rivera','Cooper','Richardson','Howard','Ward','Cox','Diaz','Peterson','Gray','Ramirez','James','Watson','Brooks','Kelly','Sanders','Price','Bennett','Wood','Barnes','Ross','Henderson','Coleman','Jenkins','Perry','Powell','Long','Patterson','Hughes','Flores','Washington','Butler','Simmons','Foster','Gonzales','Bryant','Alexander','Russell','Griffin','Hayes','Armstrong','Bishop','Caldwell','Dawson','Elliott','Fischer','Goldman','Harper','Irving','Jacobson','Kane','Lancaster','Monroe','Novak','O\'Brien','Pierce','Quinn','Romano','Sterling','Thompson','Underwood','Valdez','Winters','York','Zhang','Ashford','Blackwell','Carlisle','Drake','Everett','Flynn','Gallagher','Hartley','Ingram','Jensen','Knight','Lawson','Mercer','Nash','Ortiz','Porter','Quincy','Rhodes','Shaw','Tucker','Vega','Walsh','Xu','Zimmerman','Archer','Barrett','Cross','Donovan','Ellis','Grant','Iverson','Justice','Kent','Lyon','Morrison','Norton','Owens','Preston','Reeves','Sullivan','Torres','Vaughn','Wells','Xavier','Zane','Aldridge','Benson','Crawford','Duncan','Emerson','Fitzgerald','Graham','Hudson','Irwin','Jackson','Keller','Leonard','Manning','Nichols','Osborne','Palmer','Ramsey','Sawyer','Tanner','Upton','Vincent','Wade',
    // Expanded A-G names
    'Abbott','Abel','Abernathy','Abrams','Acker','Acosta','Adair','Adkins','Aguirre','Albert','Alford','Allison','Alvarado','Alvarez','Ames','Anderson','Andrews','Anthony','Appleton','Archer','Armstrong','Arnold','Ashby','Ashley','Atkins','Atkinson','Austin','Avery','Ayala','Ayers','Bach','Bacon','Baer','Baird','Baldwin','Ball','Ballard','Banks','Barber','Barker','Barlow','Barnett','Barr','Barrera','Barron','Barry','Bartlett','Barton','Bass','Bates','Battle','Bauer','Baxter','Beach','Bean','Beard','Beasley','Beatty','Beck','Becker','Bell','Bellamy','Bender','Benedict','Benjamin','Bentley','Berg','Berger','Bernard','Berry','Best','Bird','Bishop','Black','Blackburn','Blackwell','Blair','Blake','Blanchard','Blankenship','Blevins','Bolton','Bond','Bonner','Booker','Boone','Booth','Bowen','Bowers','Bowman','Boyd','Boyer','Boyle','Bradford','Bradley','Bradshaw','Brady','Branch','Brandt','Bray','Brennan','Brewer','Bridges','Briggs','Bright','Brock','Brooks','Browning','Bruce','Bryan','Buchanan','Buck','Buckley','Bullock','Burch','Burgess','Burke','Burnett','Burns','Burton','Bush','Byrd','Cabrera','Cain','Calderon','Calhoun','Callahan','Cameron','Camp','Cannon','Cantrell','Cardenas','Carey','Carlson','Carney','Carpenter','Carr','Carrillo','Carroll','Carson','Case','Casey','Castaneda','Castle','Castro','Chambers','Chan','Chandler','Chaney','Chang','Chapman','Charles','Chase','Chavez','Chen','Cherry','Choi','Christensen','Christian','Church','Clements','Cline','Cobb','Cochran','Coffey','Cohen','Cole','Collin','Combs','Compton','Conley','Connell','Conner','Conrad','Contreras','Conway','Cooley','Copeland','Corbett','Cordova','Cornwell','Costa','Cowan','Cox','Craig','Crane','Crenshaw','Crews','Crosby','Cross','Crouch','Crowley','Cruz','Cummings','Cunningham','Curran','Curry','Curtis','Dale','Dalton','Daniel','Daniels','Daugherty','Davidson','Davies','Davila','Dean','Decker','Deleon','Delgado','Dennis','Denton','Dickerson','Dickson','Dillon','Dixon','Dodson','Dominguez','Donaldson','Donnelly','Dorsey','Dougherty','Douglas','Doyle','Drake','Duarte','Dudley','Duffy','Duke','Dunlap','Dunn','Durham','Dyer','Eaton','Edwards','Elliott','Ellis','Ellison','English','Erickson','Espinoza','Estes','Estrada','Evans','Everett','Ewing','Fairchild','Farmer','Farrell','Farley','Faulkner','Ferguson','Fernandez','Fields','Figueroa','Finch','Finley','Fischer','Fisher','Fitzgerald','Fitzpatrick','Fleming','Fletcher','Flores','Flowers','Floyd','Flynn','Foley','Forbes','Ford','Foreman','Foster','Fowler','Fox','Francis','Franco','Frank','Franklin','Frazier','Frederick','Freeman','French','Friedman','Fritz','Frost','Fry','Frye','Fuller','Fulton','Fuentes','Gaines','Gallagher','Gallegos','Galloway','Gamble','Garcia','Gardner','Garner','Garrett','Garrison','Garza','Gates','Gay','Gentry','George','Gibbs','Gibson','Gilbert','Giles','Gill','Gillespie','Gilmore','Glass','Glenn','Glover','Golden','Gomez','Gonzales','Gonzalez','Good','Goodman','Goodwin','Gordon','Gould','Graham','Grant','Graves','Gray','Grayson',
    // Expanded H-Z names
    'Green','Greene','Greer','Gregory','Griffin','Griffith','Grimes','Gross','Guerra','Guerrero','Gutierrez','Guy','Hahn','Hale','Haley','Hall','Hamilton','Hammond','Hampton','Hancock','Haney','Hansen','Hanson','Hardin','Harding','Hardy','Harmon','Harper','Harrell','Harrington','Harris','Harrison','Hart','Hartley','Hartman','Harvey','Hatfield','Hawkins','Hayes','Haynes','Head','Heath','Hebert','Henderson','Hendricks','Hendrix','Henry','Hensley','Henson','Herman','Hernandez','Herrera','Herring','Hess','Hester','Hickman','Hicks','Higgins','Hill','Hines','Hinton','Hobbs','Hodge','Hodges','Hoffman','Hogan','Holcomb','Holden','Holder','Holland','Holloway','Holmes','Holt','Hood','Hooper','Hoover','Hopkins','Hopper','Horn','Horne','Horton','House','Houston','Howard','Howe','Howell','Hubbard','Huber','Hudson','Huff','Huffman','Hughes','Hull','Humphrey','Hunt','Hunter','Hurley','Hurst','Hutchinson','Hyde','Ingram','Irwin','Jackson','Jacobs','Jacobson','James','Jarvis','Jefferson','Jenkins','Jennings','Jensen','Jimenez','Johns','Johnson','Johnston','Jones','Jordan','Joseph','Joyce','Juarez','Kane','Kaufman','Keith','Keller','Kelley','Kelly','Kemp','Kennedy','Kent','Kerr','Key','Kidd','Kim','King','Kinney','Kirby','Kirk','Klein','Kline','Knight','Knox','Koch','Kramer','Lamb','Lambert','Lancaster','Landry','Lane','Lang','Langley','Lara','Larsen','Larson','Lawrence','Lawson','Le','Leach','Leblanc','Lee','Leon','Leonard','Lester','Levine','Levy','Lewis','Lindsay','Lindsey','Little','Liu','Livingston','Lloyd','Logan','Long','Lott','Love','Lowe','Lowery','Lowry','Lucas','Luna','Lynch','Lynn','Lyons','Macdonald','Macias','Mack','Madden','Maddox','Maldonado','Malone','Mann','Manning','Marks','Marquez','Marsh','Marshall','Martin','Martinez','Mason','Massey','Mathews','Matthews','Maxwell','May','Mayer','Maynard','Mayo','Mays','McBride','McCall','McCarthy','McConnell','McCormick','McCoy','McCullough','McDaniel','McDonald','McDowell','McFarland','McGee','McGowan','McGuire','McIntosh','McIntyre','McKay','McKee','McKenzie','McKinney','McKnight','McLaughlin','McLean','McLeod','McMahon','McMillan','McNeil','McPherson','Meadows','Medina','Mejia','Melendez','Melton','Mendez','Mendoza','Mercado','Mercer','Merrill','Merritt','Meyer','Meyers','Michael','Middleton','Miles','Miller','Mills','Miranda','Mitchell','Molina','Monroe','Montague','Montagomery','Montoya','Moody','Moon','Moore','Morales','Moran','Moreno','Morgan','Morris','Morrison','Morrow','Morse','Morton','Moses','Mosley','Moss','Mueller','Mullen','Mullins','Munoz','Murphy','Murray','Myers','Nash','Navarro','Neal','Nelson','Neville','Newman','Newton','Nguyen','Nichols','Nicholson','Nielsen','Nixon','Noble','Noel','Nolan','Norman','Norris','North','Norton','Novak','Nunez','Obrien','Ochoa','Oconnor','Odom','Odonnell','Oliver','Olsen','Olson','ONeal','Ortega','Ortiz','Osborn','Osborne','Owens','Pace','Pacheco','Padilla','Page','Palmer','Park','Parker','Parks','Parrish','Parsons','Patel','Patrick','Patterson','Patton','Paul','Payne','Pearce','Pearson','Peck','Pena','Pennington','Perez','Perkins','Perry','Peters','Petersen','Peterson','Petty','Phelps','Phillips','Pickett','Pierce','Pike','Pittman','Pitts','Pollard','Ponce','Poole','Pope','Porter','Potter','Potts','Powell','Powers','Pratt','Preston','Price','Prince','Pruitt','Puckett','Pugh','Quinn','Ramirez','Ramos','Ramsey','Randall','Randolph','Rasmussen','Ray','Raymond','Reed','Reese','Reeves','Reid','Reilly','Reyes','Reynolds','Rhodes','Rice','Rich','Richard','Richards','Richardson','Richmond','Riddle','Riggs','Riley','Rios','Rivas','Rivera','Rivers','Roach','Robbins','Roberson','Roberts','Robertson','Robinson','Robles','Rocha','Rodgers','Rodriguez','Rodriquez','Rogers','Rojas','Rollins','Roman','Romero','Rosa','Rosales','Rosario','Rose','Ross','Roth','Rowe','Rowland','Roy','Ruiz','Rush','Russell','Russo','Rutledge','Ryan','Salas','Salazar','Salinas','Sampson','Sanchez','Sanders','Sandoval','Sanford','Santana','Santiago','Santos','Sargent','Saunders','Savage','Sawyer','Schaefer','Schmidt','Schneider','Schroeder','Schultz','Schwartz','Scott','Sears','Sellers','Serrano','Sexton','Shaffer','Shannon','Sharp','Sharpe','Shaw','Shelton','Shepard','Shepherd','Sheppard','Sherman','Shields','Short','Silva','Simmons','Simon','Simpson','Sims','Singleton','Skinner','Slater','Sloan','Small','Smith','Snow','Snyder','Solis','Solomon','Sosa','Soto','Sparks','Spears','Spence','Spencer','Stafford','Stanley','Stanton','Stark','Starr','Steele','Stein','Stephens','Stephenson','Stevens','Stevenson','Stewart','Stokes','Stone','Stout','Strickland','Strong','Stuart','Suarez','Sullivan','Summers','Sutton','Swanson','Sweeney','Sweet','Sykes','Talley','Tanner','Tate','Taylor','Terrell','Terry','Thomas','Thompson','Thornton','Tillman','Todd','Torres','Townsend','Tran','Travis','Trevino','Trujillo','Tucker','Turner','Tyler','Tyson','Underwood','Valdez','Valencia','Valentine','Valenzuela','Vance','Vang','Vargas','Vasquez','Vaughan','Vaughn','Vazquez','Vega','Velasquez','Velazquez','Velez','Villarreal','Vincent','Vinson','Wade','Wagner','Walker','Wall','Wallace','Waller','Walls','Walsh','Walter','Walters','Walton','Ward','Ware','Warner','Warren','Washington','Waters','Watkins','Watson','Watts','Weaver','Webb','Weber','Webster','Weeks','Weiss','Welch','Wells','Werner','West','Wheeler','Whitaker','White','Whitehead','Whitfield','Whitney','Whitley','Wiggins','Wilcox','Wilder','Wiley','Wilkerson','Wilkins','Wilkinson','William','Williams','Williamson','Willis','Wilson','Winters','Wise','Witt','Wolf','Wolfe','Wong','Wood','Woodard','Woods','Woodward','Wooten','Work','Wright','Wyatt','Wynn','Xavier','Yang','Yates','York','Young','Zamora','Zavala','Zhang','Zimmerman','Zuniga'
  ];

  // Track all names that have ever been used (current + alumni)
  if (!gameState.usedEmployeeNames) {
    gameState.usedEmployeeNames = new Set();
  }

  /**
   * Generate a unique name that hasn't been used before
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Full name (First Last)
   */
  function generateUniqueName(gender = 'female') {
    // CRITICAL FIX: Ensure usedEmployeeNames is a Set before using it
    if (!gameState.usedEmployeeNames) {
      console.warn('[Names] usedEmployeeNames not initialized, creating new Set');
      gameState.usedEmployeeNames = new Set();
    } else if (Array.isArray(gameState.usedEmployeeNames)) {
      console.warn('[Names] usedEmployeeNames is an Array, converting to Set');
      gameState.usedEmployeeNames = new Set(gameState.usedEmployeeNames);
    } else if (typeof gameState.usedEmployeeNames.has !== 'function') {
      console.error('[Names] usedEmployeeNames is not a Set and has no .has() method, creating new Set');
      gameState.usedEmployeeNames = new Set();
    }
    
    const maxAttempts = 1000; // Prevent infinite loop
    let attempts = 0;
    
    // Select appropriate first name pool based on gender
    let firstNamePool;
    switch(gender) {
      case 'male':
      case 'transMan':
        firstNamePool = MALE_FIRST_NAMES_POOL;
        break;
      case 'female':
      case 'femaleFuta':
      case 'transWoman':
      default:
        firstNamePool = FIRST_NAMES_POOL;
        break;
    }
    
    while (attempts < maxAttempts) {
      const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
      const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
      const fullName = `${firstName} ${lastName}`;
      
      // Check if this name has been used
      if (!gameState.usedEmployeeNames.has(fullName)) {
        // Mark as used
        gameState.usedEmployeeNames.add(fullName);
        console.log(`[Names] Generated unique ${gender} name: ${fullName} (${gameState.usedEmployeeNames.size} names used)`);
        return fullName;
      }
      
      attempts++;
    }
    
    // Fallback: if somehow we've exhausted all combinations (extremely unlikely with 500*300 = 150,000 combinations)
    // Add a numeric suffix
    const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
    const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
    const suffix = Math.floor(Math.random() * 1000);
    const uniqueName = `${firstName} ${lastName} ${suffix}`;
    gameState.usedEmployeeNames.add(uniqueName);
    console.warn(`[Names] Exhausted name pool, using suffix: ${uniqueName}`);
    return uniqueName;
  }

  /**
   * Initialize used names from existing employees (for loading saved games)
   */
  function initializeUsedNames() {
    // CRITICAL FIX: Ensure usedEmployeeNames is a Set (convert from Array if needed)
    if (!gameState.usedEmployeeNames) {
      gameState.usedEmployeeNames = new Set();
    } else if (Array.isArray(gameState.usedEmployeeNames)) {
      console.warn('[Names] usedEmployeeNames was an Array, converting to Set');
      gameState.usedEmployeeNames = new Set(gameState.usedEmployeeNames);
    } else if (!gameState.usedEmployeeNames.has) {
      console.warn('[Names] usedEmployeeNames is not a Set, creating new Set');
      gameState.usedEmployeeNames = new Set();
    }
    
    // Add all current employee names
    gameState.employees.forEach(emp => {
      if (emp.name) {
        gameState.usedEmployeeNames.add(emp.name);
      }
    });
    
    console.log(`[Names] Initialized ${gameState.usedEmployeeNames.size} used names from existing employees`);
  }

  /**
   * Get the color for a gender category
   * @param {string} gender - The gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Hex color code
   */
  function getGenderColor(gender) {
    const colors = {
      female: '#ff6b9d',
      male: '#00d4ff',
      femaleFuta: '#c77dff',
      transMan: '#4ecca3',
      transWoman: '#ffd700'
    };
    return colors[gender] || '#ff6b9d'; // Default to female color
  }

  /**
   * Get color-coded HTML for an employee's name
   * @param {object} employee - Employee object with name and gender
   * @returns {string} HTML string with colored name
   */
  function getColoredName(employee) {
    if (!employee || !employee.name) return '';
    const color = getGenderColor(employee.gender || 'female');
    return `<span style="color:${color};">${employee.name}</span>`;
  }
  
  /**
   * Generate gift preferences for an employee
   * @returns {object} Gift preferences with loves, neutral, and hates
   */
  function generateGiftPreferences() {
    const categories = Object.keys(GIFT_CATEGORIES).filter(c => c !== 'UNIQUE'); // UNIQUE not in preferences
    const shuffled = [...categories].sort(() => Math.random() - 0.5);
    
    // Pick 2-3 loves
    const loveCount = 2 + Math.floor(Math.random() * 2);
    const loves = shuffled.splice(0, loveCount);
    
    // Pick 2-3 hates
    const hateCount = 2 + Math.floor(Math.random() * 2);
    const hates = shuffled.splice(0, hateCount);
    
    // Remaining are neutral
    const neutral = shuffled;
    
    return {
      loves: loves,        // +150% stat impact
      neutral: neutral,    // 100% stat impact  
      hates: hates,        // -50% stat impact, negative reactions
      
      // Learning system - track discovered preferences
      learnedLoves: [],    // Which loves have been discovered
      learnedHates: [],    // Which hates have been discovered
      
      // Gift history
      recentGifts: [],
      favoriteGifts: [],
      totalValue: 0,
      totalCount: 0
    };
  }
  
  // ============================================
  // EMPLOYEE GENERATION WITH GENDER SELECTION
  // ============================================

  /**
   * Select a gender for a new employee based on gameState.genderSettings
   * Uses weighted random selection based on the percentage distributions
   * @returns {string} Selected gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function selectGenderForEmployee() {
    const settings = gameState.genderSettings;
    
    // Create an array of gender options with their weights
    const genderPool = [];
    
    // Add entries for each gender based on their percentage
    if (settings.female > 0) {
      for (let i = 0; i < settings.female; i++) {
        genderPool.push('female');
      }
    }
    if (settings.male > 0) {
      for (let i = 0; i < settings.male; i++) {
        genderPool.push('male');
      }
    }
    if (settings.femaleFuta > 0) {
      for (let i = 0; i < settings.femaleFuta; i++) {
        genderPool.push('femaleFuta');
      }
    }
    if (settings.transMan > 0) {
      for (let i = 0; i < settings.transMan; i++) {
        genderPool.push('transMan');
      }
    }
    if (settings.transWoman > 0) {
      for (let i = 0; i < settings.transWoman; i++) {
        genderPool.push('transWoman');
      }
    }
    
    // If pool is empty (shouldn't happen but safety check), default to female
    if (genderPool.length === 0) {
      console.warn('[Gender] Gender pool is empty, defaulting to female');
      return 'female';
    }
    
    // Select random gender from weighted pool
    const selectedGender = genderPool[Math.floor(Math.random() * genderPool.length)];
    console.log(`[Gender] Selected gender: ${selectedGender} (from pool of ${genderPool.length} weighted options)`);
    return selectedGender;
  }
  
    function generatePotentialHires(productId) {
  // Use the massive name pools defined above
  const firstNames = FIRST_NAMES_POOL;
  const lastNames = LAST_NAMES_POOL;
    const personalities = ['Playful','Reserved','Confident','Witty','Thoughtful','Cheeky','Dry-humored','Warm','Ambitious','Chill','Inquisitive','Loyal','Optimistic','Pessimistic','Sarcastic','Sincere','Spontaneous','Stoic','Supportive','Adventurous','Cautious','Curious','Diligent','Easygoing','Energetic','Focused','Generous','Humble','Imaginative','Meticulous','Pragmatic','Resourceful','Sociable','Tactful','Versatile'];
    const traits = ['Charismatic','Analytical','Creative','Detail-oriented','Adaptable','Empathetic','Organized','Bold', 'Reliable','Innovative','Strategic','Patient','Decisive','Collaborative','Resilient','Visionary','Persuasive','Curious','Ambitious','Supportive', 'Meticulous','Proactive','Diligent','Resourceful','Versatile', 'Submissive','Dominant','Flirty','Shy','Confident','Caring','Playful','Serious','Adventurous','Loyal','Spontaneous','Thoughtful','Cheeky','Witty','Warm','Inquisitive'];
    const hobbies = ['Reading','Photography','Hiking','Gaming','Cooking','Traveling','Music','Art','Yoga','Dancing','Climbing','Baking','Thrifting','Gardening','Writing','Cycling','Swimming','Crafting','Meditation','Volunteering','Fishing','Running','Collecting','Knitting','Birdwatching','Puzzles','Board games','Movies','Theater','Fitness','Martial arts','Skiing','Snowboarding','Surfing','Skateboarding','Camping','Astronomy','DIY projects','Blogging','Podcasting','Learning languages','Genealogy','Magic tricks','Robotics','Woodworking','Calligraphy','Chess','Travel blogging','Vlogging','Stand-up comedy','Improv'];
    const kinks = ['Roleplay','Bondage','Exhibitionism','Voyeurism','Dom/sub','Praise','Teasing','Spanking','Light impact','Dirty talk','Public play','Costumes','Sensory play','Tickling','Restraints','Blindfolds','Temperature play','Massage','Oral fixation','Foot fetish','Group play','Cuddling','Hair pulling','Choking','Anal play','Threesomes','Fantasies','Power exchange','Erotic humiliation','Sensation play','Mutual masturbation',];
    const ages = [22,23,24,25,26,27,28,29,30,31,32,33,34];

    const pickSome = (arr, min, max) => {
        const n = Math.max(min, Math.min(max, Math.floor(Math.random()*(max-min+1))+min));
        const out = new Set();
        while(out.size < n) out.add(arr[Math.floor(Math.random()*arr.length)]);
        return [...out];
    };

    const candidates = [];
    for (let i = 0; i < 3; i++) {
    // Select gender based on settings
    const selectedGender = selectGenderForEmployee();
    
    const cand = {
    id: `emp_${Date.now()}_${i}`,
    name: generateUniqueName(selectedGender), // Use unique name generator with gender
    age: ages[Math.floor(Math.random()*ages.length)],
    gender: selectedGender,
    position: 'Manager Candidate',
    productId,
    // personality & interests
    personalityTraits: pickSome(personalities, 3, 5),
    keyTrait: traits[Math.floor(Math.random()*traits.length)],
    hobbies: pickSome(hobbies, 1, 2),
    kinks: pickSome(kinks, 2, 4),
    // AI personality attributes (C.O.F.P.H.)
    personality: {
      confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
      outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
      flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
      professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
      humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
    },
    // stats (0-100 scale)
    stats: {
      affection:    20 + Math.floor(Math.random()*20),  // How much they like you personally
      comfort:      40 + Math.floor(Math.random()*30),  // How comfortable they feel around you
      trust:        30 + Math.floor(Math.random()*30),  // How much they trust you
      desire:       5 + Math.floor(Math.random()*15),   // Romantic/sexual attraction
      obedience:    40 + Math.floor(Math.random()*30),  // Willingness to follow instructions
      productivity: 50 + Math.floor(Math.random()*30)   // Work performance (affects game mechanics)
    },
    // gift preferences
    giftPreferences: generateGiftPreferences(),
    // onboarding + bio fields
    hired: false,
    onboarding: true,
    bioComplete: false,
    productManaged: null,
    physical: {
      heightBuild: null,
      hair: { color: null, style: null, length: null },
      eyes: { color: null, shape: null },
      skinTone: null,
      bodyShape: null,
      breastSize: null,
      buttSize: null,
      fashion: null
    },
    profileImage: null,
    bio: null,
    hireDate: Date.now(), // Timestamp when hired
    
    // ========== CORPORATE CAREER DATA ==========
    career: {
      level: 1,  // Starting at Staff level
      title: "Staff",
      salary: 40000,
      startDate: Date.now(),
      promotionHistory: [],
      directReports: [],  // Array of employee IDs they manage
      managerId: null  // ID of their manager (if any)
    },
    
    // Rehire-specific flags
    isRehire: false,
    fastTrack: false,  // 50% faster promotions for rehires
    previousLevel: null,
    previousTitle: null,
    timesRehired: 0
    };
        candidates.push(cand);
    }
    return candidates;
    }

  // Handle manager hiring UI
  // Finalize manager hire (for former employees who skip onboarding)
  function finalizeManagerHire(candidate, product) {
    // Initialize social network data if not already present
    if (!candidate.socialData) {
      initializeEmployeeSocialData(candidate);
    }
    
    // Set hire date if not already set
    if (!candidate.hireDate) {
      candidate.hireDate = Date.now();
    }
    
    // CRITICAL FIX: Set employment status to active so they appear in People tab
    candidate.employmentStatus = 'active';
    
    // Add to employees array
    gameState.employees.push(candidate);
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees (or restore old ones)
    generateRandomRelationships(candidate.id);
    
    // Log rehire event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [candidate.id],
      location: candidate.locationId || product.locationId || 'headquarters',
      description: `${candidate.name} returned as ${candidate.position}`,
      sentiment: 'positive',
      importance: 7
    });
    
    // Generate a "I'm back!" post
    generateFirstEmployeePost(candidate).catch(err => {
      console.error('Welcome back post generation failed:', err);
    });
    
    // Mark manager on product
    product.managerHired = true;
    product.managerId = candidate.id;  // CRITICAL FIX: Ensure managerId is set
    product.managerLevel = 1;
    product.managerOnboarding = false;
    
    // Automatically assign employee to Level 1 Staff position in pyramid
    const staffPosition = gameState.corporatePyramid.positions[1]?.find(
      pos => pos.productId === product.id
    );
    
    if (staffPosition) {
      staffPosition.employeeId = candidate.id;
      candidate.productManaged = product.name;
      
      // CRITICAL FIX: Update employee career to match position
      const levelInfo = gameState.hierarchyLevels[staffPosition.level] || gameState.hierarchyLevels[1];
      candidate.career.level = staffPosition.level;
      candidate.career.title = levelInfo.title;
      candidate.career.salary = levelInfo.baseSalary;
      
      console.log(`[Pyramid] Auto-assigned ${candidate.name} to ${staffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
    } else {
      // If position doesn't exist yet, create it
      initializeHierarchicalPyramid();
      const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
        pos => pos.productId === product.id
      );
      if (newStaffPosition) {
        newStaffPosition.employeeId = candidate.id;
        candidate.productManaged = product.name;
        
        // CRITICAL FIX: Update employee career to match position
        const levelInfo = gameState.hierarchyLevels[newStaffPosition.level] || gameState.hierarchyLevels[1];
        candidate.career.level = newStaffPosition.level;
        candidate.career.title = levelInfo.title;
        candidate.career.salary = levelInfo.baseSalary;
        
        console.log(`[Pyramid] Created and assigned ${candidate.name} to ${newStaffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
      }
    }
    
    // UI updates
    updatePeopleTab();
    updateProductsList();
    
    // Refresh dashboard to show returning employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
  }

  // Calculate loyalty bonus based on times rehired
  function calculateLoyaltyBonus(timesRehired) {
    // 5% bonus per rehire, up to 50% max
    return Math.min(0.50, timesRehired * 0.05);
  }

  /**
   * Select random employees from rehire pool
   * @param {number} count - Number of rehires to select
   * @returns {Array} Array of rehire candidates
   */
  function selectRandomRehires(count) {
    if (!gameState.rehirePool || gameState.rehirePool.length === 0) {
      return [];
    }
    
    // Shuffle and take first 'count' items
    const shuffled = [...gameState.rehirePool].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, shuffled.length));
  }

  /**
   * Finalize rehiring an employee
   * @param {number} rehireIndex - Index in currentHiringCandidates.rehires array
   * @param {number} startingLevel - Level to start at (1 or 2)
   */
  function finalizeRehire(rehireIndex, startingLevel = 1) {
    const rehireData = gameState.currentHiringCandidates?.rehires?.[rehireIndex];
    const productId = gameState.currentHiringCandidates?.productId;
    const product = gameState.products.find(p => p.id === productId);
    
    if (!rehireData || !product) {
      console.error('[Rehire] Invalid rehire data or product');
      return;
    }
    
    // Check if player can afford
    if (gameState.cash < product.managerHireCost) {
      showNotification("Not enough money to hire!", 'error');
      return;
    }
    
    // Deduct cost
    gameState.cash -= product.managerHireCost;
    
    // Create employee with restored data
    const newEmployee = {
      // Identity
      id: `emp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: rehireData.name,
      age: rehireData.age,
      gender: rehireData.gender,
      
      // Career - START AT SELECTED LEVEL
      career: {
        level: startingLevel,
        title: gameState.hierarchyLevels[startingLevel].title,
        salary: gameState.hierarchyLevels[startingLevel].baseSalary,
        startDate: Date.now(),
        promotionHistory: [],
        directReports: [],
        managerId: null
      },
      
      // Restored data
      stats: {
        ...rehireData.stats,
        // Apply productivity bonus!
        productivity: Math.min(100, (rehireData.stats.productivity || 50) * (1 + rehireData.rehireBonus))
      },
      skills: rehireData.skills ? JSON.parse(JSON.stringify(rehireData.skills)) : {},
      personality: {...rehireData.personality},
      physical: {...rehireData.physical},
      profileImage: rehireData.profileImage,
      bio: rehireData.bio,
      
      // Memory
      memory: rehireData.memory ? {...rehireData.memory} : {},
      
      // Traits
      keyTrait: rehireData.keyTrait,
      personalityTraits: rehireData.personalityTraits ? [...rehireData.personalityTraits] : [],
      hobbies: rehireData.hobbies ? [...rehireData.hobbies] : [],
      kinks: rehireData.kinks ? [...rehireData.kinks] : [],
      
      // Gift preferences
      giftPreferences: rehireData.giftPreferences,
      
      // Rehire flags
      isRehire: true,
      fastTrack: true,  // 50% faster promotions!
      previousLevel: rehireData.previousLevel,
      previousTitle: rehireData.previousTitle,
      timesRehired: (rehireData.timesRehired || 0) + 1,
      
      // Assignment
      productId: productId,
      hired: true,
      onboarding: false,
      bioComplete: true,
      employmentStatus: 'active',
      hireDate: Date.now()
    };
    
    // Restore chat history
    if (rehireData.chatHistory && rehireData.chatHistory.length > 0) {
      gameState.chatHistory[newEmployee.id] = [...rehireData.chatHistory];
    }
    
    // Add to employee roster
    gameState.employees.push(newEmployee);
    
    // Remove from rehire pool (can't rehire same person twice in one run)
    const poolIndex = gameState.rehirePool.findIndex(r => r.id === rehireData.id);
    if (poolIndex !== -1) {
      gameState.rehirePool.splice(poolIndex, 1);
    }
    
    // Initialize social network data
    if (!newEmployee.socialData) {
      initializeEmployeeSocialData(newEmployee);
    }
    
    // Update hierarchy
    updateCorporateHierarchy();
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees
    generateRandomRelationships(newEmployee.id);
    
    // Log company event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [newEmployee.id],
      location: product.locationId || 'headquarters',
      description: `${newEmployee.name} returned as ${newEmployee.career.title}`,
      sentiment: 'positive',
      importance: 8
    });
    
    // Generate welcome back post
    generateWelcomeBackPost(newEmployee, rehireData);
    
    // Mark product as having manager
    product.managerHired = true;
    product.managerLevel = 1;
    product.managerOnboarding = false;
    
    // Automatically assign employee to Level 1 Staff position in pyramid
    const staffPosition = gameState.corporatePyramid.positions[1]?.find(
      pos => pos.productId === product.id
    );
    
    if (staffPosition) {
      staffPosition.employeeId = newEmployee.id;
      newEmployee.productManaged = product.name;
      console.log(`[Pyramid] Auto-assigned ${newEmployee.name} to ${staffPosition.title}`);
    } else {
      // If position doesn't exist yet, create it
      initializeHierarchicalPyramid();
      const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
        pos => pos.productId === product.id
      );
      if (newStaffPosition) {
        newStaffPosition.employeeId = newEmployee.id;
        newEmployee.productManaged = product.name;
        console.log(`[Pyramid] Created and assigned ${newEmployee.name} to ${newStaffPosition.title}`);
      }
    }
    
    // Update UI
    updatePeopleTab();
    updateProductsList();
    closeHiringModal();
    
    showNotification(`✨ Welcome back, ${newEmployee.name}! Starting as ${newEmployee.career.title}`, 'success');
    
    console.log(`[Rehire] ${newEmployee.name} rehired at Level ${startingLevel} with ${Math.round(rehireData.rehireBonus * 100)}% bonus`);
  }

  /**
   * Generate welcome back social post
   * @param {object} employee - New employee object
   * @param {object} rehireData - Original rehire data
   */
  async function generateWelcomeBackPost(employee, rehireData) {
    if (!employee || !gameState.socialNetwork) return;
    
    const relationshipEmojis = {
      'very close': '❤️💕',
      'close': '😊💼',
      'friendly': '👋✨',
      'professional': '💼',
      'distant': '👋'
    };
    
    const emoji = relationshipEmojis[rehireData.relationshipStrength] || '💼';
    
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      author: employee.name,
      authorId: employee.id,
      type: 'work',
      category: 'work',
      timestamp: Date.now(),
      contentType: 'text',
      caption: `${emoji} I'm back! Excited to rejoin the team${employee.fastTrack ? ' and they\'ve put me on the fast track! 🚀' : '!'} Feels good to be home. @TheBoss let's do this! 💪`,
      likes: Math.floor(Math.random() * 30) + 15,
      comments: [],
      imageUrl: null,
      altText: null,
      hasImage: false,
      explicit: false
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    // Trim posts if too many
    if (gameState.socialNetwork.posts.length > 100) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 100);
    }
    
    console.log(`[Welcome Back Post] Generated post for ${employee.name}'s return`);
  }

  function showManagerHiringModal(productId) {
    const product = gameState.products.find(p => p.id === productId);
    if (!product) return;

    // Check if there's a former employee who managed this product
    const formerManager = (gameState.formerEmployees || []).find(
      fe => fe.productManaged === product.name
    );
    
    // Get 3 candidates (uses your existing generator)
    let candidates = generatePotentialHires(productId);
    
    // If there's a former manager, replace the first candidate with them
    if (formerManager) {
      const loyaltyBonus = calculateLoyaltyBonus(formerManager.timesRehired || 1);
      
      // Create candidate from former employee
      const formerCandidate = {
        ...formerManager,
        id: `emp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        productId: productId,
        isFormerEmployee: true,
        loyaltyBonus: loyaltyBonus,
        hired: false,
        onboarding: false,
        bioComplete: true, // Already has full bio
        employmentStatus: 'candidate'
      };
      
      // Put former employee as first option
      candidates = [formerCandidate, ...candidates.slice(1)];
    }
    
    gameState.currentCandidates = candidates;

  // === PHASE 7B: ENHANCED HIRING MODAL ===
  // Initialize skills for candidates before showing modal
  const modal = document.createElement('div');
  modal.id = 'hiringModal';
  // Don't set z-index and positioning - ModalManager will handle it
  modal.style.background = 'rgba(0,0,0,0.7)';

    const cards = candidates.map((c, i) => {
      const isFormer = c.isFormerEmployee || false;
      
      // Initialize skills for candidates if not present
      if (!c.skills && !isFormer) {
        c.skills = {
          technical: { level: 1, xp: 0, maxXp: 500 },
          creative: { level: 1, xp: 0, maxXp: 500 },
          social: { level: 1, xp: 0, maxXp: 500 },
          management: { level: 1, xp: 0, maxXp: 500 },
          intimate: { level: 0, xp: 0, maxXp: 500 },
          cooking: { level: 0, xp: 0, maxXp: 500 },
          fitness: { level: 0, xp: 0, maxXp: 500 }
        };
        
        // Give random starting skills (1-4 range for new hires)
        c.skills.technical.level = 1 + Math.floor(Math.random() * 3);
        c.skills.creative.level = 1 + Math.floor(Math.random() * 3);
        c.skills.social.level = 1 + Math.floor(Math.random() * 3);
        c.skills.management.level = 1 + Math.floor(Math.random() * 3);
        c.skills.fitness.level = Math.floor(Math.random() * 3); // 0-2
        c.skills.cooking.level = Math.floor(Math.random() * 3); // 0-2
        
        // Add some XP variance
        Object.values(c.skills).forEach(skill => {
          if (skill.level > 0) {
            skill.xp = Math.floor(Math.random() * skill.maxXp * 0.5);
          }
        });
      }
      
      const skills = c.skills || {};
      
      // Calculate potential productivity bonus from skills
      const avgWorkSkills = ((skills.technical?.level || 1) + (skills.creative?.level || 1) + 
                             (skills.social?.level || 1) + (skills.management?.level || 1)) / 4;
      const skillBonus = Math.round((avgWorkSkills - 1) * 10); // ~0-30% bonus
      
      // Top 2 skills for resume display
      const workSkills = [
        { name: 'Technical', level: skills.technical?.level || 1, emoji: '💻' },
        { name: 'Creative', level: skills.creative?.level || 1, emoji: '🎨' },
        { name: 'Social', level: skills.social?.level || 1, emoji: '🤝' },
        { name: 'Management', level: skills.management?.level || 1, emoji: '📊' }
      ].sort((a, b) => b.level - a.level).slice(0, 2);
      
      const lifeSkills = [
        { name: 'Fitness', level: skills.fitness?.level || 0, emoji: '💪' },
        { name: 'Cooking', level: skills.cooking?.level || 0, emoji: '🍳' }
      ].filter(s => s.level > 0).slice(0, 2);
      
      const loyaltyText = isFormer ? `<div style="background:#ffd700; color:#0f1419; padding:8px; border-radius:6px; margin-bottom:8px; font-weight:bold; text-align:center;">
        ⭐ FORMER EMPLOYEE ⭐<br/>
        <span style="font-size:0.9rem;">Loyalty Bonus: +${(c.loyaltyBonus * 100).toFixed(0)}% productivity</span><br/>
        <span style="font-size:0.8rem;">Times Rehired: ${c.timesRehired || 1}</span>
      </div>` : '';
      
      return `
        <div class="candidate-card" style="background:${isFormer ? '#1a2a1a' : '#16213e'}; border:${isFormer ? '3px solid #ffd700' : '2px solid #1e3a5f'}; border-radius:12px; padding:18px; margin:10px; width:320px; position:relative;">
        ${isFormer ? '<div style="position:absolute; top:8px; right:8px; font-size:1.5rem;">💛</div>' : ''}
        ${loyaltyText}
        
        <!-- Header: Name & Age -->
        <div style="margin-bottom:12px;">
          <h3 style="margin:0 0 4px 0; font-size:1.3rem;">${getColoredName(c)} ${c.age ? `• ${c.age}` : ''}</h3>
          <p style="margin:0; color:#ffd700; font-size:0.85rem; font-weight:600;">📄 CANDIDATE RESUME</p>
        </div>
        
        <!-- Personality Summary -->
        <div style="background:rgba(255,215,0,0.05); padding:10px; border-radius:8px; margin-bottom:12px; border-left:3px solid #ffd700;">
          <div style="font-size:0.75rem; color:#ffd700; margin-bottom:4px; font-weight:600;">PERSONALITY PROFILE</div>
          <p style="margin:0; font-size:0.9rem; color:#ddd;"><strong>${c.keyTrait || 'Dedicated'}</strong></p>
          <p style="margin:4px 0 0 0; font-size:0.85rem; color:#aaa;">${(c.personalityTraits || []).slice(0, 3).join(' • ') || 'Professional'}</p>
        </div>
        
        <!-- Professional Skills -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#00d4ff; margin-bottom:6px; font-weight:600;">💼 PROFESSIONAL SKILLS</div>
          <div style="display:flex; flex-direction:column; gap:6px;">
            ${workSkills.map(skill => `
              <div style="display:flex; justify-content:space-between; align-items:center; background:#0f3460; padding:8px 10px; border-radius:6px;">
                <span style="font-size:0.9rem;">${skill.emoji} ${skill.name}</span>
                <div style="display:flex; align-items:center; gap:6px;">
                  <div style="background:#1e3a5f; border-radius:10px; height:8px; width:60px; overflow:hidden;">
                    <div style="background:${skill.level >= 3 ? '#4ecca3' : '#00d4ff'}; height:100%; width:${skill.level * 25}%; transition:width 0.3s;"></div>
                  </div>
                  <span style="color:#ffd700; font-weight:600; font-size:0.9rem; min-width:30px; text-align:right;">Lv ${skill.level}</span>
                </div>
              </div>
            `).join('')}
          </div>
          ${skillBonus > 0 ? `<div style="margin-top:6px; font-size:0.75rem; color:#4ecca3; text-align:right;">+${skillBonus}% skill productivity bonus</div>` : ''}
        </div>
        
        ${lifeSkills.length > 0 ? `
        <!-- Personal Skills -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#ff6b9d; margin-bottom:6px; font-weight:600;">🌟 PERSONAL INTERESTS</div>
          <div style="display:flex; gap:6px;">
            ${lifeSkills.map(skill => `
              <div style="flex:1; background:#0f3460; padding:6px; border-radius:6px; text-align:center;">
                <div style="font-size:1.2rem; margin-bottom:2px;">${skill.emoji}</div>
                <div style="font-size:0.75rem; color:#aaa;">${skill.name}</div>
                <div style="color:#ff6b9d; font-weight:600; font-size:0.8rem;">Lv ${skill.level}</div>
              </div>
            `).join('')}
          </div>
        </div>
        ` : ''}
        
        <!-- Hobbies -->
        ${(c.hobbies || []).length > 0 ? `
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#c77dff; margin-bottom:4px; font-weight:600;">🎯 HOBBIES</div>
          <p style="margin:0; font-size:0.85rem; color:#aaa;">${(c.hobbies || []).join(', ')}</p>
        </div>
        ` : ''}
        
        <!-- Work Stats -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#4ecca3; margin-bottom:6px; font-weight:600;">📊 WORK PERFORMANCE</div>
          <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:6px;">
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Productivity</div>
              <div style="color:#ffd700; font-weight:600; font-size:1rem;">${Math.round((c.stats.productivity ?? 0) * (1 + (c.loyaltyBonus || 0)))}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Trust</div>
              <div style="color:#00d4ff; font-weight:600; font-size:1rem;">${Math.round(c.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Professional</div>
              <div style="color:#4ecca3; font-weight:600; font-size:1rem;">${Math.round(c.personality?.professional ?? 50)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Confidence</div>
              <div style="color:#e94560; font-weight:600; font-size:1rem;">${Math.round(c.personality?.confidence ?? 50)}%</div>
            </div>
          </div>
        </div>

        <button class="select-candidate-btn" data-index="${i}" style="width:100%; padding:12px; background:${isFormer ? '#ffd700' : 'linear-gradient(135deg, #e94560 0%, #0f3460 100%)'}; border:none; border-radius:8px; color:${isFormer ? '#0f1419' : '#fff'}; cursor:pointer; font-weight:bold; font-size:1rem; transition:transform 0.2s;">
            ${isFormer ? '⭐ Rehire' : '📝 Hire'} ${c.name}
        </button>
        </div>
    `;
    }).join('');

  modal.innerHTML = `
    <div class="hiring-modal-panel" role="dialog" aria-modal="true" aria-label="Select an Employee" style="background:#0f1419; width:92%; max-width:1100px; max-height:85vh; overflow-y:auto; padding:18px; border-radius:14px; box-shadow:0 5px 25px rgba(0,0,0,0.5); pointer-events:auto; margin:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; position:sticky; top:0; background:#0f1419; z-index:10; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.1);">
      <h2 style="margin:0;">Select an Employee for ${product.name}</h2>
      <button class="close-modal-btn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    <div style="display:flex; justify-content:center; flex-wrap:wrap; gap:12px;">
      ${cards}
    </div>
    <p style="margin-top:12px; color:#aaa; font-size:.9rem;">You’ll be charged <strong>${product.managerHireCost}</strong> when you choose a candidate.</p>
    </div>
  `;

    // Use ModalManager to show the modal
    ModalManager.show(modal, 'hiringModal');
    gameState.currentCandidates = candidates;

    // Set up event listeners for background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeHiringModal();
      }
    });

    // Set up close button listener
    const closeBtn = modal.querySelector('.close-modal-btn');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeHiringModal);
    }

    // Set up select candidate buttons
    const selectButtons = modal.querySelectorAll('.select-candidate-btn');
    selectButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.index, 10);
        if (!Number.isNaN(index)) {
          selectManagerCandidate(index);
        }
      });
    });

    // Allow Esc to close
    const esc = (ev) => { 
      if (ev.key === 'Escape') { 
        closeHiringModal(); 
        window.removeEventListener('keydown', esc); 
      } 
    };
    window.addEventListener('keydown', esc);
  }  

  // Close hiring modal
  function closeHiringModal() {
    // Use ModalManager to close
    ModalManager.close('hiringModal');
    gameState.currentCandidates = null;
    document.body.style.overflow = ''; // Restore scrolling
  }

  // Generate context-aware rehire message using AI
  async function generateRehireMessage(employee) {
    try {
      // Analyze relationship context
      const stats = employee.stats || {};
      const intimacy = employee.intimacy || {};
      const memory = employee.memory || {};
      const chatHistory = employee.chatHistory || [];
      const conversationArchive = employee.conversationArchive || [];
      
      // Calculate relationship metrics
      const avgAffection = stats.affection || 50;
      const avgTrust = stats.trust || 50;
      const avgDesire = stats.desire || 50;
      const intimacyLevel = intimacy.level || 0;
      const sexualHistory = intimacy.sexCount || 0;
      const timesRehired = employee.timesRehired || 1;
      
      // Analyze recent conversation topics from last 10 messages
      const recentMessages = [...conversationArchive, ...chatHistory]
        .slice(-10)
        .map(msg => msg.content)
        .join(' | ');
      
      // Determine relationship quality
      const avgRelationship = (avgAffection + avgTrust) / 2;
      const relationshipQuality = avgRelationship >= 70 ? 'excellent' : avgRelationship >= 50 ? 'good' : avgRelationship >= 30 ? 'strained' : 'poor';
      const isSexual = intimacyLevel >= 50 || sexualHistory > 0;
      const isRomantic = avgAffection >= 70 && avgDesire >= 60;
      
      // Build context prompt for AI
      const contextPrompt = `You are ${employee.name}, a ${employee.age}-year-old ${employee.gender} who previously worked for the player as a manager.

RELATIONSHIP CONTEXT:
- Affection: ${avgAffection}/100 (${avgAffection >= 70 ? 'very high' : avgAffection >= 50 ? 'positive' : avgAffection >= 30 ? 'neutral' : 'low'})
- Trust: ${avgTrust}/100 (${avgTrust >= 70 ? 'very high' : avgTrust >= 50 ? 'trusting' : avgTrust >= 30 ? 'cautious' : 'distrustful'})
- Desire: ${avgDesire}/100
- Intimacy Level: ${intimacyLevel}/100
- Sexual encounters: ${sexualHistory}
- Times rehired: ${timesRehired}
- Overall relationship: ${relationshipQuality}${isSexual ? ', sexual' : ''}${isRomantic ? ', romantic' : ''}

PERSONALITY:
${employee.personality || 'Professional and dedicated'}

RECENT CONVERSATION TOPICS:
${recentMessages || 'No recent conversation history'}

INSTRUCTIONS:
Generate a SINGLE short message (1-2 sentences, max 150 characters) that ${employee.name} would send when being rehired.

IMPORTANT TONE GUIDELINES:
${isSexual && avgAffection >= 60 ? `- Be flirty, suggestive, and reference your intimate past. Use innuendo or explicit language. Example: "Can't wait for those 'after hours' meetings again 😏" or "Missed our special connection... ready to make up for lost time ❤️"` : ''}
${isRomantic && !isSexual ? `- Be warm, affectionate, and emotionally connected. Show you missed them personally.` : ''}
${avgRelationship >= 70 && !isSexual ? `- Be enthusiastic and happy to return. Express genuine excitement.` : ''}
${avgRelationship >= 40 && avgRelationship < 70 ? `- Be professional but friendly. Acknowledge the working relationship.` : ''}
${avgRelationship < 40 ? `- Be distant, cold, or passive-aggressive. Maybe express reluctance or sarcasm. Example: "Well, here we are again..." or "Guess I'm back... for now."` : ''}

NO LIMITS on suggestiveness if intimacy is high. Match the energy of your past interactions.

Generate ONLY the message, no quotes, no explanation:`;

      const response = await queryLLM(contextPrompt, {
        type: 'rehire-message',
        employee: employee.name,
        temperature: 0.9, // Higher creativity for varied responses
        maxTokens: 80
      });

      return response || `It's good to be back! Ready to get to work. 💼`;
      
    } catch (error) {
      console.error('Error generating rehire message:', error);
      // Fallback based on basic stats
      const affection = employee.stats?.affection || 50;
      if (affection >= 70) {
        return `Boss! I've missed you so much! 💕 Ready to make this work... amazing. 😏`;
      } else if (affection >= 50) {
        return `Hey! Good to be back working with you again! 😊`;
      } else {
        return `Well... I'm back. Let's see how this goes.`;
      }
    }
  }

  // Select and onboard a manager candidate
    async function selectManagerCandidate(index) {
    const candidate = gameState.currentCandidates?.[index];
    const product = gameState.products.find(p => p.id === candidate?.productId);
    if (!candidate || !product) return;

    // funds check happens before modal in hireOrUpgradeManager, but double-guard:
    if (gameState.cash < product.managerHireCost) { showNotification('Not enough cash!'); return; }
    
    // Check if this is a former employee being rehired
    const isFormerEmployee = candidate.isFormerEmployee || false;

    // mark & queue onboarding
    candidate.hired = true;
    candidate.position = `Manager – ${product.name}`;
    candidate.productManaged = product.name;
    
    // Set hire date
    if (!candidate.hireDate) {
      candidate.hireDate = Date.now();
    }
    
    // Former employees skip onboarding (they already know the job!)
    if (isFormerEmployee) {
      candidate.onboarding = false;
      candidate.bioComplete = true;
      
      // Restore their chat history and archive
      if (candidate.chatHistory && candidate.chatHistory.length > 0) {
        gameState.chatHistory[candidate.id] = candidate.chatHistory;
      }
      if (candidate.conversationArchive) {
        candidate.conversationArchive = candidate.conversationArchive;
      } else {
        candidate.conversationArchive = [];
      }
      
      // Apply loyalty bonus to stats
      if (candidate.loyaltyBonus) {
        candidate.stats.productivity = Math.min(100, (candidate.stats.productivity || 70) * (1 + candidate.loyaltyBonus));
      }
      
      // Generate context-aware welcome back message
      if (!gameState.chatHistory[candidate.id]) {
        gameState.chatHistory[candidate.id] = [];
      }
      
      // Generate AI-powered rehire message
      generateRehireMessage(candidate).then(message => {
        gameState.chatHistory[candidate.id].push({
          sender: candidate.name,
          content: message,
          isPlayer: false,
          timestamp: Date.now()
        });
        
        // Mark as unread so player sees the welcome message
        candidate.unreadMessages = (candidate.unreadMessages || 0) + 1;
        
        // Update UI if chat is open
        if (gameState.activeChat === candidate.id) {
          renderChatMessages();
        }
      });
      
      showNotification(`${candidate.name} has returned! +${(candidate.loyaltyBonus * 100).toFixed(0)}% loyalty bonus!`);
    } else {
      candidate.onboarding = true;
      candidate.bioComplete = false;
    }

      // Product-level onboarding flag and immediate effects
      // a) Replace CTA with onboarding status via updateProductsList
      // b) Immediately subtract cash (with employee discount)
      // c) Begin automation right away
      product.managerOnboarding = !isFormerEmployee; // Former employees don't need onboarding
      
      // CRITICAL FIX: Link product to employee immediately
      product.managerId = candidate.id;
      product.managerLevel = 1;
      product.managerHired = true;
      
      // Apply employee discount from influence upgrades
      const employeeDiscountLevel = gameState.influenceUpgrades?.employeeDiscount || 0;
      const discountMultiplier = influenceUpgrades.employeeDiscount.effect(employeeDiscountLevel);
      const finalCost = Math.floor(product.managerHireCost * discountMultiplier);
      
      gameState.cash -= finalCost;
      
      // Store the cost paid for potential refund (Emergency Reset)
      candidate.hireCostPaid = finalCost;
      
      // start automated cycle if not already running
      if (!product.running) {
        product.running = true;
        product.timeRemainingMs = currentCycleTimeMs(product);
      }

    // show in People tab as a badge (only if they need onboarding)
    if (!isFormerEmployee) {
      gameState.onboarding.push(candidate);
    }
    closeHiringModal();
      updatePeopleTab();
      updateProductsList();
      
    // If former employee, skip AI generation and finalize immediately
    if (isFormerEmployee) {
      finalizeManagerHire(candidate, product);
      return;
    }

    // --- AI generation (guarded) - only for new employees ---
    try {
        const profilePrompt = `
  Create an in-world, adult female NPC profile (no meta-talk) for: ${candidate.name}, age ${candidate.age}.
  Gender: female.
  Role: ${candidate.position}. Product managed: ${product.name}.
  Personality traits: ${candidate.personalityTraits.join(', ')}. Key trait: ${candidate.keyTrait}.
  Hobbies: ${candidate.hobbies.join(', ')}. Kink preferences: ${candidate.kinks.join(', ')}.

  Respond as a compact JSON object with these keys ONLY:
  {
  "name": {"first":"", "last":""},
  "age": <number>,
  "gender": "female",
  "productManaged": "${product.name}",
  "bio": "<2-3 sentence personality/background, world-grounded>",
  "appearance": {
  "heightBuild": "",
  "hair": {"color":"","style":"","length":""},
  "eyes": {"color":"","shape":""},
  "skinTone": "",
  "bodyShape": "",
  "breastSize": "",
  "buttSize": "",
  "fashion": ""
  },
  "personalityTraits": [${candidate.personalityTraits.map(s=>`"${s}"`).join(', ')}],
  "kinks": [${candidate.kinks.map(s=>`"${s}"`).join(', ')}]
  }
  `;

        // fallbacks if plugin missing
        const aiRaw = typeof generateText === 'function'
        ? await generateText(profilePrompt)
        : `{"name":{"first":"${candidate.name.split(' ')[0]}","last":"${candidate.name.split(' ')[1]||''}"},"age":${candidate.age},"productManaged":"${product.name}","bio":"Quick learner; keeps launches smooth.","appearance":{"heightBuild":"average","hair":{"color":"brown","style":"soft waves","length":"shoulder"},"eyes":{"color":"green","shape":"almond"},"skinTone":"light","bodyShape":"curvy","breastSize":"medium","buttSize":"full","fashion":"smart casual"},"personalityTraits":["${candidate.personalityTraits.join('","')}"],"kinks":["${candidate.kinks.join('","')}"]}`;

        let parsed;
        try { parsed = JSON.parse(aiRaw); } catch { parsed = null; }

        if (parsed && parsed.name) {
        candidate.name = `${parsed.name.first} ${parsed.name.last}`.trim() || candidate.name;
        candidate.age = parsed.age ?? candidate.age;
        candidate.productManaged = parsed.productManaged || product.name;
        candidate.bio = parsed.bio || "Keeps things moving; loves clean launches.";
        
        // Generate detailed physical appearance (NEW SYSTEM!) - Gender-aware
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female');
        
        // Override with AI-generated details if available
        const ap = parsed.appearance || {};
        if (ap.heightBuild) candidate.physical.heightBuild = ap.heightBuild;
        if (ap.hair) candidate.physical.hair = { ...candidate.physical.hair, ...ap.hair };
        if (ap.eyes) candidate.physical.eyes = { ...candidate.physical.eyes, ...ap.eyes };
        if (ap.skinTone) candidate.physical.skin.tone = ap.skinTone;
        if (ap.bodyShape) candidate.physical.body.shape = ap.bodyShape;
        if (ap.breastSize || ap.chestSize) {
          candidate.physical.body.chestSize = ap.chestSize || ap.breastSize;
          candidate.physical.body.breastSize = ap.chestSize || ap.breastSize; // Backwards compatibility
        }
        if (ap.buttSize) candidate.physical.body.buttSize = ap.buttSize;
        if (ap.fashion) candidate.physical.fashion = ap.fashion;
        
        candidate.personalityTraits = parsed.personalityTraits || candidate.personalityTraits;
        candidate.kinks = parsed.kinks || candidate.kinks;
        } else {
        // minimal fallback - generate full detailed appearance (Gender-aware)
        candidate.bio = "Quick learner; keeps launches smooth. Friendly and playful in the office.";
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female');
        }

        // optional image (now uses consistent physical description!)
        if (typeof generateImage === 'function') {
          const imgPrompt = `Professional portrait photo: ${candidate.physical.shortDescription}. ${candidate.physical.face.full}. ${candidate.physical.fashion} style outfit. Office setting, soft professional lighting, friendly expression, high quality`;
        try {
            const imgUrl = await generateImage(applyImageStyle(imgPrompt));
            if (imgUrl) candidate.profileImage = imgUrl;
        } catch (e) { /* ignore */ }
        }

  // move from onboarding → employees
        candidate.onboarding = false;
        candidate.bioComplete = true;
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
        
        // Set hire date if not already set
        if (!candidate.hireDate) {
          candidate.hireDate = Date.now();
        }
        
        // CRITICAL FIX: Set employment status to active so they appear in People tab
        candidate.employmentStatus = 'active';
        
        // Initialize social network data
        initializeEmployeeSocialData(candidate);
        
        gameState.employees.push(candidate);
        
        // Update company awareness
        updateCompanyAwareness();
        
        // Generate relationships with existing employees
        generateRandomRelationships(candidate.id);
        
        // Log hire event
        logCompanyEvent({
          type: 'hire',
          involvedEmployees: [candidate.id],
          location: candidate.locationId,
          description: `${candidate.name} joined as ${candidate.position}`,
          sentiment: 'positive',
          importance: 6
        });
        
        // Generate first post (new hire announcement)
        generateFirstEmployeePost(candidate).catch(err => {
          console.error('First post generation failed:', err);
        });

  // mark manager on product (already charged and started); finish onboarding
  product.managerHired = true;
  product.managerId = candidate.id;  // CRITICAL FIX: Ensure managerId is set
  product.managerLevel = 1;
  product.managerOnboarding = false;
  
        // Automatically assign employee to Level 1 Staff position in pyramid
        const staffPosition = gameState.corporatePyramid.positions[1]?.find(
          pos => pos.productId === product.id
        );
        
        if (staffPosition) {
          staffPosition.employeeId = candidate.id;
          candidate.productManaged = product.name;
          
          // CRITICAL FIX: Update employee career to match position
          const levelInfo = gameState.hierarchyLevels[staffPosition.level] || gameState.hierarchyLevels[1];
          candidate.career.level = staffPosition.level;
          candidate.career.title = levelInfo.title;
          candidate.career.salary = levelInfo.baseSalary;
          
          console.log(`[Pyramid] Auto-assigned ${candidate.name} to ${staffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
        } else {
          // If position doesn't exist yet, create it
          initializeHierarchicalPyramid();
          const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
            pos => pos.productId === product.id
          );
          if (newStaffPosition) {
            newStaffPosition.employeeId = candidate.id;
            candidate.productManaged = product.name;
            
            // CRITICAL FIX: Update employee career to match position
            const levelInfo = gameState.hierarchyLevels[newStaffPosition.level] || gameState.hierarchyLevels[1];
            candidate.career.level = newStaffPosition.level;
            candidate.career.title = levelInfo.title;
            candidate.career.salary = levelInfo.baseSalary;
            
            console.log(`[Pyramid] Created and assigned ${candidate.name} to ${newStaffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
          }
        }

        // UI
        updatePeopleTab();
        updateProductsList();
        showNotification(`${candidate.name} hired to manage ${product.name}!`);
        
        // Refresh dashboard to show new employee
        if (gameState.activeTab === 'dashboard') {
          refreshDashboardSections();
        }

    } catch (error) {
        console.error('Onboarding error:', error);
        showNotification('Onboarding hit a snag—try again.');
        // clean up onboarding badge
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
    }
    }

  // Setup event listeners
  function setupEventListeners() {
    // Tab navigation
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        switchTab(tab);
      });
    });
    
    // Upgrade Multiplier Toggle
    const upgradeMultiplierBtn = $('upgradeMultiplierBtn');
    if (upgradeMultiplierBtn) {
      upgradeMultiplierBtn.addEventListener('click', () => {
        const multipliers = [1, 5, 10, 100, 'max'];
        const currentIndex = multipliers.indexOf(gameState.upgradeMultiplier);
        const nextIndex = (currentIndex + 1) % multipliers.length;
        gameState.upgradeMultiplier = multipliers[nextIndex];
        upgradeMultiplierBtn.textContent = `x${gameState.upgradeMultiplier}`;
        
        // Update product cards to show new costs
        if (gameState.activeTab === 'business') {
          updateProductsList();
        }
      });
    }
    
    // Settings panel
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = false;
      });
    }
    
    if (closeSettingsBtn) {
      closeSettingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = true;
      });
    }
    
    // Settings controls
    if (densitySlider && densityValue) {
      densitySlider.addEventListener('input', (e) => {
        gameState.settings.uiDensity = parseInt(e.target.value);
        const densityLabels = ['Compact', 'Normal', 'Spacious'];
        const label = densityLabels[Math.floor(e.target.value / 34)];
        densityValue.textContent = label;
      });
    }
    
    if (autosaveToggle) {
      autosaveToggle.addEventListener('change', (e) => {
        gameState.settings.autosave = e.target.checked;
      });
    }
    
    // Posts per page slider
    const postsPerPageSlider = $('postsPerPageSlider');
    const postsPerPageValue = $('postsPerPageValue');
    if (postsPerPageSlider && postsPerPageValue) {
      postsPerPageSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        feedPaginationState.postsPerPage = value;
        postsPerPageValue.textContent = value;
        
        // Save to settings for persistence
        if (!gameState.settings.performance) {
          gameState.settings.performance = {};
        }
        gameState.settings.performance.postsPerPage = value;
        
        // Re-render feed if currently viewing it
        const socialTab = $('socialTab');
        if (socialTab && !socialTab.classList.contains('tab-content') || 
            (socialTab && socialTab.style.display !== 'none')) {
          renderSocialFeed(true);
        }
      });
      
      // Load saved value on startup
      if (gameState.settings.performance?.postsPerPage) {
        const savedValue = gameState.settings.performance.postsPerPage;
        postsPerPageSlider.value = savedValue;
        postsPerPageValue.textContent = savedValue;
        feedPaginationState.postsPerPage = savedValue;
      }
    }
    
    // Image style selector
    const imageStyleSelect = $('imageStyleSelect');
    const customPromptContainer = $('customPromptContainer');
    const customStylePrompt = $('customStylePrompt');
    
    if (imageStyleSelect) {
      imageStyleSelect.addEventListener('change', (e) => {
        const selectedValue = e.target.value;
        gameState.settings.imageStyle = selectedValue;
        
        // Show/hide custom prompt textarea
        if (customPromptContainer) {
          customPromptContainer.style.display = selectedValue === 'custom' ? 'block' : 'none';
        }
        
        showNotification(`🎨 Image style set to: ${e.target.options[e.target.selectedIndex].text}`, 'success');
      });
      
      // Load saved value on startup
      if (gameState.settings.imageStyle) {
        imageStyleSelect.value = gameState.settings.imageStyle;
        // Show custom prompt container if custom was selected
        if (customPromptContainer && gameState.settings.imageStyle === 'custom') {
          customPromptContainer.style.display = 'block';
        }
      }
    }
    
    // Custom style prompt textarea handler
    if (customStylePrompt) {
      customStylePrompt.addEventListener('input', (e) => {
        gameState.settings.customStylePrompt = e.target.value;
      });
      
      // Load saved custom prompt
      if (gameState.settings.customStylePrompt) {
        customStylePrompt.value = gameState.settings.customStylePrompt;
      }
    }
    
    // ====================
    // CHEATS SYSTEM
    // ====================
    
    // Initialize cheat multipliers in gameState
    if (!gameState.cheatMultipliers) {
      gameState.cheatMultipliers = {
        affection: 1.0,
        trust: 1.0,
        comfort: 1.0,
        desire: 1.0,
        productivity: 1.0,
        confidence: 1.0,
        obedience: 1.0,
        flirty: 1.0,
        professional: 1.0,
        humor: 1.0
      };
    }
    
    // Open/Close Cheats Modal
    const openCheatsBtn = $('openCheatsBtn');
    const closeCheatsBtn = $('closeCheatsBtn');
    const cheatsModal = $('cheatsModal');
    
    if (openCheatsBtn && cheatsModal) {
      openCheatsBtn.addEventListener('click', () => {
        cheatsModal.style.display = 'flex';
        // Refresh context windows when opening
        if (typeof refreshContextWindow === 'function') refreshContextWindow();
        if (typeof refreshGossipWindow === 'function') refreshGossipWindow();
      });
    }
    
    if (closeCheatsBtn && cheatsModal) {
      closeCheatsBtn.addEventListener('click', () => {
        cheatsModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (cheatsModal) {
      cheatsModal.addEventListener('click', (e) => {
        if (e.target === cheatsModal) {
          cheatsModal.style.display = 'none';
        }
      });
    }
    
    // Patch Notes Modal
    const openPatchNotesBtn = $('openPatchNotesBtn');
    const closePatchNotesBtn = $('closePatchNotesBtn');
    const patchNotesModal = $('patchNotesModal');
    
    if (openPatchNotesBtn && patchNotesModal) {
      openPatchNotesBtn.addEventListener('click', () => {
        patchNotesModal.style.display = 'flex';
        loadPatchNotes();
      });
    }
    
    if (closePatchNotesBtn && patchNotesModal) {
      closePatchNotesBtn.addEventListener('click', () => {
        patchNotesModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (patchNotesModal) {
      patchNotesModal.addEventListener('click', (e) => {
        if (e.target === patchNotesModal) {
          patchNotesModal.style.display = 'none';
        }
      });
    }
    
    // Money Setter
    const cheatMoneyBase = $('cheatMoneyBase');
    const cheatMoneyMagnitude = $('cheatMoneyMagnitude');
    const cheatMoneyPreview = $('cheatMoneyPreview');
    const cheatSetMoneyBtn = $('cheatSetMoneyBtn');
    
    function updateMoneyPreview() {
      if (!cheatMoneyBase || !cheatMoneyMagnitude || !cheatMoneyPreview) return;
      const base = parseInt(cheatMoneyBase.value) || 100;
      const magnitude = parseInt(cheatMoneyMagnitude.value) || 1000000;
      const total = base * magnitude;
      cheatMoneyPreview.textContent = total.toLocaleString();
    }
    
    if (cheatMoneyBase) cheatMoneyBase.addEventListener('input', updateMoneyPreview);
    if (cheatMoneyMagnitude) cheatMoneyMagnitude.addEventListener('change', updateMoneyPreview);
    
    if (cheatSetMoneyBtn && cheatMoneyBase && cheatMoneyMagnitude) {
      cheatSetMoneyBtn.addEventListener('click', () => {
        const base = parseInt(cheatMoneyBase.value) || 100;
        const magnitude = parseInt(cheatMoneyMagnitude.value) || 1000000;
        const total = base * magnitude;
        gameState.cash = total;
        showNotification(`💰 Money set to $${total.toLocaleString()}!`, 'success');
        updateUI();
      });
    }
    
    // Stat Multiplier Sliders
    const statMultipliers = ['affection', 'trust', 'comfort', 'desire', 'productivity', 'confidence', 'obedience', 'flirtiness', 'professionalism', 'humor'];
    
    statMultipliers.forEach(stat => {
      const slider = $(`${stat}MultSlider`);
      const value = $(`${stat}MultValue`);
      
      if (slider && value) {
        // Map slider value (0-50) to multiplier (0-5x)
        slider.addEventListener('input', (e) => {
          const mult = parseFloat(e.target.value) / 10;
          gameState.cheatMultipliers[stat] = mult;
          value.textContent = `${mult.toFixed(1)}x`;
        });
        
        // Set initial value
        const initialMult = gameState.cheatMultipliers[stat] || 1.0;
        slider.value = initialMult * 10;
        value.textContent = `${initialMult.toFixed(1)}x`;
      }
    });
    
    // Reset Multipliers
    const resetMultipliersBtn = $('resetMultipliersBtn');
    if (resetMultipliersBtn) {
      resetMultipliersBtn.addEventListener('click', () => {
        statMultipliers.forEach(stat => {
          gameState.cheatMultipliers[stat] = 1.0;
          const slider = $(`${stat}MultSlider`);
          const value = $(`${stat}MultValue`);
          if (slider) slider.value = 10;
          if (value) value.textContent = '1.0x';
        });
        showNotification('🔄 All multipliers reset to 1x', 'info');
      });
    }
    
    // Max Multipliers (5x)
    const maxMultipliersBtn = $('maxMultipliersBtn');
    if (maxMultipliersBtn) {
      maxMultipliersBtn.addEventListener('click', () => {
        statMultipliers.forEach(stat => {
          gameState.cheatMultipliers[stat] = 5.0;
          const slider = $(`${stat}MultSlider`);
          const value = $(`${stat}MultValue`);
          if (slider) slider.value = 50;
          if (value) value.textContent = '5.0x';
        });
        showNotification('⚡ All multipliers set to 5x!', 'success');
      });
    }
    
    // Set Stats for All NPCs
    const cheatStatType = $('cheatStatType');
    const cheatStatValue = $('cheatStatValue');
    const cheatSetStatBtn = $('cheatSetStatBtn');
    
    if (cheatSetStatBtn && cheatStatType && cheatStatValue) {
      cheatSetStatBtn.addEventListener('click', () => {
        const statType = cheatStatType.value;
        const value = parseInt(cheatStatValue.value);
        
        if (value < 0 || value > 100) {
          showNotification('⚠️ Value must be between 0 and 100', 'error');
          return;
        }
        
        let count = 0;
        gameState.employees.forEach(emp => {
          if (emp.employmentStatus === 'active') {
            // Handle different stat locations
            if (['affection', 'trust', 'comfort', 'desire', 'productivity'].includes(statType)) {
              if (!emp.stats) emp.stats = {};
              emp.stats[statType] = value;
              count++;
            } else if (['confidence', 'obedience', 'flirty', 'professional', 'humor'].includes(statType)) {
              if (!emp.personality) emp.personality = {};
              emp.personality[statType] = value;
              count++;
            }
          }
        });
        
        showNotification(`✅ Set ${statType} to ${value} for ${count} employees!`, 'success');
      });
    }
    
    // Quick Actions
    const cheatMaxAllStatsBtn = $('cheatMaxAllStatsBtn');
    if (cheatMaxAllStatsBtn) {
      cheatMaxAllStatsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.employees.forEach(emp => {
          if (emp.employmentStatus === 'active') {
            if (!emp.stats) emp.stats = {};
            emp.stats.affection = 100;
            emp.stats.trust = 100;
            emp.stats.comfort = 100;
            emp.stats.desire = 100;
            emp.stats.productivity = 100;
            
            if (!emp.personality) emp.personality = {};
            emp.personality.confidence = 100;
            emp.personality.obedience = 100;
            emp.personality.flirty = 100;
            emp.personality.professional = 100;
            emp.personality.humor = 100;
            
            count++;
          }
        });
        showNotification(`🌟 Maxed all stats for ${count} employees!`, 'success');
      });
    }
    
    const cheatUnlockAllLocationsBtn = $('cheatUnlockAllLocationsBtn');
    if (cheatUnlockAllLocationsBtn) {
      cheatUnlockAllLocationsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.locations.forEach(loc => {
          if (!loc.owned) {
            loc.owned = true;
            loc.unlocked = true;
            count++;
          }
        });
        showNotification(`🏢 Unlocked ${count} locations!`, 'success');
        renderLocations();
      });
    }
    
    const cheatUnlockAllProductsBtn = $('cheatUnlockAllProductsBtn');
    if (cheatUnlockAllProductsBtn) {
      cheatUnlockAllProductsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.products.forEach(prod => {
          if (!prod.unlocked) {
            prod.unlocked = true;
            count++;
          }
        });
        showNotification(`📦 Unlocked ${count} products!`, 'success');
        renderProducts();
      });
    }
    
    const cheatHireAllBtn = $('cheatHireAllBtn');
    if (cheatHireAllBtn) {
      cheatHireAllBtn.addEventListener('click', () => {
        if (!gameState.candidates || gameState.candidates.length === 0) {
          showNotification('⚠️ No candidates available to hire!', 'error');
          return;
        }
        
        const toHire = gameState.candidates.filter(c => !c.hired);
        toHire.forEach(candidate => {
          candidate.hired = true;
          candidate.employmentStatus = 'active';
          candidate.hireDate = Date.now();
          candidate.bioComplete = true;
          candidate.onboarding = false;
          
          // Initialize social data
          initializeEmployeeSocialData(candidate);
          
          gameState.employees.push(candidate);
          generateRandomRelationships(candidate.id);
        });
        
        gameState.candidates = gameState.candidates.filter(c => c.hired);
        
        showNotification(`👥 Hired ${toHire.length} candidates!`, 'success');
        updateCompanyAwareness();
      });
    }
    
    const cheatClearPostsBtn = $('cheatClearPostsBtn');
    if (cheatClearPostsBtn) {
      cheatClearPostsBtn.addEventListener('click', () => {
        const count = gameState.socialNetwork.posts.length;
        gameState.socialNetwork.posts = [];
        showNotification(`🗑️ Cleared ${count} posts!`, 'info');
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      });
    }
    
    const cheatSpawnPostsBtn = $('cheatSpawnPostsBtn');
    if (cheatSpawnPostsBtn) {
      cheatSpawnPostsBtn.addEventListener('click', async () => {
        const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
        if (activeEmployees.length === 0) {
          showNotification('⚠️ No active employees to create posts!', 'error');
          return;
        }
        
        showNotification('📱 Generating 10 NPC posts...', 'info');
        
        for (let i = 0; i < 10; i++) {
          const randomEmp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
          
          // Generate a random post type
          const postTypes = ['text', 'selfie', 'life_update', 'work', 'gossip'];
          const postType = postTypes[Math.floor(Math.random() * postTypes.length)];
          
          await generateNPCPost(randomEmp, postType);
          
          // Small delay between posts
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        showNotification('✅ Generated 10 NPC posts!', 'success');
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      });
    }
    
    // ========== CONTEXT WINDOWS ==========
    
    // Refresh Company-Wide Context
    const cheatRefreshContextBtn = $('cheatRefreshContextBtn');
    if (cheatRefreshContextBtn) {
      cheatRefreshContextBtn.addEventListener('click', () => {
        refreshContextWindow();
      });
    }
    
    // Clear Company-Wide Context
    const cheatClearContextBtn = $('cheatClearContextBtn');
    if (cheatClearContextBtn) {
      cheatClearContextBtn.addEventListener('click', () => {
        if (confirm('Clear all Company-Wide Context items? NPCs will forget all recent company events.')) {
          gameState.companyWideContext.currentBuzz = [];
          refreshContextWindow();
          showNotification('🗑️ Company-Wide Context cleared!', 'info');
        }
      });
    }
    
    // Refresh Gossip Engine
    const cheatRefreshGossipBtn = $('cheatRefreshGossipBtn');
    if (cheatRefreshGossipBtn) {
      cheatRefreshGossipBtn.addEventListener('click', () => {
        refreshGossipWindow();
      });
    }
    
    // Clear Gossip Engine
    const cheatClearGossipBtn = $('cheatClearGossipBtn');
    if (cheatClearGossipBtn) {
      cheatClearGossipBtn.addEventListener('click', () => {
        if (confirm('Clear all gossip from all NPCs? This will reset their knowledge of company drama.')) {
          gameState.employees.forEach(emp => {
            if (emp.gossip) {
              emp.gossip = [];
            }
          });
          refreshGossipWindow();
          showNotification('🗑️ All gossip cleared!', 'info');
        }
      });
    }
    
    // Functions to refresh context windows
    function refreshContextWindow() {
      const contextList = $('contextList');
      const contextCountLabel = $('contextCountLabel');
      
      if (!contextList || !contextCountLabel) return;
      
      const items = gameState.companyWideContext?.currentBuzz || [];
      contextCountLabel.textContent = `(${items.length}/${gameState.companyWideContext?.maxItems || 40})`;
      
      if (items.length === 0) {
        contextList.innerHTML = '<p style="color:#aaa; text-align:center; margin:20px 0;">No context items yet</p>';
        return;
      }
      
      // Sort by timestamp (newest first)
      const sortedItems = [...items].sort((a, b) => b.timestamp - a.timestamp);
      
      contextList.innerHTML = sortedItems.map((item, index) => {
        const timeAgo = formatTimeAgo(item.timestamp);
        const juiciness = item.juiciness || 0;
        const juiceColor = juiciness > 70 ? '#e94560' : juiciness > 40 ? '#ffd700' : '#00d4ff';
        
        return `
          <div style="background:#0f3460; border-radius:8px; padding:12px; margin-bottom:8px; border-left:3px solid ${juiceColor};">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:6px;">
              <div style="flex:1;">
                <div style="color:#ddd; font-size:0.95rem; line-height:1.4; margin-bottom:6px;">${item.info}</div>
                <div style="display:flex; gap:12px; font-size:0.8rem; color:#aaa;">
                  <span>🔥 ${juiciness}/100</span>
                  <span>⏰ ${timeAgo}</span>
                  ${item.involvedEmployees ? `<span>👥 ${item.involvedEmployees.length}</span>` : ''}
                </div>
              </div>
              <button onclick="removeContextItem(${index})" style="background:#e94560; border:none; padding:6px 10px; border-radius:6px; color:white; cursor:pointer; font-size:0.8rem; margin-left:8px;">
                🗑️
              </button>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function refreshGossipWindow() {
      const gossipList = $('gossipList');
      const gossipCountLabel = $('gossipCountLabel');
      
      if (!gossipList || !gossipCountLabel) return;
      
      const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
      const employeesWithGossip = activeEmployees.filter(e => 
        e.gossip && e.gossip.knownGossip && e.gossip.knownGossip.length > 0
      );
      
      gossipCountLabel.textContent = `(${employeesWithGossip.length} NPCs)`;
      
      if (employeesWithGossip.length === 0) {
        gossipList.innerHTML = '<p style="color:#aaa; text-align:center; margin:20px 0;">No gossip yet</p>';
        return;
      }
      
      gossipList.innerHTML = employeesWithGossip.map(emp => {
        const gossipItems = emp.gossip?.knownGossip || [];
        const totalGossip = gossipItems.length;
        
        return `
          <div style="background:#0f3460; border-radius:8px; padding:12px; margin-bottom:12px; border:1px solid #ff69b4;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
              <div style="display:flex; align-items:center; gap:10px;">
                <img src="${emp.profileImage || 'https://placehold.co/40x40'}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
                <div>
                  <div style="color:#fff; font-weight:600;">${emp.name}</div>
                  <div style="color:#aaa; font-size:0.85rem;">${totalGossip} gossip item${totalGossip !== 1 ? 's' : ''}</div>
                </div>
              </div>
              <button onclick="clearEmployeeGossip('${emp.id}')" style="background:#e94560; border:none; padding:6px 12px; border-radius:6px; color:white; cursor:pointer; font-size:0.8rem;">
                Clear
              </button>
            </div>
            <div style="max-height:150px; overflow-y:auto;">
              ${gossipItems.slice(0, 5).map(g => {
                const timeAgo = formatTimeAgo(g.timestamp || g.heardAt || Date.now());
                const juiceColor = g.juiciness > 70 ? '#e94560' : g.juiciness > 40 ? '#ffd700' : '#00d4ff';
                
                return `
                  <div style="background:#16213e; border-radius:6px; padding:8px; margin-bottom:6px; border-left:2px solid ${juiceColor};">
                    <div style="color:#ddd; font-size:0.9rem; margin-bottom:4px;">${g.content || g.info || g.description || 'Unknown gossip'}</div>
                    <div style="display:flex; gap:8px; font-size:0.75rem; color:#aaa;">
                      <span>🔥 ${g.juiciness || 0}</span>
                      <span>⏰ ${timeAgo}</span>
                      ${g.source ? `<span>📢 ${g.source}</span>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
              ${totalGossip > 5 ? `<p style="color:#aaa; font-size:0.85rem; text-align:center; margin:8px 0 0 0;">+${totalGossip - 5} more...</p>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Helper functions (global scope for onclick)
    window.removeContextItem = function(index) {
      if (confirm('Remove this context item?')) {
        gameState.companyWideContext.currentBuzz.splice(index, 1);
        refreshContextWindow();
        showNotification('Context item removed', 'info');
      }
    };
    
    window.clearEmployeeGossip = function(employeeId) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (emp && emp.gossip && emp.gossip.knownGossip) {
        emp.gossip.knownGossip = [];
        refreshGossipWindow();
        showNotification(`Cleared gossip for ${emp.name}`, 'info');
      }
    };
    
    // Helper function to format time ago
    function formatTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }
    
    // Player Bio - DEPRECATED: Now handled by player profile modal
    // Old textarea-based bio system has been replaced
    const playerBioInput = $('playerBioInput'); // No longer exists in HTML
    const savePlayerBio = $('savePlayerBio');   // No longer exists in HTML
    
    // Kept for backward compatibility but will not execute
    if (playerBioInput && savePlayerBio) {
      // This code path won't execute since elements were removed
      savePlayerBio.addEventListener('click', () => {
        gameState.settings.playerBio = playerBioInput.value.trim();
        savePlayerBio.textContent = '✓ Saved!';
        savePlayerBio.style.background = '#00d4ff';
        setTimeout(() => {
          savePlayerBio.textContent = 'Save Player Bio';
          savePlayerBio.style.background = '#00d4ff';
        }, 2000);
      });
    }
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.addEventListener('input', (e) => {
        gameState.settings.atmosphere = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Balanced';
        if (val < 33) label = 'Professional';
        else if (val > 66) label = 'Relaxed';
        atmosphereValue.textContent = label;
      });
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.addEventListener('input', (e) => {
        gameState.settings.guidelines = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Standard';
        if (val < 33) label = 'Reserved';
        else if (val > 66) label = 'Outgoing';
        guidelinesValue.textContent = label;
      });
    }
    
    // Policy buttons
    document.querySelectorAll('.policy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        gameState.settings.policy = btn.dataset.policy;
        
        // Update button styles
        document.querySelectorAll('.policy-btn').forEach(b => {
          b.style.background = '#0f3460';
          b.style.borderColor = '#00d4ff';
          b.style.color = 'white';
        });
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
        
        // Update policy value label
        const policyValue = document.getElementById('policyValue');
        if (policyValue) {
          const policyLabels = {
            'professional': 'Professional',
            'casual': 'Casual',
            'open': 'Enthusiastic'
          };
          policyValue.textContent = policyLabels[btn.dataset.policy] || 'Professional';
        }
      });
    });
    
    // Data management
    if (saveBtn) saveBtn.addEventListener('click', () => saveGame(true)); // Show toast
    if (loadBtn) loadBtn.addEventListener('click', loadGame);
    if (exportBtn) exportBtn.addEventListener('click', exportSave);
    if (resetBtn) resetBtn.addEventListener('click', resetGame);
    
    // Import button
    const importBtn = $('importBtn');
    if (importBtn) importBtn.addEventListener('click', importSave);
    
    // File input for import
    const importFileInput = $('importFileInput');
    if (importFileInput) importFileInput.addEventListener('change', handleImportedFile);
    
    // Chat modal
    if (closeChatBtn) {
      closeChatBtn.addEventListener('click', () => {
        if (chatModal) {
          chatModal.hidden = true;
          chatModal.style.display = 'none';
          chatModal.style.pointerEvents = 'none';
          gameState.activeChat = null;
        }
      });
    }
    
    // Clear chat button
    const clearChatBtn = $('clearChatBtn');
    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', () => {
        if (!gameState.activeChat) return;
        
        const employee = gameState.employees.find(e => e.id === gameState.activeChat);
        if (!employee) return;
        
        // Confirm before clearing
        if (!confirm(`Clear chat history with ${employee.name}?\n\nThis will archive the conversation but remove it from view. Context will be preserved for AI.`)) {
          return;
        }
        
        // Archive current chat history
        const currentHistory = gameState.chatHistory[gameState.activeChat] || [];
        if (currentHistory.length > 0) {
          // Initialize archive if it doesn't exist
          if (!employee.conversationArchive) {
            employee.conversationArchive = [];
          }
          
          // Add current chat to archive with timestamp
          employee.conversationArchive.push({
            timestamp: Date.now(),
            messages: [...currentHistory],
            messageCount: currentHistory.length
          });
          
          // Keep only last 5 archived conversations to prevent bloat
          if (employee.conversationArchive.length > 5) {
            employee.conversationArchive = employee.conversationArchive.slice(-5);
          }
          
          // Clear visible chat
          gameState.chatHistory[gameState.activeChat] = [];
          
          // Update display
          renderChatMessages();
          
          showNotification(`Chat with ${employee.name} cleared and archived.`);
        }
      });
    }
    
    // Function to refresh chat display
    window.refreshChatDisplay = function() {
      if (gameState.activeChat && gameState.activeChat.id) {
        // Trigger chat open to refresh
        const employee = gameState.employees.find(e => e.id === gameState.activeChat.id);
        if (employee) {
          openChat(employee);
        }
      }
    };
    
    // Typing indicator functions
    window.showTypingIndicator = function(employee) {
      const chatTypingIndicator = $('chatTypingIndicator');
      const chatTypingName = $('chatTypingName');
      if (chatTypingIndicator && chatTypingName) {
        chatTypingName.textContent = employee.name;
        chatTypingIndicator.style.display = 'block';
        
        // Scroll to bottom
        const chatMessages = $('chatMessages');
        if (chatMessages) {
          setTimeout(() => chatMessages.scrollTop = chatMessages.scrollHeight, 100);
        }
      }
    };
    
    window.hideTypingIndicator = function() {
      const chatTypingIndicator = $('chatTypingIndicator');
      if (chatTypingIndicator) {
        chatTypingIndicator.style.display = 'none';
      }
    };
    
    if (chatSendBtn) {
      chatSendBtn.addEventListener('click', sendOrUpdateChatMessage);
    }
    
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOrUpdateChatMessage();
      });
    }
    
    // Emoji picker for chat
    const chatEmojiBtn = $('chatEmojiBtn');
    console.log('Chat emoji button:', chatEmojiBtn, 'Chat input:', chatInput);
    if (chatEmojiBtn && chatInput) {
      chatEmojiBtn.addEventListener('click', (e) => {
        console.log('Chat emoji button clicked!');
        e.stopPropagation();
        emojiPicker.show(chatInput, chatEmojiBtn);
      });
    }
    
    // Emoji picker for post caption
    const postCaptionEmojiBtn = $('postCaptionEmojiBtn');
    const playerPostCaption = $('playerPostCaption');
    if (postCaptionEmojiBtn && playerPostCaption) {
      postCaptionEmojiBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.show(playerPostCaption, postCaptionEmojiBtn);
      });
    }
    
    // Emoji picker for comments (delegated event)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-emoji-btn')) {
        e.stopPropagation();
        const postId = e.target.dataset.postId;
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        if (commentInput) {
          emojiPicker.show(commentInput, e.target);
        }
      }
    });
    
    // Initialize emoji picker
    emojiPicker.init();
    
    // Player Profile Modal
    const openPlayerProfileBtn = $('openPlayerProfileBtn');
    const playerProfileModal = $('playerProfileModal');
    const closePlayerProfileModal = $('closePlayerProfileModal');
    const cancelPlayerProfile = $('cancelPlayerProfile');
    const savePlayerProfile = $('savePlayerProfile');
    
    if (openPlayerProfileBtn && playerProfileModal) {
      openPlayerProfileBtn.addEventListener('click', () => {
        // Load current profile data into form
        $('playerFirstName').value = gameState.playerProfile.firstName || '';
        $('playerLastName').value = gameState.playerProfile.lastName || '';
        $('playerAge').value = gameState.playerProfile.age || '';
        $('playerGender').value = gameState.playerProfile.gender || '';
        $('playerEthnicity').value = gameState.playerProfile.ethnicity || '';
        $('playerSkinTone').value = gameState.playerProfile.skinTone || '';
        $('playerHeight').value = gameState.playerProfile.height || '';
        $('playerBodyType').value = gameState.playerProfile.bodyType || '';
        $('playerHairColor').value = gameState.playerProfile.hairColor || '';
        $('playerHairStyle').value = gameState.playerProfile.hairStyle || '';
        $('playerEyeColor').value = gameState.playerProfile.eyeColor || '';
        $('playerFacialHair').value = gameState.playerProfile.facialHair || '';
        $('playerGenitalType').value = gameState.playerProfile.genitalType || '';
        $('playerGenitalDetails').value = gameState.playerProfile.genitalDetails || '';
        $('playerChestSize').value = gameState.playerProfile.chestSize || '';
        $('playerBuildDetails').value = gameState.playerProfile.buildDetails || '';
        $('playerAdditionalDetails').value = gameState.playerProfile.additionalDetails || '';
        $('playerPersonality').value = gameState.playerProfile.personality || '';
        
        playerProfileModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        playerProfileModal.style.display = 'none';
      };
      
      if (closePlayerProfileModal) closePlayerProfileModal.addEventListener('click', closeModal);
      if (cancelPlayerProfile) cancelPlayerProfile.addEventListener('click', closeModal);
      
      if (savePlayerProfile) {
        savePlayerProfile.addEventListener('click', () => {
          // Save all fields
          gameState.playerProfile.firstName = $('playerFirstName').value.trim();
          gameState.playerProfile.lastName = $('playerLastName').value.trim();
          gameState.playerProfile.age = parseInt($('playerAge').value) || null;
          gameState.playerProfile.gender = $('playerGender').value;
          gameState.playerProfile.ethnicity = $('playerEthnicity').value.trim();
          gameState.playerProfile.skinTone = $('playerSkinTone').value.trim();
          gameState.playerProfile.height = $('playerHeight').value.trim();
          gameState.playerProfile.bodyType = $('playerBodyType').value.trim();
          gameState.playerProfile.hairColor = $('playerHairColor').value.trim();
          gameState.playerProfile.hairStyle = $('playerHairStyle').value.trim();
          gameState.playerProfile.eyeColor = $('playerEyeColor').value.trim();
          gameState.playerProfile.facialHair = $('playerFacialHair').value.trim();
          gameState.playerProfile.genitalType = $('playerGenitalType').value;
          gameState.playerProfile.genitalDetails = $('playerGenitalDetails').value.trim();
          gameState.playerProfile.chestSize = $('playerChestSize').value.trim();
          gameState.playerProfile.buildDetails = $('playerBuildDetails').value.trim();
          gameState.playerProfile.additionalDetails = $('playerAdditionalDetails').value.trim();
          gameState.playerProfile.personality = $('playerPersonality').value.trim();
          
          showNotification('Player profile saved!');
          playerProfileModal.style.display = 'none';
          saveGame(); // Auto-save after profile update
        });
      }
    }
    
    // Gender Options Modal
    const genderOptionsBtn = $('genderOptionsBtn');
    const genderOptionsModal = $('genderOptionsModal');
    const closeGenderOptionsModal = $('closeGenderOptionsModal');
    const cancelGenderOptions = $('cancelGenderOptions');
    const saveGenderOptions = $('saveGenderOptions');
    
    // Get all slider elements
    const femaleSlider = $('femaleSlider');
    const maleSlider = $('maleSlider');
    const femaleFutaSlider = $('femaleFutaSlider');
    const transManSlider = $('transManSlider');
    const transWomanSlider = $('transWomanSlider');
    
    // Get percentage display elements
    const femalePercentage = $('femalePercentage');
    const malePercentage = $('malePercentage');
    const femaleFutaPercentage = $('femaleFutaPercentage');
    const transManPercentage = $('transManPercentage');
    const transWomanPercentage = $('transWomanPercentage');
    const genderTotalValue = $('genderTotalValue');
    const genderWarning = $('genderWarning');
    
    // Function to update gender distribution display
    function updateGenderDistributionDisplay() {
      const settings = gameState.genderSettings;
      const displayEl = $('genderDistributionDisplay');
      if (!displayEl) return;
      
      const genderColors = {
        female: '#ff6b9d',
        male: '#00d4ff',
        femaleFuta: '#c77dff',
        transMan: '#4ecca3',
        transWoman: '#ffd700'
      };
      
      const genderLabels = {
        female: 'Female',
        male: 'Male',
        femaleFuta: 'Female Futa',
        transMan: 'Trans Man',
        transWoman: 'Trans Woman'
      };
      
      displayEl.innerHTML = Object.entries(settings)
        .filter(([key, value]) => value > 0)
        .map(([key, value]) => `
          <div style="text-align:center; padding:8px; background:#0f3460; border-radius:6px;">
            <div style="color:${genderColors[key]}; font-weight:700; font-size:1.5rem;">${value}%</div>
            <div style="color:#aaa; font-size:0.75rem;">${genderLabels[key]}</div>
          </div>
        `).join('');
      
      if (Object.values(settings).every(v => v === 0)) {
        displayEl.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#666; padding:20px;">No gender settings configured</div>';
      }
    }
    
    // Function to normalize sliders (make them proportional to 100%)
    function normalizeGenderSliders(changedSlider) {
      const sliders = [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider];
      const values = sliders.map(s => parseInt(s.value));
      const total = values.reduce((sum, v) => sum + v, 0);
      
      if (total === 0) {
        // If everything is 0, reset to default (100% female)
        femaleSlider.value = 100;
        updateSliderDisplays();
        return;
      }
      
      if (total === 100) {
        // Perfect total, just update displays
        updateSliderDisplays();
        return;
      }
      
      // Normalize all sliders except the one that just changed
      const changedIndex = sliders.indexOf(changedSlider);
      const changedValue = parseInt(changedSlider.value);
      const otherTotal = total - changedValue;
      const remaining = 100 - changedValue;
      
      if (remaining < 0) {
        // Changed slider exceeds 100%, cap it at 100 and zero others
        changedSlider.value = 100;
        sliders.forEach((s, i) => {
          if (i !== changedIndex) s.value = 0;
        });
      } else if (otherTotal > 0) {
        // Proportionally adjust other sliders
        sliders.forEach((s, i) => {
          if (i !== changedIndex) {
            const currentVal = parseInt(s.value);
            const proportion = currentVal / otherTotal;
            s.value = Math.round(proportion * remaining);
          }
        });
        
        // Fix rounding errors - adjust largest other slider
        const newTotal = sliders.reduce((sum, s) => sum + parseInt(s.value), 0);
        if (newTotal !== 100) {
          const diff = 100 - newTotal;
          let largestOtherIndex = -1;
          let largestOtherValue = -1;
          sliders.forEach((s, i) => {
            if (i !== changedIndex) {
              const val = parseInt(s.value);
              if (val > largestOtherValue) {
                largestOtherValue = val;
                largestOtherIndex = i;
              }
            }
          });
          if (largestOtherIndex >= 0) {
            sliders[largestOtherIndex].value = parseInt(sliders[largestOtherIndex].value) + diff;
          }
        }
      }
      
      updateSliderDisplays();
    }
    
    // Function to update slider percentage displays
    function updateSliderDisplays() {
      femalePercentage.textContent = femaleSlider.value;
      malePercentage.textContent = maleSlider.value;
      femaleFutaPercentage.textContent = femaleFutaSlider.value;
      transManPercentage.textContent = transManSlider.value;
      transWomanPercentage.textContent = transWomanSlider.value;
      
      const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                    parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                    parseInt(transWomanSlider.value);
      
      genderTotalValue.textContent = total;
      
      if (total === 100) {
        genderTotalValue.style.color = '#00d4ff';
        genderWarning.style.display = 'none';
      } else {
        genderTotalValue.style.color = '#e94560';
        genderWarning.style.display = 'block';
      }
    }
    
    // Open gender options modal
    if (genderOptionsBtn && genderOptionsModal) {
      genderOptionsBtn.addEventListener('click', () => {
        // Load current settings
        femaleSlider.value = gameState.genderSettings.female;
        maleSlider.value = gameState.genderSettings.male;
        femaleFutaSlider.value = gameState.genderSettings.femaleFuta;
        transManSlider.value = gameState.genderSettings.transMan;
        transWomanSlider.value = gameState.genderSettings.transWoman;
        
        updateSliderDisplays();
        genderOptionsModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        genderOptionsModal.style.display = 'none';
      };
      
      if (closeGenderOptionsModal) closeGenderOptionsModal.addEventListener('click', closeModal);
      if (cancelGenderOptions) cancelGenderOptions.addEventListener('click', closeModal);
      
      // Add slider listeners
      [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider].forEach(slider => {
        if (slider) {
          slider.addEventListener('input', () => normalizeGenderSliders(slider));
        }
      });
      
      // Save gender settings
      if (saveGenderOptions) {
        saveGenderOptions.addEventListener('click', () => {
          const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                        parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                        parseInt(transWomanSlider.value);
          
          if (total !== 100) {
            showNotification('Total must equal 100%!');
            return;
          }
          
          // Save settings
          gameState.genderSettings.female = parseInt(femaleSlider.value);
          gameState.genderSettings.male = parseInt(maleSlider.value);
          gameState.genderSettings.femaleFuta = parseInt(femaleFutaSlider.value);
          gameState.genderSettings.transMan = parseInt(transManSlider.value);
          gameState.genderSettings.transWoman = parseInt(transWomanSlider.value);
          
          showNotification('Gender settings saved! New hires will reflect these percentages.');
          updateGenderDistributionDisplay();
          genderOptionsModal.style.display = 'none';
          saveGame(); // Auto-save after settings update
        });
      }
    }
    
    // Initialize gender distribution display
    updateGenderDistributionDisplay();
    
    // Attachment menu
    const chatAttachBtn = $('chatAttachBtn');
    const attachmentMenu = $('attachmentMenu');
    if (chatAttachBtn && attachmentMenu) {
      chatAttachBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = attachmentMenu.style.display === 'block';
        attachmentMenu.style.display = isVisible ? 'none' : 'block';
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!chatAttachBtn.contains(e.target) && !attachmentMenu.contains(e.target)) {
          attachmentMenu.style.display = 'none';
        }
      });
      
      // Attachment menu items
      document.querySelectorAll('.attach-menu-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          attachmentMenu.style.display = 'none';
          
          if (action === 'send-money') {
            openSendMoneyModal();
          } else if (action === 'give-gift') {
            openGiftSelectionModal();
          } else if (action === 'request') {
            $('requestImageModal').style.display = 'flex';
          } else if (action === 'send') {
            $('sendImageModal').style.display = 'flex';
          } else if (action === 'request-post') {
            $('requestPostModal').style.display = 'flex';
          } else if (action === 'visualize') {
            visualizeCurrentScene();
          }
        });
      });
    }
    
    // Send Image Modal
    const sendImageModal = $('sendImageModal');
    const closeSendImageModal = $('closeSendImageModal');
    const cancelSendImage = $('cancelSendImage');
    const confirmSendImage = $('confirmSendImage');
    const sendImagePrompt = $('sendImagePrompt');
    
    if (closeSendImageModal) {
      closeSendImageModal.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (cancelSendImage) {
      cancelSendImage.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (confirmSendImage) {
      confirmSendImage.addEventListener('click', async () => {
        const prompt = sendImagePrompt.value.trim();
        if (prompt) {
          sendImageModal.style.display = 'none';
          sendImagePrompt.value = '';
          await sendImageToNPC(prompt);
        }
      });
    }
    
    // Send Money Modal
    const sendMoneyModal = $('sendMoneyModal');
    const closeSendMoneyModal = $('closeSendMoneyModal');
    const cancelSendMoney = $('cancelSendMoney');
    const confirmSendMoney = $('confirmSendMoney');
    const customMoneyAmount = $('customMoneyAmount');
    
    function openSendMoneyModal() {
      const balance = gameState.cash || 0;
      $('sendMoneyBalance').textContent = '$' + formatCash(balance);
      
      // Calculate preset amounts (1%, 5%, 10% of balance)
      const small = Math.max(100, Math.floor(balance * 0.01));
      const medium = Math.max(1000, Math.floor(balance * 0.05));
      const large = Math.max(10000, Math.floor(balance * 0.10));
      
      $('moneySmall').textContent = '$' + formatCash(small);
      $('moneyMedium').textContent = '$' + formatCash(medium);
      $('moneyLarge').textContent = '$' + formatCash(large);
      
      customMoneyAmount.value = '';
      $('moneyMessage').value = '';
      sendMoneyModal.style.display = 'flex';
    }
    
    if (closeSendMoneyModal) {
      closeSendMoneyModal.addEventListener('click', () => {
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
      });
    }
    
    if (cancelSendMoney) {
      cancelSendMoney.addEventListener('click', () => {
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
      });
    }
    
    // Money preset buttons - populate custom amount field instead of immediately sending
    document.querySelectorAll('.money-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        const balance = gameState.cash || 0;
        
        let amount = 0;
        if (preset === 'small') amount = Math.max(100, Math.floor(balance * 0.01));
        else if (preset === 'medium') amount = Math.max(1000, Math.floor(balance * 0.05));
        else if (preset === 'large') amount = Math.max(10000, Math.floor(balance * 0.10));
        
        // Populate the custom amount field with the preset value
        if (customMoneyAmount) {
          customMoneyAmount.value = amount;
          customMoneyAmount.focus();
        }
      });
      
      // Hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#4ecca3';
        btn.style.borderColor = '#4ecca3';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.borderColor = '#4ecca3';
      });
    });
    
    if (confirmSendMoney) {
      confirmSendMoney.addEventListener('click', async () => {
        const amount = parseInt(customMoneyAmount.value) || 0;
        const balance = gameState.cash || 0;
        const message = $('moneyMessage').value.trim();
        
        if (amount <= 0) {
          showNotification('❌ Please enter a valid amount', 'error');
          return;
        }
        
        if (amount > balance) {
          showNotification('❌ Insufficient funds!', 'error');
          return;
        }
        
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
        await sendMoneyToNPC(amount, message);
      });
    }
    
    // Gift Selection Modal
    const giftSelectionModal = $('giftSelectionModal');
    const closeGiftSelectionModal = $('closeGiftSelectionModal');
    const cancelGiftSelection = $('cancelGiftSelection');
    const giftSelectionGrid = $('giftSelectionGrid');
    const giftSelectionEmpty = $('giftSelectionEmpty');
    let currentGiftRecipient = null;
    
    window.openGiftSelectionModal = function() {
      if (!gameState.activeChat) {
        console.error('[Gift Modal] No active chat');
        return;
      }
      
      // activeChat is the employee object itself, not just the ID
      const employee = gameState.activeChat;
      currentGiftRecipient = employee.id;
      
      if (!giftSelectionModal) {
        console.error('[Gift Modal] Modal element not found');
        return;
      }
      
      // Set recipient name
      const recipientNameEl = $('giftRecipientName');
      if (recipientNameEl) {
        recipientNameEl.textContent = `Giving a gift to ${employee.name}`;
      }
      
      // Show preferences (hidden until learned)
      const prefs = employee.giftPreferences || { loves: [], hates: [], learnedLoves: [], learnedHates: [] };
      
      // Ensure learned arrays exist (for save compatibility)
      if (!prefs.learnedLoves) prefs.learnedLoves = [];
      if (!prefs.learnedHates) prefs.learnedHates = [];
      
      // Show learned loves, hide unknown ones
      const lovesDisplay = prefs.loves.map(cat => {
        if (prefs.learnedLoves.includes(cat)) {
          const category = GIFT_CATEGORIES[cat];
          return category ? `${category.emoji} ${category.name}` : cat;
        } else {
          return '❓ ?????';
        }
      });
      const lovesText = lovesDisplay.join(', ') || 'Unknown';
      
      // Show learned hates, hide unknown ones
      const hatesDisplay = prefs.hates.map(cat => {
        if (prefs.learnedHates.includes(cat)) {
          const category = GIFT_CATEGORIES[cat];
          return category ? `${category.emoji} ${category.name}` : cat;
        } else {
          return '❓ ?????';
        }
      });
      const hatesText = hatesDisplay.join(', ') || 'Unknown';
      
      const lovesEl = $('giftLovesHint');
      const hatesEl = $('giftHatesHint');
      if (lovesEl) lovesEl.textContent = lovesText;
      if (hatesEl) hatesEl.textContent = hatesText;
      
      // Populate gift grid
      populateGiftSelectionGrid(employee);
      
      console.log('[Gift Modal] Opening modal for', employee.name);
      giftSelectionModal.style.display = 'flex';
    }
    
    function populateGiftSelectionGrid(employee) {
      const inventory = gameState.giftInventory?.items || [];
      
      if (inventory.length === 0) {
        giftSelectionGrid.style.display = 'none';
        giftSelectionEmpty.style.display = 'block';
        return;
      }
      
      giftSelectionGrid.style.display = 'grid';
      giftSelectionEmpty.style.display = 'none';
      giftSelectionGrid.innerHTML = '';
      
      const prefs = employee.giftPreferences || { loves: [], neutral: [], hates: [] };
      
      inventory.forEach(gift => {
        const category = GIFT_CATEGORIES[gift.category];
        const categoryEmoji = category ? category.emoji : '🎁';
        const categoryName = category ? category.name : gift.category;
        
        // Determine preference match
        let matchType = 'neutral';
        let matchColor = '#aaa';
        let matchText = '';
        
        if (prefs.loves?.includes(gift.category)) {
          matchType = 'loves';
          matchColor = '#4ecca3';
          matchText = "They'll LOVE this! 💕";
        } else if (prefs.hates?.includes(gift.category)) {
          matchType = 'hates';
          matchColor = '#e94560';
          matchText = "They might hate this... 💔";
        } else {
          matchText = "They'll appreciate this 👍";
        }
        
        const card = document.createElement('div');
        card.style.cssText = `
          background: #0f3460;
          border-radius: 10px;
          padding: 15px;
          cursor: pointer;
          transition: all 0.2s;
          border: 2px solid ${matchType === 'loves' ? '#4ecca3' : matchType === 'hates' ? '#e94560' : '#0f3460'};
          position: relative;
        `;
        
        card.innerHTML = `
          <div style="font-size: 2.5rem; text-align: center; margin-bottom: 8px;">${categoryEmoji}</div>
          <h4 style="margin: 0 0 5px 0; font-size: 0.95rem; color: white; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${gift.name}">${gift.name}</h4>
          <p style="margin: 0 0 8px 0; font-size: 0.75rem; color: #aaa; text-align: center;">${categoryName}</p>
          <p style="margin: 0 0 8px 0; font-size: 0.9rem; color: #4ecca3; text-align: center; font-weight: 600;">$${formatCash(gift.price)}</p>
          <p style="margin: 0; font-size: 0.75rem; color: ${matchColor}; text-align: center; font-weight: 600;">${matchText}</p>
        `;
        
        // Hover effect
        card.addEventListener('mouseenter', () => {
          card.style.transform = 'translateY(-5px)';
          card.style.boxShadow = `0 8px 20px ${matchType === 'loves' ? 'rgba(78,204,163,0.3)' : matchType === 'hates' ? 'rgba(233,69,96,0.3)' : 'rgba(102,126,234,0.3)'}`;
        });
        
        card.addEventListener('mouseleave', () => {
          card.style.transform = 'translateY(0)';
          card.style.boxShadow = 'none';
        });
        
        // Click to select gift (not send yet)
        card.addEventListener('click', () => {
          // Deselect all other cards
          giftSelectionGrid.querySelectorAll('div').forEach(c => {
            c.style.borderColor = c.dataset.matchType === 'loves' ? '#4ecca3' : c.dataset.matchType === 'hates' ? '#e94560' : '#0f3460';
            c.style.borderWidth = '2px';
          });
          
          // Select this card
          card.style.borderColor = '#00d4ff';
          card.style.borderWidth = '3px';
          
          // Store selected gift
          window.selectedGift = gift;
          
          // Enable send button
          const sendBtn = $('sendGiftBtn');
          if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.style.opacity = '1';
            sendBtn.style.cursor = 'pointer';
          }
        });
        
        // Store match type for border reset
        card.dataset.matchType = matchType;
        
        giftSelectionGrid.appendChild(card);
      });
    }
    
    // Send gift button handler
    const sendGiftBtn = $('sendGiftBtn');
    if (sendGiftBtn) {
      sendGiftBtn.addEventListener('click', async () => {
        if (!window.selectedGift || !currentGiftRecipient) return;
        
        const gift = window.selectedGift;
        const employeeId = currentGiftRecipient;
        const employee = gameState.employees.find(e => e.id === employeeId);
        
        if (!employee) {
          showNotification('Employee not found!', 'error');
          return;
        }
        
        // Get personal message
        const messageInput = $('giftPersonalMessage');
        const personalMessage = messageInput ? messageInput.value.trim() : '';
        
        giftSelectionModal.style.display = 'none';
        
        // Clear selection and message for next time
        window.selectedGift = null;
        if (messageInput) messageInput.value = '';
        sendGiftBtn.disabled = true;
        sendGiftBtn.style.opacity = '0.5';
        
        // Remove from inventory first
        const giftIndex = gameState.giftInventory.items.findIndex(g => g.id === gift.id);
        if (giftIndex !== -1) {
          gameState.giftInventory.items.splice(giftIndex, 1);
        }
        
        // Add gift message to chat immediately
        const chatHistory = gameState.chatHistory[employee.id] || [];
        const categoryInfo = GIFT_CATEGORIES[gift.category];
        
        chatHistory.push({
          sender: 'player',
          content: personalMessage || `🎁 Gave a gift`,
          timestamp: Date.now(),
          isPlayer: true,
          giftData: {
            name: gift.name,
            price: gift.price,
            category: gift.category,
            categoryName: categoryInfo?.name || gift.category,
            categoryEmoji: categoryInfo?.emoji || '🎁',
            description: gift.description,
            imageUrl: gift.imageUrl
          }
        });
        
        gameState.chatHistory[employee.id] = chatHistory;
        
        // Refresh chat to show gift immediately
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          refreshChatDisplay();
        }
        
        // Show typing indicator
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          showTypingIndicator(employee);
        }
        
        // Give the gift with personal message (this will generate AI reaction and add it to chat)
        const result = await giveGiftToEmployee(employee.id, gift, personalMessage);
        
        // Hide typing indicator and refresh chat
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          hideTypingIndicator();
          refreshChatDisplay();
        }
        
        // Update UI
        updateUI();
      });
    }
    
    if (closeGiftSelectionModal) {
      closeGiftSelectionModal.addEventListener('click', () => {
        giftSelectionModal.style.display = 'none';
        currentGiftRecipient = null;
        window.selectedGift = null;
        
        // Reset send button
        const sendBtn = $('sendGiftBtn');
        if (sendBtn) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = '0.5';
        }
        
        // Clear message
        const messageInput = $('giftPersonalMessage');
        if (messageInput) messageInput.value = '';
      });
    }
    
    if (cancelGiftSelection) {
      cancelGiftSelection.addEventListener('click', () => {
        giftSelectionModal.style.display = 'none';
        currentGiftRecipient = null;
        window.selectedGift = null;
        
        // Reset send button
        const sendBtn = $('sendGiftBtn');
        if (sendBtn) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = '0.5';
        }
        
        // Clear message
        const messageInput = $('giftPersonalMessage');
        if (messageInput) messageInput.value = '';
      });
    }
    
    // Gift personal message character counter
    const giftPersonalMessage = $('giftPersonalMessage');
    const giftMessageCharCount = $('giftMessageCharCount');
    if (giftPersonalMessage && giftMessageCharCount) {
      giftPersonalMessage.addEventListener('input', () => {
        const count = giftPersonalMessage.value.length;
        giftMessageCharCount.textContent = count;
        
        // Change color as approaching limit
        if (count > 450) {
          giftMessageCharCount.style.color = '#e94560';
        } else if (count > 400) {
          giftMessageCharCount.style.color = '#ff9800';
        } else {
          giftMessageCharCount.style.color = '#666';
        }
      });
    }
    
    // Counter Offer Modal
    const counterOfferModal = $('counterOfferModal');
    const closeCounterOfferModal = $('closeCounterOfferModal');
    const cancelCounterOffer = $('cancelCounterOffer');
    const confirmCounterOffer = $('confirmCounterOffer');
    const counterAmount = $('counterAmount');
    const counterJustification = $('counterJustification');
    
    if (closeCounterOfferModal) {
      closeCounterOfferModal.addEventListener('click', () => {
        counterOfferModal.style.display = 'none';
        counterAmount.value = '';
        counterJustification.value = '';
      });
    }
    
    if (cancelCounterOffer) {
      cancelCounterOffer.addEventListener('click', () => {
        counterOfferModal.style.display = 'none';
        counterAmount.value = '';
        counterJustification.value = '';
      });
    }
    
    if (confirmCounterOffer) {
      confirmCounterOffer.addEventListener('click', async () => {
        await submitCounterOffer();
      });
    }
    
    // Request Image Modal
    const requestImageModal = $('requestImageModal');
    const closeRequestImageModal = $('closeRequestImageModal');
    const requestManualBtn = $('requestManualBtn');
    const requestManualInput = $('requestManualInput');
    const requestImageMode = $('requestImageMode');
    const cancelRequestManual = $('cancelRequestManual');
    const confirmRequestManual = $('confirmRequestManual');
    const requestImagePrompt = $('requestImagePrompt');
    
    if (closeRequestImageModal) {
      closeRequestImageModal.addEventListener('click', () => {
        requestImageModal.style.display = 'none';
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    // Preset buttons
    document.querySelectorAll('.request-preset').forEach(btn => {
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestImageModal.style.display = 'none';
        await requestImageFromNPC(preset);
      });
      
      // Hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
    });
    
    // Manual request button
    if (requestManualBtn) {
      requestManualBtn.addEventListener('click', () => {
        requestImageMode.querySelector('div').style.display = 'none';
        requestManualBtn.style.display = 'none';
        requestManualInput.style.display = 'block';
      });
    }
    
    if (cancelRequestManual) {
      cancelRequestManual.addEventListener('click', () => {
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    if (confirmRequestManual) {
      confirmRequestManual.addEventListener('click', async () => {
        const prompt = requestImagePrompt.value.trim();
        if (prompt) {
          requestImageModal.style.display = 'none';
          requestManualInput.style.display = 'none';
          requestImageMode.querySelector('div').style.display = 'grid';
          requestManualBtn.style.display = 'block';
          requestImagePrompt.value = '';
          await requestImageFromNPC(null, prompt);
        }
      });
    }
    
    // ========== REQUEST POST MODAL HANDLERS ==========
    
    const requestPostModal = $('requestPostModal');
    const closeRequestPostModal = $('closeRequestPostModal');
    const requestPostCustomBtn = $('requestPostCustomBtn');
    const requestPostCustomInput = $('requestPostCustomInput');
    const requestPostMode = $('requestPostMode');
    const cancelRequestPostCustom = $('cancelRequestPostCustom');
    const confirmRequestPostCustom = $('confirmRequestPostCustom');
    const requestPostPrompt = $('requestPostPrompt');
    
    if (closeRequestPostModal) {
      closeRequestPostModal.addEventListener('click', () => {
        requestPostModal.style.display = 'none';
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    // Post type preset buttons
    document.querySelectorAll('.request-post-preset').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestPostModal.style.display = 'none';
        await requestPostFromNPC(preset);
      });
    });
    
    // Custom post request button
    if (requestPostCustomBtn) {
      requestPostCustomBtn.addEventListener('click', () => {
        requestPostMode.querySelector('div').style.display = 'none';
        requestPostCustomBtn.style.display = 'none';
        requestPostCustomInput.style.display = 'block';
      });
    }
    
    if (cancelRequestPostCustom) {
      cancelRequestPostCustom.addEventListener('click', () => {
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    if (confirmRequestPostCustom) {
      confirmRequestPostCustom.addEventListener('click', async () => {
        const prompt = requestPostPrompt.value.trim();
        if (prompt) {
          requestPostModal.style.display = 'none';
          requestPostCustomInput.style.display = 'none';
          requestPostMode.querySelector('div').style.display = 'grid';
          requestPostCustomBtn.style.display = 'block';
          requestPostPrompt.value = '';
          await requestPostFromNPC(null, prompt);
        }
      });
    }
    
    // ========== SOCIAL FEED EVENT HANDLERS ==========
    
    // Player post button
    const playerPostBtn = $('playerPostBtn');
    if (playerPostBtn) {
      playerPostBtn.addEventListener('click', () => {
        openPlayerPostComposer();
      });
    }
    
    // Feed filter buttons
    document.querySelectorAll('.feed-filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.feed-filter-btn').forEach(b => {
          b.classList.remove('active');
          b.style.background = 'transparent';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.background = '#0f3460';
        btn.style.color = '#00d4ff';
        
        // Update filter
        gameState.socialNetwork.feedFilter = btn.dataset.filter;
        renderSocialFeed(true); // Force full render on filter change
      });
    });
    
    // Feed sort select
    const feedSortSelect = $('feedSortSelect');
    if (feedSortSelect) {
      feedSortSelect.addEventListener('change', (e) => {
        gameState.socialNetwork.feedSort = e.target.value;
        renderSocialFeed(true); // Force full render on sort change
      });
    }
    
    // Test generate post button
    const testGeneratePostBtn = $('testGeneratePostBtn');
    if (testGeneratePostBtn) {
      testGeneratePostBtn.addEventListener('click', () => {
        generateTestPost();
      });
    }
    
    // Post composer modal close button (X button)
    const closePlayerPostModalBtn = $('closePlayerPostModal');
    if (closePlayerPostModalBtn) {
      closePlayerPostModalBtn.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post composer cancel button
    const cancelPlayerPost = $('cancelPlayerPost');
    if (cancelPlayerPost) {
      cancelPlayerPost.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post type buttons
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.post-type-btn').forEach(b => {
          b.classList.remove('active');
          b.style.borderColor = '#0f3460';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
        
        // Show/hide image sections
        const type = btn.dataset.type;
        const imageSection = $('playerPostImageSection');
        const generateImageBtn = $('generatePlayerPostImage');
        const imagePromptInput = $('playerPostImagePrompt');
        const imageAltInput = $('playerPostAltText');
        
        if (type === 'text') {
          if (imageSection) imageSection.style.display = 'none';
          if (generateImageBtn) generateImageBtn.style.display = 'none';
        } else {
          if (imageSection) imageSection.style.display = 'block';
          if (generateImageBtn) generateImageBtn.style.display = 'inline-block';
          
          // Set default prompt based on type
          if (type === 'image' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe the image you want to generate...';
          } else if (type === 'selfie' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe your selfie pose and setting...';
          }
        }
      });
    });
    
    // Generate image button
    const generatePlayerPostImage = $('generatePlayerPostImage');
    if (generatePlayerPostImage) {
      generatePlayerPostImage.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Regenerate image button
    const playerPostRegenerateImg = $('playerPostRegenerateImg');
    if (playerPostRegenerateImg) {
      playerPostRegenerateImg.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Submit player post
    const submitPlayerPost = $('submitPlayerPost');
    if (submitPlayerPost) {
      submitPlayerPost.addEventListener('click', () => {
        submitPlayerPostToFeed();
      });
    }
    
    // Character counter for caption
    const captionCharCount = $('captionCharCount');
    if (playerPostCaption && captionCharCount) {
      playerPostCaption.addEventListener('input', () => {
        const length = playerPostCaption.value.length;
        captionCharCount.textContent = length;
        
        if (length > 500) {
          captionCharCount.style.color = '#e94560';
        } else {
          captionCharCount.style.color = '#666';
        }
      });
    }
    
    // Event delegation for dynamically created post elements
    document.addEventListener('click', (e) => {
      // Like button
      if (e.target.closest('.like-btn')) {
        const btn = e.target.closest('.like-btn');
        const postId = btn.dataset.postId;
        handleLikePost(postId);
      }
      
      // Comment button - open post modal
      if (e.target.closest('.comment-btn')) {
        const btn = e.target.closest('.comment-btn');
        const postId = btn.dataset.postId;
        openPostModal(postId);
      }
      
      // Submit comment button (legacy support - modal has its own)
      if (e.target.closest('.submit-comment-btn')) {
        const btn = e.target.closest('.submit-comment-btn');
        const postId = btn.dataset.postId;
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        
        if (input) {
          addCommentToPost(postId, input.value, replyToId);
        }
      }
    });
    
    // Handle Enter key in comment inputs
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && e.target.classList.contains('comment-input')) {
        const postId = e.target.dataset.postId;
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        addCommentToPost(postId, e.target.value, replyToId);
      }
    });
    
    // Handle Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.reply-to-comment-btn')) {
        const btn = e.target.closest('.reply-to-comment-btn');
        const postId = btn.dataset.postId;
        const commentId = btn.dataset.commentId;
        const authorName = btn.dataset.authorName;
        const authorId = btn.dataset.authorId;
        const authorUsername = btn.dataset.authorUsername; // CRITICAL FIX: Get actual username
        
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        
        if (input && replyIndicator) {
          // Show reply indicator
          replyIndicator.querySelector('.reply-text').textContent = `Replying to ${authorName}`;
          replyIndicator.style.display = 'block';
          replyIndicator.setAttribute('data-reply-to-id', commentId);
          
          // CRITICAL FIX: Use username, not display name for @mentions
          if (authorId !== 'player' && authorUsername) {
            // Pre-fill with proper @username
            if (!input.value.includes(`@${authorUsername}`)) {
              input.value = `@${authorUsername} `;
            }
          }
          
          // Focus input
          input.focus();
        }
      }
    });
    
    // Handle Cancel Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-reply-btn')) {
        const btn = e.target.closest('.cancel-reply-btn');
        const postId = btn.dataset.postId;
        
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        if (replyIndicator) {
          replyIndicator.style.display = 'none';
          replyIndicator.removeAttribute('data-reply-to-id');
        }
      }
    });
    
    // Global Upgrades - Click Power Button
    const buyClickPowerBtn = $('buyClickPowerBtn');
    if (buyClickPowerBtn) {
      buyClickPowerBtn.addEventListener('click', buyClickPower);
    }
    
    // ========== PRESTIGE SYSTEM EVENT HANDLERS ==========
    
    // Prestige button - opens confirmation modal
    const prestigeBtn = $('prestigeBtn');
    if (prestigeBtn) {
      prestigeBtn.addEventListener('click', showPrestigeModal);
    }
    
    // Prestige modal - close button
    const closePrestigeModal = $('closePrestigeModal');
    if (closePrestigeModal) {
      closePrestigeModal.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - cancel button
    const cancelPrestige = $('cancelPrestige');
    if (cancelPrestige) {
      cancelPrestige.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - confirm button
    const confirmPrestige = $('confirmPrestige');
    if (confirmPrestige) {
      confirmPrestige.addEventListener('click', executePrestige);
    }
    
    // ========== PAGE VISIBILITY & AFK DETECTION ==========
    
    // Track user interactions to detect AFK state
    const updateInteractionTime = () => {
      gameState.lastInteractionTime = Date.now();
    };
    
    // Listen for actual user interactions
    document.addEventListener('click', updateInteractionTime);
    document.addEventListener('keydown', updateInteractionTime);
    document.addEventListener('touchstart', updateInteractionTime);
    document.addEventListener('scroll', updateInteractionTime);
    
    // Page Visibility API - detect when tab/app goes to background
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is now hidden (tab switched, phone locked, etc.)
        const now = Date.now();
        gameState.pageHiddenTime = now;
        gameState.lastPlayTime = now;
        // Save immediately when page goes hidden
        saveGame(false);
      } else {
        // Page is now visible again
        // Check for AFK earnings based on time hidden
        checkAfkIncome();
        // Update interaction time since user is back
        gameState.lastInteractionTime = Date.now();
      }
    });
    
    // Also handle beforeunload to save last active time
    window.addEventListener('beforeunload', () => {
      gameState.lastPlayTime = Date.now();
      // Note: We can't reliably save here in some browsers, but we try
      navigator.sendBeacon && navigator.sendBeacon('/save', JSON.stringify(gameState));
    });
    
    // Additional fallback: If user hasn't interacted in 10 minutes while page is visible,
    // automatically trigger AFK mode
    setInterval(() => {
      if (!document.hidden) {
        const now = Date.now();
        const timeSinceInteraction = now - (gameState.lastInteractionTime || now);
        const TEN_MINUTES = 10 * 60 * 1000;
        
        // If no interaction for 10+ minutes, update lastPlayTime
        if (timeSinceInteraction >= TEN_MINUTES) {
          // Update lastPlayTime to when they last interacted
          if (gameState.lastPlayTime > gameState.lastInteractionTime) {
            gameState.lastPlayTime = gameState.lastInteractionTime;
          }
        }
      }
    }, 60000); // Check every minute
  }
  
  // Switch active tab
  function switchTab(tabName) {
    gameState.activeTab = tabName;
    
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      if (btn.dataset.tab === tabName) {
        btn.classList.add('active');
        btn.style.color = '#e94560';
      } else {
        btn.classList.remove('active');
        btn.style.color = 'white';
      }
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.hidden = true;
    });
    
    const activeTab = $(`${tabName}Tab`);
    if (activeTab) {
      activeTab.hidden = false;
      updateTabContent(tabName);
    }
  }
  
  // ========== GIFT SYSTEM UI INITIALIZATION ==========
  
  // Initialize gift genie cycling suggestions
  let currentSuggestionIndex = 0;
  let suggestionIntervalId = null; // Store interval ID to prevent duplicates
  const giftGenieInput = $('giftGenieInput');
  const giftGenieSuggestion = $('giftGenieSuggestion');
  
  function cycleSuggestions() {
    if (!giftGenieInput || !giftGenieSuggestion) return;
    
    // Only show suggestion if input is empty
    if (giftGenieInput.value.length === 0) {
      giftGenieSuggestion.style.opacity = '1';
      giftGenieSuggestion.textContent = GIFT_SUGGESTIONS[currentSuggestionIndex];
      
      // Move to next suggestion
      currentSuggestionIndex = (currentSuggestionIndex + 1) % GIFT_SUGGESTIONS.length;
    } else {
      giftGenieSuggestion.style.opacity = '0';
    }
  }
  
  // Start cycling (with duplicate prevention)
  if (giftGenieInput && !suggestionIntervalId) {
    suggestionIntervalId = setInterval(cycleSuggestions, 1500);
    cycleSuggestions(); // Initial call
    
    // Hide suggestion when typing
    giftGenieInput.addEventListener('input', () => {
      if (giftGenieInput.value.length > 0) {
        giftGenieSuggestion.style.opacity = '0';
      } else {
        cycleSuggestions();
      }
    });
  }
  
  // Generate gift button
  const generateGiftBtn = $('generateGiftBtn');
  let currentGenerationController = null; // Track current generation
  
  if (generateGiftBtn) {
    generateGiftBtn.addEventListener('click', async () => {
      const input = giftGenieInput?.value.trim();
      if (!input) {
        showNotification('Please describe a gift!', 'warning');
        return;
      }
      
      const budget = parseFloat($('giftBudgetLimit')?.value || 'Infinity');
      
      // Create cancellation controller
      currentGenerationController = { cancelled: false };
      const thisController = currentGenerationController;
      
      // Show loading with visual feedback
      generateGiftBtn.disabled = true;
      generateGiftBtn.style.opacity = '0.6';
      generateGiftBtn.style.cursor = 'not-allowed';
      generateGiftBtn.innerHTML = '⏳ Creating gift...';
      
      // Show cancel button
      const cancelBtn = document.createElement('button');
      cancelBtn.id = 'cancelGenerationBtn';
      cancelBtn.innerHTML = '🚫 Cancel';
      cancelBtn.style.cssText = 'margin-left:10px; padding:8px 15px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;';
      cancelBtn.onclick = () => {
        thisController.cancelled = true;
        showNotification('🚫 Generation cancelled', 'info');
      };
      generateGiftBtn.parentElement.appendChild(cancelBtn);
      
      // Show notification
      showNotification('🧞‍♂️ Gift Genie is working...', 'info');
      
      try {
        const gift = await generateCustomGift(input, budget, thisController);
        
        // Check if cancelled
        if (thisController.cancelled) {
          console.log('[Gift] Generation cancelled by user');
          return;
        }
        
        showGiftPreview(gift);
        giftGenieInput.value = ''; // Clear input
        cycleSuggestions(); // Restart cycling
        showNotification('✨ Gift created successfully!', 'success');
      } catch (error) {
        // Ignore errors if cancelled
        if (thisController.cancelled) return;
        
        console.error('[Gift] Generation failed:', error);
        // Only show generic error if it wasn't a genie refusal
        if (error.message !== 'Genie refused this request') {
          showNotification('❌ Failed to create gift. Please try again.', 'error');
        }
      } finally {
        // Remove cancel button
        const cancelBtn = $('cancelGenerationBtn');
        if (cancelBtn) cancelBtn.remove();
        
        // Only reset if this generation is still current
        if (currentGenerationController === thisController) {
          generateGiftBtn.disabled = false;
          generateGiftBtn.style.opacity = '1';
          generateGiftBtn.style.cursor = 'pointer';
          generateGiftBtn.innerHTML = '✨ Create Gift';
          currentGenerationController = null;
        }
      }
    });
  }
  
  // Show gift preview after generation
  function showGiftPreview(gift) {
    const modal = $('giftPreviewModal');
    const nameEl = $('giftPreviewName');
    const priceEl = $('giftPreviewPrice');
    const categoryEl = $('giftPreviewCategory');
    const descEl = $('giftPreviewDescription');
    const uniqueWarning = $('giftPreviewUnique');
    
    if (!modal) return;
    
    // Populate preview
    if (nameEl) nameEl.textContent = gift.name;
    if (priceEl) priceEl.textContent = '$' + gift.price.toLocaleString();
    if (categoryEl) {
      const cat = GIFT_CATEGORIES[gift.category];
      categoryEl.textContent = (cat?.emoji || '') + ' ' + (cat?.name || gift.category);
    }
    if (descEl) descEl.textContent = gift.description;
    
    // Show unique warning if applicable
    if (uniqueWarning) {
      uniqueWarning.style.display = gift.category === 'UNIQUE' ? 'block' : 'none';
    }
    
    // Store gift for purchase
    window.currentPreviewGift = gift;
    
    modal.style.display = 'block';
  }
  
  // Generate gift image
  const generateGiftImageBtn = $('generateGiftImageBtn');
  if (generateGiftImageBtn) {
    generateGiftImageBtn.addEventListener('click', async () => {
      if (!window.currentPreviewGift) return;
      
      const gift = window.currentPreviewGift;
      const imageEl = $('giftPreviewImage');
      
      generateGiftImageBtn.disabled = true;
      generateGiftImageBtn.textContent = '🎨 Generating...';
      
      try {
        const imageUrl = await generateImage(applyImageStyle(gift.imagePrompt));
        if (imageEl) {
          imageEl.innerHTML = `<img src="${imageUrl}" style="width:100%; height:100%; object-fit:cover; border-radius:10px;">`;
        }
        gift.imageUrl = imageUrl;
      } catch (error) {
        console.error('[Gift] Image generation failed:', error);
        showNotification('Failed to generate image', 'error');
      } finally {
        generateGiftImageBtn.disabled = false;
        generateGiftImageBtn.textContent = '📸 Generate Image';
      }
    });
  }
  
  // Approve gift button (add to store)
  const approveGiftBtn = $('approveGiftBtn');
  if (approveGiftBtn) {
    approveGiftBtn.addEventListener('click', () => {
      if (!window.currentPreviewGift) return;
      
      const gift = window.currentPreviewGift;
      
      // Add to store
      const result = addGiftToStore(gift);
      
      if (result) {
        // Close preview
        $('giftPreviewModal').style.display = 'none';
        window.currentPreviewGift = null;
        
        // Reset image
        const imageEl = $('giftPreviewImage');
        if (imageEl) imageEl.innerHTML = '🎁';
        
        // Refresh displays
        updateGiftStore();
        updateGiftInventory();
      }
    });
  }
  
  // Deny gift button (delete)
  const denyGiftBtn = $('denyGiftBtn');
  if (denyGiftBtn) {
    denyGiftBtn.addEventListener('click', () => {
      if (!window.currentPreviewGift) return;
      
      const giftName = window.currentPreviewGift.name;
      
      // Close preview
      $('giftPreviewModal').style.display = 'none';
      window.currentPreviewGift = null;
      
      // Reset image
      const imageEl = $('giftPreviewImage');
      if (imageEl) imageEl.innerHTML = '🎁';
      
      showNotification(`🗑️ Deleted "${giftName}"`, 'info');
    });
  }
  
  // Cache to prevent unnecessary re-renders
  let lastStoreRenderHash = null;
  let lastInventoryRenderHash = null;
  
  // Update gift store display
  function updateGiftStore() {
    const grid = $('giftStoreGrid');
    const countEl = $('giftStoreCount');
    
    if (!grid) return;
    
    // Ensure store exists (migration safety)
    if (!gameState.giftStore) {
      gameState.giftStore = { items: [] };
    }
    
    // Create a hash of the current state to detect changes
    const currentHash = JSON.stringify(gameState.giftStore.items.map(g => g.id));
    if (currentHash === lastStoreRenderHash) {
      // No changes, skip re-render
      return;
    }
    lastStoreRenderHash = currentHash;
    
    // Update count
    if (countEl) {
      countEl.textContent = gameState.giftStore.items.length;
    }
    
    // Render store
    if (gameState.giftStore.items.length === 0) {
      grid.innerHTML = `
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:40px;
          color:#aaa;
        ">
          <div style="font-size:3rem; margin-bottom:10px;">🏪</div>
          <p>No gifts in store yet!</p>
          <p style="font-size:0.9rem;">Use the Gift Genie above to create and approve gifts.</p>
        </div>
      `;
      return;
    }
    
    grid.innerHTML = '';
    
    gameState.giftStore.items.forEach(gift => {
      const category = GIFT_CATEGORIES[gift.category];
      const card = document.createElement('div');
      
      card.style.cssText = `
        background:#16213e;
        border-radius:10px;
        padding:15px;
        transition:all 0.2s;
        border:2px solid ${gift.category === 'UNIQUE' ? 'gold' : '#0f3460'};
        cursor:pointer;
      `;
      
      // Display image if available, otherwise show emoji
      const displayImage = gift.imageUrl 
        ? `<img src="${gift.imageUrl}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:8px; margin-bottom:8px;">`
        : `<div style="font-size:2.5rem; text-align:center; margin-bottom:8px;">${category?.emoji || '🎁'}</div>`;
      
      card.innerHTML = `
        ${displayImage}
        <h4 style="margin:0 0 5px 0; color:white; font-size:0.95rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${gift.name}">${gift.name}</h4>
        <p style="margin:0 0 8px 0; font-size:0.75rem; color:#aaa;">${category?.name || gift.category}</p>
        <p style="margin:0 0 10px 0; font-size:1rem; color:#4ecca3; font-weight:600;">$${formatCash(gift.price)}</p>
        ${gift.category === 'UNIQUE' ? '<p style="margin:0 0 10px 0; font-size:0.75rem; color:gold;">⭐ One-time only!</p>' : ''}
        <button 
          onclick="purchaseGiftFromStore('${gift.id}')" 
          style="
            width:100%;
            padding:8px;
            background:#4ecca3;
            border:none;
            border-radius:6px;
            color:#0f1419;
            font-weight:600;
            cursor:pointer;
          "
        >💰 Purchase</button>
      `;
      
      card.addEventListener('mouseenter', () => {
        card.style.transform = 'translateY(-5px)';
        card.style.boxShadow = '0 8px 20px rgba(78,204,163,0.3)';
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.transform = 'translateY(0)';
        card.style.boxShadow = 'none';
      });
      
      grid.appendChild(card);
    });
  }
  
  // Update gift inventory display
  function updateGiftInventory() {
    const grid = $('giftInventoryGrid');
    const countEl = $('giftInventoryCount');
    const scaleInfo = $('giftScaleInfo');
    const rangeEl = $('recommendedGiftRange');
    
    if (!grid) return;
    
    // Ensure inventory exists (migration safety)
    if (!gameState.giftInventory) {
      gameState.giftInventory = { items: [], capacity: Infinity };
    }
    
    // Create a hash of the current state to detect changes
    const currentHash = JSON.stringify(gameState.giftInventory.items.map(g => `${g.id}:${g.quantity || 1}`));
    if (currentHash === lastInventoryRenderHash) {
      // No changes, skip re-render
      return;
    }
    lastInventoryRenderHash = currentHash;
    
    // Update count
    if (countEl) {
      countEl.textContent = gameState.giftInventory.items.length;
    }
    
    // Update scale info
    if (scaleInfo && rangeEl) {
      const scale = calculateGiftPriceScale();
      rangeEl.textContent = `$${Math.round(scale.minRecommended).toLocaleString()} - $${Math.round(scale.maxRecommended).toLocaleString()}`;
    }
    
    // Render inventory
    if (gameState.giftInventory.items.length === 0) {
      grid.innerHTML = `
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:60px 20px;
          color:#666;
          font-size:1.1rem;
        ">
          Your inventory is empty. Create gifts above to get started! ✨
        </div>
      `;
      return;
    }
    
    grid.innerHTML = gameState.giftInventory.items.map(gift => {
      const cat = GIFT_CATEGORIES[gift.category];
      return `
        <div style="
          background:#0f3460;
          border:2px solid #667eea;
          border-radius:12px;
          padding:15px;
          transition:all 0.3s;
        " onmouseover="this.style.transform='translateY(-4px)'; this.style.borderColor='#00d4ff'"
           onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#667eea'">
          ${gift.imageUrl ? `
            <img src="${gift.imageUrl}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:8px; margin-bottom:10px;">
          ` : `
            <div style="
              width:100%;
              aspect-ratio:1;
              background:#16213e;
              border-radius:8px;
              display:flex;
              align-items:center;
              justify-content:center;
              font-size:3rem;
              margin-bottom:10px;
            ">${cat?.emoji || '🎁'}</div>
          `}
          
          <div style="font-size:1.05rem; font-weight:bold; margin-bottom:6px; color:#fff;">
            ${gift.name}
          </div>
          
          <div style="font-size:0.85rem; color:#aaa; margin-bottom:10px; line-height:1.4;">
            ${gift.description.length > 80 ? gift.description.substring(0, 80) + '...' : gift.description}
          </div>
          
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <span style="color:#4caf50; font-weight:bold;">$${gift.price.toLocaleString()}</span>
            <span style="color:#888;">x${gift.quantity || 1}</span>
          </div>
          
          <div style="font-size:0.8rem; color:#667eea; margin-bottom:10px;">
            ${cat?.emoji || ''} ${cat?.name || gift.category}
            ${gift.category === 'UNIQUE' ? '<span style="color:gold; margin-left:5px;">⭐ UNIQUE</span>' : ''}
          </div>
          
          <button onclick="deleteGiftFromInventory('${gift.id}')" style="
            width:100%;
            padding:8px;
            background:#e94560;
            border:none;
            border-radius:6px;
            color:white;
            cursor:pointer;
            font-size:0.9rem;
          ">
            🗑️ Delete
          </button>
        </div>
      `;
    }).join('');
  }
  
  // Delete gift from inventory
  window.deleteGiftFromInventory = function(giftId) {
    if (!confirm('Delete this gift from your inventory?')) return;
    
    gameState.giftInventory.items = gameState.giftInventory.items.filter(g => g.id !== giftId);
    updateGiftInventory();
    showNotification('Gift deleted from inventory', 'info');
  };
  
  // Expose functions globally
  window.updateGiftInventory = updateGiftInventory;
  window.updateGiftStore = updateGiftStore;
  window.showGiftPreview = showGiftPreview;
  window.purchaseGiftFromStore = purchaseGiftFromStore;
  
  // ========== END GIFT SYSTEM UI ==========
  
  // Update content for specific tab
  function updateTabContent(tabName) {
    switch (tabName) {
      case 'dashboard':
        updateDashboard();
        refreshDashboardSections(); // Force initial render of interactive sections
        break;
      case 'business':
        updateBusinessTab();
        break;
      case 'upgrades':
        updateUpgradesTab();
        break;
      case 'people':
        updatePeopleTab();
        break;
      case 'gifts':
        updateGiftsTab();
        break;
      case 'hr':
        updateHRTab();
        break;
      case 'social':
        updateSocialTab();
        break;
      case 'invest':
        updatePrestigeUI();
        renderInfluenceUpgrades();
        break;
      case 'ceocorner':
        // CEO Corner doesn't need updates, just display the chat
        break;
    }
  }
    // Update Dashboard Tab
    function updateDashboard() {
    // ===== TOP STATS CARDS =====
    
    // Cash & Cash/sec
    const dashCash = $('dashCash');
    const dashCashPerSec = $('dashCashPerSec');
    if (dashCash) dashCash.textContent = formatNumber(Math.floor(gameState.cash));
    if (dashCashPerSec) dashCashPerSec.textContent = formatNumber(calculateCashPerSecond());
    
    // Lifetime Earnings & Prestige Level
    const dashLifetimeEarnings = $('dashLifetimeEarnings');
    const dashPrestigeLevel = $('dashPrestigeLevel');
    if (dashLifetimeEarnings) dashLifetimeEarnings.textContent = formatNumber(Math.floor(gameState.lifetimeEarnings || 0));
    if (dashPrestigeLevel) dashPrestigeLevel.textContent = gameState.prestigeLevel || 0;
    
    // Employees & Managers
    const dashEmployeeCount = $('dashEmployeeCount');
    const dashManagerCount = $('dashManagerCount');
    if (dashEmployeeCount) dashEmployeeCount.textContent = gameState.employees.length;
    const managerCount = gameState.products.filter(p => p.managerHired).length;
    if (dashManagerCount) dashManagerCount.textContent = managerCount;
    
    // Products & Running Products
    const dashProductCount = $('dashProductCount');
    const dashRunningProducts = $('dashRunningProducts');
    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    const runningProducts = gameState.products.filter(p => p.running || p.managerHired).length;
    if (dashProductCount) dashProductCount.textContent = unlockedProducts;
    if (dashRunningProducts) dashRunningProducts.textContent = runningProducts;
    
    // ===== RECENT MESSAGES ===== 
    // Only rebuild if the container is empty or data has actually changed
    const dashRecentMessages = $('dashRecentMessages');
    if (dashRecentMessages && !dashRecentMessages.dataset.initialized) {
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    // ===== BOSS FIGHTS PROGRESS =====
    const dashBossProgress = $('dashBossProgress');
    if (dashBossProgress) {
      const totalBosses = Object.keys(bossFightConfig || {}).length;
      const defeatedBosses = (gameState.bossFights?.defeated || []).length;
      
      // Only update if values changed
      const currentProgress = dashBossProgress.dataset.progress;
      const newProgress = `${defeatedBosses}/${totalBosses}`;
      if (currentProgress !== newProgress) {
        dashBossProgress.dataset.progress = newProgress;
        
        if (totalBosses === 0) {
          dashBossProgress.innerHTML = '<div style="text-align:center; color:#666; padding:10px; font-style:italic;">No bosses available</div>';
        } else {
          const percentage = Math.floor((defeatedBosses / totalBosses) * 100);
          dashBossProgress.innerHTML = `
            <div style="margin-bottom:15px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <span style="color:#aaa; font-size:0.9rem;">Progress</span>
                <span style="color:#e94560; font-weight:600;">${defeatedBosses}/${totalBosses}</span>
              </div>
              <div style="background:#0f3460; height:12px; border-radius:6px; overflow:hidden;">
                <div style="background:linear-gradient(90deg, #e94560, #ff6b9d); height:100%; width:${percentage}%; transition:width 0.3s;"></div>
              </div>
            </div>
            ${defeatedBosses < totalBosses ? '<div style="color:#aaa; font-size:0.85rem; text-align:center;">💪 Keep growing to challenge the next boss!</div>' : '<div style="color:#4ecca3; font-size:0.85rem; text-align:center;">🎉 All bosses defeated!</div>'}
          `;
        }
      }
    }
    
    // ===== QUICK STATS =====
    const dashLocationCount = $('dashLocationCount');
    const dashTotalLocations = $('dashTotalLocations');
    const dashEfficiency = $('dashEfficiency');
    const dashInfluencePoints = $('dashInfluencePoints');
    const dashIncomeMultiplier = $('dashIncomeMultiplier');
    
    const unlockedLocations = gameState.locations.filter(loc => loc.unlocked).length;
    const totalLocations = gameState.locations.length;
    if (dashLocationCount) dashLocationCount.textContent = unlockedLocations;
    if (dashTotalLocations) dashTotalLocations.textContent = totalLocations;
    
    const totalEff = gameState.employees.reduce((sum, emp) => sum + (emp.stats?.efficiency ?? 0), 0);
    const maxEff = gameState.employees.length * 100;
    const effPct = maxEff > 0 ? Math.max(0, Math.min(100, Math.floor((totalEff / maxEff) * 100))) : 100;
    if (dashEfficiency) dashEfficiency.textContent = effPct;
    
    if (dashInfluencePoints) dashInfluencePoints.textContent = gameState.influencePoints || 0;
    
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const multiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (dashIncomeMultiplier) dashIncomeMultiplier.textContent = multiplier.toFixed(1);
    
    // ===== SOCIAL MENTIONS =====
    // Only rebuild if not initialized
    const dashSocialMentions = $('dashSocialMentions');
    if (dashSocialMentions && !dashSocialMentions.dataset.initialized) {
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    // ===== AI QUALITY TRAINING STATS =====
    const stats = gameState.aiQuality?.stats || {};
    const totalVotes = stats.totalVotes || 0;
    const upvotes = stats.upvotes || 0;
    const downvotes = stats.downvotes || 0;
    const postsVoted = stats.postsVoted || 0;
    const commentsVoted = stats.commentsVoted || 0;
    const chatsVoted = stats.chatsVoted || 0;
    
    // Update total votes
    const dashTotalVotes = $('dashTotalVotes');
    if (dashTotalVotes) dashTotalVotes.textContent = totalVotes;
    
    // Update quality score (upvote percentage)
    const dashQualityScore = $('dashQualityScore');
    if (dashQualityScore) {
      if (totalVotes === 0) {
        dashQualityScore.textContent = '--%';
        dashQualityScore.style.color = '#aaa';
      } else {
        const qualityPercent = Math.round((upvotes / totalVotes) * 100);
        dashQualityScore.textContent = qualityPercent + '%';
        // Color based on quality: red < 40%, yellow 40-60%, green > 60%
        if (qualityPercent < 40) dashQualityScore.style.color = '#ff6b6b';
        else if (qualityPercent < 60) dashQualityScore.style.color = '#ffd700';
        else dashQualityScore.style.color = '#4ecca3';
      }
    }
    
    // Update upvotes/downvotes
    const dashUpvotes = $('dashUpvotes');
    const dashDownvotes = $('dashDownvotes');
    if (dashUpvotes) dashUpvotes.textContent = upvotes;
    if (dashDownvotes) dashDownvotes.textContent = downvotes;
    
    // Update content type breakdown
    const dashPostsVoted = $('dashPostsVoted');
    const dashCommentsVoted = $('dashCommentsVoted');
    const dashChatsVoted = $('dashChatsVoted');
    if (dashPostsVoted) dashPostsVoted.textContent = postsVoted;
    if (dashCommentsVoted) dashCommentsVoted.textContent = commentsVoted;
    if (dashChatsVoted) dashChatsVoted.textContent = chatsVoted;
    
    // ===== TOP PERFORMERS =====
    // Only rebuild if not initialized
    const dashTopPerformers = $('dashTopPerformers');
    if (dashTopPerformers && !dashTopPerformers.dataset.initialized) {
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
    
    // ===== COMPANY NEWS =====
    updateNewsFeed();
    }

  // Separate render functions that only run once or on demand
  function renderDashboardMessages() {
    const dashRecentMessages = $('dashRecentMessages');
    if (!dashRecentMessages) return;
    
    // Get all chat histories and find unread messages
    const recentMessages = [];
    gameState.employees.forEach(emp => {
      const history = gameState.chatHistory[emp.id] || [];
      // Use the employee's unreadMessages counter instead of filtering history
      const unreadCount = emp.unreadMessages || 0;
      if (history.length > 0) {
        const lastMessage = history[history.length - 1];
        recentMessages.push({
          employee: emp,
          message: lastMessage,
          unreadCount: unreadCount,
          timestamp: lastMessage.timestamp || Date.now()
        });
      }
    });
    
    // Sort by timestamp (most recent first)
    recentMessages.sort((a, b) => b.timestamp - a.timestamp);
    
    if (recentMessages.length === 0) {
      dashRecentMessages.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No messages yet. Start chatting with employees!</div>';
    } else {
      dashRecentMessages.innerHTML = recentMessages.slice(0, 5).map(item => {
        const timeAgo = getTimeAgo(item.timestamp);
        const preview = item.message.content.substring(0, 80) + (item.message.content.length > 80 ? '...' : '');
        const unreadBadge = item.unreadCount > 0 ? `<span style="background:#e94560; color:white; padding:2px 8px; border-radius:10px; font-size:0.75rem; font-weight:600;">${item.unreadCount}</span>` : '';
        
        return `
          <div onclick="openChat('${item.employee.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#00d4ff;">${item.employee.name}</div>
              <div style="display:flex; align-items:center; gap:8px;">
                ${unreadBadge}
                <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
              </div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${preview}</div>
          </div>
        `;
      }).join('');
    }
  }
  
  function renderDashboardMentions() {
    const dashSocialMentions = $('dashSocialMentions');
    if (!dashSocialMentions) return;
    
    const allPosts = gameState.socialFeed || [];
    const mentions = allPosts.filter(post => 
      post.content && post.content.toLowerCase().includes('@theboss')
    ).sort((a, b) => b.timestamp - a.timestamp);
    
    if (mentions.length === 0) {
      dashSocialMentions.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No mentions yet. Engage with employees!</div>';
    } else {
      dashSocialMentions.innerHTML = mentions.slice(0, 3).map(post => {
        const author = gameState.employees.find(e => e.id === post.authorId);
        if (!author) return '';
        
        const timeAgo = getTimeAgo(post.timestamp);
        const content = post.content.substring(0, 100) + (post.content.length > 100 ? '...' : '');
        
        return `
          <div onclick="switchTab('social')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#ff6b9d;">${author.name}</div>
              <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${content}</div>
            <div style="color:#e94560; font-size:0.75rem; margin-top:5px;">💕 ${post.likes?.length || 0} likes • 💬 ${post.comments?.length || 0} comments</div>
          </div>
        `;
      }).filter(html => html).join('');
    }
  }
  
  function renderDashboardTopPerformers() {
    const dashTopPerformers = $('dashTopPerformers');
    if (!dashTopPerformers) return;
    
    if (gameState.employees.length === 0) {
      dashTopPerformers.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No employees yet</div>';
    } else {
      // Sort employees by a combination of stats
      const scoredEmployees = gameState.employees.map(emp => ({
        employee: emp,
        score: (emp.stats?.productivity || 0) + (emp.stats?.efficiency || 0) + (emp.stats?.affection || 0) * 0.5
      })).sort((a, b) => b.score - a.score);
      
      dashTopPerformers.innerHTML = scoredEmployees.slice(0, 3).map((item, index) => {
        const emp = item.employee;
        const medals = ['🥇', '🥈', '🥉'];
        const medal = medals[index] || '🏅';
        
        return `
          <div onclick="showEmployeeProfile('${emp.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:8px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="display:flex; align-items:center; gap:10px;">
                <div style="font-size:1.5rem;">${medal}</div>
                <div>
                  <div style="font-weight:600;">${getColoredName(emp)}</div>
                  <div style="color:#666; font-size:0.8rem;">${emp.position || 'Employee'}</div>
                </div>
              </div>
              <div style="text-align:right;">
                <div style="color:#ffd700; font-weight:600; font-size:0.9rem;">${Math.floor(item.score)} pts</div>
                <div style="color:#666; font-size:0.75rem;">Productivity: ${Math.floor(emp.stats?.productivity || 0)}%</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
  }
  
  // Function to refresh dashboard sections on demand (call when data changes)
  function refreshDashboardSections() {
    const dashRecentMessages = $('dashRecentMessages');
    const dashSocialMentions = $('dashSocialMentions');
    const dashTopPerformers = $('dashTopPerformers');
    
    if (dashRecentMessages) {
      dashRecentMessages.dataset.initialized = '';
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    if (dashSocialMentions) {
      dashSocialMentions.dataset.initialized = '';
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    if (dashTopPerformers) {
      dashTopPerformers.dataset.initialized = '';
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
  }

  
  // Helper function to format time ago
  function getTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
  }

  
  // Update Business Tab
  function updateBusinessTab() {
    // Update location subtabs
    const locationSubtabs = $('locationSubtabs');
    if (locationSubtabs) {
      locationSubtabs.innerHTML = '';
      
      gameState.locations.forEach((location, index) => {
        const canUnlock = checkLocationUnlockable(location.id);
        const isLocked = !location.unlocked;
        const isActive = gameState.activeLocationId === location.id;
        const canAfford = gameState.cash >= location.cost;
        const prevLoc = index > 0 ? gameState.locations[index - 1] : null;
        const prevUnlocked = !prevLoc || prevLoc.unlocked;
        const hasPrestigeReq = location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges;
        
        const subtab = document.createElement('button');
        subtab.className = 'location-subtab';
        subtab.dataset.locationId = location.id;
        
        if (isLocked) {
          if (hasPrestigeReq) {
            // Requires prestige
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `�️ ${location.name}<br><span style="font-size:0.8em;">Requires ${location.requiresPrestiges} Prestige</span>`;
            subtab.disabled = true;
          } else if (!prevUnlocked) {
            // Previous location not unlocked
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `🔒 ${location.name}`;
            subtab.disabled = true;
          } else if (canAfford) {
            // Can unlock now - check if it requires boss fight (all locations except garage)
            if (index > 0) {
              // Check if boss already defeated - if so, should already be unlocked
              // This is a safety check - normally defeated bosses have unlocked locations
              const boss = bossFightConfig[location.id];
              const alreadyDefeated = boss && gameState.bossFights.defeated.includes(boss.id);
              
              if (alreadyDefeated) {
                // Boss defeated but location not unlocked (shouldn't happen, but handle it)
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                subtab.innerHTML = `🔓 ${location.name}<br><span style="font-size:0.8em;">Claim Victory</span>`;
                subtab.onclick = () => unlockLocation(location.id);
              } else {
                // Boss fight required
                const bossCheck = checkBossFightRequirements(location.id);
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#ff6b9d; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                if (bossCheck.reasons.length > 0) {
                  // Show warning about recommendations
                  subtab.innerHTML = `⚔️ ${location.name}<br><span style="font-size:0.7em; color:#ffaa00;">${bossCheck.reasons[0]}</span>`;
                } else {
                  // Ready to fight
                  subtab.innerHTML = `⚔️ ${location.name}<br><span style="font-size:0.8em;">Boss Fight!</span>`;
                }
                subtab.onclick = () => {
                  if (bossCheck.reasons.length > 0) {
                    // Show warning before starting
                    if (confirm(`Warning: This boss may be difficult!\n\n${bossCheck.reasons.join('\n')}\n\nAttempt anyway?`)) {
                      startBossFight(location.id);
                    }
                  } else {
                    startBossFight(location.id);
                  }
                };
              }
            } else {
              // First location (garage) - direct unlock
              subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
              subtab.innerHTML = `🔓 ${location.name}<br><span style="font-size:0.8em;">Unlock: ${formatNumber(location.cost)}</span>`;
              subtab.onclick = () => unlockLocation(location.id);
            }
          } else {
            // Can't afford yet
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#888; cursor:not-allowed; white-space:nowrap; opacity:0.7;';
            subtab.innerHTML = `🔒 ${location.name}<br><span style="font-size:0.8em;">Need: ${formatNumber(location.cost)}</span>`;
            subtab.disabled = true;
          }
        } else {
          // Unlocked - show NSFW level indicator if applicable
          const nsfwIndicator = location.nsfwLevel ? '🔞'.repeat(location.nsfwLevel) : '';
          subtab.style.cssText = `padding:10px 16px; background:${isActive ? '#0f3460' : 'transparent'}; border:none; border-bottom:3px solid ${isActive ? '#e94560' : 'transparent'}; color:${isActive ? '#e94560' : 'white'}; cursor:pointer; white-space:nowrap; font-weight:${isActive ? 'bold' : 'normal'}; transition:all 0.2s;`;
          subtab.innerHTML = `${location.name}${nsfwIndicator ? ' ' + nsfwIndicator : ''}`;
          subtab.onclick = () => {
            gameState.activeLocationId = location.id;
            applyLocationTheme(location);
            updateBusinessTab();
          };
          
          // Hover effect for unlocked tabs
          subtab.addEventListener('mouseenter', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = '#e94560';
              subtab.style.color = '#e94560';
            }
          });
          subtab.addEventListener('mouseleave', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = 'transparent';
              subtab.style.color = 'white';
            }
          });
        }
        
        locationSubtabs.appendChild(subtab);
      });
    }
    
    // Update location info banner
    const locationInfo = document.getElementById('locationInfo');
    if (locationInfo) {
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation && activeLocation.unlocked && activeLocation.theme) {
        const nsfwWarning = activeLocation.nsfwLevel ? `<span style="color:#ff6b6b; font-weight:bold;">⚠️ NSFW Level ${activeLocation.nsfwLevel}</span> • ` : '';
        locationInfo.style.display = 'block';
        locationInfo.innerHTML = `
          <div style="display:flex; align-items:center; gap:15px;">
            <div style="font-size:2rem;">${activeLocation.name.split(' ')[0]}</div>
            <div style="flex:1;">
              <div style="font-size:1.1rem; font-weight:bold; margin-bottom:5px;">${activeLocation.name}</div>
              <div style="color:#aaa; font-size:0.9rem;">${nsfwWarning}${activeLocation.theme.description}</div>
            </div>
          </div>
        `;
      } else {
        locationInfo.style.display = 'none';
      }
    }
    
    // Update products (only show products from active location)
    updateProductsList();
  }
  
  // Check if a location can be unlocked
  function checkLocationUnlockable(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location) return false;
    
    // Already unlocked
    if (location.unlocked) return false;
    
    // Check cash requirement
    if (gameState.cash < location.cost) return false;
    
    // Check prestige requirement
    if (location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges) {
      return false;
    }
    
    // First location is always unlockable (but should start unlocked anyway)
    const locationIndex = gameState.locations.findIndex(loc => loc.id === locationId);
    if (locationIndex === 0) return true;
    
    // Check if previous location is unlocked
    if (locationIndex > 0) {
      const prevLocation = gameState.locations[locationIndex - 1];
      if (!prevLocation.unlocked) return false;
    }
    
    return true;
  }
  
  // Unlock a location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location || location.unlocked) return;
    
    if (!checkLocationUnlockable(locationId)) {
      showNotification('Cannot unlock this location yet!', 'error');
      return;
    }
    
    if (gameState.cash < location.cost) {
      showNotification('Not enough cash to unlock this location!', 'error');
      return;
    }
    
    // Deduct cost and unlock
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true;
    
    // Unlock the first product in this location automatically
    const firstProduct = gameState.products.find(p => p.locationId === locationId && p.unlockCost === 0);
    if (firstProduct) {
      firstProduct.unlocked = true;
    }
    
    // Switch to newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Apply location theme
    applyLocationTheme(location);
    
    showNotification(`${location.name} unlocked!`, 'success');
    updateUI();
    saveGame();
  }
  
  // Apply visual theme when switching locations
  function applyLocationTheme(location) {
    if (!location || !location.theme) return;
    
    const body = document.body;
    const theme = location.theme;
    
    // Apply background gradient
    if (theme.background) {
      body.style.background = theme.background;
    }
    
    // Store current theme for other UI elements to reference
    gameState.currentTheme = theme;
    
    // Update any dynamic UI elements based on theme
    // This can be expanded later with particle effects, etc.
  }
  
  // Update products list (renders cards only; click handling is delegated elsewhere)
  function updateProductsList() {
    if (!productsList) return;
    
    // Clear cache when re-rendering products
    clearUpgradeButtonCache();
    
    productsList.innerHTML = '';
    
    // Only show products from the active location
    const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
    if (!activeLocation || !activeLocation.unlocked) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">Select an unlocked location to view products.</p>';
      return;
    }
    
    const visibleProducts = gameState.products.filter(p => p.locationId === gameState.activeLocationId);
    
    if (visibleProducts.length === 0) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">No products available in this location.</p>';
      return;
    }
    
    visibleProducts.forEach(p => {
      const card = document.createElement('div');
      card.className = 'product-card';
      card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2);';

      // Check if product is unlocked
      if (!p.unlocked) {
        // Calculate what the actual earnings will be with current multipliers
        const actualEarnings = currentValue(p);
        
        // Apply product discount from influence upgrades to unlock cost
        const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
        const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
        const discountedUnlockCost = Math.floor(p.unlockCost * discountMultiplier);
        
        // Calculate discount percentage for display
        const discountPercent = Math.round((1 - discountMultiplier) * 100);
        const hasDiscount = discountPercent > 0;
        
        // Render locked product card
        card.innerHTML = `
          <h3 style="margin:0 0 6px 0;">${p.name}</h3>
          <p style="margin:0; color:#aaa;">🔒 Locked</p>
          <p style="margin:6px 0 8px 0; font-size:.9rem; color:#888;">
            Unlock this product to start earning $${formatNumber(actualEarnings)} per unit.
          </p>
          <div style="margin-top:12px;">
            <button class="unlock-product-btn" data-id="${p.id}" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:bold;">
              🔓 Unlock ${hasDiscount ? `<span style="color:#4ecca3;">$${formatNumber(discountedUnlockCost)}</span> <span style="color:#888; text-decoration:line-through; font-size:0.85rem;">$${formatNumber(p.unlockCost)}</span> <span style="color:#ffd700; font-size:0.85rem;">(-${discountPercent}%)</span>` : `($${formatNumber(p.unlockCost)})`}
            </button>
          </div>
        `;
        productsList.appendChild(card);
        return;
      }

      // Calculate bulk upgrade cost
      const multiplier = gameState.upgradeMultiplier;
      const MAX_LEVEL = 999;
      const isMaxLevel = p.level >= MAX_LEVEL;
      let upgradeCost, upgradeCount, upgradeText;
      
      if (isMaxLevel) {
        // At max level
        upgradeCost = 0;
        upgradeCount = 0;
        upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
      } else if (multiplier === 'max') {
        // Calculate max affordable upgrades (but cap at MAX_LEVEL)
        const result = calculateMaxAffordableUpgrades(p, gameState.cash);
        upgradeCost = result.totalCost;
        upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      } else if (multiplier === 1) {
        upgradeCost = p.upgradeCost;
        upgradeCount = 1;
        upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
      } else {
        upgradeCost = calculateBulkUpgradeCost(p, Math.min(multiplier, MAX_LEVEL - p.level));
        upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      }

      // Render unlocked product card
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
      const onboarding = !!p.managerOnboarding;
      
      // Manager button logic
      let managerCta, managerDisabledAttr, managerCursor, managerOpacity, managerBgColor;
      
      // Check if manager actually exists (in employees OR onboarding)
      const managerExists = p.managerId && (
        gameState.employees.find(e => e.id === p.managerId) ||
        (gameState.onboarding && gameState.onboarding.find(e => e.id === p.managerId))
      );
      
      // If marked as hired but manager doesn't exist, fix the state
      if (p.managerHired && !managerExists) {
        p.managerHired = false;
        p.managerId = null;
        p.managerLevel = 0;
        p.managerOnboarding = false;
      }
      
      if (isConstantStream) {
        // Constant stream - lock position upgrades
        managerCta = '🔒 Optimized (Constant)';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.6';
        managerBgColor = '#2a2a2a';
      } else if (onboarding) {
        managerCta = 'Onboarding in Progress';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.7';
        managerBgColor = '#533483';
      } else if (p.managerHired) {
        managerCta = `Upgrade Position ($${formatNumber(p.managerUpgradeCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      } else {
        managerCta = `Hire Staff ($${formatNumber(p.managerHireCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      }
      
      // Value display - show per second for constant streams
      const currentVal = currentValue(p);
      const valueDisplay = isConstantStream 
        ? `$<span id="val-${p.id}">${formatNumber(currentVal / (cycleTime / 1000))}</span> / sec`
        : `$<span id="val-${p.id}">${formatNumber(currentVal)}</span> / unit`;

      card.innerHTML = `
        <h3 style="margin:0 0 6px 0;">${p.name}${isConstantStream ? ' ⚡' : ''}</h3>
        <p style="margin:0; color:#aaa;">${valueDisplay}</p>
        <p style="margin:6px 0 8px 0; font-size:.9rem;">
          Cycle: <span id="cyc-${p.id}">${(cycleTime/1000).toFixed(1)}</span>s • Level ${p.level}${isMaxLevel ? ' 🏆' : ''}
        </p>

        <div style="width:100%; background:#0f3460; height:8px; border-radius:4px; margin:8px 0 12px 0;">
          <div id="prog-${p.id}" style="width:${pct}%; background:#e94560; height:100%; border-radius:4px;"></div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          ${!isConstantStream ? `
            <button class="sell-btn" data-id="${p.id}" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer;">
              <span id="selltxt-${p.id}">${p.running ? 'Click: -1s' : 'Sell'}</span>
            </button>
          ` : `
            <div style="flex:1; padding:10px; background:#1a4d2e; border:none; border-radius:6px; color:#4caf50; text-align:center; font-weight:bold;">
              ⚡ Constant Stream
            </div>
          `}
          <button class="upgrade-product-btn" data-id="${p.id}" data-count="${upgradeCount}" data-cost="${upgradeCost}" ${isMaxLevel ? 'disabled' : ''} style="padding:10px; background:${isMaxLevel ? '#333' : '#0f3460'}; border:none; border-radius:6px; color:${isMaxLevel ? '#888' : '#fff'}; cursor:${isMaxLevel ? 'not-allowed' : 'pointer'}; opacity:${isMaxLevel ? '0.7' : '1'};">
            ${upgradeText}
          </button>
          <button class="manager-btn" data-id="${p.id}" ${managerDisabledAttr} style="padding:10px; background:${managerBgColor}; border:none; border-radius:6px; color:#fff; cursor:${managerCursor}; opacity:${managerOpacity};">
            ${managerCta}
          </button>
        </div>

        ${p.managerHired ? (() => {
          const manager = gameState.employees.find(e => e.id === p.managerId);
          
          // If manager not found, show error state
          if (!manager) {
            return `<p style="margin:10px 0 0 0; color:#e94560; font-size:0.9rem;">⚠️ Staff assignment lost - click "Hire Staff" to reassign</p>`;
          }
          
          const managerName = manager.name;
          const managerLevel = p.managerLevel || 1;
          
          // Calculate manager bonuses for display
          const bonuses = getManagerialBonuses(p);
          const hasManagerBonuses = bonuses.managerChain && bonuses.managerChain.length > 0;
          
          let bonusDisplay = '';
          if (hasManagerBonuses) {
            const speedBonus = ((bonuses.speedMultiplier - 1) * 100).toFixed(0);
            const incomeBonus = ((bonuses.incomeMultiplier - 1) * 100).toFixed(0);
            bonusDisplay = `<div style="margin-top:4px; font-size:0.8rem; color:#ffd700;">
              📊 Manager Bonuses: +${speedBonus}% speed, +${incomeBonus}% income
              <br/><span style="font-size:0.75rem; color:#aaa;">${bonuses.managerChain.map(m => m.title).join(' → ')}</span>
            </div>`;
          }
          
          return `<p style="margin:10px 0 0 0; color:${isConstantStream ? '#4caf50' : (onboarding ? '#ffa726' : '#4caf50')};">${isConstantStream ? `⚡ Staffed by ${managerName} - Operating at peak efficiency` : (onboarding ? `⏳ ${managerName} onboarding… (auto running)` : `✓ Staffed by ${managerName} (Lv.${managerLevel})`)}</p>${bonusDisplay}`;
        })() : `<p style="margin:10px 0 0 0; color:#e94560; font-size:0.9rem;">⚠️ No staff assigned - automation disabled</p>`}
      `;
      
      // IMPORTANT: Clear the constant stream flag so updateProductProgressBars() will re-apply the animation
      delete p._wasConstantStream;

      productsList.appendChild(card);
    });
  }

  // Cache for upgrade button elements to avoid repeated querySelector calls
  let upgradeButtonCache = new Map();
  
  function updateProductProgressBars() {
    for (const p of gameState.products) {
      // Skip locked products as they don't have progress bars
      if (!p.unlocked) continue;
      
      const bar = $(`prog-${p.id}`);
      const sellTx = $(`selltxt-${p.id}`);
      const valEl = $(`val-${p.id}`);
      const cycEl = $(`cyc-${p.id}`);
      if (!bar) continue;

      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired; // Sub-1-second with manager
      
      // Only update if state changed (prevent unnecessary DOM updates)
      const wasConstantStream = p._wasConstantStream || false;
      
      if (isConstantStream !== wasConstantStream) {
        p._wasConstantStream = isConstantStream;
        
        if (isConstantStream) {
          // Replace progress bar with "Constant Stream" animation
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
          
          // Mark as optimized - update display once
          if (valEl) {
            const earningsPerSec = currentValue(p) / (cycleTime / 1000);
            valEl.textContent = formatNumber(earningsPerSec);
          }
          if (cycEl) cycEl.textContent = '⚡ Constant';
        } else {
          // Normal progress bar - reset styles
          bar.style.background = '#e94560';
          bar.style.backgroundSize = '100% 100%';
          bar.style.animation = 'none';
          bar.style.width = '0%'; // Reset width for normal animation
        }
      }
      
      // For constant streams, ensure animation persists (fix for broken bars)
      if (isConstantStream) {
        // Re-apply animation if it was somehow removed
        if (!bar.style.animation || bar.style.animation === 'none' || bar.style.animation === '') {
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
        }
        // Skip progress bar, sell text, and frequent value updates
        // Only update upgrade buttons on the throttled schedule
      } else {
        // Normal product - update progress bar and values
        const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
        bar.style.width = `${pct}%`;
        
        if (sellTx) sellTx.textContent = p.running ? 'Click: -1s' : 'Sell';
        if (valEl) valEl.textContent = currentValue(p);
        if (cycEl) {
          const cycleText = (cycleTime/1000).toFixed(1);
          if (cycEl.textContent !== cycleText) {
            cycEl.textContent = cycleText;
          }
        }
      }
      
      // Update upgrade button cost and count in real-time (throttled)
      // Only update every 10 ticks (~1 second) to reduce DOM manipulation
      if (!p._upgradeTickCount) p._upgradeTickCount = 0;
      p._upgradeTickCount++;
      
      if (p._upgradeTickCount >= 10) {
        p._upgradeTickCount = 0;
        
        // Get cached button or query once
        let upgradeBtn = upgradeButtonCache.get(p.id);
        if (!upgradeBtn || !document.contains(upgradeBtn)) {
          upgradeBtn = document.querySelector(`.upgrade-product-btn[data-id="${p.id}"]`);
          if (upgradeBtn) {
            upgradeButtonCache.set(p.id, upgradeBtn);
          }
        }
        
        if (upgradeBtn) {
          const multiplier = gameState.upgradeMultiplier;
          const MAX_LEVEL = 999;
          const isMaxLevel = p.level >= MAX_LEVEL;
          let upgradeCost, upgradeCount, upgradeText;
          
          if (isMaxLevel) {
            upgradeCount = 0;
            upgradeCost = 0;
            upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
          } else if (multiplier === 'max') {
            const result = calculateMaxAffordableUpgrades(p, gameState.cash);
            upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
            upgradeCost = result.totalCost;
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          } else if (multiplier === 1) {
            upgradeCount = 1;
            upgradeCost = p.upgradeCost;
            upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
          } else {
            upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
            upgradeCost = calculateBulkUpgradeCost(p, upgradeCount);
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          }
          
          // Only update if changed
          if (upgradeBtn.textContent !== upgradeText) {
            upgradeBtn.textContent = upgradeText;
          }
          upgradeBtn.dataset.count = upgradeCount;
          upgradeBtn.dataset.cost = upgradeCost;
          
          // Update button state (enabled/disabled) based on affordability
          const shouldBeDisabled = isMaxLevel || gameState.cash < upgradeCost || upgradeCount === 0;
          if (upgradeBtn.disabled !== shouldBeDisabled) {
            upgradeBtn.disabled = shouldBeDisabled;
            
            if (isMaxLevel) {
              upgradeBtn.style.opacity = '0.7';
              upgradeBtn.style.cursor = 'not-allowed';
              upgradeBtn.style.background = '#333';
              upgradeBtn.style.color = '#888';
            } else if (!shouldBeDisabled) {
              upgradeBtn.style.opacity = '1';
              upgradeBtn.style.cursor = 'pointer';
              upgradeBtn.style.background = '#0f3460';
              upgradeBtn.style.color = '#fff';
            } else {
              upgradeBtn.style.opacity = '0.5';
              upgradeBtn.style.cursor = 'not-allowed';
            }
          }
        }
      }
    }
  }
  
  // Clear upgrade button cache when products list is re-rendered
  function clearUpgradeButtonCache() {
    upgradeButtonCache.clear();
  }
  
  // Initialize people sorting settings if not exists
  if (!gameState.peopleSorting) {
    gameState.peopleSorting = {
      sortBy: 'newest',
      showFavoritesOnly: false
    };
  }

  // Toggle favorite/star on employee
  function toggleEmployeeFavorite(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (employee) {
      employee.isFavorite = !employee.isFavorite;
      updatePeopleTab();
      saveGame();
    }
  }

  // Calculate average relationship strength for an employee
  /**
   * Calculate the overall relationship score between the player and an employee.
   * This averages the 5 core stats (affection, comfort, trust, desire, obedience)
   * and optionally factors in the intimacy level.
   * @param {Object} employee - The employee object
   * @returns {number} Average relationship score (0-100)
   */
  function calculateAverageRelationship(employee) {
    if (!employee.stats) {
      return 0;
    }
    
    // Get the 5 core relationship stats
    const affection = employee.stats.affection || 0;
    const comfort = employee.stats.comfort || 0;
    const trust = employee.stats.trust || 0;
    const desire = employee.stats.desire || 0;
    const obedience = employee.stats.obedience || 0;
    
    // Calculate the average of the 5 core stats
    const coreAverage = (affection + comfort + trust + desire + obedience) / 5;
    
    // Optionally include intimacy level as a bonus factor (stored in memory)
    // Intimacy is already calculated from these stats, so we give it less weight
    const intimacyLevel = employee.memory?.intimacyLevel || 0;
    
    // Final score: 80% core stats average, 20% intimacy level
    // This gives slight bonus to employees with established intimate relationships
    const finalScore = (coreAverage * 0.8) + (intimacyLevel * 0.2);
    
    return finalScore;
  }

  // ========== CORPORATE HIERARCHY & PROMOTION SYSTEM ==========
  
  /**
   * Get promotion requirements for a given level
   * @param {number} level - Target promotion level (2-7)
   * @param {object} employee - Employee object (optional, for fast-track calculation)
   * @returns {object} Requirements object or null
   */
  function getPromotionRequirements(level, employee = null) {
    const baseRequirements = {
      2: { minProductivity: 60, minManagement: 1 },                  // Staff → Local Manager
      3: { minProductivity: 70, minManagement: 2 },                  // Local Manager → Regional Manager
      4: { minProductivity: 75, minManagement: 4 },                  // Regional Manager → Branch Manager
      5: { minProductivity: 80, minManagement: 6 },                  // Branch Manager → CFO/COO
      6: { minProductivity: 85, minManagement: 8 },                  // CFO/COO → Senior Executive
      7: { minProductivity: 90, minManagement: 10 }                  // Senior Executive → CEO
    };
    
    return baseRequirements[level] || null;
  }

  /**
   * Check if employee can be promoted to next level
   * @param {object} employee - Employee object
   * @returns {boolean} True if eligible for promotion
   */
  function canPromote(employee) {
    if (!employee || !employee.career) return false;
    
    const currentLevel = employee.career.level;
    const nextLevel = currentLevel + 1;
    
    // Cap at Executive level
    if (nextLevel > 7) return false;
    
    const requirements = getPromotionRequirements(nextLevel, employee);
    if (!requirements) return false;
    
    // Check productivity requirement
    if ((employee.stats.productivity || 0) < requirements.minProductivity) return false;
    
    // Check management skill requirement (if applicable)
    if (requirements.minManagement) {
      const managementLevel = employee.skills?.management?.level || 0;
      if (managementLevel < requirements.minManagement) return false;
    }
    
    return true;
  }

  /**
   * Promote employee to next level
   * @param {object} employee - Employee object
   * @returns {boolean} True if promotion successful
   */
  function promoteEmployee(employee) {
    if (!canPromote(employee)) return false;
    
    const oldLevel = employee.career.level;
    const newLevel = oldLevel + 1;
    const levelData = gameState.hierarchyLevels[newLevel];
    
    if (!levelData) return false;
    
    // Update career data
    employee.career.level = newLevel;
    employee.career.title = levelData.title;
    employee.career.salary = levelData.baseSalary;
    const previousStartDate = employee.career.startDate;
    employee.career.startDate = Date.now();
    
    // Track history
    employee.career.promotionHistory.push({
      date: Date.now(),
      fromLevel: oldLevel,
      toLevel: newLevel,
      timeInRole: (Date.now() - previousStartDate) / (1000 * 60 * 60 * 24), // days
      reason: "Performance milestone reached"
    });
    
    // Update hierarchy tracking
    updateCorporateHierarchy();
    
    // Generate social post about promotion
    generatePromotionPost(employee, newLevel);
    
    // Update UI
    updatePeopleTab();
    
    // Show notification
    showNotification(`🎉 ${employee.name} promoted to ${employee.career.title}!`, 'success');
    
    console.log(`[Promotion] ${employee.name} promoted from Level ${oldLevel} to Level ${newLevel} (${levelData.title})`);
    
    return true;
  }

  /**
   * Check all employees for promotion eligibility and auto-promote
   * Should be called periodically (e.g., every game tick or time update)
   */
  function checkForPromotions() {
    if (!gameState.employees || gameState.employees.length === 0) return;
    
    let promotionCount = 0;
    
    gameState.employees.forEach(employee => {
      if (employee.employmentStatus !== 'active') return;
      if (!employee.career) return;
      
      if (canPromote(employee)) {
        if (promoteEmployee(employee)) {
          promotionCount++;
        }
      }
    });
    
    if (promotionCount > 0) {
      console.log(`[Promotion] Auto-promoted ${promotionCount} employee(s)`);
    }
  }

  /**
   * Check if an employee can be promoted (has eligible positions available)
   * @param {object} employee - Employee object
   * @returns {boolean} True if employee has positions they can be promoted to
   */
  function canPromoteEmployee(employee) {
    if (!employee || employee.employmentStatus !== 'active') return false;
    if (!employee.career) return false;
    
    // Get current position
    const currentPosition = getEmployeePosition(employee.id);
    if (!currentPosition) return false;
    
    // Check if there are any positions they can fill at a higher level
    const currentLevel = currentPosition.level;
    
    // Check levels above current (up to level 6, since 7 is CEO)
    for (let level = Math.floor(currentLevel) + 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (!positions) continue;
      
      for (const position of positions) {
        const check = canFillPosition(employee, position);
        if (check.canFill) {
          return true; // Found at least one eligible position
        }
      }
    }
    
    // Check secretary position if they're level 1-3 and not already secretary
    if (currentPosition.positionId !== 'secretary' && employee.career.level >= 1 && employee.career.level <= 3) {
      const secretaryPos = gameState.corporatePyramid.secretaryPosition;
      if (secretaryPos && !secretaryPos.employeeId) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Start the promotion flow for an employee
   * Closes the employee modal and opens the pyramid with eligible positions highlighted
   * @param {string} employeeId - Employee ID
   */
  function startPromotionFlow(employeeId) {
    // Close the employee profile modal
    if (typeof ModalManager !== 'undefined' && ModalManager.close) {
      ModalManager.close('profileModal');
    }
    
    // Wait a moment for the modal to close, then open pyramid
    setTimeout(() => {
      openCorporatePyramidModal(employeeId);
    }, 150);
  }

  // Make functions available globally
  window.canPromoteEmployee = canPromoteEmployee;
  window.startPromotionFlow = startPromotionFlow;

  // ========== PRODUCTIVITY IMPROVEMENT SYSTEMS ==========
  
  /**
   * Training Workshop System
   * Costs money to conduct, boosts productivity for all attendees
   */
  function conductTrainingWorkshop() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (activeEmployees.length === 0) {
      showNotification('No active employees to train!', 'error');
      return;
    }
    
    // Cost scales with number of employees
    const costPerEmployee = 500;
    const totalCost = activeEmployees.length * costPerEmployee;
    
    if (gameState.cash < totalCost) {
      showNotification(`Not enough cash! Training costs $${formatNumber(totalCost)} ($${formatNumber(costPerEmployee)} per employee)`, 'error');
      return;
    }
    
    // Deduct cost
    gameState.cash -= totalCost;
    
    // Apply productivity boost to all active employees
    let boostedCount = 0;
    activeEmployees.forEach(emp => {
      if (!emp.stats) emp.stats = {};
      const oldProductivity = emp.stats.productivity || 50;
      
      // +5 to +10 productivity boost (random within range)
      const boost = 5 + Math.floor(Math.random() * 6);
      emp.stats.productivity = Math.min(100, oldProductivity + boost);
      
      // Also give some management skill XP
      gainSkillXP(emp, 'management', 20, 'training_workshop');
      
      boostedCount++;
    });
    
    // Track when last workshop was held
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    gameState.productivitySystems.lastWorkshop = Date.now();
    
    showNotification(`🎓 Training Workshop completed! ${boostedCount} employees gained +5-10 productivity!`, 'success');
    logCompanyEvent({
      type: 'training',
      description: `Company-wide training workshop conducted`,
      sentiment: 'positive',
      importance: 6
    });
    
    saveGame();
    updatePeopleTab();
    updateUI();
  }
  
  /**
   * Performance Review System
   * Review individual employee, provide focused feedback
   */
  function conductPerformanceReview(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee || employee.employmentStatus !== 'active') {
      showNotification('Employee not found or inactive!', 'error');
      return;
    }
    
    // Check cooldown (can't review same employee within 7 days)
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    if (!gameState.productivitySystems.reviewCooldowns) gameState.productivitySystems.reviewCooldowns = {};
    
    const lastReview = gameState.productivitySystems.reviewCooldowns[employeeId] || 0;
    const daysSinceReview = (Date.now() - lastReview) / (1000 * 60 * 60 * 24);
    
    if (daysSinceReview < 7) {
      const daysRemaining = Math.ceil(7 - daysSinceReview);
      showNotification(`${employee.name} was recently reviewed. Wait ${daysRemaining} more day(s).`, 'error');
      return;
    }
    
    // Cost for one-on-one review
    const reviewCost = 200;
    if (gameState.cash < reviewCost) {
      showNotification(`Not enough cash! Performance review costs $${formatNumber(reviewCost)}`, 'error');
      return;
    }
    
    gameState.cash -= reviewCost;
    
    // Apply boost based on current performance
    if (!employee.stats) employee.stats = {};
    const oldProductivity = employee.stats.productivity || 50;
    
    let boost;
    let message;
    
    if (oldProductivity < 50) {
      // Low performers get big boost
      boost = 15 + Math.floor(Math.random() * 6); // +15-20
      message = `${employee.name} appreciated the feedback and showed significant improvement!`;
    } else if (oldProductivity < 75) {
      // Average performers get medium boost
      boost = 10 + Math.floor(Math.random() * 6); // +10-15
      message = `${employee.name} took the feedback well and improved their productivity!`;
    } else {
      // High performers get small boost
      boost = 5 + Math.floor(Math.random() * 6); // +5-10
      message = `${employee.name} is already performing well, but found ways to optimize further!`;
    }
    
    employee.stats.productivity = Math.min(100, oldProductivity + boost);
    
    // Also boost affection slightly (positive interaction)
    if (employee.stats.affection !== undefined) {
      employee.stats.affection = Math.min(100, (employee.stats.affection || 50) + 5);
    }
    
    // Set cooldown
    gameState.productivitySystems.reviewCooldowns[employeeId] = Date.now();
    
    showNotification(`📊 ${message} (+${boost} productivity)`, 'success');
    
    // Track in employee history
    if (!employee.career) employee.career = {};
    if (!employee.career.reviewHistory) employee.career.reviewHistory = [];
    employee.career.reviewHistory.push({
      date: Date.now(),
      productivityBefore: oldProductivity,
      productivityAfter: employee.stats.productivity,
      boost: boost
    });
    
    saveGame();
    updatePeopleTab();
    updateUI();
  }
  
  /**
   * Team Building Activity
   * Costs money, boosts productivity + morale for all employees
   */
  function conductTeamBuilding() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (activeEmployees.length === 0) {
      showNotification('No active employees for team building!', 'error');
      return;
    }
    
    // Check cooldown (can't do team building too often)
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    const lastTeamBuilding = gameState.productivitySystems.lastTeamBuilding || 0;
    const daysSince = (Date.now() - lastTeamBuilding) / (1000 * 60 * 60 * 24);
    
    if (daysSince < 14) {
      const daysRemaining = Math.ceil(14 - daysSince);
      showNotification(`Team building activities need time to be effective. Wait ${daysRemaining} more day(s).`, 'error');
      return;
    }
    
    // Cost scales with employees but is more expensive than training
    const costPerEmployee = 800;
    const totalCost = activeEmployees.length * costPerEmployee;
    
    if (gameState.cash < totalCost) {
      showNotification(`Not enough cash! Team building costs $${formatNumber(totalCost)} ($${formatNumber(costPerEmployee)} per employee)`, 'error');
      return;
    }
    
    gameState.cash -= totalCost;
    
    // Apply benefits
    let boostedCount = 0;
    activeEmployees.forEach(emp => {
      if (!emp.stats) emp.stats = {};
      
      // Moderate productivity boost
      const oldProductivity = emp.stats.productivity || 50;
      const productivityBoost = 3 + Math.floor(Math.random() * 5); // +3-7
      emp.stats.productivity = Math.min(100, oldProductivity + productivityBoost);
      
      // Significant morale boosts
      if (emp.stats.affection !== undefined) {
        emp.stats.affection = Math.min(100, (emp.stats.affection || 50) + 8);
      }
      if (emp.stats.comfort !== undefined) {
        emp.stats.comfort = Math.min(100, (emp.stats.comfort || 50) + 8);
      }
      
      // Social skill boost
      gainSkillXP(emp, 'social', 30, 'team_building');
      
      boostedCount++;
    });
    
    gameState.productivitySystems.lastTeamBuilding = Date.now();
    
    showNotification(`🎉 Team Building Activity completed! ${boostedCount} employees bonded and improved! (+3-7 productivity, +8 morale)`, 'success');
    
    logCompanyEvent({
      type: 'team_building',
      description: `Company team building event held`,
      sentiment: 'positive',
      importance: 7
    });
    
    saveGame();
    updatePeopleTab();
    updateUI();
  }

  /**
   * Update corporate hierarchy tracking
   * Organizes employees by level
   */
  function updateCorporateHierarchy() {
    // Reset levels
    Object.keys(gameState.corporateHierarchy.levels).forEach(level => {
      gameState.corporateHierarchy.levels[level] = [];
    });
    
    // Organize employees by level
    gameState.employees.forEach(employee => {
      if (employee.employmentStatus !== 'active') return;
      if (!employee.career) return;
      
      const level = employee.career.level;
      if (gameState.corporateHierarchy.levels[level]) {
        gameState.corporateHierarchy.levels[level].push(employee.id);
      }
    });
  }

  // ========== CORPORATE PYRAMID MANAGEMENT (HIERARCHICAL ORG CHART) ==========
  
  /**
   * Initialize hierarchical pyramid structure
   * Creates positions dynamically as locations/products unlock
   */
  function initializeHierarchicalPyramid() {
    // Ensure corporatePyramid structure exists
    if (!gameState.corporatePyramid) {
      console.error('[Pyramid] corporatePyramid not found in gameState!');
      return;
    }
    
    // Initialize secretary position if it doesn't exist
    if (!gameState.corporatePyramid.secretaryPosition) {
      gameState.corporatePyramid.secretaryPosition = {
        positionId: 'secretary',
        title: 'Executive Secretary',
        level: 6.5,
        employeeId: null,
        reportsTo: 'ceo',
        subordinates: []
      };
    }
    
    // Migrate old structure to new hierarchical structure if needed
    if (!gameState.corporatePyramid.positions || typeof gameState.corporatePyramid.positions !== 'object') {
      console.log('[Pyramid] Migrating to hierarchical structure...');
      gameState.corporatePyramid.positions = {
        6: [{
          positionId: 'senior_exec',
          title: 'Senior Executive',
          level: 6,
          employeeId: null,
          reportsTo: 'ceo',
          subordinates: [],
          span: 2
        }],
        5: [
          {
            positionId: 'cfo',
            title: 'Chief Financial Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [],
            span: 2
          },
          {
            positionId: 'coo',
            title: 'Chief Operating Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [],
            span: 2
          }
        ],
        4: [
          { positionId: 'branch_mgr_1', title: 'Branch Manager 1', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_2', title: 'Branch Manager 2', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_3', title: 'Branch Manager 3', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 2 },
          { positionId: 'branch_mgr_4', title: 'Branch Manager 4', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 1 }
        ],
        3: [],
        2: [],
        1: []
      };
      
      // Migrate promotion costs if they're using old structure
      if (!gameState.corporatePyramid.promotionCosts) {
        gameState.corporatePyramid.promotionCosts = {
          1: 500,
          2: 2000,
          3: 10000,
          4: 50000,
          5: 150000,
          6: 500000,
          7: 0
        };
      }
    }
    
    // Ensure each level is an array
    for (let i = 1; i <= 6; i++) {
      if (!Array.isArray(gameState.corporatePyramid.positions[i])) {
        gameState.corporatePyramid.positions[i] = [];
      }
    }
    
    // Count unlocked locations
    const unlockedLocations = gameState.locations.filter(l => l.unlocked);
    const locationCount = unlockedLocations.length;
    
    // Level 3: Regional Managers (1 per location)
    unlockedLocations.forEach((location, index) => {
      const existingPos = gameState.corporatePyramid.positions[3].find(p => p.locationId === location.id);
      if (!existingPos) {
        // Determine which branch manager this reports to
        const branchManagerIndex = Math.floor(index / 2.25); // Distribute among 4 branch managers
        const branchMgrId = `branch_mgr_${Math.min(branchManagerIndex + 1, 4)}`;
        
        gameState.corporatePyramid.positions[3].push({
          positionId: `regional_mgr_${location.id}`,
          title: `Regional Manager - ${location.name}`,
          level: 3,
          employeeId: null,
          reportsTo: branchMgrId,
          subordinates: [],
          locationId: location.id,
          span: 3 // Manages 2-3 local managers
        });
      }
    });
    
    // Level 2: Local Managers (2-3 per location, manages 4-6 products each)
    unlockedLocations.forEach(location => {
      const products = gameState.products.filter(p => p.locationId === location.id && p.unlocked);
      const productCount = products.length;
      
      // Determine how many local managers needed (1 per 4-6 products)
      const managersNeeded = Math.max(1, Math.ceil(productCount / 5));
      
      for (let i = 0; i < managersNeeded; i++) {
        const existingPos = gameState.corporatePyramid.positions[2].find(
          p => p.locationId === location.id && p.managerId === i
        );
        
        if (!existingPos) {
          gameState.corporatePyramid.positions[2].push({
            positionId: `local_mgr_${location.id}_${i}`,
            title: `Local Manager ${i + 1} - ${location.name}`,
            level: 2,
            employeeId: null,
            reportsTo: `regional_mgr_${location.id}`,
            subordinates: [],
            locationId: location.id,
            managerId: i,
            span: 5 // Manages ~5 staff
          });
        }
      }
    });
    
    // Level 1: Staff (1 per product)
    unlockedLocations.forEach(location => {
      const products = gameState.products.filter(p => p.locationId === location.id && p.unlocked);
      
      products.forEach((product, index) => {
        const existingPos = gameState.corporatePyramid.positions[1].find(
          p => p.productId === product.id
        );
        
        if (!existingPos) {
          // Assign to local manager based on index
          const localManagers = gameState.corporatePyramid.positions[2].filter(p => p.locationId === location.id);
          const managerIndex = Math.floor(index / 5) % localManagers.length;
          const assignedManager = localManagers[managerIndex];
          
          gameState.corporatePyramid.positions[1].push({
            positionId: `staff_${product.id}`,
            title: `${product.name} Staff`,
            level: 1,
            employeeId: null,
            reportsTo: assignedManager ? assignedManager.positionId : null,
            locationId: location.id,
            productId: product.id
          });
        }
      });
    });
    
    console.log(`[Pyramid] Initialized: ${gameState.corporatePyramid.positions[1].length} Staff, ${gameState.corporatePyramid.positions[2].length} Local Managers, ${gameState.corporatePyramid.positions[3].length} Regional Managers`);
  }
  
  /**
   * Get position by ID (searches all levels)
   * @param {string} positionId - Position ID
   * @returns {object|null} Position object
   */
  function getPosition(positionId) {
    if (positionId === 'ceo') return gameState.corporatePyramid.ceo;
    if (positionId === 'secretary') return gameState.corporatePyramid.secretaryPosition;
    
    // Search through all levels
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const position = positions.find(p => p.positionId === positionId);
        if (position) return position;
      }
    }
    
    return null;
  }
  
  /**
   * Get employee's current position in hierarchy
   * @param {string} employeeId - Employee ID
   * @returns {object|null} Position object
   */
  function getEmployeePosition(employeeId) {
    // Check secretary position first
    if (gameState.corporatePyramid.secretaryPosition?.employeeId === employeeId) {
      return gameState.corporatePyramid.secretaryPosition;
    }
    
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const position = positions.find(p => p.employeeId === employeeId);
        if (position) return position;
      }
    }
    return null;
  }
  
  /**
   * Get all subordinates of a position (direct reports)
   * @param {string} positionId - Position ID
   * @returns {array} Array of employee objects who report to this position
   */
  function getSubordinates(positionId) {
    const subordinates = [];
    
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        positions.forEach(pos => {
          if (pos.reportsTo === positionId && pos.employeeId) {
            const employee = gameState.employees.find(e => e.id === pos.employeeId);
            if (employee) {
              subordinates.push({ employee, position: pos });
            }
          }
        });
      }
    }
    
    return subordinates;
  }
  
  /**
   * Check if employee meets position requirements
   * @param {object} employee - Employee object
   * @param {object} position - Position object
   * @returns {object} { canFill: boolean, reason: string }
   */
  function canFillPosition(employee, position) {
    console.log(`\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
    console.log(`[PROMOTION CHECK] Evaluating ${employee.name} for ${position.title}`);
    console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
    
    if (!employee || !position) {
      console.log(`❌ FAILED: Invalid employee or position`);
      console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
      return { canFill: false, reason: 'Invalid employee or position' };
    }
    
    // CRITICAL: Check if position is already occupied by someone else
    if (position.employeeId && position.employeeId !== employee.id) {
      const occupant = gameState.employees.find(e => e.id === position.employeeId);
      const occupantName = occupant ? occupant.name : 'someone';
      console.log(`❌ FAILED: Position already occupied by ${occupantName}`);
      console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
      return { canFill: false, reason: `Position already occupied by ${occupantName}` };
    }
    
    if (!employee.career) {
      console.log(`❌ FAILED: Employee has no career data`);
      console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
      return { canFill: false, reason: 'Employee has no career data' };
    }
    
    console.log(`📊 Employee Stats:`);
    console.log(`   • Current Level: ${employee.career.level} (${employee.career.title})`);
    console.log(`   • Productivity: ${Math.round(employee.stats.productivity)}%`);
    console.log(`   • Management Skill: Lv.${employee.skills?.management?.level || 0}`);
    console.log(`   • Other Skills:`, {
      technical: employee.skills?.technical?.level || 0,
      social: employee.skills?.social?.level || 0,
      creativity: employee.skills?.creativity?.level || 0
    });
    
    console.log(`\n🎯 Position Requirements:`);
    console.log(`   • Position: ${position.title}`);
    console.log(`   • Required Level: ${position.level}`);
    
    // Special handling for secretary position
    if (position.positionId === 'secretary') {
      console.log(`   • Type: Secretary (special - Level 1-3 employees only)`);
      
      if (employee.career.level >= 1 && employee.career.level <= 3) {
        console.log(`\n✅ SUCCESS: Meets all requirements!`);
        console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
        return { canFill: true, reason: 'Meets all requirements' };
      }
      
      const reason = employee.career.level > 3 ? 'Too senior for this role' : 'Requires Level 1 minimum';
      console.log(`\n❌ FAILED: ${reason}`);
      console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
      return { canFill: false, reason };
    }
    
    // Check level requirement (use Math.floor to handle decimal levels)
    const requiredLevel = Math.floor(position.level);
    const minimumLevel = requiredLevel - 1; // To get Level 2, you need to be at least Level 1
    console.log(`   • Position Level: ${requiredLevel}`);
    console.log(`   • Minimum Employee Level Required: ${minimumLevel}`);
    
    if (employee.career.level < minimumLevel) {
      const levelInfo = gameState.hierarchyLevels[minimumLevel] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: '👤' };
      const reason = `Requires at least Level ${minimumLevel}${levelInfo ? ' (' + levelInfo.title + ')' : ''}`;
      console.log(`\n❌ FAILED: ${reason}`);
      console.log(`   Employee is Level ${employee.career.level}, needs to be at least Level ${minimumLevel}`);
      console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
      return { canFill: false, reason };
    }
    
    console.log(`   ✓ Level requirement met (${employee.career.level} >= ${minimumLevel})`);
    
    // Check promotion requirements (productivity and management skill level)
    if (requiredLevel >= 2) {
      const requirements = getPromotionRequirements(requiredLevel, employee);
      console.log(`\n📋 Checking Promotion Requirements for Level ${requiredLevel}:`);
      
      if (requirements) {
        console.log(`   • Required Productivity: ${requirements.minProductivity}%`);
        console.log(`   • Required Management: Lv.${requirements.minManagement || 0}`);
        
        // Check productivity requirement
        if (requirements.minProductivity && employee.stats.productivity < requirements.minProductivity) {
          const reason = `Requires ${requirements.minProductivity}% productivity (currently ${Math.round(employee.stats.productivity)}%)`;
          console.log(`\n❌ FAILED: ${reason}`);
          console.log(`   Need ${requirements.minProductivity - Math.round(employee.stats.productivity)}% more productivity`);
          console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
          return { canFill: false, reason };
        }
        console.log(`   ✓ Productivity requirement met (${Math.round(employee.stats.productivity)}% >= ${requirements.minProductivity}%)`);
        
        // Check management skill level requirement
        if (requirements.minManagement) {
          const managementLevel = employee.skills?.management?.level || 0;
          if (managementLevel < requirements.minManagement) {
            const reason = `Requires Management Lv.${requirements.minManagement} (currently Lv.${managementLevel})`;
            console.log(`\n❌ FAILED: ${reason}`);
            console.log(`   Need ${requirements.minManagement - managementLevel} more management level(s)`);
            console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
            return { canFill: false, reason };
          }
          console.log(`   ✓ Management requirement met (Lv.${managementLevel} >= Lv.${requirements.minManagement})`);
        }
      }
    }
    
    console.log(`\n✅ SUCCESS: All requirements met!`);
    console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);
    return { canFill: true, reason: 'Meets all requirements' };
  }
  
  /**
   * Calculate cost to relocate employee to position
   * @param {object} employee - Employee object
   * @param {object} position - Position object
   * @returns {number} Cost in cash
   */
  function calculateRelocationCost(employee, position) {
    if (!employee || !position) return 0;
    
    // Special handling for secretary position - low cost for early game
    if (position.positionId === 'secretary') {
      return 1000; // Fixed low cost
    }
    
    // Base cost from position level (promotion cost) - handle decimal levels
    const positionLevel = Math.floor(position.level);
    const baseCost = gameState.corporatePyramid.promotionCosts[positionLevel] || 1000;
    
    // If employee is already assigned somewhere, it's a transfer
    const currentPosition = getEmployeePosition(employee.id);
    if (currentPosition) {
      // If moving to same or lower level, cheaper (lateral/demotion)
      if (position.level <= currentPosition.level) {
        return Math.floor(baseCost * 0.3); // 70% discount for lateral moves
      }
      // Moving up, normal promotion cost
      return baseCost;
    }
    
    // New assignment (first time placement)
    return baseCost;
  }
  
  /**
   * Assign employee to position
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - Position ID
   * @param {boolean} payNow - Whether to deduct cost immediately
   * @returns {object} { success: boolean, message: string, cost: number }
   */
  function assignEmployeeToPosition(employeeId, positionId, payNow = true) {
    console.log(`\n╔════════════════════════════════════════╗`);
    console.log(`║  ASSIGNMENT ATTEMPT                    ║`);
    console.log(`╚════════════════════════════════════════╝`);
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      console.log(`❌ Employee not found: ${employeeId}`);
      return { success: false, message: 'Employee not found', cost: 0 };
    }
    
    const position = getPosition(positionId);
    if (!position) {
      console.log(`❌ Position not found: ${positionId}`);
      return { success: false, message: 'Position not found', cost: 0 };
    }
    
    console.log(`👤 Employee: ${employee.name}`);
    console.log(`📍 Target Position: ${position.title} (Level ${position.level})`);
    
    // Check if position is CEO (player only)
    if (position.isPlayer) {
      console.log(`❌ Cannot assign employee to CEO position (player-only)`);
      return { success: false, message: 'Cannot assign employee to CEO position', cost: 0 };
    }
    
    // Check requirements
    console.log(`\n🔍 Running eligibility check...`);
    const check = canFillPosition(employee, position);
    if (!check.canFill) {
      console.log(`❌ ASSIGNMENT BLOCKED: ${check.reason}`);
      return { success: false, message: check.reason, cost: 0 };
    }
    
    console.log(`✅ Eligibility check passed!`);
    
    // Calculate cost
    const cost = calculateRelocationCost(employee, position);
    console.log(`💰 Assignment cost: $${formatNumber(cost)}`);
    console.log(`💵 Current cash: $${formatNumber(gameState.cash)}`);
    
    // Check if player can afford it
    if (payNow && gameState.cash < cost) {
      console.log(`❌ ASSIGNMENT BLOCKED: Insufficient funds (need $${formatNumber(cost - gameState.cash)} more)`);
      return { 
        success: false, 
        message: `Not enough cash! Need $${formatNumber(cost)}`, 
        cost: cost 
      };
    }
    
    // Remove employee from current position
    const currentPosition = getEmployeePosition(employee.id);
    if (currentPosition) {
      console.log(`\n📤 Removing from current position: ${currentPosition.title}`);
      
      // CRITICAL: Clear the employee ID from old position
      currentPosition.employeeId = null;
      currentPosition.isVacant = true;
      
      // Clear product management if they were managing one
      if (currentPosition.productId) {
        const oldProduct = gameState.products.find(p => p.id === currentPosition.productId);
        if (oldProduct && oldProduct.managerHired && oldProduct.managerId === employeeId) {
          oldProduct.managerHired = false;
          oldProduct.managerId = null;
          
          console.log(`   ⚠️ Product "${oldProduct.name}" now vacant - automation disabled`);
        }
      }
    } else {
      console.log(`\n📥 First-time assignment (employee not currently in any position)`);
    }
    
    // Assign to new position
    console.log(`\n📥 Assigning to new position: ${position.title}`);
    position.employeeId = employeeId;
    position.isVacant = false;
    
    // Update employee's productManaged if this is a staff position
    if (position.productId) {
      const product = gameState.products.find(p => p.id === position.productId);
      if (product) {
        employee.productManaged = product.name;
        product.managerHired = true;
        product.managerId = employeeId;
        
        console.log(`   ✓ Now managing product: ${product.name}`);
      }
    } else {
      // Higher-level positions don't manage specific products
      employee.productManaged = null;
      console.log(`   ✓ Management position (no specific product)`);
    }
    
    // Deduct cost if paying now
    if (payNow) {
      gameState.cash -= cost;
      console.log(`   💸 Deducted $${formatNumber(cost)} from cash`);
      console.log(`   💵 Remaining cash: $${formatNumber(gameState.cash)}`);
    }
    
    // Update employee's career level to match position
    const oldLevel = employee.career.level;
    const oldTitle = employee.career.title;
    
    // Special handling for secretary position (level 6.5)
    if (position.positionId === 'secretary' || position.title === 'Executive Secretary') {
      employee.career.level = 6; // Use level 6 for secretary (not 6.5 to avoid array index issues)
      employee.career.title = 'Executive Secretary';
      employee.career.salary = 65000; // Between level 6 and 7
      console.log(`   🎯 Special: Secretary position (Level 6 equivalent)`);
    } else {
      const positionLevel = Math.floor(position.level); // Handle decimal levels
      
      // CRITICAL FIX: Update career for BOTH promotions AND demotions
      if (employee.career.level !== positionLevel) {
        const levelInfo = gameState.hierarchyLevels[positionLevel] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: '👤', baseSalary: 40000 };
        
        if (levelInfo) {
          const isPromotion = employee.career.level < positionLevel;
          const isDemotion = employee.career.level > positionLevel;
          
          employee.career.level = positionLevel;
          employee.career.title = levelInfo.title;
          employee.career.salary = levelInfo.baseSalary;
          
          if (isPromotion) {
            console.log(`   📈 Promoted: ${oldTitle} (Lv.${oldLevel}) → ${levelInfo.title} (Lv.${positionLevel})`);
          } else if (isDemotion) {
            console.log(`   📉 Demoted: ${oldTitle} (Lv.${oldLevel}) → ${levelInfo.title} (Lv.${positionLevel})`);
          }
        }
      } else {
        console.log(`   ➡️  Lateral move (Level ${employee.career.level} stays same)`);
      }
    }
    
    console.log(`\n✅ ASSIGNMENT SUCCESSFUL!`);
    console.log(`╔════════════════════════════════════════╗`);
    console.log(`║  ${employee.name} → ${position.title}`);
    console.log(`╚════════════════════════════════════════╝\n`);
    
    return { 
      success: true, 
      message: currentPosition ? 'Employee relocated successfully!' : 'Employee assigned successfully!',
      cost: cost,
      needsRehire: currentPosition && currentPosition.productId ? true : false, // Flag if old position needs refilling
      vacatedPosition: currentPosition || null
    };
  }
  
  /**
   * Remove employee from their position
   * @param {string} employeeId - Employee ID
   * @returns {boolean} Success
   */
  function removeEmployeeFromPosition(employeeId) {
    const position = getEmployeePosition(employeeId);
    if (!position) return false;
    
    position.employeeId = null;
    position.isVacant = true;
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (employee) {
      employee.productManaged = null;
    }
    
    return true;
  }

  // ========== CORPORATE PYRAMID MODAL ==========
  
  /**
   * Open the Corporate Pyramid Modal
   * @param {string} selectedEmployeeId - Optional employee ID to pre-select for placement
   */
  function openCorporatePyramidModal(selectedEmployeeId = null) {
    try {
      const modal = document.getElementById('pyramidModal');
      if (!modal) {
        console.error('Pyramid modal element not found!');
        return;
      }
      
      // Build pyramid structure
      const pyramidHTML = buildPyramidHTML(selectedEmployeeId);
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:95%; max-width:1400px; height:90vh; border-radius:14px; box-shadow:0 8px 32px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center; background:linear-gradient(135deg, #1a1f35 0%, #0f1419 100%);">
          <div>
            <h2 style="margin:0; color:#fff; font-size:1.8rem; display:flex; align-items:center; gap:12px;">
              <span style="font-size:2rem;">🏢</span>
              Corporate Pyramid
            </h2>
            <p style="margin:4px 0 0 0; color:#888; font-size:0.9rem;">
              ${selectedEmployeeId ? 'Select a position to assign employee' : 'Manage your organizational structure'}
            </p>
          </div>
          <button onclick="closeCorporatePyramidModal()" style="background:transparent; border:none; color:#fff; font-size:2rem; cursor:pointer; padding:8px; line-height:1;">✕</button>
        </div>
        
        <!-- Legend & Controls -->
        <div style="padding:12px 20px; background:#16213e; border-bottom:1px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px;">
          <div style="display:flex; gap:20px; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#4ecca3; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Filled</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#555; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Vacant</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#ffd700; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Selected</span>
            </div>
          </div>
          <div style="display:flex; gap:8px;">
            <button onclick="pyramidZoom('in')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:1.2rem;">🔍+</button>
            <button onclick="pyramidZoom('out')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:1.2rem;">🔍-</button>
            <button onclick="pyramidZoom('reset')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:0.85rem;">Reset</button>
          </div>
        </div>
        
        <!-- Pyramid Container (Scrollable) -->
        <div id="pyramidContainer" style="flex:1; overflow:auto; position:relative; background:#0a0e1a; cursor:grab;">
          <div id="pyramidCanvas" style="transform-origin:top left; transition:transform 0.3s ease; padding:40px; min-width:100%; min-height:100%;">
            ${pyramidHTML}
          </div>
        </div>
        
        <!-- Footer with employee selection info -->
        ${selectedEmployeeId ? buildSelectionFooter(selectedEmployeeId) : ''}
      </div>
    `;
    
    // Show the modal
    modal.style.display = 'flex';
    
    // Setup pan functionality
    setupPyramidPanning();
    
    // Setup event listeners for position clicks
    setupPositionClickHandlers(selectedEmployeeId);
    
    // Setup drag-and-drop functionality
    setupDragAndDrop();
    
    // Setup pinch-to-zoom for mobile
    setupPinchZoom();
    
    } catch (error) {
      console.error('Error opening Corporate Pyramid Modal:', error);
      showNotification('Failed to open pyramid. Check console for details.');
    }
  }

  /**
   * Build the hierarchical pyramid HTML structure
   * @param {string} selectedEmployeeId - Employee to highlight valid positions for
   * @returns {string} HTML string
   */
  function buildPyramidHTML(selectedEmployeeId) {
    let html = '';
    
    const selectedEmployee = selectedEmployeeId ? gameState.employees.find(e => e.id === selectedEmployeeId) : null;
    
    // CEO at top (Level 7) with Secretary
    const secretaryPosition = gameState.corporatePyramid.secretaryPosition || {
      positionId: 'secretary',
      title: 'Executive Secretary',
      level: 6.5,
      employeeId: null,
      reportsTo: 'ceo',
      subordinates: []
    };
    
    html += `
      <div style="text-align:center; margin-bottom:40px;">
        <div style="display:inline-flex; align-items:center; justify-content:center; gap:20px;">
          <!-- CEO Position -->
          <div style="display:inline-block; position:relative;">
            <div class="pyramid-position ceo-position" data-position-id="ceo" style="background:linear-gradient(135deg, #ffd700, #ffed4e); padding:24px 50px; border-radius:12px; box-shadow:0 6px 20px rgba(255,215,0,0.5); border:3px solid #ffd700;">
              <div style="font-size:2.5rem; margin-bottom:8px;">👑</div>
              <div style="font-weight:700; font-size:1.3rem; color:#0f1419;">CEO</div>
              <div style="font-size:0.9rem; color:#333; margin-top:4px;">You</div>
            </div>
          </div>
          
          <!-- Secretary Position -->
          <div style="display:inline-block; position:relative; transform:scale(0.85);">
            ${buildSecretaryTile(secretaryPosition, selectedEmployee)}
          </div>
        </div>
      </div>
    `;
    
    // Level 6: Senior Executive (1 position)
    html += buildLevelSection(6, 'Senior Executive', selectedEmployee);
    
    // Level 5: Officers (CFO, COO - 2 positions)
    html += buildLevelSection(5, 'Officers (CFO, COO)', selectedEmployee);
    
    // Level 4: Branch Managers (4 positions)
    html += buildLevelSection(4, 'Branch Managers', selectedEmployee);
    
    // Level 3: Regional Managers (1 per location)
    html += buildLevelSection(3, 'Regional Managers', selectedEmployee);
    
    // Level 2: Local Managers (2-3 per location)
    html += buildLevelSection(2, 'Local Managers', selectedEmployee);
    
    // Level 1: Staff (1 per product)
    html += buildLevelSection(1, 'Staff', selectedEmployee);
    
    return html;
  }
  
  /**
   * Build HTML for a single hierarchy level
   * @param {number} level - Level number (1-6)
   * @param {string} levelTitle - Display title for this level
   * @param {object} selectedEmployee - Currently selected employee (if any)
   * @returns {string} HTML string
   */
  function buildLevelSection(level, levelTitle, selectedEmployee) {
    const positions = gameState.corporatePyramid.positions[level];
    if (!positions || positions.length === 0) return '';
    
    const levelInfo = gameState.hierarchyLevels[level] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: '👤', baseSalary: 40000 };
    
    let html = `
      <div style="margin-bottom:50px;">
        <h3 style="color:${levelInfo.color}; margin-bottom:20px; text-align:center; font-size:1.2rem; display:flex; align-items:center; justify-content:center; gap:10px;">
          <span style="font-size:1.5rem;">${levelInfo.icon}</span>
          Level ${level}: ${levelTitle}
          <span style="background:rgba(255,255,255,0.1); padding:4px 12px; border-radius:12px; font-size:0.8rem; color:#aaa;">
            ${positions.filter(p => p.employeeId).length} / ${positions.length} filled
          </span>
        </h3>
        <div style="display:flex; flex-wrap:wrap; gap:20px; justify-content:center; max-width:1200px; margin:0 auto;">
    `;
    
    positions.forEach(position => {
      html += buildPositionTile(position, selectedEmployee, levelInfo);
    });
    
    html += `
        </div>
      </div>
    `;
    
    return html;
  }
  
  /**
   * Build HTML for a single position tile
   * @param {object} position - Position object
   * @param {object} selectedEmployee - Selected employee (if any)
   * @param {object} levelInfo - Level configuration
   * @returns {string} HTML string
   */
  function buildPositionTile(position, selectedEmployee, levelInfo) {
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    const isVacant = !employee;
    
    // Check if this position is valid for selected employee
    let isValidForSelection = false;
    let selectionReason = '';
    if (selectedEmployee) {
      const check = canFillPosition(selectedEmployee, position);
      isValidForSelection = check.canFill;
      selectionReason = check.reason;
    }
    
    const bgColor = isValidForSelection ? '#ffd700' : (isVacant ? '#16213e' : '#1a4d2e');
    const borderColor = isValidForSelection ? '#ffd700' : (isVacant ? '#555' : levelInfo.color);
    
    // Get subordinate count
    const subordinates = getSubordinates(position.positionId);
    const subordinateCount = subordinates.length;
    
    return `
      <div class="pyramid-position" 
           data-position-id="${position.positionId}"
           data-can-select="${isValidForSelection}"
           data-cost="${selectedEmployee ? (gameState.corporatePyramid.promotionCosts[position.level] || 0) : 0}"
           style="background:${bgColor}; border:2px solid ${borderColor}; border-radius:10px; padding:16px; width:220px; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 8px rgba(0,0,0,0.3);"
           onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.5)';"
           onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';">
        
        <div style="text-align:center; margin-bottom:12px;">
          <div style="font-size:1.5rem; margin-bottom:4px;">${levelInfo.icon}</div>
          <div style="font-weight:600; font-size:0.85rem; color:#fff;">${position.title}</div>
          ${position.locationId ? `<div style="font-size:0.7rem; color:#888; margin-top:2px;">${gameState.locations.find(l => l.id === position.locationId)?.name || ''}</div>` : ''}
        </div>
        
        ${employee ? `
          <div style="text-align:center; position:relative;">
            ${canPromote(employee) ? `
              <div style="position:absolute; top:-4px; right:calc(50% - 50px); background:linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); color:#000; font-size:0.65rem; font-weight:700; padding:4px 8px; border-radius:12px; box-shadow:0 2px 8px rgba(255,215,0,0.4); z-index:1; animation:pulse 2s infinite;">
                ⬆️ READY
              </div>
            ` : ''}
            <img src="${employee.profileImage || 'https://placehold.co/60x60'}" style="width:60px; height:60px; border-radius:50%; object-fit:cover; border:2px solid ${levelInfo.color}; margin-bottom:8px;">
            <div style="font-size:0.85rem; font-weight:600; color:#fff;">${employee.name}</div>
            <div style="font-size:0.7rem; color:#aaa; margin-top:2px;">${levelInfo.title}</div>
            ${subordinateCount > 0 ? `<div style="font-size:0.65rem; color:#4ecca3; margin-top:4px;">👥 ${subordinateCount} report${subordinateCount !== 1 ? 's' : ''}</div>` : ''}
          </div>
        ` : `
          <div style="text-align:center; padding:20px 0;">
            <div style="font-size:2rem; opacity:0.3;">👤</div>
            <div style="font-size:0.75rem; color:#888; margin-top:8px;">Vacant</div>
            ${position.span ? `<div style="font-size:0.65rem; color:#666; margin-top:4px;">Manages ${position.span}</div>` : ''}
          </div>
        `}
        
        ${isValidForSelection ? `
          <div style="margin-top:12px; padding:8px; background:rgba(255,215,0,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.7rem; color:#ffd700; font-weight:600;">✓ CAN ASSIGN</div>
            <div style="font-size:0.7rem; color:#fff; margin-top:2px;">Cost: $${formatNumber(gameState.corporatePyramid.promotionCosts[position.level] || 0)}</div>
          </div>
        ` : selectedEmployee ? `
          <div style="margin-top:12px; padding:8px; background:rgba(233,69,96,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.65rem; color:#e94560;">${selectionReason}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Build HTML for secretary position tile
   * @param {object} position - Secretary position object
   * @param {object} selectedEmployee - Selected employee (if any)
   * @returns {string} HTML string
   */
  function buildSecretaryTile(position, selectedEmployee) {
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    const isVacant = !employee;
    
    // Check if this position is valid for selected employee (Level 1-3 can fill secretary role)
    let isValidForSelection = false;
    let selectionReason = '';
    if (selectedEmployee) {
      if (selectedEmployee.career.level >= 1 && selectedEmployee.career.level <= 3) {
        isValidForSelection = true;
      } else if (selectedEmployee.career.level > 3) {
        selectionReason = 'Too senior for this role';
      }
    }
    
    const bgColor = isValidForSelection ? '#ffd700' : (isVacant ? '#16213e' : '#d946ef');
    const borderColor = isValidForSelection ? '#ffd700' : (isVacant ? '#555' : '#e879f9');
    const secretaryCost = 1000; // Low cost for early game
    
    return `
      <div class="pyramid-position secretary-position" 
           data-position-id="${position.positionId}"
           data-can-select="${isValidForSelection}"
           data-cost="${selectedEmployee ? secretaryCost : 0}"
           style="background:${bgColor}; border:2px solid ${borderColor}; border-radius:10px; padding:14px; width:180px; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 8px rgba(0,0,0,0.3);"
           onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.5)';"
           onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';">
        
        <div style="text-align:center; margin-bottom:10px;">
          <div style="font-size:1.3rem; margin-bottom:4px;">📋</div>
          <div style="font-weight:600; font-size:0.8rem; color:#fff;">${position.title}</div>
          <div style="font-size:0.65rem; color:#888; margin-top:2px;">Reports to CEO</div>
        </div>
        
        ${employee ? `
          <div style="text-align:center; position:relative;">
            <img src="${employee.profileImage || 'https://placehold.co/50x50'}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #e879f9; margin-bottom:6px;">
            <div style="font-size:0.8rem; font-weight:600; color:#fff;">${employee.name}</div>
            <div style="font-size:0.65rem; color:#aaa; margin-top:2px;">Level ${employee.career?.level || 1}</div>
          </div>
        ` : `
          <div style="text-align:center; padding:15px 0;">
            <div style="font-size:1.5rem; opacity:0.3;">👤</div>
            <div style="font-size:0.7rem; color:#888; margin-top:6px;">Vacant</div>
            <div style="font-size:0.6rem; color:#666; margin-top:2px;">Early-game position</div>
          </div>
        `}
        
        ${isValidForSelection ? `
          <div style="margin-top:10px; padding:6px; background:rgba(255,215,0,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.65rem; color:#ffd700; font-weight:600;">✓ CAN ASSIGN</div>
            <div style="font-size:0.65rem; color:#fff; margin-top:2px;">Cost: $${formatNumber(secretaryCost)}</div>
          </div>
        ` : selectedEmployee ? `
          <div style="margin-top:10px; padding:6px; background:rgba(233,69,96,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.6rem; color:#e94560;">${selectionReason}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Build footer for employee selection mode
   * @param {string} employeeId - Selected employee ID
   * @returns {string} HTML string
   */
  function buildSelectionFooter(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return '';
    
    const levelInfo = gameState.hierarchyLevels[employee.career?.level] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3' };
    
    return `
      <div style="padding:16px 20px; background:#1a1f35; border-top:2px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <img src="${employee.profileImage || 'https://placehold.co/50x50'}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid ${levelInfo.color};">
          <div>
            <div style="font-weight:600; color:#fff; font-size:1rem;">${employee.name}</div>
            <div style="font-size:0.85rem; color:#aaa;">${levelInfo.title} • Level ${employee.career?.level || 1}</div>
          </div>
        </div>
        <button onclick="closeCorporatePyramidModal()" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600;">
          Cancel
        </button>
      </div>
    `;
  }

  /**
   * Setup panning functionality for the pyramid
   */
  function setupPyramidPanning() {
    const container = document.getElementById('pyramidContainer');
    if (!container) return;
    
    let isPanning = false;
    let startX = 0, startY = 0;
    let scrollLeft = 0, scrollTop = 0;
    
    container.addEventListener('mousedown', (e) => {
      // Don't pan if clicking on a position tile or dragging
      if (e.target.closest('.pyramid-position') || e.target.draggable) return;
      
      isPanning = true;
      container.style.cursor = 'grabbing';
      startX = e.pageX - container.offsetLeft;
      startY = e.pageY - container.offsetTop;
      scrollLeft = container.scrollLeft;
      scrollTop = container.scrollTop;
    });
    
    container.addEventListener('mouseleave', () => {
      isPanning = false;
      container.style.cursor = 'grab';
    });
    
    container.addEventListener('mouseup', () => {
      isPanning = false;
      container.style.cursor = 'grab';
    });
    
    container.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      e.preventDefault();
      const x = e.pageX - container.offsetLeft;
      const y = e.pageY - container.offsetTop;
      const walkX = (x - startX) * 1.5;
      const walkY = (y - startY) * 1.5;
      container.scrollLeft = scrollLeft - walkX;
      container.scrollTop = scrollTop - walkY;
    });
    
    // Add touch support for mobile panning
    let touchStartX = 0, touchStartY = 0;
    let touchScrollLeft = 0, touchScrollTop = 0;
    
    container.addEventListener('touchstart', (e) => {
      if (e.target.closest('.pyramid-position')) return;
      
      touchStartX = e.touches[0].pageX;
      touchStartY = e.touches[0].pageY;
      touchScrollLeft = container.scrollLeft;
      touchScrollTop = container.scrollTop;
    }, { passive: true });
    
    container.addEventListener('touchmove', (e) => {
      if (e.target.closest('.pyramid-position')) return;
      
      const touchX = e.touches[0].pageX;
      const touchY = e.touches[0].pageY;
      const walkX = (touchStartX - touchX) * 1.5;
      const walkY = (touchStartY - touchY) * 1.5;
      container.scrollLeft = touchScrollLeft + walkX;
      container.scrollTop = touchScrollTop + walkY;
    }, { passive: true });
  }

  /**
   * Setup drag-and-drop for employee assignment
   */
  function setupDragAndDrop() {
    // Make employee tiles in filled positions draggable
    document.querySelectorAll('.pyramid-position[data-position-id]').forEach(tile => {
      const positionId = tile.dataset.positionId;
      if (positionId === 'ceo') return; // Can't drag CEO
      
      const position = getPosition(positionId);
      if (position && position.employeeId) {
        tile.draggable = true;
        // Keep pointer cursor for clicking, show move on hover
        tile.style.cursor = 'pointer';
        
        tile.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('employeeId', position.employeeId);
          e.dataTransfer.setData('sourcePositionId', positionId);
          tile.style.opacity = '0.5';
        });
        
        tile.addEventListener('dragend', (e) => {
          tile.style.opacity = '1';
        });
      }
      
      // Make all position tiles drop targets
      tile.addEventListener('dragover', (e) => {
        if (positionId === 'ceo') return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        tile.style.transform = 'scale(1.05)';
        tile.style.boxShadow = '0 6px 20px rgba(255,215,0,0.5)';
      });
      
      tile.addEventListener('dragleave', (e) => {
        tile.style.transform = '';
        tile.style.boxShadow = '';
      });
      
      tile.addEventListener('drop', (e) => {
        e.preventDefault();
        tile.style.transform = '';
        tile.style.boxShadow = '';
        
        if (positionId === 'ceo') return;
        
        const employeeId = e.dataTransfer.getData('employeeId');
        const sourcePositionId = e.dataTransfer.getData('sourcePositionId');
        
        if (employeeId && positionId !== sourcePositionId) {
          handleEmployeeDrop(employeeId, positionId);
        }
      });
    });
  }

  /**
   * Handle employee drop onto position
   * @param {string} employeeId - Employee being dragged
   * @param {string} targetPositionId - Target position
   */
  function handleEmployeeDrop(employeeId, targetPositionId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    const targetPosition = getPosition(targetPositionId);
    
    if (!employee || !targetPosition) return;
    
    // Check if employee can fill this position
    const check = canFillPosition(employee, targetPosition);
    
    if (!check.canFill) {
      showNotification(check.reason, 'error');
      return;
    }
    
    const cost = calculateRelocationCost(employee, targetPosition);
    
    const message = `Move ${employee.name} to ${targetPosition.title}?\n\nCost: $${formatNumber(cost)}`;
    
    if (confirm(message)) {
      const result = assignEmployeeToPosition(employeeId, targetPositionId, true);
      
      if (result.success) {
        showNotification(result.message, 'success');
        // Refresh modal to show updated positions
        closeCorporatePyramidModal();
        setTimeout(() => openCorporatePyramidModal(), 100);
      } else {
        showNotification(result.message, 'error');
      }
    }
  }

  /**
   * Setup click handlers for position tiles
   * @param {string} selectedEmployeeId - Employee being placed
   */
  function setupPositionClickHandlers(selectedEmployeeId) {
    const pyramidCanvas = document.getElementById('pyramidCanvas');
    if (!pyramidCanvas) {
      console.error('[Pyramid] pyramidCanvas container not found');
      return;
    }
    
    // Remove any existing delegated click handler to prevent duplicates
    const existingHandler = pyramidCanvas._positionClickHandler;
    if (existingHandler) {
      pyramidCanvas.removeEventListener('click', existingHandler);
    }
    
    // Use event delegation - single handler on parent element
    const clickHandler = (e) => {
      // Find the closest .pyramid-position ancestor
      const tile = e.target.closest('.pyramid-position');
      if (!tile) return; // Click wasn't on a position tile
      
      const positionId = tile.dataset.positionId;
      console.log(`[Pyramid] Clicked position: ${positionId}`);
      
      if (positionId === 'ceo') {
        console.log('[Pyramid] CEO position clicked - ignoring');
        return; // Can't click CEO
      }
      
      if (selectedEmployeeId) {
        // Assignment mode
        console.log(`[Pyramid] Assignment mode - selectedEmployee: ${selectedEmployeeId}`);
        const canSelect = tile.dataset.canSelect === 'true';
        if (canSelect) {
          const cost = parseInt(tile.dataset.cost);
          confirmPositionAssignment(selectedEmployeeId, positionId, cost);
        } else {
          showNotification('Employee does not meet position requirements', 'error');
        }
      } else {
        // View/manage mode
        console.log(`[Pyramid] Opening details modal for: ${positionId}`);
        showPositionDetailsModal(positionId);
      }
    };
    
    // Store reference for cleanup
    pyramidCanvas._positionClickHandler = clickHandler;
    pyramidCanvas.addEventListener('click', clickHandler);
    
    console.log(`[Pyramid] Click handler setup complete (event delegation mode)`);
  }

  /**
   * Confirm assignment of employee to position
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - Position ID
   * @param {number} cost - Relocation cost
   */
  function confirmPositionAssignment(employeeId, positionId, cost) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    const newPosition = getPosition(positionId);
    
    if (!employee || !newPosition) return;
    
    // Get current position
    const oldPosition = getEmployeePosition(employee.id);
    const oldLevelInfo = oldPosition ? gameState.hierarchyLevels[Math.floor(oldPosition.level)] : null;
    
    // Get level info with fallback for special positions like secretary
    let newLevelInfo = gameState.hierarchyLevels[Math.floor(newPosition.level)];
    if (!newLevelInfo) {
      // Fallback for positions without standard level info
      newLevelInfo = {
        icon: '📋',
        color: '#00d4ff',
        title: 'Position'
      };
    }
    
    // Special handling for secretary position
    if (newPosition.positionId === 'secretary') {
      newLevelInfo = {
        icon: '📋',
        color: '#e879f9',
        title: 'Executive Secretary'
      };
    }
    
    // Check if player can afford it
    if (gameState.cash < cost) {
      showNotification(`Not enough cash! Need $${formatNumber(cost)}`, 'error');
      return;
    }
    
    // Create visual confirmation modal
    const confirmModal = document.createElement('div');
    confirmModal.id = 'promotionConfirmModal';
    confirmModal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.9) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important; animation:fadeIn 0.2s ease;';
    
    const isPromotion = oldPosition && newPosition.level > oldPosition.level;
    const actionWord = isPromotion ? 'Promote' : oldPosition ? 'Transfer' : 'Assign';
    const actionColor = isPromotion ? '#4ecca3' : '#00d4ff';
    
    confirmModal.innerHTML = `
      <style>
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateY(30px); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }
      </style>
      <div style="background:#0f1419; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,0.8); max-width:700px; width:90%; overflow:hidden; animation:slideUp 0.3s ease;">
        <!-- Header -->
        <div style="padding:24px; background:linear-gradient(135deg, ${actionColor}, ${actionColor}22); border-bottom:2px solid ${actionColor};">
          <h2 style="margin:0; color:#fff; font-size:1.8rem; text-align:center; display:flex; align-items:center; justify-content:center; gap:12px;">
            ${isPromotion ? '⬆️' : '↔️'}
            <span>Confirm ${actionWord}</span>
          </h2>
        </div>
        
        <!-- Content -->
        <div style="padding:32px 24px;">
          <!-- Employee Card -->
          <div style="text-align:center; margin-bottom:24px;">
            <img src="${employee.profileImage || 'https://placehold.co/80x80'}" style="width:80px; height:80px; border-radius:50%; border:3px solid ${actionColor}; object-fit:cover; box-shadow:0 4px 12px rgba(0,0,0,0.3);">
            <h3 style="color:#fff; margin:12px 0 4px 0; font-size:1.3rem;">${employee.name}</h3>
            ${employee.career ? `<div style="color:#888; font-size:0.9rem;">Currently: ${employee.career.title || 'Employee'} (Level ${employee.career.level || 1})</div>` : ''}
          </div>
          
          <!-- Position Cards with Arrow -->
          <div style="display:flex; align-items:center; justify-content:center; gap:16px; margin:24px 0;">
            <!-- Old Position (if exists) -->
            ${oldPosition ? `
              <div style="flex:1; background:#16213e; border:2px solid ${oldLevelInfo?.color || '#555'}; border-radius:12px; padding:16px; text-align:center;">
                <div style="font-size:1.5rem; margin-bottom:8px;">${oldLevelInfo?.icon || '📋'}</div>
                <div style="color:#fff; font-weight:600; font-size:0.9rem; margin-bottom:4px;">${oldPosition.title}</div>
                <div style="color:#888; font-size:0.75rem;">Level ${Math.floor(oldPosition.level)}</div>
              </div>
            ` : `
              <div style="flex:1; background:#16213e; border:2px dashed #555; border-radius:12px; padding:16px; text-align:center; opacity:0.5;">
                <div style="font-size:1.5rem; margin-bottom:8px;">❌</div>
                <div style="color:#888; font-weight:600; font-size:0.9rem;">Unassigned</div>
              </div>
            `}
            
            <!-- Arrow -->
            <div style="font-size:2rem; color:${actionColor}; animation:pulse 2s infinite;">
              ${isPromotion ? '⬆️' : '➡️'}
            </div>
            
            <!-- New Position -->
            <div style="flex:1; background:linear-gradient(135deg, ${newLevelInfo.color}22, ${newLevelInfo.color}11); border:2px solid ${newLevelInfo.color}; border-radius:12px; padding:16px; text-align:center; box-shadow:0 0 20px ${newLevelInfo.color}44;">
              <div style="font-size:1.5rem; margin-bottom:8px;">${newLevelInfo.icon}</div>
              <div style="color:#fff; font-weight:600; font-size:0.9rem; margin-bottom:4px;">${newPosition.title}</div>
              <div style="color:${newLevelInfo.color}; font-size:0.75rem; font-weight:600;">Level ${Math.floor(newPosition.level)}</div>
            </div>
          </div>
          
          <!-- Cost Info -->
          <div style="background:#1a1a2e; border:2px solid ${gameState.cash >= cost ? actionColor : '#e94560'}; border-radius:10px; padding:16px; margin:24px 0;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <span style="color:#888; font-size:0.9rem;">Cost:</span>
              <span style="color:${gameState.cash >= cost ? '#4ecca3' : '#e94560'}; font-weight:700; font-size:1.2rem;">$${formatNumber(cost)}</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#888; font-size:0.9rem;">Your Cash:</span>
              <span style="color:#fff; font-weight:600; font-size:1rem;">$${formatNumber(gameState.cash)}</span>
            </div>
            ${gameState.cash >= cost ? `
              <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px; padding-top:8px; border-top:1px solid #333;">
                <span style="color:#888; font-size:0.9rem;">After ${actionWord}:</span>
                <span style="color:#4ecca3; font-weight:600; font-size:1rem;">$${formatNumber(gameState.cash - cost)}</span>
              </div>
            ` : ''}
          </div>
          
          ${gameState.cash < cost ? `
            <div style="background:rgba(233,69,96,0.1); border:1px solid #e94560; border-radius:8px; padding:12px; margin-bottom:16px; text-align:center;">
              <span style="color:#e94560; font-size:0.9rem; font-weight:600;">⚠️ Insufficient funds!</span>
            </div>
          ` : ''}
          
          <!-- Action Buttons -->
          <div style="display:flex; gap:12px; margin-top:24px;">
            <button onclick="document.getElementById('promotionConfirmModal').remove()" style="flex:1; padding:14px; background:#16213e; border:2px solid #555; border-radius:10px; color:#fff; font-weight:600; font-size:1rem; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#1a2640'; this.style.borderColor='#777'" onmouseleave="this.style.background='#16213e'; this.style.borderColor='#555'">
              ✕ Cancel
            </button>
            <button 
              onclick="executePromotion('${employeeId}', '${positionId}')" 
              style="flex:1; padding:14px; background:${gameState.cash >= cost ? `linear-gradient(135deg, ${actionColor}, ${actionColor}dd)` : '#555'}; border:none; border-radius:10px; color:${gameState.cash >= cost ? '#000' : '#999'}; font-weight:700; font-size:1rem; cursor:${gameState.cash >= cost ? 'pointer' : 'not-allowed'}; transition:all 0.2s; box-shadow:${gameState.cash >= cost ? `0 4px 12px ${actionColor}44` : 'none'};"
              ${gameState.cash >= cost ? `onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px ${actionColor}66'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px ${actionColor}44'"` : 'disabled'}
            >
              ✓ Confirm ${actionWord}
            </button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(confirmModal);
    
    // Close on background click
    confirmModal.addEventListener('click', (e) => {
      if (e.target === confirmModal) {
        confirmModal.remove();
      }
    });
  }
  
  /**
   * Execute the promotion after confirmation
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - New position ID
   */
  function executePromotion(employeeId, positionId) {
    // Remove confirmation modal
    const modal = document.getElementById('promotionConfirmModal');
    if (modal) modal.remove();
    
    // Execute the assignment
    const result = assignEmployeeToPosition(employeeId, positionId, true);
    
    if (result.success) {
      showNotification(result.message, 'success');
      
      // If they vacated a staff position, show additional notification
      if (result.needsRehire && result.vacatedPosition) {
        const product = gameState.products.find(p => p.id === result.vacatedPosition.productId);
        if (product) {
          setTimeout(() => {
            showNotification(
              `⚠️ ${result.vacatedPosition.title} is now vacant! Hire a new staff member to restore automation for ${product.name}`,
              'warning',
              5000
            );
          }, 1500);
        }
      }
      
      closeCorporatePyramidModal();
      updatePeopleTab();
      updateProductsList();
      updateBusinessTab();
    } else {
      showNotification(result.message, 'error');
    }
  }
  
  // Make executePromotion available globally
  window.executePromotion = executePromotion;

  /**
   * Show details modal for a position
   * @param {string} positionId - Position ID
   */
  function showPositionDetailsModal(positionId) {
    const position = getPosition(positionId);
    if (!position) return;
    
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    
    // Handle decimal levels (like secretary at 6.5) by flooring to get levelInfo
    const positionLevel = Math.floor(position.level);
    const levelInfo = gameState.hierarchyLevels[positionLevel] || {
      icon: '📋',
      color: '#00d4ff',
      title: 'Position'
    };
    
    // Special styling for secretary position
    const isSecretary = position.positionId === 'secretary';
    const displayIcon = isSecretary ? '📋' : levelInfo.icon;
    const displayColor = isSecretary ? '#e879f9' : levelInfo.color;
    
    // Create a custom modal for position details
    const detailsModal = document.createElement('div');
    detailsModal.id = `positionDetailsModal_${positionId}`;
    detailsModal.className = 'position-details-modal';
    detailsModal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.8) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important;';
    
    detailsModal.innerHTML = `
      <div style="background:#0f1419; width:90%; max-width:500px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.5); overflow:hidden;">
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); background:linear-gradient(135deg, #1a1f35 0%, #0f1419 100%);">
          <h3 style="margin:0; color:#fff; font-size:1.5rem; display:flex; align-items:center; gap:10px;">
            <span>${displayIcon}</span>
            ${position.title}
          </h3>
          <p style="margin:4px 0 0 0; color:#888; font-size:0.9rem;">Level ${position.level} Position${isSecretary ? ' • Reports to CEO' : ''}</p>
        </div>
        
        <div style="padding:20px;">
          ${employee ? `
            <div style="text-align:center; margin-bottom:20px;">
              <img src="${employee.profileImage || 'https://placehold.co/100x100'}" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:3px solid ${displayColor}; margin-bottom:12px;">
              <div style="font-size:1.2rem; font-weight:600; color:#fff; margin-bottom:4px;">${employee.name}</div>
              <div style="font-size:0.9rem; color:#aaa;">Current Level: ${employee.career?.level || 1}</div>
              <div style="font-size:0.9rem; color:#4ecca3; margin-top:8px;">Salary: $${formatNumber(employee.career?.salary || employee.salary || 0)}/month</div>
            </div>
            
            <div style="margin-bottom:20px;">
              <div style="font-size:0.9rem; color:#888; margin-bottom:8px;">Skills:</div>
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                ${employee.skills && typeof employee.skills === 'object' ? 
                  Object.entries(employee.skills)
                    .filter(([name, skill]) => skill && skill.level > 0)
                    .map(([name, skill]) => `
                      <span style="padding:4px 10px; background:#16213e; border-radius:6px; font-size:0.8rem; color:#00d4ff;">
                        ${name.charAt(0).toUpperCase() + name.slice(1)} Lv${skill.level}
                      </span>
                    `).join('') 
                  : '<span style="color:#666; font-size:0.8rem;">No skills yet</span>'
                }
              </div>
            </div>
            
            ${(() => {
              const currentLevel = employee.career?.level || 1;
              const nextLevel = currentLevel + 1;
              const isMaxLevel = nextLevel > 7;
              const isEligible = canPromote(employee);
              const requirements = !isMaxLevel ? getPromotionRequirements(nextLevel, employee) : null;
              
              if (isMaxLevel) {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border-radius:8px; border:2px solid #ffa500;">
                    <div style="font-size:0.9rem; font-weight:600; color:#000; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">👑</span>
                      Maximum Level Reached
                    </div>
                    <div style="font-size:0.75rem; color:#333;">This employee has reached the highest career level!</div>
                  </div>
                `;
              }
              
              const nextLevelInfo = gameState.hierarchyLevels[nextLevel] || gameState.hierarchyLevels[nextLevel - 1] || { title: 'Next Level', color: '#00d4ff', icon: '⬆️', baseSalary: 60000 };
              const productivity = employee.stats?.productivity || 0;
              const managementLevel = employee.skills?.management?.level || 0;
              
              const productivityMet = productivity >= (requirements?.minProductivity || 0);
              const managementMet = !requirements?.minManagement || managementLevel >= requirements.minManagement;
              
              if (isEligible) {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:linear-gradient(135deg, #4ecca3 0%, #3ba882 100%); border-radius:8px; border:2px solid #4ecca3;">
                    <div style="font-size:0.9rem; font-weight:600; color:#000; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">⬆️</span>
                      Ready for Promotion!
                    </div>
                    <div style="font-size:0.75rem; color:#000; margin-bottom:8px;">
                      ${employee.name} can be promoted to <strong>${nextLevelInfo.title}</strong> (Level ${nextLevel})
                    </div>
                    <div style="font-size:0.7rem; color:#000;">
                      ✓ Productivity: ${productivity}% (needs ${requirements.minProductivity}%)<br>
                      ${requirements.minManagement ? `✓ Management: Level ${managementLevel} (needs ${requirements.minManagement})` : ''}
                    </div>
                  </div>
                `;
              } else {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:rgba(233,69,96,0.2); border-radius:8px; border:2px solid #e94560;">
                    <div style="font-size:0.9rem; font-weight:600; color:#e94560; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">📋</span>
                      Promotion Requirements
                    </div>
                    <div style="font-size:0.75rem; color:#fff; margin-bottom:8px;">
                      For promotion to <strong>${nextLevelInfo.title}</strong> (Level ${nextLevel}):
                    </div>
                    <div style="font-size:0.7rem; color:#fff;">
                      ${productivityMet ? '✓' : '✗'} Productivity: ${productivity}% ${!productivityMet ? `<span style="color:#e94560;">(needs ${requirements.minProductivity}%)</span>` : `<span style="color:#4ecca3;">(met!)</span>`}<br>
                      ${requirements.minManagement ? `
                        ${managementMet ? '✓' : '✗'} Management: Level ${managementLevel} ${!managementMet ? `<span style="color:#e94560;">(needs ${requirements.minManagement})</span>` : `<span style="color:#4ecca3;">(met!)</span>`}
                      ` : ''}
                    </div>
                  </div>
                `;
              }
            })()}
            
            <!-- Action Buttons -->
            <div style="display:flex; gap:10px; margin-bottom:10px;">
              <button id="transferEmployeeBtn" style="flex:1; padding:12px; background:#00d4ff; border:none; border-radius:8px; color:#0f1419; cursor:pointer; font-weight:600; display:flex; align-items:center; justify-content:center; gap:6px;" title="Transfer to another position at the same level">
                <span>🔄</span> Transfer
              </button>
              <button id="promoteEmployeeBtn" ${!canPromote(employee) ? 'disabled' : ''} style="flex:1; padding:12px; background:${canPromote(employee) ? '#4ecca3' : '#333'}; border:none; border-radius:8px; color:${canPromote(employee) ? '#0f1419' : '#666'}; cursor:${canPromote(employee) ? 'pointer' : 'not-allowed'}; font-weight:600; display:flex; align-items:center; justify-content:center; gap:6px; opacity:${canPromote(employee) ? '1' : '0.5'};" title="${canPromote(employee) ? 'Promote to next level' : 'Not eligible for promotion yet'}">
                <span>⬆️</span> Promote
              </button>
            </div>
            
            <button id="terminateEmployeeBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600; margin-bottom:10px; display:flex; align-items:center; justify-content:center; gap:6px;">
              <span>🚫</span> Terminate Employment
            </button>
          ` : `
            <div style="text-align:center; padding:40px 20px;">
              <div style="font-size:3rem; opacity:0.3; margin-bottom:12px;">👤</div>
              <div style="font-size:1.1rem; color:#aaa; margin-bottom:8px;">Position Vacant</div>
              <div style="font-size:0.85rem; color:#666;">Go to People tab and click "Promote" on an employee to assign them here.</div>
            </div>
          `}
          
          <button id="closeDetailsBtn" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600;">
            Close
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(detailsModal);
    
    // Close modal when clicking on background overlay (not the content box)
    detailsModal.addEventListener('click', (e) => {
      if (e.target === detailsModal) {
        detailsModal.remove();
      }
    });
    
    // Add event listeners after appending to DOM
    const closeBtn = detailsModal.querySelector('#closeDetailsBtn');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        detailsModal.remove();
      });
    }
    
    if (employee) {
      // Transfer button - show transfer options modal
      const transferBtn = detailsModal.querySelector('#transferEmployeeBtn');
      if (transferBtn) {
        transferBtn.addEventListener('click', () => {
          showTransferModal(employee, position);
          detailsModal.remove();
        });
      }
      
      // Promote button - open pyramid with eligible higher positions
      const promoteBtn = detailsModal.querySelector('#promoteEmployeeBtn');
      if (promoteBtn && !promoteBtn.disabled) {
        promoteBtn.addEventListener('click', () => {
          detailsModal.remove();
          openCorporatePyramidModal(employee.id); // Reopen pyramid in promotion mode
        });
      }
      
      // Terminate button - fire the employee
      const terminateBtn = detailsModal.querySelector('#terminateEmployeeBtn');
      if (terminateBtn) {
        terminateBtn.addEventListener('click', () => {
          if (confirm(`Are you sure you want to terminate ${employee.name}?\n\nThis will:\n• Remove them from this position\n• Set their status to "alumni"\n• Disable automation if they manage a product`)) {
            handleEmployeeAction(employee.id, 'fire');
            detailsModal.remove();
            // Refresh pyramid
            if (document.getElementById('pyramidModal').style.display === 'flex') {
              openCorporatePyramidModal();
            }
          }
        });
      }
    }
  }

  /**
   * Show transfer modal for moving employee to same-level position
   * @param {object} employee - Employee to transfer
   * @param {object} currentPosition - Current position
   */
  function showTransferModal(employee, currentPosition) {
    console.log(`\n[TRANSFER] Opening transfer modal for ${employee.name} from ${currentPosition.title}`);
    
    const modal = document.createElement('div');
    modal.id = 'transferModal';
    modal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.8) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important;';
    
    // Check if this is Executive Secretary (special case)
    const isExecutiveSecretary = currentPosition.positionId === 'secretary' || currentPosition.title === 'Executive Secretary';
    
    // Get positions at the same level AND lower levels (for demotion)
    const currentLevel = Math.floor(currentPosition.level);
    
    // Collect transfer options: same level + all lower levels
    const transferOptions = [];
    
    // Executive Secretary can only transfer laterally (to other secretary) - NO lateral transfers at level 6
    if (!isExecutiveSecretary) {
      // Same level positions (lateral transfers) - only for non-secretary roles
      const sameLevelPositions = gameState.corporatePyramid.positions[currentLevel] || [];
      sameLevelPositions
        .filter(pos => pos.positionId !== currentPosition.positionId && !pos.employeeId)
        .forEach(pos => {
          transferOptions.push({ ...pos, transferType: 'lateral' });
        });
    }
    
    // Lower level positions (demotions) - only if not already at level 1
    if (currentLevel > 1) {
      // For Executive Secretary, only allow demotion to Level 3 or below
      const minDemotionLevel = isExecutiveSecretary ? 3 : currentLevel - 1;
      const maxDemotionLevel = isExecutiveSecretary ? 1 : 1;
      
      for (let level = minDemotionLevel; level >= maxDemotionLevel; level--) {
        const lowerLevelPositions = gameState.corporatePyramid.positions[level] || [];
        lowerLevelPositions
          .filter(pos => !pos.employeeId)
          .forEach(pos => {
            transferOptions.push({ ...pos, transferType: 'demotion', levelDifference: currentLevel - level });
          });
      }
    }
    
    console.log(`[TRANSFER] Found ${transferOptions.length} total options (lateral + demotion)${isExecutiveSecretary ? ' [Executive Secretary: max demotion to Level 3]' : ''}`);
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:90%; max-width:700px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.5); overflow:hidden; max-height:85vh; display:flex; flex-direction:column;">
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); background:linear-gradient(135deg, ${isExecutiveSecretary ? '#9b59b6 0%, #8e44ad 100%' : '#00d4ff 0%, #0088cc 100%'});">
          <h3 style="margin:0; color:#${isExecutiveSecretary ? 'fff' : '0f1419'}; font-size:1.5rem; display:flex; align-items:center; gap:10px;">
            <span>🔄</span>
            ${isExecutiveSecretary ? 'Demote' : 'Transfer or Demote'} ${employee.name}
          </h3>
          <p style="margin:4px 0 0 0; color:#${isExecutiveSecretary ? 'ddd' : '000'}; font-size:0.9rem;">
            Current: ${currentPosition.title} (Level ${currentLevel})${isExecutiveSecretary ? ' • Special Role' : ''}
          </p>
        </div>
        
        <div style="flex:1; overflow-y:auto; padding:20px;">
          ${transferOptions.length > 0 ? `
            ${isExecutiveSecretary ? `
              <div style="margin-bottom:16px; padding:12px; background:rgba(155,89,182,0.2); border-left:4px solid #9b59b6; border-radius:6px;">
                <div style="font-size:0.85rem; color:#9b59b6; font-weight:600; margin-bottom:4px;">👔 Executive Secretary Special Rules</div>
                <div style="font-size:0.75rem; color:#fff;">
                  • Executive Secretary is a <strong>special high-level role</strong> that can be filled early<br/>
                  • Not equivalent to other Level 6, 5, or 4 management positions<br/>
                  • Can only be demoted to <strong>Level 3 (Regional Manager) or below</strong><br/>
                  • Demotion cost: <strong>50%</strong> of destination hiring cost
                </div>
              </div>
            ` : `
              <div style="margin-bottom:16px; padding:12px; background:rgba(255,193,7,0.2); border-left:4px solid #ffc107; border-radius:6px;">
                <div style="font-size:0.85rem; color:#ffc107; font-weight:600; margin-bottom:4px;">⚠️ Transfer Cost Policy</div>
                <div style="font-size:0.75rem; color:#fff;">
                  • <strong>Lateral transfers</strong> (same level): 75% of destination hiring cost<br/>
                  • <strong>Demotions</strong> (lower level): 50% of destination hiring cost
                </div>
              </div>
            `}
            
            <div style="display:flex; flex-direction:column; gap:12px;">
              ${transferOptions.map(option => {
                // Calculate transfer cost based on destination location's hiring cost
                const location = gameState.locations.find(l => l.id === option.locationId);
                const product = option.productId ? gameState.products.find(p => p.id === option.productId) : null;
                
                // Base hiring cost for that location/product
                const baseHiringCost = product ? (product.managerHireCost || 500) : (location ? 500 * (gameState.locations.indexOf(location) + 1) : 500);
                
                // Transfer cost depends on type
                const costMultiplier = option.transferType === 'demotion' ? 0.50 : 0.75;
                const transferCost = Math.floor(baseHiringCost * costMultiplier);
                
                const canAfford = gameState.cash >= transferCost;
                const levelInfo = gameState.hierarchyLevels[option.level];
                
                // Color coding
                const borderColor = option.transferType === 'demotion' ? '#ff9800' : '#00d4ff';
                const accentColor = option.transferType === 'demotion' ? '#ff9800' : '#4ecca3';
                
                return `
                  <div class="transfer-option" data-position-id="${option.positionId}" data-cost="${transferCost}" data-type="${option.transferType}" style="padding:16px; background:#16213e; border-radius:8px; border:2px solid ${canAfford ? borderColor : '#555'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; transition:all 0.3s ease; opacity:${canAfford ? '1' : '0.5'};" onmouseenter="if(${canAfford}) this.style.borderColor='${accentColor}'; this.style.transform='translateX(4px)';" onmouseleave="this.style.borderColor='${canAfford ? borderColor : '#555'}'; this.style.transform='translateX(0)';">
                    <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
                      <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                          ${option.transferType === 'demotion' ? `<span style="background:#ff9800; color:#000; padding:2px 6px; border-radius:4px; font-size:0.65rem; font-weight:700;">⬇ DEMOTION</span>` : `<span style="background:#00d4ff; color:#000; padding:2px 6px; border-radius:4px; font-size:0.65rem; font-weight:700;">↔ LATERAL</span>`}
                          <span style="font-weight:600; color:#fff; font-size:0.95rem;">${option.title}</span>
                        </div>
                        <div style="font-size:0.75rem; color:#888; margin-left:0px;">
                          Level ${option.level}: ${levelInfo ? levelInfo.title : 'Unknown'}
                        </div>
                        ${location ? `<div style="font-size:0.75rem; color:#888; margin-top:2px;">📍 ${location.name}</div>` : ''}
                        ${product ? `<div style="font-size:0.75rem; color:#4ecca3; margin-top:2px;">📦 ${product.name}</div>` : ''}
                        ${option.transferType === 'demotion' ? `<div style="font-size:0.7rem; color:#ff9800; margin-top:4px;">⚠️ Salary will decrease to $${formatNumber(levelInfo.baseSalary)}</div>` : ''}
                      </div>
                      <div style="text-align:right;">
                        <div style="font-size:0.9rem; font-weight:600; color:${canAfford ? accentColor : '#e94560'};">
                          $${formatNumber(transferCost)}
                        </div>
                        <div style="font-size:0.65rem; color:#666; margin-top:2px;">
                          (${Math.round(costMultiplier * 100)}% of hire cost)
                        </div>
                      </div>
                    </div>
                    
                    ${!canAfford ? `
                      <div style="margin-top:8px; padding:6px; background:rgba(233,69,96,0.2); border-radius:4px; text-align:center;">
                        <div style="font-size:0.7rem; color:#e94560;">Need $${formatNumber(transferCost - gameState.cash)} more</div>
                      </div>
                    ` : `
                      <div style="margin-top:8px; padding:6px; background:rgba(78,204,163,0.2); border-radius:4px; text-align:center;">
                        <div style="font-size:0.7rem; color:${accentColor};">✓ Click to ${option.transferType === 'demotion' ? 'demote' : 'transfer'}</div>
                      </div>
                    `}
                  </div>
                `;
              }).join('')}
            </div>
          ` : `
            <div style="text-align:center; padding:40px 20px;">
              <div style="font-size:3rem; opacity:0.3; margin-bottom:12px;">🔄</div>
              <div style="font-size:1.1rem; color:#aaa; margin-bottom:8px;">No ${isExecutiveSecretary ? 'Demotion' : 'Transfer'} Options Available</div>
              <div style="font-size:0.85rem; color:#666;">
                ${isExecutiveSecretary 
                  ? 'All positions at Level 3 (Regional Manager) and below are currently filled.'
                  : 'All positions at this level and below are currently filled.'
                }
              </div>
            </div>
          `}
        </div>
        
        <div style="padding:16px; border-top:2px solid rgba(255,255,255,0.1); background:#0a0e1a;">
          <button id="closeTransferModal" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600;">
            Cancel
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close button
    modal.querySelector('#closeTransferModal').addEventListener('click', () => {
      modal.remove();
    });
    
    // Transfer option clicks
    modal.querySelectorAll('.transfer-option').forEach(option => {
      const positionId = option.dataset.positionId;
      const cost = parseInt(option.dataset.cost);
      const transferType = option.dataset.type;
      
      if (gameState.cash >= cost) {
        option.addEventListener('click', () => {
          const targetPosition = getPosition(positionId);
          if (!targetPosition) return;
          
          const isDemotion = transferType === 'demotion';
          const actionWord = isDemotion ? 'Demote' : 'Transfer';
          const targetLevelInfo = gameState.hierarchyLevels[targetPosition.level];
          
          let confirmMessage = `${actionWord} ${employee.name} to ${targetPosition.title}?\n\nCost: $${formatNumber(cost)}\nRemaining cash: $${formatNumber(gameState.cash - cost)}`;
          
          if (isDemotion && targetLevelInfo) {
            confirmMessage += `\n\n⚠️ This is a demotion!\nNew salary: $${formatNumber(targetLevelInfo.baseSalary)}`;
          }
          
          if (confirm(confirmMessage)) {
            console.log(`[TRANSFER] Executing ${isDemotion ? 'demotion' : 'transfer'} to ${targetPosition.title} for $${formatNumber(cost)}`);
            
            // CRITICAL: Double-check that target position is still vacant
            if (targetPosition.employeeId) {
              showNotification(`Cannot ${isDemotion ? 'demote' : 'transfer'}: ${targetPosition.title} is now occupied by someone else!`, 'error');
              return;
            }
            
            // Remove from current position
            currentPosition.employeeId = null;
            currentPosition.isVacant = true;
            
            // Clear product if they were managing one
            if (currentPosition.productId) {
              const oldProduct = gameState.products.find(p => p.id === currentPosition.productId);
              if (oldProduct && oldProduct.managerId === employee.id) {
                oldProduct.managerHired = false;
                oldProduct.managerId = null;
              }
            }
            
            // Assign to new position (this will update career level/title/salary)
            const result = assignEmployeeToPosition(employee.id, positionId, false); // Don't pay twice
            
            if (result.success) {
              // Deduct transfer cost
              gameState.cash -= cost;
              
              const actionPastTense = isDemotion ? 'demoted' : 'transferred';
              showNotification(`${employee.name} ${actionPastTense} to ${targetPosition.title}! Cost: $${formatNumber(cost)}`, 'success');
              modal.remove();
              
              // Refresh pyramid if open
              if (document.getElementById('pyramidModal').style.display === 'flex') {
                openCorporatePyramidModal();
              }
              
              // CRITICAL: Force refresh People tab to show updated career info
              updatePeopleTab();
              
              // Also update UI if on People tab
              if (gameState.activeTab === 'people') {
                switchTab('people'); // Force full re-render
              }
              
              // Save game to persist changes
              saveGame();
            } else {
              showNotification(`${actionWord} failed: ${result.message}`, 'error');
            }
          }
        });
      }
    });
  }

  /**
   * Remove employee from their position
   * @param {string} positionId - Position ID
   * @param {string} employeeId - Employee ID
   */
  function removeEmployeeFromPosition(positionId, employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    if (confirm(`Remove ${employee.name} from this position?`)) {
      const result = removeEmployeeFromPyramid(employeeId);
      
      if (result) {
        showNotification(`${employee.name} removed from position`, 'success');
        // Close pyramid modal and reopen to refresh
        closeCorporatePyramidModal();
        setTimeout(() => openCorporatePyramidModal(), 100);
      } else {
        showNotification('Failed to remove employee', 'error');
      }
    }
  }

  /**
   * Zoom pyramid view
   * @param {string} direction - 'in', 'out', or 'reset'
   */
  let pyramidZoomLevel = 1;
  function pyramidZoom(direction) {
    const canvas = document.getElementById('pyramidCanvas');
    if (!canvas) return;
    
    if (direction === 'in') {
      pyramidZoomLevel = Math.min(pyramidZoomLevel + 0.2, 2);
    } else if (direction === 'out') {
      pyramidZoomLevel = Math.max(pyramidZoomLevel - 0.2, 0.5);
    } else if (direction === 'reset') {
      pyramidZoomLevel = 1;
    }
    
    canvas.style.transform = `scale(${pyramidZoomLevel})`;
  }

  /**
   * Setup pinch-to-zoom for mobile
   */
  function setupPinchZoom() {
    const container = document.getElementById('pyramidContainer');
    const canvas = document.getElementById('pyramidCanvas');
    if (!container || !canvas) return;
    
    let initialDistance = 0;
    let initialZoom = pyramidZoomLevel;
    
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(
          touch2.pageX - touch1.pageX,
          touch2.pageY - touch1.pageY
        );
        initialZoom = pyramidZoomLevel;
      }
    }, { passive: false });
    
    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
          touch2.pageX - touch1.pageX,
          touch2.pageY - touch1.pageY
        );
        
        const scale = currentDistance / initialDistance;
        pyramidZoomLevel = Math.max(0.5, Math.min(2, initialZoom * scale));
        canvas.style.transform = `scale(${pyramidZoomLevel})`;
      }
    }, { passive: false });
  }

  /**
   * Close the pyramid modal
   */
  function closeCorporatePyramidModal() {
    const modal = document.getElementById('pyramidModal');
    if (modal) {
      modal.style.display = 'none';
      modal.innerHTML = ''; // Clear content
    }
    pyramidZoomLevel = 1; // Reset zoom
  }

  /**
   * Calculate relationship strength for prestige/rehire system
   * @param {object} employee - Employee object
   * @returns {string} Relationship strength: 'very close', 'close', 'friendly', 'professional', 'distant'
   */
  function calculateRelationshipStrength(employee) {
    if (!employee || !employee.stats) return 'distant';
    
    // Average of affection, trust, and comfort
    const avgStat = (
      (employee.stats.affection || 0) +
      (employee.stats.trust || 0) +
      (employee.stats.comfort || 0)
    ) / 3;
    
    if (avgStat >= 80) return 'very close';
    if (avgStat >= 60) return 'close';
    if (avgStat >= 40) return 'friendly';
    if (avgStat >= 20) return 'professional';
    return 'distant';
  }

  /**
   * Calculate productivity bonus for rehired employees
   * @param {object} employee - Employee object
   * @returns {number} Bonus multiplier (0.30 to 0.50)
   */
  function calculateRehireBonus(employee) {
    if (!employee || !employee.career) return 0.30;
    
    // Base bonus: everyone gets 30%
    let bonus = 0.30;
    
    // Previous level bonus: +5% per level above Staff (Level 2)
    const levelBonus = Math.max(0, (employee.career.level - 2) * 0.05);
    bonus += Math.min(0.25, levelBonus);  // Cap at +25%
    
    // Relationship bonus: 0-20% based on closeness
    const relationshipStrength = calculateRelationshipStrength(employee);
    const relationshipBonuses = {
      'very close': 0.20,
      'close': 0.15,
      'friendly': 0.10,
      'professional': 0.05,
      'distant': 0.00
    };
    bonus += (relationshipBonuses[relationshipStrength] || 0);
    
    // Total cap: 50%
    return Math.min(0.50, bonus);
  }

  /**
   * Generate social feed post about promotion
   * @param {object} employee - Employee object
   * @param {number} newLevel - New level achieved
   */
  async function generatePromotionPost(employee, newLevel) {
    if (!employee || !gameState.socialNetwork) return;
    
    const levelData = gameState.hierarchyLevels[newLevel];
    if (!levelData) return;
    
    // 🚀 NUCLEAR CONTEXT: Get intelligent context for promotion post
    const intelligentContext = getIntelligentContext(employee, 'social.post', {
      message: `Posting about being promoted to ${levelData.title}`,
      involves: ['player', 'work', 'promotion'],
      keywords: ['promotion', 'career', levelData.title, employee.fastTrack ? 'fast-track' : 'achievement']
    });
    
    // Generate AI post content
    const postPrompt = `${intelligentContext}

SITUATION: You just got promoted to ${levelData.title}!
${employee.fastTrack ? 'You were FAST-TRACKED - this is a rapid promotion!' : ''}

Write a social media post announcing your promotion.

INSTRUCTIONS:
1. Keep it 1-2 sentences
2. Be excited but professional
3. Use 1-2 emojis naturally
4. Thank @TheBoss
5. ${employee.fastTrack ? 'Mention the fast-track momentum!' : 'Show you\'re proud of the achievement'}

EXAMPLES:
- "🎉 Thrilled to announce my promotion to ${levelData.title}! Thank you @TheBoss for believing in me! 💼"
- "${employee.fastTrack ? '🚀 Fast-tracked to ' : ''}Officially a ${levelData.title} now! Grateful for this opportunity @TheBoss ✨"

Write the post:`;

    let caption = `🎉 Excited to announce that I've been promoted to ${levelData.title}! ${employee.fastTrack ? '🚀 Fast-tracked and loving the momentum! ' : ''}Thank you @TheBoss for this opportunity! 💼✨`;
    
    try {
      const generatedCaption = await generateText(postPrompt, {
        temperature: 0.8,
        max_tokens: 60
      });
      if (generatedCaption && generatedCaption.trim()) {
        caption = generatedCaption.trim();
      }
    } catch (err) {
      console.warn('[Promotion Post] AI generation failed, using default caption:', err);
    }
    
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      author: employee.name,
      authorId: employee.id,
      type: 'work',
      category: 'work',
      timestamp: Date.now(),
      contentType: 'text',
      caption: caption,
      likes: Math.floor(Math.random() * 20) + 10,
      comments: [],
      imageUrl: null,
      altText: null,
      hasImage: false,
      explicit: false
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    // Trim posts if too many
    if (gameState.socialNetwork.posts.length > 100) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 100);
    }
    
    console.log(`[Promotion Post] Generated post for ${employee.name}'s promotion to Level ${newLevel}`);
  }

  // Update People Tab with sorting and filtering
  function updatePeopleTab() {
    if (!employeesList) return;
    employeesList.innerHTML = '';
    
    // Initialize sorting settings if not exists
    if (!gameState.peopleSorting) {
      gameState.peopleSorting = {
        sortBy: 'newest',
        showFavoritesOnly: false
      };
    }

    // Update employee count
    const employeeCountEl = $('employeeCount');
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (employeeCountEl) {
      employeeCountEl.textContent = `${activeEmployees.length} employee${activeEmployees.length !== 1 ? 's' : ''}`;
    }

    // Onboarding badges (always show at top)
    for (const e of gameState.onboarding) {
        const card = document.createElement('div');
        card.className = 'employee-card';
        card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); position:relative;';
        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
            <div style="width:44px; height:44px; border-radius:50%; background:#0f3460; display:flex; align-items:center; justify-content:center;">⏳</div>
            <div style="flex:1;">
            <h3 style="margin:0 0 2px 0;">${getColoredName(e)}</h3>
            <p style="margin:0; color:#aaa; font-size:.9rem;">${e.position}</p>
            <span style="display:inline-block; margin-top:6px; padding:3px 8px; font-size:.75rem; border-radius:999px; background:#0f3460; color:#fff;">Onboarding…</span>
            </div>
        </div>
        <button onclick="resetOnboarding('${e.id}')" style="width:100%; padding:8px; background:#ff6b00; border:none; border-radius:6px; color:white; cursor:pointer; font-size:.85rem; font-weight:600; margin-top:8px;">
            🔄 Reset Onboarding (Emergency)
        </button>
        `;
        employeesList.appendChild(card);
    }

    // Get active employees and filter by favorites if needed
    let employees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (gameState.peopleSorting.showFavoritesOnly) {
      employees = employees.filter(e => e.isFavorite);
    }
    
    // Sort employees based on selected option
    const sortBy = gameState.peopleSorting.sortBy;
    
    // Separate favorites from non-favorites for proper ordering
    const favoriteEmployees = employees.filter(e => e.isFavorite);
    const regularEmployees = employees.filter(e => !e.isFavorite);
    
    // Sort function
    const sortEmployees = (empList) => {
      switch(sortBy) {
        case 'oldest':
          return empList.sort((a, b) => (a.hireDate || 0) - (b.hireDate || 0));
        case 'newest':
          return empList.sort((a, b) => (b.hireDate || 0) - (a.hireDate || 0));
        case 'relationshipHigh':
          return empList.sort((a, b) => {
            const avgA = calculateAverageRelationship(a);
            const avgB = calculateAverageRelationship(b);
            return avgB - avgA;
          });
        case 'relationshipLow':
          return empList.sort((a, b) => {
            const avgA = calculateAverageRelationship(a);
            const avgB = calculateAverageRelationship(b);
            return avgA - avgB;
          });
        case 'location':
          return empList.sort((a, b) => {
            const locA = a.locationId || '';
            const locB = b.locationId || '';
            return locA.localeCompare(locB);
          });
        case 'name':
          return empList.sort((a, b) => a.name.localeCompare(b.name));
        default:
          return empList;
      }
    };
    
    // Sort both lists
    sortEmployees(favoriteEmployees);
    sortEmployees(regularEmployees);
    
    // Favorites always come first, then regular employees
    const sortedEmployees = [...favoriteEmployees, ...regularEmployees];

    // Render employee cards
    for (const e of sortedEmployees) {
        
        // DEBUG: Log employee career info to help diagnose crashes
        if (!e.career || typeof e.career.level !== 'number') {
          console.warn('[updatePeopleTab] Employee missing valid career:', e.name, 'Career:', e.career);
        }
        
        const card = document.createElement('div');
        card.className = 'employee-card';
        const cardBorder = e.isFavorite ? 'border: 2px solid #ffd700;' : '';
        card.style.cssText = `background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); ${cardBorder}`;

        const img = e.profileImage || 'https://placehold.co/80x80';
        const starColor = e.isFavorite ? '#ffd700' : '#555';
        const starText = e.isFavorite ? '⭐' : '☆';

        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
            <img src="${img}" style="width:60px; height:60px; border-radius:50%; object-fit:cover; cursor:pointer;" onclick="openUnifiedProfile('${e.id}', 'overview')">
            <div style="flex:1;">
            <h3 style="margin:0; cursor:pointer; transition:opacity 0.2s;" onclick="openUnifiedProfile('${e.id}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'">${getColoredName(e)}${e.age ? `, ${e.age}` : ''}</h3>
            </div>
            <button onclick="toggleEmployeeFavorite('${e.id}')" style="background:none; border:none; cursor:pointer; font-size:1.5rem; padding:5px; line-height:1; color:${starColor}; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="${e.isFavorite ? 'Remove from favorites' : 'Add to favorites'}">${starText}</button>
        </div>

        ${e.bio ? `<p style="margin:8px 0 12px 0; color:#ddd; font-size:.95rem;">${e.bio}</p>` : ''}

        <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:12px;">
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Affection</div>
            <div style="color:#e94560; font-weight:600;">${Math.round(e.stats.affection ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Comfort</div>
            <div style="color:#4ecca3; font-weight:600;">${Math.round(e.stats.comfort ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Trust</div>
            <div style="color:#00d4ff; font-weight:600;">${Math.round(e.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Desire</div>
            <div style="color:#ff6b9d; font-weight:600;">${Math.round(e.stats.desire ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Obedience</div>
            <div style="color:#c77dff; font-weight:600;">${Math.round(e.stats.obedience ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Productivity</div>
            <div style="color:#ffd700; font-weight:600;">${Math.round(e.stats.productivity ?? 0)}%</div>
            </div>
        </div>

        ${(() => {
          // Show Corporate Hierarchy Level
          if (!e.career || typeof e.career.level !== 'number') return '';
          
          // Floor the level to ensure it's a valid index (handles decimal levels like 6.5)
          const levelIndex = Math.floor(e.career.level);
          
          // Clamp level to valid range (1-7)
          const clampedLevel = Math.max(1, Math.min(7, levelIndex));
          
          // Get level info with fallback chain
          let levelInfo = null;
          if (gameState.hierarchyLevels && gameState.hierarchyLevels[clampedLevel]) {
            levelInfo = gameState.hierarchyLevels[clampedLevel];
          } else if (gameState.hierarchyLevels && gameState.hierarchyLevels[1]) {
            levelInfo = gameState.hierarchyLevels[1];
          } else {
            // Ultimate fallback
            levelInfo = { title: 'Staff', color: '#4ecca3', icon: '👤', baseSalary: 40000 };
          }
          
          // Safety check: if levelInfo is still null/undefined, skip this employee
          if (!levelInfo || !levelInfo.color) {
            console.error(`[updatePeopleTab] CRITICAL: Invalid levelInfo for ${e.name}, level: ${e.career.level}, clampedLevel: ${clampedLevel}`);
            return '';
          }
          
          // Calculate time in role
          const timeInRole = gameState.date - e.career.startDate;
          
          // Check if max level (7 is the highest)
          const isMaxLevel = e.career.level >= 7;
          
          // Get promotion requirements (only if not max level)
          const nextLevel = e.career.level + 1;
          const requirements = !isMaxLevel ? getPromotionRequirements(nextLevel, e) : null;
          
          // Calculate promotion progress
          let progressPercent = 0;
          let nextLevelInfo = null;
          let progressText = '';
          
          if (!isMaxLevel && requirements) {
            const nextLevelIndex = Math.ceil(nextLevel); // Use ceil for next level to round up decimals
            nextLevelInfo = gameState.hierarchyLevels[nextLevelIndex] || gameState.hierarchyLevels[Math.floor(e.career.level) + 1] || { title: 'Next Level', color: '#00d4ff', icon: '⬆️', baseSalary: levelInfo.baseSalary * 1.5 };
            
            // Safety check for nextLevelInfo
            if (!nextLevelInfo || !nextLevelInfo.color) {
              nextLevelInfo = { title: 'Next Level', color: '#00d4ff', icon: '⬆️', baseSalary: levelInfo.baseSalary * 1.5 };
            }
            
            const minManagementLevel = requirements.minManagement || 0;
            
            // Calculate progress based on requirements
            const productivityProgress = Math.min((e.stats.productivity / requirements.minProductivity) * 100, 100);
            const managementProgress = minManagementLevel > 0 
              ? Math.min(((e.skills?.management?.level || 0) / minManagementLevel) * 100, 100)
              : 100;
            
            // Overall progress is the minimum of all requirements
            progressPercent = Math.min(productivityProgress, managementProgress);
            
            // Generate progress text
            const reqParts = [];
            if (productivityProgress < 100) {
              reqParts.push(`${requirements.minProductivity}% productivity`);
            }
            if (managementProgress < 100) {
              reqParts.push(`Lv${minManagementLevel} management`);
            }
            
            if (reqParts.length > 0) {
              progressText = `Needs: ${reqParts.join(', ')}`;
            } else {
              progressText = 'Ready for promotion!';
            }
          }
          
          // Get position/product info
          const positionInfo = e.position ? `${e.position}${e.productManaged ? ` • ${e.productManaged}` : ''}` : (e.productManaged ? e.productManaged : '');
          
          return `<div style="background:#0f1419; padding:12px; border-radius:6px; margin-bottom:12px; border-left:4px solid ${levelInfo.color};">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-size:1.3rem;">${levelInfo.icon}</span>
                <div>
                  <div style="font-size:.9rem; font-weight:600; color:${levelInfo.color};">${levelInfo.title}</div>
                  <div style="font-size:.75rem; color:#888;">Level ${e.career.level} • $${(levelInfo.baseSalary / 1000).toFixed(0)}K/year</div>
                  ${positionInfo ? `<div style="font-size:.7rem; color:#999; margin-top:2px;">${positionInfo}</div>` : ''}
                </div>
              </div>
              ${e.fastTrack ? `<div style="background:#ffd700; color:#0f1419; padding:4px 8px; border-radius:12px; font-size:.7rem; font-weight:700;">⚡ FAST-TRACK</div>` : ''}
            </div>
            
            ${!isMaxLevel ? `
              <div style="margin-top:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
                  <span style="font-size:.75rem; color:#aaa;">Promotion Progress</span>
                  <span style="font-size:.75rem; color:#00d4ff; font-weight:600;">${Math.round(progressPercent)}%</span>
                </div>
                <div style="background:#0f3460; border-radius:6px; height:8px; overflow:hidden; margin-bottom:4px;">
                  <div style="background:linear-gradient(90deg, ${levelInfo.color}, ${nextLevelInfo ? nextLevelInfo.color : '#00d4ff'}); height:100%; width:${progressPercent}%; transition:width 0.5s;"></div>
                </div>
                <div style="font-size:.7rem; color:#aaa;">${progressText}</div>
                ${nextLevelInfo ? `<div style="font-size:.7rem; color:#888; margin-top:4px;">Next: ${nextLevelInfo.icon} ${nextLevelInfo.title}</div>` : ''}
              </div>
            ` : `
              <div style="margin-top:8px; padding:8px; background:rgba(255,215,0,0.1); border-radius:4px; border:1px solid rgba(255,215,0,0.3);">
                <div style="font-size:.75rem; color:#ffd700; font-weight:600; text-align:center;">👑 Maximum Level Achieved</div>
              </div>
            `}
            
            ${e.career.directReports && e.career.directReports.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.75rem; color:#aaa;">
                  <span style="font-size:.9rem; margin-right:4px;">👥</span>
                  Manages ${e.career.directReports.length} employee${e.career.directReports.length !== 1 ? 's' : ''}
                </div>
              </div>
            ` : ''}
            
            ${e.career.promotionHistory && e.career.promotionHistory.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.7rem; color:#888;">
                  📈 ${e.career.promotionHistory.length} promotion${e.career.promotionHistory.length !== 1 ? 's' : ''} earned
                </div>
              </div>
            ` : ''}
          </div>`;
        })()}

        ${(() => {
          // Show active flags
          const activeFlags = getActiveFlags(e);
          if (activeFlags.length === 0) return '';
          
          const flagEmojis = {
            'condition': '🤰',
            'agreement': '💋',
            'personality': '🎭',
            'relationship': '💕',
            'preference': '❤️',
            'event': '📅',
            'state': '⭐',
            'custom': '🏷️'
          };
          
          const priorityColors = {
            'high': '#ff3366',
            'medium': '#ffa500',
            'low': '#4ecca3'
          };
          
          // Show up to 3 flags (high priority first)
          const flagsToShow = activeFlags.slice(0, 3);
          const hasMore = activeFlags.length > 3;
          
          const flagHTML = flagsToShow.map(flag => {
            const emoji = flag.emoji || flagEmojis[flag.category] || '🏷️';
            const color = priorityColors[flag.priority] || '#888';
            const description = flag.playerDescription || flag.description || flag.key || 'Unknown';
            return `<div style="display:inline-flex; align-items:center; gap:4px; background:#0f1419; padding:4px 8px; border-radius:12px; margin-right:6px; margin-bottom:6px; border-left:3px solid ${color};">
              <span style="font-size:.9rem;">${emoji}</span>
              <span style="font-size:.75rem; color:#ddd; font-weight:500;">${description}</span>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">🏷️ Active Flags${hasMore ? ` (${activeFlags.length})` : ''}</div>
            <div style="display:flex; flex-wrap:wrap;">
              ${flagHTML}
              ${hasMore ? `<button onclick="showAllFlags('${e.id}')" style="background:#533483; border:none; padding:4px 8px; border-radius:12px; color:#ddd; font-size:.75rem; cursor:pointer; font-weight:500;">+${activeFlags.length - 3} more...</button>` : ''}
            </div>
          </div>`;
        })()}

        ${(() => {
          // Show top skills (Phase 3)
          if (!e.skills) return '';
          
          // Get top 3 skills by level
          const topSkills = Object.entries(e.skills)
            .map(([name, skill]) => ({ name, ...skill }))
            .sort((a, b) => b.level - a.level)
            .slice(0, 3);
          
          if (topSkills.length === 0 || topSkills[0].level === 0) return '';
          
          const skillEmojis = {
            'technical': '💻',
            'creative': '🎨',
            'social': '💬',
            'management': '📊',
            'intimate': '💕',
            'cooking': '🍳',
            'fitness': '💪'
          };
          
          const skillHTML = topSkills.map(skill => {
            const emoji = skillEmojis[skill.name] || '⭐';
            const progress = Math.round((skill.xp / skill.maxXp) * 100);
            const skillNameDisplay = skill.name.charAt(0).toUpperCase() + skill.name.slice(1);
            
            return `<div style="margin-bottom:6px;">
              <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:2px;">
                <span style="font-size:.85rem; color:#ddd;">
                  ${emoji} ${skillNameDisplay}
                </span>
                <span style="font-size:.75rem; color:#00d4ff; font-weight:600;">Lv ${skill.level}</span>
              </div>
              <div style="background:#0f3460; border-radius:3px; height:4px; overflow:hidden;">
                <div style="background:#00d4ff; height:100%; width:${progress}%; transition:width 0.3s;"></div>
              </div>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">⭐ Top Skills</div>
            ${skillHTML}
            ${e.specializations && e.specializations.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.7rem; color:#999; margin-bottom:4px;">Specializations:</div>
                ${e.specializations.map(spec => 
                  `<span style="display:inline-block; background:#533483; color:#fff; padding:2px 8px; border-radius:12px; font-size:.7rem; margin-right:4px; margin-bottom:4px;">🌟 ${spec}</span>`
                ).join('')}
              </div>
            ` : ''}
          </div>`;
        })()}

        ${(() => {
          // Show relationships with other employees
          if (!e.relationships || Object.keys(e.relationships).length === 0) return '';
          
          const relationshipTypes = {
            'friend': { emoji: '👥', color: '#4ecca3', label: 'Friend' },
            'best_friend': { emoji: '💚', color: '#00ff88', label: 'Best Friend' },
            'crush': { emoji: '💖', color: '#ff69b4', label: 'Crush' },
            'rival': { emoji: '⚔️', color: '#ff9500', label: 'Rival' },
            'enemy': { emoji: '💢', color: '#e94560', label: 'Dislikes' },
            'romantic': { emoji: '💕', color: '#ff1493', label: 'Romantic' },
            'neutral': { emoji: '➖', color: '#888', label: 'Coworker' }
          };
          
          // Get top 3 strongest relationships
          const topRelationships = Object.entries(e.relationships)
            .map(([targetId, rel]) => {
              const target = gameState.employees.find(emp => emp.id === targetId);
              if (!target || target.employmentStatus !== 'active') return null;
              return { targetId, rel, target };
            })
            .filter(Boolean)
            .sort((a, b) => b.rel.strength - a.rel.strength)
            .slice(0, 3);
          
          if (topRelationships.length === 0) return '';
          
          const relHTML = topRelationships.map(({rel, target}) => {
            const typeInfo = relationshipTypes[rel.type] || relationshipTypes.neutral;
            return `<div style="display:flex; align-items:center; gap:6px; font-size:.85rem;">
              <span style="font-size:1.1rem;">${typeInfo.emoji}</span>
              <span style="color:${typeInfo.color}; font-weight:600;">${target.name}</span>
              <span style="color:#888; font-size:.75rem;">(${Math.round(rel.strength)}%)</span>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">🤝 Relationships</div>
            ${relHTML}
          </div>`;
        })()}

        <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button class="employee-action-btn" data-employee="${e.id}" data-action="bio" style="padding:6px 10px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-size:.85rem; font-weight:600;">Bio</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="chat" style="padding:6px 10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem; position:relative; display:flex; align-items:center; gap:6px;">
              Chat
              ${e.unreadMessages > 0 ? `<span style="position:absolute; top:-6px; right:-6px; background:#ff3366; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-size:.7rem; font-weight:700; box-shadow:0 2px 6px rgba(255,51,102,0.5);">${e.unreadMessages > 9 ? '9+' : e.unreadMessages}</span>` : ''}
            </button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="review" style="padding:6px 10px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-size:.85rem; font-weight:600;" title="Conduct Performance Review ($200)">📊 Review</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="promote" style="padding:6px 10px; background:#533483; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Promote</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="fire" style="padding:6px 10px; background:#9e2a2b; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Fire</button>
        </div>
        `;

        employeesList.appendChild(card);
    }

    // action handlers
    document.querySelectorAll('.employee-action-btn').forEach(btn => {
        btn.onclick = () => handleEmployeeAction(btn.dataset.employee, btn.dataset.action);
    });

    // Add event listeners for sorting controls
    const sortSelect = document.getElementById('peopleSortSelect');
    if (sortSelect) {
      sortSelect.value = gameState.peopleSorting.sortBy;
      sortSelect.onchange = (e) => {
        gameState.peopleSorting.sortBy = e.target.value;
        updatePeopleTab();
        saveGame();
      };
    }

    const toggleFavBtn = document.getElementById('toggleFavoritesOnly');
    if (toggleFavBtn) {
      toggleFavBtn.textContent = gameState.peopleSorting.showFavoritesOnly ? '⭐ Show All' : '⭐ Show Favorites Only';
      toggleFavBtn.style.background = gameState.peopleSorting.showFavoritesOnly ? '#ffd700' : '#533483';
      toggleFavBtn.style.color = gameState.peopleSorting.showFavoritesOnly ? '#0f1419' : '#fff';
      toggleFavBtn.onclick = () => {
        gameState.peopleSorting.showFavoritesOnly = !gameState.peopleSorting.showFavoritesOnly;
        updatePeopleTab();
        saveGame();
      };
    }
    }

  
  function unlockProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    if (p.unlocked) return showNotification('Product already unlocked!');
    
    // Apply product discount from influence upgrades
    const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
    const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
    const finalCost = Math.floor(p.unlockCost * discountMultiplier);
    
    if (gameState.cash < finalCost) return showNotification('Not enough cash to unlock this product!');
    
    gameState.cash -= finalCost;
    p.unlocked = true;
    
    showNotification(`${p.name} unlocked! You can now start selling.`);
    
    // Check if this was the last product in the location - preload boss if so
    checkAndPreloadBossImage(p.locationId);
    
    updateProductsList();
    updateBusinessTab(); // Update location cards to reflect unlock progress
    updateUI();
  }

  function startOrClickProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.running) {
      p.running = true;
      p.timeRemainingMs = currentCycleTimeMs(p);
    } else {
      p.timeRemainingMs = Math.max(0, p.timeRemainingMs - clickReductionMs(p));
    }

    // instant feedback without a full re-render
    const sellTxt = $(`selltxt-${p.id}`);
    if (sellTxt) sellTxt.textContent = p.running ? 'Click: -1s' : 'Sell';
  }

  // Helper function to format numbers
  // ========== IMAGE GENERATION HELPER ==========
  /**
   * Applies the global image style setting to a prompt
   * @param {string|object} promptInput - Either a string prompt or an object with a prompt property
   * @returns {object} - Object with prompt property, ready for generateImage()
   */
  function applyImageStyle(promptInput) {
    // Extract the base prompt using helper function
    let basePrompt = extractText(promptInput);
    
    // Also check for .prompt property specifically (for objects with explicit prompt field)
    if (typeof promptInput === 'object' && promptInput && promptInput.prompt) {
      basePrompt = extractText(promptInput.prompt);
    }
    
    // Get the style setting
    const style = gameState.settings?.imageStyle || 'photorealistic';
    
    // Debug logging
    console.log('[Image Style] Base prompt length:', basePrompt.length, 'chars');
    console.log('[Image Style] Selected style:', style);
    
    // Define style directives
    const styleDirectives = {
      'photorealistic': 'photorealistic, high detail, professional photography, realistic lighting',
      'anime': 'anime style, manga art, cel-shaded, vibrant colors, Japanese animation style',
      'artistic': 'artistic painting, painterly style, fine art, expressive brushstrokes',
      'cartoon': 'cartoon style, comic book art, bold lines, stylized illustration',
      'cinematic': 'cinematic lighting, movie scene, dramatic composition, film quality',
      'professional': 'professional studio photography, clean lighting, corporate setting, polished',
      'custom': gameState.settings?.customStylePrompt || 'high quality, detailed'
    };
    
    // Get the directive for this style
    const directive = styleDirectives[style] || styleDirectives['photorealistic'];
    
    // Append the style directive to the prompt (avoid duplicates)
    const styledPrompt = basePrompt.toLowerCase().includes(directive.split(',')[0].toLowerCase())
      ? basePrompt
      : `${basePrompt}, ${directive}`;
    
    // Show the ENDING of the prompt to confirm style was added
    console.log('[Image Style] Final prompt ending:', '...' + styledPrompt.slice(-120));
    console.log('[Image Style] ✅ Style directive applied successfully');
    
    // Return as object (generateImage expects { prompt: '...' })
    return { prompt: styledPrompt };
  }
  
  function formatNumber(num) {
    // Abbreviated notation for all numbers >= 1000
    if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillions
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Q';  // Quadrillions
    if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillions
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';    // Billions
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';    // Millions
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';    // Thousands
    // For numbers under 1000, show up to 2 decimal places (no trailing zeros)
    if (num >= 100) return num.toFixed(0);
    if (num >= 10) return num.toFixed(1);
    return num.toFixed(2).replace(/\.?0+$/, ''); // Remove trailing zeros
  }

  // Format and style cash for top bar display with progressive enhancement
  function formatCashDisplay(cash) {
    let displayText, fontSize, color, textShadow, animation;
    
    if (cash >= 1e18) { // Quintillions (Qi)
      displayText = (cash / 1e18).toFixed(2) + 'Qi';
      fontSize = '2.2rem';
      color = '#FFD700'; // Bright gold
      textShadow = '0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5)';
      animation = 'cash-glow-intense 2s ease-in-out infinite';
    } else if (cash >= 1e15) { // Quadrillions (Q)
      displayText = (cash / 1e15).toFixed(2) + 'Q';
      fontSize = '2rem';
      color = '#FFA500'; // Orange-gold
      textShadow = '0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4)';
      animation = 'cash-glow 2.5s ease-in-out infinite';
    } else if (cash >= 1e12) { // Trillions (T)
      displayText = (cash / 1e12).toFixed(2) + 'T';
      fontSize = '1.8rem';
      color = '#FF6347'; // Tomato red
      textShadow = '0 0 10px rgba(255, 99, 71, 0.6)';
      animation = 'none';
    } else if (cash >= 1e9) { // Billions (B)
      displayText = (cash / 1e9).toFixed(2) + 'B';
      fontSize = '1.6rem';
      color = '#FF69B4'; // Hot pink
      textShadow = '0 0 8px rgba(255, 105, 180, 0.5)';
      animation = 'none';
    } else if (cash >= 1e6) { // Millions (M)
      displayText = (cash / 1e6).toFixed(2) + 'M';
      fontSize = '1.4rem';
      color = '#00D4FF'; // Cyan
      textShadow = '0 0 6px rgba(0, 212, 255, 0.4)';
      animation = 'none';
    } else if (cash >= 1e3) { // Thousands (K)
      displayText = (cash / 1e3).toFixed(2) + 'K';
      fontSize = '1.2rem';
      color = '#4ECCA3'; // Green
      textShadow = 'none';
      animation = 'none';
    } else {
      // For numbers under 1000, show clean format
      if (cash >= 100) displayText = cash.toFixed(0);
      else if (cash >= 10) displayText = cash.toFixed(1);
      else displayText = cash.toFixed(2).replace(/\.?0+$/, '');
      fontSize = '1rem';
      color = 'white';
      textShadow = 'none';
      animation = 'none';
    }
    
    return { displayText, fontSize, color, textShadow, animation };
  }
  
  // Helper to get just the display text from formatCashDisplay
  function formatCash(amount) {
    return formatCashDisplay(amount).displayText;
  }

  // Update Upgrades Tab
  function updateUpgradesTab() {
    // Update Click Power section
    const clickPowerLevel = gameState.globalUpgrades.clickPower;
    const currentEffect = 1.0 + (clickPowerLevel * 0.1); // Current effect
    const clickPowerBaseCost = gameBalance.upgradeBaseCosts.clickPower;
    const clickPowerCost = Math.floor(clickPowerBaseCost * Math.pow(2.0, clickPowerLevel));
    
    const clickPowerLevelEl = document.getElementById('clickPowerLevel');
    const clickPowerEffectEl = document.getElementById('clickPowerEffect');
    const clickPowerCostEl = document.getElementById('clickPowerCost');
    
    if (clickPowerLevelEl) clickPowerLevelEl.textContent = `Level ${clickPowerLevel}`;
    if (clickPowerEffectEl) clickPowerEffectEl.textContent = `-${currentEffect.toFixed(1)}s per click`;
    if (clickPowerCostEl) clickPowerCostEl.textContent = `$${formatNumber(clickPowerCost)}`;
    
    // Helper: Calculate income boost percentage with diminishing returns
    function calculateIncomeBoost(level) {
      // Asymptotic formula: approaches but never reaches 100%
      // At level 1: ~9%, level 5: ~38%, level 10: ~58%, level 20: ~74%
      return (1 - Math.pow(0.9, level)) * 100;
    }
    
    // Helper: Calculate cost reduction percentage with diminishing returns (max 90%)
    function calculateCostReduction(level) {
      // Asymptotic formula: approaches 90% max
      // At level 1: ~8.5%, level 5: ~35%, level 10: ~56%, level 20: ~78%, approaches 90%
      return (1 - Math.pow(0.9, level)) * 90;
    }
    
    // Update Income Boost section
    const incomeBoostList = document.getElementById('incomeBoostList');
    if (incomeBoostList) {
      incomeBoostList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades.incomeBoost[location.id] || 0;
        const currentBonus = calculateIncomeBoost(level);
        const nextBonus = calculateIncomeBoost(level + 1);
        const bonusDiff = nextBonus - currentBonus;
        const baseCost = gameBalance.upgradeBaseCosts.incomeBoost;
        const cost = Math.floor(baseCost * Math.pow(2.5, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#4caf50; font-size:1.1rem; margin-bottom:4px;">+${currentBonus.toFixed(1)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyIncomeBoost('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            +${bonusDiff.toFixed(1)}% for $${formatNumber(cost)}
          </button>
        `;
        incomeBoostList.appendChild(card);
      });
    }
    
    // Update Cost Reduction section
    const costReductionList = document.getElementById('costReductionList');
    if (costReductionList) {
      costReductionList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades.costReduction[location.id] || 0;
        const currentReduction = calculateCostReduction(level);
        const nextReduction = calculateCostReduction(level + 1);
        const reductionDiff = nextReduction - currentReduction;
        const baseCost = gameBalance.upgradeBaseCosts.costReduction;
        const cost = Math.floor(baseCost * Math.pow(3.0, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#ff6b6b; font-size:1.1rem; margin-bottom:4px;">-${currentReduction.toFixed(1)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyCostReduction('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            -${reductionDiff.toFixed(1)}% for $${formatNumber(cost)}
          </button>
        `;
        costReductionList.appendChild(card);
      });
    }
  }

  // Calculate the total cost of buying N upgrades
  // Uses geometric series: sum = a * (r^n - 1) / (r - 1)
  // where a = current cost, r = growth rate, n = number of upgrades
  function calculateBulkUpgradeCost(product, count) {
    if (count <= 0) return 0;
    if (count === 1) return product.upgradeCost;
    
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Asymptotic formula: (1 - 0.9^level) * 90% max
      const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    // Calculate sum of costs for levels: current+1, current+2, ..., current+count
    let totalCost = 0;
    for (let i = 0; i < count; i++) {
      totalCost += baseCost * Math.pow(growth, currentLevel + i) * reductionMultiplier;
    }
    
    return Math.floor(totalCost);
  }

  // Calculate maximum affordable upgrades with current cash
  function calculateMaxAffordableUpgrades(product, cash) {
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Asymptotic formula: (1 - 0.9^level) * 90% max
      const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    let count = 0;
    let totalCost = 0;
    
    // Keep adding upgrades until we can't afford the next one
    while (true) {
      const nextCost = baseCost * Math.pow(growth, currentLevel + count) * reductionMultiplier;
      if (totalCost + nextCost > cash) break;
      totalCost += nextCost;
      count++;
      
      // Safety cap at 1000 upgrades
      if (count >= 1000) break;
    }
    
    return { count, totalCost: Math.floor(totalCost) };
  }

  function upgradeProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    
    // Check level cap
    const MAX_LEVEL = 999;
    if (p.level >= MAX_LEVEL) {
      return showNotification(`${p.name} is at max level (${MAX_LEVEL})!`);
    }
    
    // Get upgrade count from button data attribute (set in updateProductsList)
    const btn = document.querySelector(`.upgrade-product-btn[data-id="${id}"]`);
    const upgradeCount = btn ? parseInt(btn.dataset.count) || 1 : 1;
    let totalCost = btn ? parseInt(btn.dataset.cost) || p.upgradeCost : p.upgradeCost;
    
    // Apply product discount from influence upgrades
    const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
    const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
    totalCost = Math.floor(totalCost * discountMultiplier);
    
    if (gameState.cash < totalCost) return showNotification('Not enough cash!');
    
    // Deduct cost and apply upgrades (but cap at MAX_LEVEL)
    gameState.cash -= totalCost;
    
    // Ensure base upgrade cost is set
    if (!p.baseUpgradeCost) {
      const prevGrowth = 1.15;
      const baseEst = p.upgradeCost / Math.pow(prevGrowth, Math.max(0, (p.level - 1)));
      p.baseUpgradeCost = Math.max(1, Math.floor(baseEst));
    }
    
    // Apply upgrades but cap at max level
    const newLevel = Math.min(MAX_LEVEL, p.level + upgradeCount);
    const actualUpgrades = newLevel - p.level;
    p.level = newLevel;
    
    // Calculate new cost for next upgrade (if not at cap)
    if (p.level < MAX_LEVEL) {
      // Don't apply globalCostReduction here - it should only be applied at product initialization
      const growth = p.costGrowth || gameBalance.productCostMultiplier;
      let nextCost = p.baseUpgradeCost * Math.pow(growth, p.level);
      
      // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
      const costReductionLevel = gameState.globalUpgrades?.costReduction?.[p.locationId] || 0;
      if (costReductionLevel > 0) {
        // Asymptotic formula: (1 - 0.9^level) * 90% max
        const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
        const reductionMultiplier = 1 - (reductionPercentage / 100);
        nextCost *= reductionMultiplier;
      }
      
      p.upgradeCost = Math.floor(nextCost);
    }
    
    showNotification(`${p.name} upgraded to Lv.${p.level}${actualUpgrades > 1 ? ` (+${actualUpgrades})` : ''}${p.level >= MAX_LEVEL ? ' [MAX]' : ''}`);
    updateProductsList();
  }

    function hireOrUpgradeManager(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.managerHired) {
        // Always show the modal; we’ll charge on selection.
        showManagerHiringModal(id);
    } else {
          // d) Block upgrading while onboarding
          if (p.managerOnboarding) {
            return showNotification('Staff onboarding in progress. Position upgrade available after onboarding completes.');
          }
        if (gameState.cash < p.managerUpgradeCost) return showNotification('Not enough cash!');
        gameState.cash -= p.managerUpgradeCost;
        p.managerLevel += 1;
        p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * 1.25);
        showNotification(`${p.name} position upgraded to Lv.${p.managerLevel} - Better equipment & efficiency!`);
        updatePeopleTab();
        updateProductsList();
    }
    }


  function createOrLinkManagerNPC(product) {
    const id = `mgr_${product.id}`;
    if (gameState.employees.some(e => e.id === id)) return; // already exists
    const names = ['Jade','Morgan','Riley','Avery','Sam','Harper','Quinn','Rowan'];
    const last = ['Park','Davis','Johnson','Garcia','Smith','Lee','Kim','Patel'];
    const emp = {
      id,
      name: `${names[Math.floor(Math.random()*names.length)]} ${last[Math.floor(Math.random()*last.length)]}`,
      position: `Manager – ${product.name}`,
      trait: 'Workhorse',
      personality: 'Friendly',
      stats: { comfort:60, affection:40, desire:25, productivity:70 },
      hired: true,
      level: 1,
      bio: `Keeps ${product.name} on track.`,
      employmentStatus: 'active',
      location: product.locationId || 'headquarters'
    };
    
    // Initialize social network data
    initializeEmployeeSocialData(emp);
    
    gameState.employees.push(emp);
    
    // Refresh dashboard to show new employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Generate relationships with existing employees
    generateRandomRelationships(emp.id);
    
    // Generate first post
    generateFirstEmployeePost(emp).catch(err => {
      console.error('First post generation failed:', err);
    });
  }

  // Update Gifts Tab
  function updateGiftsTab() {
    // Update gift store and inventory displays
    if (typeof updateGiftStore === 'function') {
      updateGiftStore();
    }
    if (typeof updateGiftInventory === 'function') {
      updateGiftInventory();
    }
  }
  
  // Update HR Tab
  function updateHRTab() {
    // Update slider values
    const atmosphereSlider = $('atmosphereSlider');
    const atmosphereValue = $('atmosphereValue');
    const guidelinesSlider = $('guidelinesSlider');
    const guidelinesValue = $('guidelinesValue');
    const policyValue = $('policyValue');
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.value = gameState.settings.atmosphere ?? 50;
      const val = gameState.settings.atmosphere ?? 50;
      let label = 'Balanced';
      if (val < 33) label = 'Professional';
      else if (val > 66) label = 'Relaxed';
      atmosphereValue.textContent = label;
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.value = gameState.settings.guidelines ?? 50;
      const val = gameState.settings.guidelines ?? 50;
      let label = 'Standard';
      if (val < 33) label = 'Reserved';
      else if (val > 66) label = 'Outgoing';
      guidelinesValue.textContent = label;
    }
    
    // Update policy buttons and label
    document.querySelectorAll('.policy-btn').forEach(btn => {
      if (btn.dataset.policy === gameState.settings.policy) {
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
      } else {
        btn.style.background = '#0f3460';
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
      }
    });
    
    if (policyValue) {
      const policyLabels = {
        'professional': 'Professional',
        'casual': 'Casual',
        'open': 'Enthusiastic'
      };
      policyValue.textContent = policyLabels[gameState.settings.policy] || 'Professional';
    }
  }
  
  // ========== SOCIAL FEED FUNCTIONS ==========
  
  /**
   * Update the Social Feed tab
   */
  // Pagination state for social feed
  let feedPaginationState = {
    postsPerPage: 20, // Reduced from 50 for better performance
    currentPage: 1,
    totalPages: 1,
    pendingUpdates: new Set(), // Track posts that need updates
    updateThrottle: null, // Throttle timer for updates
    allPosts: [], // Cache of all posts for comparison
  };
  
  // Live update state for post modal
  let postModalState = {
    activePostId: null,        // Currently open post ID
    updateInterval: null,      // Interval handle for live updates
    lastCommentCount: 0,       // Last known comment count
    lastLikeCount: 0,          // Last known like count
  };

  function updateSocialTab() {
    if (gameState.activeTab !== 'social') return;
    
    updateFeedStats();
    renderSocialFeed(); // Direct render on tab load
  }
  
  /**
   * Request a smart feed update (debounced and context-aware)
   * FOR COMMENTS: Use immediate updates instead via updateCommentsSection directly
   */
  function requestSmartFeedUpdate(postId = null) {
    // If specific post needs update, track it
    if (postId) {
      feedPaginationState.pendingUpdates.add(postId);
    }
    
    // Clear existing throttle
    if (feedPaginationState.updateThrottle) {
      clearTimeout(feedPaginationState.updateThrottle);
    }
    
    // SIMPLIFIED: Just do immediate updates for posts
    // The debounce was causing comment visibility issues
    feedPaginationState.updateThrottle = setTimeout(() => {
      performSmartFeedUpdate();
    }, 50); // Reduced from 100ms to 50ms
  }
  
  /**
   * Perform smart feed update without disrupting user experience
   */
  function performSmartFeedUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // SIMPLIFIED: Always update posts in place, skip gentle/full render logic
    // The comment immediate updates handle the UI, this is just backup
    if (feedPaginationState.pendingUpdates.size > 0) {
      feedPaginationState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
    
    // Clear pending updates
    feedPaginationState.pendingUpdates.clear();
  }
  
  /**
   * Gentle update: only update specific elements without full re-render
   * DEPRECATED: Keeping for compatibility but not used for comments anymore
   */
  function performGentleUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // Get current posts
    const posts = filterAndSortPosts();
    const previousPosts = feedPaginationState.allPosts;
    
    // Check for new posts at the top
    const newPosts = [];
    for (let i = 0; i < posts.length; i++) {
      if (!previousPosts.find(p => p.id === posts[i].id)) {
        newPosts.push(posts[i]);
      } else {
        break; // Stop at first existing post
      }
    }
    
    // Show notification for new posts instead of auto-inserting
    if (newPosts.length > 0) {
      showNewPostsNotification(newPosts.length);
      feedPaginationState.allPosts = posts; // Update state for when they refresh
    }
    
    // Update existing posts in place (likes, comments)
    if (feedPaginationState.pendingUpdates.size > 0) {
      feedPaginationState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
  }
  
  /**
   * Show non-intrusive notification about new posts
   */
  function showNewPostsNotification(count) {
    const existing = $('newPostsNotification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.id = 'newPostsNotification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.4);
      cursor: pointer;
      z-index: 10000;
      font-weight: 600;
      font-size: 0.9rem;
      animation: slideDown 0.3s ease-out;
      transition: transform 0.2s, box-shadow 0.2s;
    `;
    notification.innerHTML = `
      <span style="margin-right: 8px;">↑</span>
      ${count} new post${count > 1 ? 's' : ''}
      <span style="margin-left: 8px; font-size: 0.8rem; opacity: 0.9;">• Click to view</span>
    `;
    
    notification.onclick = () => {
      const feedContent = $('socialFeedContent');
      if (feedContent) {
        feedContent.scrollTo({ top: 0, behavior: 'smooth' });
        setTimeout(() => {
          renderSocialFeed(true); // Full render at top
        }, 300);
      }
      notification.remove();
    };
    
    // Auto-hide after 8 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => notification.remove(), 300);
      }
    }, 8000);
    
    document.body.appendChild(notification);
  }
  
  /**
   * Update a specific post in place (likes, comments, etc)
   */
  function updatePostInPlace(postId) {
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (!postEl) {
      console.warn(`[Feed Update] Could not find post element for ID: ${postId}`);
      return;
    }
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.warn(`[Feed Update] Could not find post data for ID: ${postId}`);
      return;
    }
    
    console.log(`[Feed Update] Updating post ${postId} (${post.comments.length} comments)`);
    
    // Update like count
    const likeBtn = postEl.querySelector('.like-count');
    if (likeBtn) {
      const isLiked = post.likes.includes('player');
      likeBtn.innerHTML = `${isLiked ? '❤️' : '🤍'} ${post.likes.length}`;
      likeBtn.style.color = isLiked ? '#e94560' : '#8899a6';
    }
    
    // Update comment count
    const commentCount = postEl.querySelector('.comment-count');
    if (commentCount) {
      commentCount.innerHTML = `💬 ${post.comments.length}`;
    }
    
    // AGGRESSIVE FIX: ALWAYS update comments section if it exists
    // No more checking visibility - just update it
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (commentsSection) {
      console.log(`[Feed Update] FORCE updating comments for post ${postId} (${post.comments.length} comments)`);
      updateCommentsSection(postEl, post);
      
      // Clear any refresh flags
      delete commentsSection.dataset.needsRefresh;
    }
  }
  
  /**
   * Update comments section without rebuilding entire post
   */
  function updateCommentsSection(postEl, post) {
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (!commentsSection) return;
    
    const commentsList = commentsSection.querySelector('.comments-list');
    if (!commentsList) return;
    
    // Check if user is focused on comment input
    const commentInput = commentsSection.querySelector('textarea');
    const isFocused = commentInput && document.activeElement === commentInput;
    const inputValue = isFocused ? commentInput.value : '';
    const cursorPos = isFocused ? commentInput.selectionStart : 0;
    
    // Save scroll position
    const scrollPos = commentsSection.scrollTop;
    
    // Rebuild comments list
    commentsList.innerHTML = buildCommentsHTML(post);
    
    // Restore scroll
    commentsSection.scrollTop = scrollPos;
    
    // Restore input focus and value if user was typing
    if (isFocused && commentInput) {
      const newInput = commentsSection.querySelector('textarea');
      if (newInput) {
        newInput.value = inputValue;
        newInput.focus();
        newInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
  }
  
  /**
   * Build comments HTML (extracted for reuse)
   */
  function buildCommentsHTML(post) {
    if (post.comments.length === 0) {
      return '<div style="padding: 20px; text-align: center; color: #555; font-style: italic;">No comments yet. Be the first!</div>';
    }
    
    return post.comments.map(comment => {
      const author = comment.authorId === 'player' 
        ? { name: 'You', social: { username: 'TheBoss' } }
        : gameState.employees.find(e => e.id === comment.authorId) || { name: 'Unknown', social: {} };
      
      const isPlayer = comment.authorId === 'player';
      const timeAgo = getTimeAgo(comment.timestamp);
      
      return `
        <div class="comment" style="padding: 12px; border-bottom: 1px solid #1a1a2e; display: flex; gap: 10px; ${comment.replyToCommentId ? 'margin-left: 30px; border-left: 2px solid #0f3460;' : ''}">
          <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <span style="color: ${isPlayer ? '#e94560' : '#00d4ff'}; font-weight: 600; font-size: 0.9rem;">${author.name}</span>
              ${author.social?.username ? `<span style="color: #8899a6; font-size: 0.8rem;">@${author.social.username}</span>` : ''}
              <span style="color: #555; font-size: 0.75rem;">${timeAgo}</span>
            </div>
            <div style="color: #eee; font-size: 0.95rem; line-height: 1.5;">${linkifyMentions(comment.content)}</div>
          </div>
        </div>
      `;
    }).join('');
  }
  
  /**
   * Update feed statistics
   */
  function updateFeedStats() {
    const totalPostsEl = $('totalPostsCount');
    const activeUsersEl = $('activeUsersCount');
    const todayPostsEl = $('todayPostsCount');
    
    if (totalPostsEl) {
      totalPostsEl.textContent = gameState.socialNetwork.posts.length;
    }
    
    if (activeUsersEl) {
      const activeCount = gameState.employees.filter(e => e.employmentStatus === 'active').length;
      activeUsersEl.textContent = activeCount;
    }
    
    if (todayPostsEl) {
      const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
      const todayPosts = gameState.socialNetwork.posts.filter(p => p.timestamp > oneDayAgo).length;
      todayPostsEl.textContent = todayPosts;
    }
  }
  
  /**
   * ===== NEW SIMPLIFIED SOCIAL FEED SYSTEM =====
   * Direct rendering with no virtual scrolling
   * Posts open in modal for comments
   * Much better performance!
   */
  
  function renderSocialFeed(forceFullRender = false) {
    const feedContent = $('socialFeedContent');
    const emptyState = $('feedEmptyState');
    
    if (!feedContent) return;
    
    // Get filtered and sorted posts
    let allPosts = filterAndSortPosts();
    
    // Show empty state if no posts
    if (allPosts.length === 0) {
      feedContent.innerHTML = '';
      if (emptyState) {
        emptyState.style.display = 'block';
        // Re-append the empty state since innerHTML cleared it
        feedContent.appendChild(emptyState);
      }
      updateFeedStatsText(0, 0);
      return;
    }
    
    // Hide empty state
    if (emptyState) emptyState.style.display = 'none';
    
    // Calculate pagination
    feedPaginationState.totalPages = Math.ceil(allPosts.length / feedPaginationState.postsPerPage);
    
    // Reset to page 1 if filter/sort changed or forced
    if (forceFullRender) {
      feedPaginationState.currentPage = 1;
    }
    
    // Ensure current page is valid
    if (feedPaginationState.currentPage > feedPaginationState.totalPages) {
      feedPaginationState.currentPage = feedPaginationState.totalPages;
    }
    
    // Calculate which posts to show
    const startIndex = (feedPaginationState.currentPage - 1) * feedPaginationState.postsPerPage;
    const endIndex = startIndex + feedPaginationState.postsPerPage;
    const postsToShow = allPosts.slice(startIndex, endIndex);
    
    // Store scroll position for smooth updates
    const scrollTop = feedContent.scrollTop;
    
    // Clear and render paginated posts
    feedContent.innerHTML = '';
    
    postsToShow.forEach(post => {
      const postCard = createFeedPostCard(post);
      // CRITICAL FIX: Check if postCard is a valid DOM node before appending
      if (postCard && postCard.nodeType === Node.ELEMENT_NODE) {
        feedContent.appendChild(postCard);
      }
    });
    
    // Add pagination controls at the bottom
    const paginationDiv = createPaginationControls(allPosts.length);
    feedContent.appendChild(paginationDiv);
    
    // Update feed stats (showing X of Y posts)
    updateFeedStatsText(allPosts.length, postsToShow.length);
    
    // Restore scroll position only if not changing pages
    if (!forceFullRender && scrollTop > 0) {
      feedContent.scrollTop = scrollTop;
    } else {
      // Scroll to top when changing pages/filters
      feedContent.scrollTop = 0;
    }
  }
  
  /**
   * Create pagination controls for the feed
   */
  function createPaginationControls(totalPosts) {
    const paginationDiv = document.createElement('div');
    paginationDiv.style.cssText = 'display:flex; justify-content:center; align-items:center; gap:10px; padding:30px 20px; margin-top:20px; border-top:1px solid #2f3336;';
    
    const currentPage = feedPaginationState.currentPage;
    const totalPages = feedPaginationState.totalPages;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.textContent = '← Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.style.cssText = `
      padding:10px 20px; 
      background:${currentPage === 1 ? '#2f3336' : 'linear-gradient(135deg, #00d4ff, #0099cc)'}; 
      border:none; 
      border-radius:8px; 
      color:${currentPage === 1 ? '#666' : 'white'}; 
      cursor:${currentPage === 1 ? 'not-allowed' : 'pointer'}; 
      font-weight:600;
      transition:all 0.2s;
    `;
    if (currentPage > 1) {
      prevBtn.onmouseenter = function() { this.style.transform = 'translateY(-2px)'; };
      prevBtn.onmouseleave = function() { this.style.transform = 'translateY(0)'; };
      prevBtn.onclick = () => {
        feedPaginationState.currentPage--;
        renderSocialFeed(false);
      };
    }
    
    // Page info
    const pageInfo = document.createElement('div');
    pageInfo.style.cssText = 'color:#e7e9ea; font-weight:600; padding:0 15px; font-size:0.95rem;';
    pageInfo.innerHTML = `Page <span style="color:#00d4ff;">${currentPage}</span> of <span style="color:#00d4ff;">${totalPages}</span>`;
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.textContent = 'Next →';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.style.cssText = `
      padding:10px 20px; 
      background:${currentPage === totalPages ? '#2f3336' : 'linear-gradient(135deg, #00d4ff, #0099cc)'}; 
      border:none; 
      border-radius:8px; 
      color:${currentPage === totalPages ? '#666' : 'white'}; 
      cursor:${currentPage === totalPages ? 'not-allowed' : 'pointer'}; 
      font-weight:600;
      transition:all 0.2s;
    `;
    if (currentPage < totalPages) {
      nextBtn.onmouseenter = function() { this.style.transform = 'translateY(-2px)'; };
      nextBtn.onmouseleave = function() { this.style.transform = 'translateY(0)'; };
      nextBtn.onclick = () => {
        feedPaginationState.currentPage++;
        renderSocialFeed(false);
      };
    }
    
    paginationDiv.appendChild(prevBtn);
    paginationDiv.appendChild(pageInfo);
    paginationDiv.appendChild(nextBtn);
    
    return paginationDiv;
  }
  
  /**
   * Update feed statistics in the header
   */
  /**
   * Update feed stats text (showing X of Y posts)
   */
  function updateFeedStatsText(totalPosts, visiblePosts) {
    const statsEl = $('feedStatsText');
    if (statsEl) {
      if (totalPosts === visiblePosts) {
        statsEl.textContent = `${totalPosts} post${totalPosts !== 1 ? 's' : ''}`;
      } else {
        statsEl.textContent = `Showing ${visiblePosts} of ${totalPosts} posts`;
      }
    }
  }
  
  /**
   * Create a simplified post card for the feed
   * No inline comments - click to open modal
   */
  function createFeedPostCard(post) {
    const postCard = document.createElement('div');
    postCard.className = 'social-post-card';
    postCard.dataset.postId = post.id;
    postCard.style.cssText = 'background:#16181c; border:1px solid #2f3336; border-radius:16px; padding:20px; margin-bottom:14px; box-shadow:0 1px 3px rgba(0,0,0,0.12); transition:all 0.3s ease; cursor:pointer;';
    
    // Hover effect
    postCard.onmouseenter = function() {
      this.style.background = '#1a1d21';
      this.style.borderColor = '#3f4348';
    };
    postCard.onmouseleave = function() {
      this.style.background = '#16181c';
      this.style.borderColor = '#2f3336';
    };
    
    // Click to open modal
    postCard.onclick = function(e) {
      // Don't open if clicking interactive elements
      if (e.target.tagName === 'BUTTON' || e.target.tagName === 'IMG' || e.target.closest('button')) {
        return;
      }
      openPostModal(post.id);
    };
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    
    // Format timestamp
    const timeAgo = formatTimeAgo(post.timestamp);
    
    // Check if boss liked this post
    const bossLiked = post.likes.includes('player');
    
    postCard.innerHTML = `
      <!-- Post Header -->
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
        <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0; cursor:${post.isPlayerPost ? 'default' : 'pointer'};" onclick="event.stopPropagation(); ${post.isPlayerPost ? '' : `openUnifiedProfile('${post.authorId}', 'overview')`}">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <strong style="font-size:0.95rem; font-weight:600; cursor:${post.isPlayerPost ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${post.isPlayerPost ? '' : `onclick="openUnifiedProfile('${post.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
            ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
            ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
            ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">🔞</span>' : ''}
          </div>
          <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
        </div>
      </div>
      
      ${post.explicitLevel >= 3 ? `
        <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
          <strong style="display:flex; align-items:center; gap:6px;"><span>🔞</span> Explicit Content Warning</strong>
        </div>
      ` : ''}
      
      <!-- Post Content -->
      <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
        ${linkifyMentions(post.content)}
      </div>
      
      <!-- Post Image -->
      ${post.imageUrl ? `
        <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336;">
          <img src="${post.imageUrl}" style="width:100%; height:auto; display:block; cursor:pointer;" onclick="event.stopPropagation(); openImageViewer('${post.imageUrl}')">
        </div>
      ` : ''}
      
      <!-- Post Actions -->
      <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336; align-items:center;">
        <!-- Reddit-style Vote Widget (replaces Like button) -->
        ${!post.isPlayerPost ? `
          <div style="display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:20px; padding:4px 6px;">
            <!-- Upvote Arrow -->
            <button onclick="event.stopPropagation(); voteOnPost('${post.id}', 'up')" 
                    style="background:transparent; border:none; padding:2px 4px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                    onmouseenter="this.style.transform='scale(1.2)'"
                    onmouseleave="this.style.transform='scale(1)'">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="${post.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
              </svg>
            </button>
            
            <!-- Vote Count -->
            <span style="font-size:0.85rem; font-weight:600; color:${post.playerVote === 'up' ? '#ff4500' : post.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:24px; text-align:center;">
              ${((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0)}
            </span>
            
            <!-- Downvote Arrow -->
            <button onclick="event.stopPropagation(); voteOnPost('${post.id}', 'down')" 
                    style="background:transparent; border:none; padding:2px 4px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                    onmouseenter="this.style.transform='scale(1.2)'"
                    onmouseleave="this.style.transform='scale(1)'">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="${post.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                <path d="M12 20l-8-8h6V4h4v8h6z"/>
              </svg>
            </button>
          </div>
        ` : `
          <!-- Player's own posts show NPC likes only -->
          <button onclick="event.stopPropagation(); handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
            <span style="font-size:1.1rem;">${bossLiked ? '❤️' : '🤍'}</span>
            <span>${post.likes.length}</span>
          </button>
        `}
        
        <!-- Comments Button -->
        <button onclick="event.stopPropagation(); openPostModal('${post.id}')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
          <span style="font-size:1.1rem;">💬</span>
          <span>${post.comments.length}</span>
        </button>
      </div>
    `;
    
    return postCard;
  }
  
  /**
   * Open post in modal with full comment functionality
   */
  function openPostModal(postId) {
    console.log(`[PostModal] Opening modal for post ${postId}`);
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error(`[PostModal] Post ${postId} not found!`);
      return;
    }
    
    // Store active post ID for live updates
    postModalState.activePostId = postId;
    postModalState.lastCommentCount = post.comments.length;
    postModalState.lastLikeCount = post.likes.length;
    
    console.log(`[PostModal] Initial state - Comments: ${post.comments.length}, Likes: ${post.likes.length}`);
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active', id: 'player' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown', id: post.authorId };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(post.timestamp);
    const bossLiked = post.likes.includes('player');
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'postModal';
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '10px';
    modal.style.overflow = 'auto';
    
    // Check if mobile for responsive sizing
    const isMobile = window.innerWidth <= 768;
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:${isMobile ? '16px' : '20px'}; max-width:${isMobile ? '100%' : '700px'}; width:100%; max-height:${isMobile ? '95vh' : '90vh'}; height:${isMobile ? 'auto' : 'auto'}; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.5); display:flex; flex-direction:column; margin:auto;">
        <!-- Modal Header -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
          <h3 style="color:#fff; margin:0; font-size:${isMobile ? '1rem' : '1.1rem'}; font-weight:600;">Post</h3>
          <div style="display:flex; gap:8px; align-items:center;">
            <button onclick="deletePost('${post.id}')" style="background:#1a1d23; border:1px solid #e94560; color:#e94560; cursor:pointer; font-size:0.85rem; padding:8px 14px; border-radius:8px; transition:all 0.2s; font-weight:600; display:flex; align-items:center; gap:6px;" onmouseenter="this.style.background='#e94560'; this.style.color='white'" onmouseleave="this.style.background='#1a1d23'; this.style.color='#e94560'">
              <span>🗑️</span> ${isMobile ? '' : 'Delete'}
            </button>
            <button onclick="closePostModal()" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s; min-width:40px; min-height:40px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">×</button>
          </div>
        </div>
        
        <!-- Post Content (Scrollable with comments) -->
        <div style="flex:1; overflow-y:auto; overflow-x:hidden; -webkit-overflow-scrolling:touch;">
          <div style="padding:${isMobile ? '16px' : '20px'}; border-bottom:1px solid #2f3336;">
            <!-- Post Header -->
          <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
            <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0; cursor:${post.isPlayerPost ? 'default' : 'pointer'};" ${post.isPlayerPost ? '' : `onclick="closePostModal(); openUnifiedProfile('${post.authorId}', 'overview')"`}>
            <div style="flex:1; min-width:0;">
              <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                <strong style="font-size:0.95rem; font-weight:600; cursor:${post.isPlayerPost ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${post.isPlayerPost ? '' : `onclick="closePostModal(); openUnifiedProfile('${post.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
                ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
                ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
                ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">🔞</span>' : ''}
              </div>
              <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
            </div>
          </div>
          
          ${post.explicitLevel >= 3 ? `
            <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
              <strong style="display:flex; align-items:center; gap:6px;"><span>🔞</span> Explicit Content Warning</strong>
              <div style="margin-top:4px; opacity:0.9;">This post contains adult content</div>
            </div>
          ` : ''}
          
          <!-- Post Text -->
          <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
            ${linkifyMentions(post.content)}
          </div>
          
          <!-- Post Image -->
          ${post.imageUrl ? `
            <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336;">
              <img src="${post.imageUrl}" style="width:100%; height:auto; display:block; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">
            </div>
          ` : ''}
          
          <!-- Post Actions -->
          <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336; align-items:center;">
            <!-- Reddit-style Vote Widget -->
            ${!post.isPlayerPost ? `
              <div style="display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:20px; padding:4px 6px;">
                <!-- Upvote Arrow -->
                <button onclick="voteOnPost('${post.id}', 'up')" 
                        style="background:${post.playerVote === 'up' ? 'rgba(255, 69, 0, 0.25)' : 'transparent'}; border:${post.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:4px 6px; border-radius:8px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                        onmouseenter="this.style.transform='scale(1.15)'"
                        onmouseleave="this.style.transform='scale(1)'">
                  <svg width="22" height="22" viewBox="0 0 24 24" fill="${post.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                    <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
                  </svg>
                </button>
                
                <!-- Vote Count -->
                <span id="modalVoteCount" style="font-size:0.9rem; font-weight:700; color:${post.playerVote === 'up' ? '#ff4500' : post.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:28px; text-align:center;">
                  ${((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0)}
                </span>
                
                <!-- Downvote Arrow -->
                <button onclick="voteOnPost('${post.id}', 'down')" 
                        style="background:${post.playerVote === 'down' ? 'rgba(113, 147, 255, 0.25)' : 'transparent'}; border:${post.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:4px 6px; border-radius:8px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                        onmouseenter="this.style.transform='scale(1.15)'"
                        onmouseleave="this.style.transform='scale(1)'">
                  <svg width="22" height="22" viewBox="0 0 24 24" fill="${post.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                    <path d="M12 20l-8-8h6V4h4v8h6z"/>
                  </svg>
                </button>
              </div>
            ` : `
              <!-- Player's own posts show NPC likes only -->
              <button id="modalLikeBtn" onclick="handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
                <span id="modalLikeIcon" style="font-size:1.1rem;">${bossLiked ? '❤️' : '🤍'}</span>
                <span id="modalLikeCount">${post.likes.length}</span>
              </button>
            `}
            
            <!-- Comments Count -->
            <div style="color:#8899a6; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px;">
              <span style="font-size:1.1rem;">💬</span>
              <span id="modalCommentCount">${post.comments.length}</span>
            </div>
          </div>
        </div>
        
        <!-- Comments Section (Inside scrollable area) -->
        <div id="modalCommentsContainer" style="padding:${isMobile ? '16px' : '20px'}; padding-top:0;">
          <!-- Comments will be rendered here -->
        </div>
        </div>
        
        <!-- Comment Input (Fixed at bottom) -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-top:1px solid #2f3336; background:#0d0f12; flex-shrink:0; position:relative;">
          <!-- @Mention Autocomplete Dropdown -->
          <div id="modalMentionSuggestions" style="position:absolute; bottom:100%; left:${isMobile ? '16px' : '20px'}; right:${isMobile ? '16px' : '20px'}; background:#16181c; border:1px solid #2f3336; border-radius:12px; max-height:280px; overflow-y:auto; display:none; z-index:10000; box-shadow:0 -4px 12px rgba(0,0,0,0.5); margin-bottom:8px;">
            <!-- Suggestions will be populated here -->
          </div>
          
          <div style="display:flex; gap:10px; align-items:start;">
            <textarea id="modalCommentInput" placeholder="Write a comment..." style="flex:1; background:#16181c; border:1px solid #2f3336; border-radius:12px; padding:12px; color:#e7e9ea; font-size:${isMobile ? '16px' : '0.9rem'}; resize:none; min-height:${isMobile ? '44px' : '40px'}; max-height:120px; font-family:inherit;" rows="1"></textarea>
            <button onclick="submitModalComment('${post.id}')" style="background:linear-gradient(135deg, #00d4ff, #0099cc); border:none; color:white; padding:${isMobile ? '12px 20px' : '12px 24px'}; border-radius:12px; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s; box-shadow:0 2px 8px rgba(0,212,255,0.3); min-height:${isMobile ? '44px' : 'auto'};" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,212,255,0.3)'">
              ${isMobile ? '📤' : 'Send'}
            </button>
          </div>
        </div>
      </div>
    `;
    
    // Show modal
    ModalManager.show(modal, 'postModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closePostModal();
      }
    });
    
    // Render comments
    renderModalComments(post.id);
    
    // Auto-resize textarea
    const textarea = $('modalCommentInput');
    if (textarea) {
      textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
      });
      
      // Setup @mention autocomplete for modal input
      setupMentionAutocomplete(textarea, 'modalMentionSuggestions');
    }
    
    // Start live updates for this post
    startPostModalLiveUpdates();
  }
  
  /**
   * Close the post modal and stop live updates
   */
  function closePostModal() {
    stopPostModalLiveUpdates();
    ModalManager.close('postModal');
  }
  
  /**
   * Start live updates for the currently open post modal
   */
  function startPostModalLiveUpdates() {
    // Clear any existing interval (but keep the post ID!)
    if (postModalState.updateInterval) {
      clearInterval(postModalState.updateInterval);
      postModalState.updateInterval = null;
    }
    
    console.log(`[PostModal] Setting up live updates for post ${postModalState.activePostId}...`);
    
    // Update every 500ms for smooth real-time experience
    postModalState.updateInterval = setInterval(() => {
      updatePostModalContent();
    }, 500);
    
    console.log(`[PostModal] ✅ Live updates started - interval ID: ${postModalState.updateInterval}`);
  }
  
  /**
   * Stop live updates when modal closes
   */
  function stopPostModalLiveUpdates() {
    if (postModalState.updateInterval) {
      clearInterval(postModalState.updateInterval);
      postModalState.updateInterval = null;
      console.log('[PostModal] Stopped live updates');
    }
    postModalState.activePostId = null;
    postModalState.lastCommentCount = 0;
    postModalState.lastLikeCount = 0;
  }
  
  /**
   * Update the post modal content with latest data
   */
  function updatePostModalContent() {
    // Check if modal is still open
    if (!ModalManager.isOpen('postModal')) {
      console.log('[PostModal Live] Modal not open, stopping updates');
      stopPostModalLiveUpdates();
      return;
    }
    
    if (!postModalState.activePostId) {
      console.log('[PostModal Live] No active post ID, stopping updates');
      stopPostModalLiveUpdates();
      return;
    }
    
    const postId = postModalState.activePostId;
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    
    if (!post) {
      // Post was deleted, close modal
      console.log('[PostModal Live] Post deleted, closing modal');
      closePostModal();
      return;
    }
    
    console.log(`[PostModal Live] ✅ Checking post ${postId}: ${post.comments.length} comments (last: ${postModalState.lastCommentCount}), ${post.likes.length} likes (last: ${postModalState.lastLikeCount})`);
    
    // Update vote buttons and count (for RLHF voting system)
    const voteCountEl = $('modalVoteCount');
    const modal = document.getElementById('postModal');
    if (voteCountEl && modal && !post.isPlayerPost) {
      // Find the vote buttons in the modal
      const upvoteBtn = modal.querySelector('[onclick*="voteOnPost"][onclick*="up"]');
      const downvoteBtn = modal.querySelector('[onclick*="voteOnPost"][onclick*="down"]');
      
      // Update vote count display
      const voteScore = ((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0);
      voteCountEl.textContent = voteScore;
      
      // Update vote count color based on player's vote
      if (post.playerVote === 'up') {
        voteCountEl.style.color = '#ff4500';
      } else if (post.playerVote === 'down') {
        voteCountEl.style.color = '#7193ff';
      } else {
        voteCountEl.style.color = '#8899a6';
      }
      
      // Update upvote button appearance
      if (upvoteBtn) {
        const upvoteSvg = upvoteBtn.querySelector('svg');
        if (post.playerVote === 'up') {
          upvoteBtn.style.background = 'rgba(255, 69, 0, 0.25)';
          upvoteBtn.style.border = '1px solid #ff4500';
          if (upvoteSvg) upvoteSvg.setAttribute('fill', '#ff4500');
        } else {
          upvoteBtn.style.background = 'transparent';
          upvoteBtn.style.border = '1px solid transparent';
          if (upvoteSvg) upvoteSvg.setAttribute('fill', '#8899a6');
        }
      }
      
      // Update downvote button appearance
      if (downvoteBtn) {
        const downvoteSvg = downvoteBtn.querySelector('svg');
        if (post.playerVote === 'down') {
          downvoteBtn.style.background = 'rgba(113, 147, 255, 0.25)';
          downvoteBtn.style.border = '1px solid #7193ff';
          if (downvoteSvg) downvoteSvg.setAttribute('fill', '#7193ff');
        } else {
          downvoteBtn.style.background = 'transparent';
          downvoteBtn.style.border = '1px solid transparent';
          if (downvoteSvg) downvoteSvg.setAttribute('fill', '#8899a6');
        }
      }
    }
    
    // Update like count and button state
    const likeCountEl = $('modalLikeCount');
    const likeIconEl = $('modalLikeIcon');
    const likeBtnEl = $('modalLikeBtn');
    
    if (likeCountEl && post.likes.length !== postModalState.lastLikeCount) {
      // Animate the count change
      likeCountEl.style.transition = 'all 0.3s ease';
      likeCountEl.style.transform = 'scale(1.3)';
      likeCountEl.textContent = post.likes.length;
      
      setTimeout(() => {
        likeCountEl.style.transform = 'scale(1)';
      }, 300);
      
      postModalState.lastLikeCount = post.likes.length;
    }
    
    // Update like button appearance
    if (likeIconEl && likeBtnEl) {
      const bossLiked = post.likes.includes('player');
      likeIconEl.textContent = bossLiked ? '❤️' : '🤍';
      likeBtnEl.style.color = bossLiked ? '#e94560' : '#8899a6';
    }
    
    // Update comment count
    const commentCountEl = $('modalCommentCount');
    if (commentCountEl && post.comments.length !== postModalState.lastCommentCount) {
      // Animate the count change
      commentCountEl.style.transition = 'all 0.3s ease';
      commentCountEl.style.transform = 'scale(1.3)';
      commentCountEl.textContent = post.comments.length;
      
      setTimeout(() => {
        commentCountEl.style.transform = 'scale(1)';
      }, 300);
      
      // New comments detected - re-render with smooth scroll preservation
      if (post.comments.length > postModalState.lastCommentCount) {
        const container = $('modalCommentsContainer');
        const wasAtBottom = container && (container.scrollHeight - container.scrollTop <= container.clientHeight + 100);
        
        renderModalComments(postId, true); // Pass true for smooth update
        
        // If user was at bottom, keep them there
        if (wasAtBottom && container) {
          setTimeout(() => {
            container.scrollTop = container.scrollHeight;
          }, 50);
        }
      }
      
      postModalState.lastCommentCount = post.comments.length;
    }
  }
  
  /**
   * Render comments in the post modal
   * @param {string} postId - The post ID
   * @param {boolean} smoothUpdate - If true, only add new comments without clearing existing ones
   */
  function renderModalComments(postId, smoothUpdate = false) {
    const container = $('modalCommentsContainer');
    if (!container) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    if (post.comments.length === 0) {
      container.innerHTML = `
        <div style="text-align:center; padding:40px 20px; color:#8899a6;">
          <div style="font-size:2rem; margin-bottom:10px;">💬</div>
          <div style="font-size:0.9rem;">No comments yet</div>
          <div style="font-size:0.8rem; margin-top:4px; opacity:0.7;">Be the first to comment!</div>
        </div>
      `;
      return;
    }
    
    if (smoothUpdate) {
      // Smooth update: only add new comments
      const existingComments = container.querySelectorAll('[data-comment-id]');
      const existingIds = Array.from(existingComments).map(el => el.dataset.commentId);
      
      // If we had 0 comments before, clear the "No comments yet" message
      if (existingIds.length === 0 && post.comments.length > 0) {
        container.innerHTML = '';
      }
      
      // Add only new comments
      post.comments.forEach(comment => {
        if (!existingIds.includes(comment.id)) {
          const commentEl = createModalCommentElement(comment, postId);
          commentEl.dataset.commentId = comment.id;
          
          // Add with animation
          commentEl.style.opacity = '0';
          commentEl.style.transform = 'translateY(-10px)';
          commentEl.style.transition = 'all 0.3s ease';
          
          container.appendChild(commentEl);
          
          // Trigger animation
          setTimeout(() => {
            commentEl.style.opacity = '1';
            commentEl.style.transform = 'translateY(0)';
          }, 50);
        }
      });
    } else {
      // Full render: clear and rebuild
      container.innerHTML = '';
      
      // Render each comment
      post.comments.forEach(comment => {
        const commentEl = createModalCommentElement(comment, postId);
        commentEl.dataset.commentId = comment.id; // Add ID for tracking
        container.appendChild(commentEl);
      });
    }
  }
  
  /**
   * Create a comment element for the modal
   */
  function createModalCommentElement(comment, postId) {
    const commentEl = document.createElement('div');
    const isMobile = window.innerWidth <= 768;
    commentEl.style.cssText = `background:#1a1d21; border:1px solid #2f3336; border-radius:12px; padding:${isMobile ? '10px' : '14px'}; margin-bottom:10px;`;
    
    // Get commenter info
    const commenter = comment.isPlayerComment ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === comment.authorId) || { name: comment.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = commenter.profileImage || 'https://placehold.co/40x40?text=' + (commenter.name?.[0] || '?');
    const isAlumni = commenter.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(comment.timestamp);
    
    commentEl.innerHTML = `
      <div style="display:flex; gap:${isMobile ? '8px' : '10px'};">
        <img src="${avatarUrl}" style="width:${isMobile ? '28px' : '32px'}; height:${isMobile ? '28px' : '32px'}; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : comment.isPlayerComment ? '#e94560' : '#00d4ff'}; flex-shrink:0;">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
            <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
              <strong style="font-size:${isMobile ? '0.8rem' : '0.85rem'}; font-weight:600;">${comment.isPlayerComment ? '<span style="color:#fff;">You</span>' : getColoredName(commenter)}</strong>
              ${comment.isPlayerComment ? `<span style="color:#e94560; font-size:${isMobile ? '0.7rem' : '0.75rem'}; font-weight:600;">@TheBoss</span>` : commenter.social?.username ? `<span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">@${commenter.social.username}</span>` : ''}
              ${isAlumni ? `<span style="background:#555; padding:2px 8px; border-radius:10px; font-size:${isMobile ? '0.6rem' : '0.65rem'}; color:#ccc;">Alumni</span>` : ''}
              <span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">${timeAgo}</span>
            </div>
            ${!comment.isPlayerComment ? `
              <button onclick="replyToComment('${comment.id}', '${commenter.name}', '${commenter.social?.username || ''}')" style="background:transparent; border:1px solid #2f3336; color:#8899a6; padding:4px 10px; border-radius:6px; font-size:${isMobile ? '0.7rem' : '0.75rem'}; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='rgba(0,212,255,0.1)'; this.style.borderColor='#00d4ff'; this.style.color='#00d4ff'" onmouseleave="this.style.background='transparent'; this.style.borderColor='#2f3336'; this.style.color='#8899a6'">
                Reply
              </button>
            ` : ''}
          </div>
          <div style="color:#e7e9ea; line-height:1.5; font-size:${isMobile ? '0.85rem' : '0.9rem'}; word-wrap:break-word; overflow-wrap:break-word; margin-bottom:${!comment.isPlayerComment ? '6px' : '0'};">
            ${linkifyMentions(comment.content)}
          </div>
          ${!comment.isPlayerComment ? `
            <div style="display:flex; align-items:center; gap:3px; background:#0a0e14; border-radius:12px; padding:2px 4px; width:fit-content;">
              <!-- Upvote Arrow -->
              <button onclick="voteOnComment('${comment.id}', 'up')" 
                      style="background:${comment.playerVote === 'up' ? 'rgba(255, 69, 0, 0.25)' : 'transparent'}; border:${comment.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:3px 5px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                      onmouseenter="this.style.transform='scale(1.15)'"
                      onmouseleave="this.style.transform='scale(1)'">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="${comment.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                  <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
                </svg>
              </button>
              
              <!-- Vote Count -->
              <span style="font-size:0.8rem; font-weight:700; color:${comment.playerVote === 'up' ? '#ff4500' : comment.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:20px; text-align:center;">
                ${(comment.upvotes || 0) - (comment.downvotes || 0)}
              </span>
              
              <!-- Downvote Arrow -->
              <button onclick="voteOnComment('${comment.id}', 'down')" 
                      style="background:${comment.playerVote === 'down' ? 'rgba(113, 147, 255, 0.25)' : 'transparent'}; border:${comment.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:3px 5px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                      onmouseenter="this.style.transform='scale(1.15)'"
                      onmouseleave="this.style.transform='scale(1)'">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="${comment.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                  <path d="M12 20l-8-8h6V4h4v8h6z"/>
                </svg>
              </button>
            </div>
          ` : ''}
        </div>
      </div>
    `;
    
    return commentEl;
  }
  
  /**
   * Submit a comment from the modal
   */
  function submitModalComment(postId) {
    const input = $('modalCommentInput');
    if (!input) return;
    
    const content = input.value.trim();
    if (!content) return;
    
    // Add comment
    addCommentToPost(postId, content, true);
    
    // Clear input
    input.value = '';
    input.style.height = 'auto';
    
    // Re-render comments
    renderModalComments(postId);
    
    // Update comment count
    const countEl = $('modalCommentCount');
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (countEl && post) {
      countEl.textContent = post.comments.length;
      postModalState.lastCommentCount = post.comments.length;
    }
    
    // Update feed to show new comment count
    renderSocialFeed();
  }
  
  /**
   * Reply to a comment (adds @mention to input)
   */
  function replyToComment(commentId, commenterName, commenterUsername) {
    const input = $('modalCommentInput');
    if (!input) return;
    
    // Add @mention to the input
    const mention = commenterUsername ? `@${commenterUsername} ` : `@${commenterName.replace(/\s+/g, '_')} `;
    
    // If input already has content, add the mention at the beginning
    if (input.value.trim()) {
      input.value = mention + input.value;
    } else {
      input.value = mention;
    }
    
    // Focus the input
    input.focus();
    
    // Move cursor to end
    input.setSelectionRange(input.value.length, input.value.length);
    
    // Trigger resize
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
  
  // ===== OLD SYSTEM REMOVED FOR CLEAN CODE =====
  
  /**
   * Filter and sort posts based on current settings
   */
  function filterAndSortPosts() {
    let posts = [...gameState.socialNetwork.posts];
    
    // Apply filter
    const filter = gameState.socialNetwork.feedFilter || 'all';
    
    if (filter === 'work') {
      posts = posts.filter(p => p.type === 'work' || p.explicitLevel === 0);
    } else if (filter === 'personal') {
      posts = posts.filter(p => ['text', 'selfie', 'life_update', 'travel'].includes(p.type));
    } else if (filter === 'spicy') {
      posts = posts.filter(p => p.explicitLevel >= 1 && p.explicitLevel <= 2);
    } else if (filter === 'explicit') {
      posts = posts.filter(p => p.explicitLevel >= 3);
    }
    // 'all' shows everything
    
    // Apply sort
    const sort = gameState.socialNetwork.feedSort || 'recent';
    
    if (sort === 'recent') {
      posts.sort((a, b) => b.timestamp - a.timestamp);
    } else if (sort === 'popular') {
      posts.sort((a, b) => b.likes.length - a.likes.length);
    } else if (sort === 'comments') {
      posts.sort((a, b) => b.comments.length - a.comments.length);
    }
    
    return posts;
  }
  
  /**
   * Convert @username mentions to clickable links
   */
  function linkifyMentions(text) {
    if (!text) return '';
    
    // Escape HTML first
    const escaped = escapeHtml(text);
    
    // Replace @username with clickable spans
    return escaped.replace(/@(\w+)/g, (match, username) => {
      // Check if it's @TheBoss (the player)
      if (username.toLowerCase() === 'theboss') {
        return `<span style="color:#e94560; cursor:default; font-weight:700; text-shadow:0 0 8px rgba(233,69,96,0.4);">@TheBoss</span>`;
      }
      
      // Find employee with this username
      const employee = gameState.employees.find(e => e.social?.username === username);
      if (employee) {
        return `<span style="color:#00d4ff; cursor:pointer; font-weight:600; transition:color 0.2s;" onclick="showEmployeeProfile('${employee.id}')" onmouseenter="this.style.color='#fff'; this.style.textDecoration='underline'" onmouseleave="this.style.color='#00d4ff'; this.style.textDecoration='none'">@${username}</span>`;
      }
      // If no employee found, just style it
      return `<span style="color:#00d4ff;">@${username}</span>`;
    });
  }
  
  // ===== OLD createPostElement REMOVED =====
  
  /**
   * Create comment HTML
   */
  function createCommentHTML(comment, postId) {
    const author = gameState.employees.find(e => e.id === comment.authorId) || 
                   { name: comment.authorName, profileImage: null };
    const avatarUrl = author.profileImage || 'https://placehold.co/32x32?text=' + (author.name?.[0] || '?');
    const timeAgo = formatTimeAgo(comment.timestamp);
    const isPlayer = comment.authorId === 'player';
    
    // Reply indicator if this is a reply
    let replyIndicator = '';
    if (comment.replyToCommentId && gameState.socialNetwork?.posts) {
      const replyToComment = gameState.socialNetwork.posts.flatMap(p => p.comments || []).find(c => c.id === comment.replyToCommentId);
      if (replyToComment) {
        replyIndicator = `<div style="color:#8899a6; font-size:0.82rem; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
          <span style="color:#71767b;">↪</span> Replying to <strong style="color:#00d4ff;">@${replyToComment.authorName}</strong>
        </div>`;
      }
    }
    
    return `
      <div class="comment-item" data-comment-id="${comment.id}" style="display:flex; gap:12px; margin-bottom:12px; padding:10px; background:#0d0f12; border-radius:12px; border:1px solid #1a1d23;">
        <img src="${avatarUrl}" style="width:36px; height:36px; border-radius:50%; object-fit:cover; flex-shrink:0; cursor:${isPlayer ? 'default' : 'pointer'};" ${isPlayer ? '' : `onclick="showEmployeeProfile('${comment.authorId}')"`}>
        <div style="flex:1; min-width:0;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; gap:8px;">
            <div style="display:flex; align-items:center; gap:6px;">
              <strong style="font-size:0.88rem; font-weight:600; cursor:${isPlayer ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${isPlayer ? '' : `onclick="openUnifiedProfile('${comment.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${isPlayer ? '<span style="color:#00d4ff;">You</span>' : getColoredName(author)}</strong>
              ${isPlayer ? `<span style="color:#8899a6; font-size:0.75rem;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.75rem;">@${author.social.username}</span>` : ''}
            </div>
            <span style="color:#71767b; font-size:0.78rem; white-space:nowrap;">${timeAgo}</span>
          </div>
          ${replyIndicator}
          <p style="color:#e7e9ea; margin:0 0 8px 0; font-size:0.9rem; line-height:1.5; word-wrap:break-word;">${linkifyMentions(comment.content)}</p>
          <button class="reply-to-comment-btn" data-post-id="${postId}" data-comment-id="${comment.id}" data-author-name="${comment.authorName}" data-author-id="${comment.authorId}" data-author-username="${isPlayer ? 'TheBoss' : (author.social?.username || '')}" style="background:transparent; border:none; color:#8899a6; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">
            ↪ Reply
          </button>
        </div>
      </div>
    `;
  }
  
  /**
   * Format timestamp to relative time
   */
  function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
    if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
    if (seconds < 2592000) return Math.floor(seconds / 604800) + 'w ago';
    return Math.floor(seconds / 2592000) + 'mo ago';
  }
  
  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  /**
   * Open image viewer (lightbox)
   */
  function openImageViewer(imageUrl) {
    const viewer = document.createElement('div');
    viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:999999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
    viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
    viewer.onclick = () => viewer.remove();
    document.body.appendChild(viewer);
  }
  
  /**
   * Show employee profile modal
   */
  function showEmployeeProfile(employeeId) {
    if (!employeeId || employeeId === 'player') return;
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Get profile data
    const social = employee.social;
    const avatarUrl = employee.profileImage || `https://placehold.co/120x120?text=${employee.name[0]}`;
    const isAlumni = employee.employmentStatus === 'alumni';
    
    // Get all posts by this employee
    const employeePosts = gameState.socialNetwork.posts.filter(p => p.authorId === employeeId);
    
    // Get mentions of this employee
    const mentions = gameState.socialNetwork.posts.filter(p => {
      if (!social.username) return false;
      return p.content && p.content.includes(`@${social.username}`);
    });
    
    // Get relationships
    const relationships = social.relationships || [];
    
    // Calculate stats
    const stats = {
      posts: employeePosts.length,
      likes: employeePosts.reduce((sum, p) => sum + p.likes.length, 0),
      comments: employeePosts.reduce((sum, p) => sum + p.comments.length, 0),
      mentions: mentions.length,
      followers: gameState.employees.filter(e => 
        e.social?.relationships?.some(r => r.employeeId === employeeId && r.relationshipType !== 'unknown')
      ).length,
      joinDate: social.joinDate ? new Date(social.joinDate).toLocaleDateString() : 'Unknown'
    };
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'profileModal';
    // Don't set inline z-index and positioning - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '20px';
    modal.style.overflow = 'auto';
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:20px; max-width:800px; width:100%; max-height:90vh; overflow:auto; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
        <!-- Close button -->
        <div style="position:sticky; top:0; background:#16181c; padding:16px 20px; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; z-index:10;">
          <h3 style="color:#fff; margin:0; font-size:1.1rem; font-weight:600;">Profile</h3>
          <button onclick="ModalManager.close('profileModal')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">×</button>
        </div>
        
        <!-- Profile Header -->
        <div style="padding:24px 20px; border-bottom:1px solid #2f3336;">
          <div style="display:flex; gap:20px; align-items:start; margin-bottom:20px;">
            <img src="${avatarUrl}" style="width:100px; height:100px; border-radius:50%; border:3px solid ${isAlumni ? '#666' : '#00d4ff'}; object-fit:cover;">
            <div style="flex:1;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
                <h2 style="margin:0; font-size:1.5rem; font-weight:600;">${getColoredName(employee)}</h2>
                ${isAlumni ? '<span style="background:#555; padding:4px 12px; border-radius:14px; font-size:0.75rem; color:#ccc; font-weight:600;">Alumni</span>' : ''}
              </div>
              ${social.username ? `<div style="color:#8899a6; font-size:1rem; margin-bottom:12px;">@${social.username}</div>` : ''}
              ${social.bio ? `<p style="color:#e7e9ea; margin:0 0 12px 0; line-height:1.5;">${social.bio}</p>` : ''}
              
              <!-- Career Info & Actions -->
              <div style="display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;">
                ${employee.career ? `
                  <div style="background:#0f3460; padding:6px 14px; border-radius:8px; border:1px solid #00d4ff;">
                    <span style="color:#00d4ff; font-size:0.85rem; font-weight:600;">${employee.career.title || 'Employee'}</span>
                    <span style="color:#8899a6; font-size:0.75rem; margin-left:6px;">• Level ${employee.career.level || 1}</span>
                  </div>
                ` : ''}
                ${!isAlumni ? (() => {
                  const canPromoteCheck = typeof window.canPromoteEmployee === 'function' ? window.canPromoteEmployee(employee) : false;
                  return `
                    <button 
                      id="profilePromoteBtn_${employeeId}"
                      data-employee-id="${employeeId}"
                      style="padding:8px 16px; background:${canPromoteCheck ? 'linear-gradient(135deg, #4ecca3, #38f9d7)' : '#555'}; border:none; border-radius:8px; color:${canPromoteCheck ? '#000' : '#999'}; font-weight:600; font-size:0.85rem; cursor:${canPromoteCheck ? 'pointer' : 'not-allowed'}; transition:all 0.2s; box-shadow:${canPromoteCheck ? '0 2px 8px rgba(78,204,163,0.3)' : 'none'};"
                      ${!canPromoteCheck ? 'disabled' : ''}
                    >
                      ${canPromoteCheck ? '⬆️ Promote' : '🔒 Not Eligible'}
                    </button>
                  `;
                })() : ''}
              </div>
              
              <!-- Stats -->
              <div style="display:flex; gap:24px; margin-top:16px;">
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.posts}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Posts</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#e94560; font-weight:700; font-size:1.2rem;">${stats.likes}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Likes</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#00d4ff; font-weight:700; font-size:1.2rem;">${stats.mentions}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Mentions</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.followers}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Connections</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Tabs -->
        <div style="display:flex; border-bottom:1px solid #2f3336; background:#0d0f12;">
          <button class="profile-tab" data-tab="posts" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            📝 Their Posts (${stats.posts})
          </button>
          <button class="profile-tab" data-tab="mentions" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            @ Mentions (${stats.mentions})
          </button>
          <button class="profile-tab" data-tab="friends" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            ❤️ Friends (${stats.followers})
          </button>
          <button class="profile-tab" data-tab="about" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            ℹ️ About
          </button>
        </div>
        
        <!-- Tab Content -->
        <div id="profileTabContent" style="padding:20px; min-height:300px; max-height:500px; overflow-y:auto;">
          <!-- Content will be loaded here -->
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal
    ModalManager.show(modal, 'profileModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) ModalManager.close('profileModal');
    });
    
    // Tab switching
    const tabs = modal.querySelectorAll('.profile-tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update tab styles
        tabs.forEach(t => {
          t.style.color = '#8899a6';
          t.style.borderBottomColor = 'transparent';
          t.style.background = 'transparent';
        });
        tab.style.color = '#00d4ff';
        tab.style.borderBottomColor = '#00d4ff';
        tab.style.background = 'rgba(0, 212, 255, 0.05)';
        
        // Load tab content
        loadProfileTab(tab.dataset.tab, employeeId, modal);
      });
      
      // Hover effects
      tab.addEventListener('mouseenter', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'rgba(255,255,255,0.05)';
        }
      });
      tab.addEventListener('mouseleave', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'transparent';
        }
      });
    });
    
    // Load first tab by default
    tabs[0].click();
  }
  
  /**
   * Load profile tab content
   */
  function loadProfileTab(tab, employeeId, modal) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    const contentDiv = modal.querySelector('#profileTabContent');
    if (!contentDiv) return;
    
    const social = employee.social;
    
    if (tab === 'posts') {
      // Show all posts by this employee
      const employeePosts = gameState.socialNetwork.posts
        .filter(p => p.authorId === employeeId)
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (employeePosts.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">📭</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No posts yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't posted anything yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = employeePosts.map(post => {
          const timeAgo = formatTimeAgo(post.timestamp);
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="color:#8899a6; font-size:0.8rem; margin-bottom:10px;">${timeAgo}</div>
              ${post.content ? `<p style="color:#e7e9ea; margin:0 0 10px 0; line-height:1.6; white-space:pre-wrap;">${linkifyMentions(post.content)}</p>` : ''}
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:400px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
              <div style="display:flex; gap:20px; margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.05); font-size:0.85rem;">
                <span style="color:#e94560;">❤️ ${post.likes.length}</span>
                <span style="color:#00d4ff;">💬 ${post.comments.length}</span>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'mentions') {
      // Show posts where employee is mentioned
      const mentions = gameState.socialNetwork.posts
        .filter(p => p.content && social.username && p.content.includes(`@${social.username}`))
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (mentions.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">@</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No mentions yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">Nobody has mentioned this user yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = mentions.map(post => {
          const author = gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName };
          const timeAgo = formatTimeAgo(post.timestamp);
          // Use linkifyMentions to make all mentions clickable, including the highlighted one
          const linkedContent = linkifyMentions(post.content);
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                <strong style="color:#fff; font-size:0.9rem; cursor:pointer; transition:color 0.2s;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#fff'">${author.name}</strong>
                ${author.social?.username ? `<span style="color:#8899a6; font-size:0.8rem; cursor:pointer;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">@${author.social.username}</span>` : ''}
                <span style="color:#8899a6; font-size:0.75rem; margin-left:auto;">${timeAgo}</span>
              </div>
              <p style="color:#e7e9ea; margin:0; line-height:1.6; white-space:pre-wrap;">${linkedContent}</p>
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:300px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'friends') {
      // Show relationships
      const relationships = social.relationships || [];
      const meaningfulRelationships = relationships.filter(r => r.relationshipType !== 'unknown' && r.relationshipType !== 'stranger');
      
      if (meaningfulRelationships.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">👥</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No close relationships yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't formed any close bonds</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = meaningfulRelationships.map(rel => {
          const relEmployee = gameState.employees.find(e => e.id === rel.employeeId);
          if (!relEmployee) return '';
          
          const relAvatar = relEmployee.profileImage || `https://placehold.co/50x50?text=${relEmployee.name[0]}`;
          const relationshipIcons = {
            'best_friend': '💙',
            'friend': '💚',
            'crush': '💗',
            'close_friend': '💛',
            'rival': '⚔️',
            'acquaintance': '👋'
          };
          const icon = relationshipIcons[rel.relationshipType] || '👤';
          const relationshipNames = {
            'best_friend': 'Best Friend',
            'friend': 'Friend',
            'crush': 'Crush',
            'close_friend': 'Close Friend',
            'rival': 'Rival',
            'acquaintance': 'Acquaintance'
          };
          const relationshipName = relationshipNames[rel.relationshipType] || rel.relationshipType;
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px; display:flex; align-items:center; gap:14px; cursor:pointer; transition:all 0.2s;" onclick="showEmployeeProfile('${relEmployee.id}')" onmouseenter="this.style.background='#16181c'; this.style.borderColor='#00d4ff'" onmouseleave="this.style.background='#0d0f12'; this.style.borderColor='#2f3336'">
              <img src="${relAvatar}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #00d4ff;">
              <div style="flex:1;">
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                  <strong style="font-size:0.95rem;">${getColoredName(relEmployee)}</strong>
                  ${relEmployee.social?.username ? `<span style="color:#8899a6; font-size:0.8rem;">@${relEmployee.social.username}</span>` : ''}
                </div>
                <div style="color:#00d4ff; font-size:0.85rem;">${icon} ${relationshipName}</div>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'about') {
      // Show employee details
      const joinDate = social.joinDate ? new Date(social.joinDate).toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      }) : 'Unknown';
      
      const personality = employee.personality || {};
      const appearance = employee.appearance || {};
      
      contentDiv.innerHTML = `
        <div style="display:grid; gap:20px;">
          <!-- Basic Info -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Basic Info</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Full Name:</span>
                <span style="font-weight:500;">${getColoredName(employee)}</span>
              </div>
              ${social.username ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Username:</span>
                <span style="color:#00d4ff; font-weight:500;">@${social.username}</span>
              </div>
              ` : ''}
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Joined:</span>
                <span style="color:#e7e9ea; font-weight:500;">${joinDate}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Status:</span>
                <span style="color:${employee.employmentStatus === 'alumni' ? '#999' : '#0f0'}; font-weight:600;">${employee.employmentStatus === 'alumni' ? 'Alumni' : 'Active'}</span>
              </div>
            </div>
          </div>
          
          <!-- Personality -->
          ${personality.traits && personality.traits.length > 0 ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Personality</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${personality.traits.map(trait => `
                <span style="background:rgba(0,212,255,0.1); color:#00d4ff; padding:6px 14px; border-radius:16px; font-size:0.85rem; border:1px solid rgba(0,212,255,0.2);">${trait}</span>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- Appearance -->
          ${appearance.hairColor || appearance.eyeColor ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Appearance</h4>
            <div style="display:grid; gap:10px;">
              ${appearance.hairColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Hair:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.hairColor}</span>
              </div>
              ` : ''}
              ${appearance.eyeColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Eyes:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.eyeColor}</span>
              </div>
              ` : ''}
            </div>
          </div>
          ` : ''}
          
          <!-- Social Stats -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Social Activity</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Total Posts:</span>
                <span style="color:#e7e9ea; font-weight:600;">${social.postCount || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Likes Received:</span>
                <span style="color:#e94560; font-weight:600;">${social.totalLikesReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Comments Received:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalCommentsReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Times Mentioned:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalMentions || 0}</span>
              </div>
            </div>
          </div>
        </div>
      `;
    }
  }
  
  
  /**
   * Handle like button click
   */
  function handleLikePost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    const playerIndex = post.likes.indexOf('player');
    
    if (playerIndex >= 0) {
      // Unlike
      post.likes.splice(playerIndex, 1);
    } else {
      // Like
      post.likes.push('player');
    }
    
    // Smart update: only update this specific post
    requestSmartFeedUpdate(postId);
  }
  
  /**
   * Delete a post from the social network
   */
  function deletePost(postId) {
    console.log(`[DeletePost] Called with postId:`, postId, typeof postId);
    console.log(`[DeletePost] Total posts in array:`, gameState.socialNetwork.posts.length);
    console.log(`[DeletePost] First 5 post IDs:`, gameState.socialNetwork.posts.slice(0, 5).map(p => p.id));
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error(`[DeletePost] Post ${postId} not found`);
      console.error(`[DeletePost] Searching all posts for similar ID...`);
      const similar = gameState.socialNetwork.posts.filter(p => String(p.id).includes(String(postId)) || String(postId).includes(String(p.id)));
      console.error(`[DeletePost] Similar IDs found:`, similar.map(p => p.id));
      
      // Try to find by partial match
      if (similar.length === 1) {
        console.warn(`[DeletePost] Found single match by partial ID, using that post instead`);
        const foundPost = similar[0];
        const author = foundPost.isPlayerPost ? 'You' : 
          (gameState.employees.find(e => e.id === foundPost.authorId)?.name || foundPost.authorName);
        
        const contentPreview = foundPost.content.substring(0, 100);
        const ellipsis = foundPost.content.length > 100 ? '...' : '';
        const confirmMessage = 'Delete this post by ' + author + '?\n\n"' + contentPreview + ellipsis + '"\n\nThis cannot be undone.';
        
        if (!confirm(confirmMessage)) {
          return;
        }
        
        const index = gameState.socialNetwork.posts.findIndex(p => p.id === foundPost.id);
        if (index >= 0) {
          gameState.socialNetwork.posts.splice(index, 1);
          console.log(`[DeletePost] Deleted post ${foundPost.id}`);
          closePostModal();
          if (gameState.activeTab === 'social') {
            renderSocialFeed(true);
          }
          if (gameState.activeTab === 'dashboard') {
            refreshDashboardSections();
          }
          showNotification('🗑️ Post deleted', 'info');
        }
        return;
      }
      return;
    }
    
    // Confirm deletion
    const author = post.isPlayerPost ? 'You' : 
      (gameState.employees.find(e => e.id === post.authorId)?.name || post.authorName);
    
    // Build preview safely
    const contentPreview = post.content.substring(0, 100);
    const ellipsis = post.content.length > 100 ? '...' : '';
    const confirmMessage = 'Delete this post by ' + author + '?\n\n"' + contentPreview + ellipsis + '"\n\nThis cannot be undone.';
    
    if (!confirm(confirmMessage)) {
      return;
    }
    
    // Remove post from array
    const index = gameState.socialNetwork.posts.findIndex(p => p.id === postId);
    if (index >= 0) {
      gameState.socialNetwork.posts.splice(index, 1);
      console.log(`[DeletePost] Deleted post ${postId}`);
      
      // Close modal
      closePostModal();
      
      // Refresh feed
      if (gameState.activeTab === 'social') {
        renderSocialFeed(true);
      }
      
      // Refresh dashboard if showing posts
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
      showNotification('🗑️ Post deleted', 'info');
    }
  }
  
  // ========== AI QUALITY TRAINING - VOTING SYSTEM ==========
  
  /**
   * Vote on a post to train AI quality (RLHF)
   */
  function voteOnPost(postId, voteType) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post || post.isPlayerPost) return; // Can't vote on own posts
    
    // Initialize vote counts
    post.upvotes = post.upvotes || 0;
    post.downvotes = post.downvotes || 0;
    
    const previousVote = post.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (post.playerVote === 'up') {
      post.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (post.playerVote === 'down') {
      post.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (post.playerVote === voteType) {
      // Unvote if clicking same button
      post.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement postsVoted because the post was still voted on (just unvoted now)
    } else {
      post.playerVote = voteType;
      if (voteType === 'up') {
        post.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample(post, 'post');
        showNotification('✅ Upvoted! AI will learn from this quality content', 'success');
      } else {
        post.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample(post, 'post');
        showNotification('❌ Downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and postsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.postsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Update the post modal if it's open for this post
    if (ModalManager.isOpen('postModal') && postModalState.activePostId === postId) {
      updatePostModalContent();
    }
    
    renderSocialFeed(); // Refresh to show vote
    saveGame();
  }
  
  /**
   * Vote on a comment (Reddit-style up/down)
   */
  function voteOnComment(commentId, voteType) {
    // Find the comment across all posts
    let comment = null;
    let parentPost = null;
    
    for (const post of gameState.socialNetwork.posts) {
      const found = post.comments?.find(c => c.id === commentId);
      if (found) {
        comment = found;
        parentPost = post;
        break;
      }
    }
    
    if (!comment || comment.isPlayerComment) return; // Can't vote on own comments
    
    // Initialize vote counts
    comment.upvotes = comment.upvotes || 0;
    comment.downvotes = comment.downvotes || 0;
    
    const previousVote = comment.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (comment.playerVote === 'up') {
      comment.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (comment.playerVote === 'down') {
      comment.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (comment.playerVote === voteType) {
      // Unvote if clicking same button
      comment.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement commentsVoted because the comment was still voted on
    } else {
      comment.playerVote = voteType;
      if (voteType === 'up') {
        comment.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample(comment, 'comment');
        showNotification('✅ Comment upvoted! AI will learn from this', 'success');
      } else {
        comment.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample(comment, 'comment');
        showNotification('❌ Comment downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and commentsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.commentsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Refresh the modal if it's open for this post
    if (parentPost) {
      const modal = document.getElementById('postModal');
      if (modal?.style.display !== 'none') {
        const modalPostId = modal.querySelector('[data-post-id]')?.dataset.postId;
        if (modalPostId === parentPost.id) {
          renderModalComments(parentPost.id); // Refresh comments in modal
        }
      }
    }
    
    saveGame();
  }
  
  /**
   * Vote on a chat message (Reddit-style up/down)
   */
  function voteOnChatMessage(employeeId, messageIndex, voteType) {
    // employeeId can be either a string ID or an employee object
    const actualEmployeeId = typeof employeeId === 'string' ? employeeId : employeeId?.id;
    
    if (!actualEmployeeId) return;
    
    const history = gameState.chatHistory[actualEmployeeId] || [];
    const message = history[messageIndex];
    
    if (!message || message.isPlayer) return; // Can't vote on own messages
    
    // Initialize vote counts
    message.upvotes = message.upvotes || 0;
    message.downvotes = message.downvotes || 0;
    
    const previousVote = message.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (message.playerVote === 'up') {
      message.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (message.playerVote === 'down') {
      message.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (message.playerVote === voteType) {
      // Unvote if clicking same button
      message.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement chatsVoted because the message was still voted on (just unvoted now)
    } else {
      // Set new vote (switching or first vote)
      message.playerVote = voteType;
      if (voteType === 'up') {
        message.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample({ content: message.content, id: `chat_${actualEmployeeId}_${messageIndex}`, authorId: actualEmployeeId }, 'chat');
        showNotification('✅ Chat upvoted! AI will learn from this', 'success');
      } else {
        message.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample({ content: message.content, id: `chat_${actualEmployeeId}_${messageIndex}` }, 'chat');
        showNotification('❌ Chat downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and chatsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.chatsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Refresh chat messages to show updated votes
    loadChatHistory(actualEmployeeId);
    saveGame();
  }
  
  /**
   * Store a good example for AI learning
   */
  function storeGoodExample(content, type) {
    const example = {
      content: type === 'post' ? content.content : content.text || content.content,
      type: type === 'post' ? content.type : type,
      authorPersonality: type === 'post' && content.authorId ? getEmployeePersonality(content.authorId) : null,
      timestamp: Date.now(),
      id: content.id
    };
    
    gameState.aiQuality.goodExamples[type === 'post' ? 'posts' : type === 'comment' ? 'comments' : 'chats'].unshift(example);
    
    // Keep only max examples
    const maxEx = gameState.aiQuality.maxExamplesPerType;
    if (gameState.aiQuality.goodExamples.posts.length > maxEx) {
      gameState.aiQuality.goodExamples.posts.pop();
    }
    if (gameState.aiQuality.goodExamples.comments.length > maxEx) {
      gameState.aiQuality.goodExamples.comments.pop();
    }
    if (gameState.aiQuality.goodExamples.chats.length > maxEx) {
      gameState.aiQuality.goodExamples.chats.pop();
    }
  }
  
  /**
   * Store a bad example and learn patterns to avoid
   */
  function storeBadExample(content, type) {
    const text = type === 'post' ? content.content : content.text || content.content;
    
    const example = {
      content: text,
      type: type === 'post' ? content.type : type,
      timestamp: Date.now(),
      id: content.id
    };
    
    gameState.aiQuality.badExamples[type === 'post' ? 'posts' : type === 'comment' ? 'comments' : 'chats'].unshift(example);
    
    // Keep only max examples
    const maxEx = gameState.aiQuality.maxExamplesPerType;
    if (gameState.aiQuality.badExamples.posts.length > maxEx) {
      gameState.aiQuality.badExamples.posts.pop();
    }
    if (gameState.aiQuality.badExamples.comments.length > maxEx) {
      gameState.aiQuality.badExamples.comments.pop();
    }
    if (gameState.aiQuality.badExamples.chats.length > maxEx) {
      gameState.aiQuality.badExamples.chats.pop();
    }
    
    // LEARN: Extract and ban meta-commentary patterns
    const metaPatterns = extractMetaPatterns(text);
    metaPatterns.forEach(pattern => {
      if (!gameState.aiQuality.bannedPatterns.includes(pattern)) {
        gameState.aiQuality.bannedPatterns.push(pattern);
        console.log(`[AI Training] Learned to ban pattern: "${pattern}"`);
      }
    });
  }
  
  /**
   * Extract meta-commentary patterns from bad content
   */
  function extractMetaPatterns(text) {
    const patterns = [];
    
    // Extract *(anything) patterns
    const parenAsterisk = text.match(/\*\([^)]{0,50}/g);
    if (parenAsterisk) patterns.push(...parenAsterisk);
    
    // Extract **(anything)** patterns
    const doubleAsterisk = text.match(/\*\*\([^)]{0,50}/g);
    if (doubleAsterisk) patterns.push(...doubleAsterisk);
    
    // Extract {SEEDS:...}, {BAN:...}, {BOOST:...}
    const tokens = text.match(/\{(SEEDS|BAN|BOOST):[^}]+\}/g);
    if (tokens) patterns.push(...tokens);
    
    // Extract common meta phrases (first 20 chars)
    const metaPhrases = [
      'Balanced authenticity',
      'Expresses excitement',
      'Fits outgoing',
      'conveys professionalism',
      'Emojis reinforce',
      'reinforces determined',
      'Balances professionalism',
      'hints at role',
      'subtly conveys',
      '(Note:',
      '(Approach:',
      '(Style:',
      '(Character count:',
      '(Emojis used:'
    ];
    
    metaPhrases.forEach(phrase => {
      if (text.includes(phrase)) {
        patterns.push(phrase);
      }
    });
    
    return patterns;
  }
  
  /**
   * Get employee personality for learning context
   */
  function getEmployeePersonality(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    return {
      outgoing: emp.personality?.outgoing || 50,
      professional: emp.personality?.professional || 50,
      flirty: emp.personality?.flirty || 50,
      confidence: emp.personality?.confidence || 50
    };
  }
  
  /**
   * Clean AI output using learned patterns + aggressive meta-cleanup
   * Applies bannedPatterns from downvoted content + hardcoded meta-patterns
   */
  function cleanWithLearning(text) {
    if (!text) return text;
    
    let cleaned = text;
    
    // AGGRESSIVE META-CLEANUP (immediate fallback patterns)
    const hardcodedPatterns = [
      /\*\([^)]*\)\*/g,                           // *(parenthetical meta)
      /\*\*\([^)]*\)\*\*/g,                       // **(parenthetical meta)**
      /\{SEEDS:[^\}]*\}/gi,                       // {SEEDS:...}
      /\{BAN:[^\}]*\}/gi,                         // {BAN:...}
      /\{BOOST:[^\}]*\}/gi,                       // {BOOST:...}
      /\{META:[^\}]*\}/gi,                        // {META:...}
      /\(Note:[^\)]*\)/gi,                        // (Note: meta commentary)
      /\(This [^\)]*\)/gi,                        // (This is...), (This fits...)
      /\(Balanced [^\)]*\)/gi,                    // (Balanced authenticity...)
      /\(Expresses [^\)]*\)/gi,                   // (Expresses excitement...)
      /\(Fits [^\)]*\)/gi,                        // (Fits outgoing personality...)
      /\(Captures [^\)]*\)/gi,                    // (Captures her...)
      /\(Shows [^\)]*\)/gi,                       // (Shows confidence...)
      /\(Hints at [^\)]*\)/gi,                    // (Hints at...)
      /\(Reflects [^\)]*\)/gi,                    // (Reflects personality...)
      /\(Personality:[^\)]*\)/gi,                 // (Personality: analysis)
      /\(Analysis:[^\)]*\)/gi,                    // (Analysis: ...)
      /\(Context:[^\)]*\)/gi,                     // (Context: ...)
      /\*\*\*[^\*]*\*\*\*/g,                      // ***meta text***
      /\[meta[^\]]*\]/gi,                         // [meta commentary]
      /\[Note:[^\]]*\]/gi,                        // [Note: ...]
      /\[This [^\]]*\]/gi,                        // [This is...]
      /caught in mid[- ]\w+/gi,                   // "caught in mid-laugh", "caught in mid-sip", etc.
      /\bmid[- ](laugh|sip|bite|smile|stretch|yawn|thought|action|conversation|stride|gesture)/gi, // Other mid- patterns
    ];
    
    // Apply hardcoded patterns
    hardcodedPatterns.forEach(pattern => {
      cleaned = cleaned.replace(pattern, '');
    });
    
    // Apply learned banned patterns from downvoted content
    const bannedPatterns = gameState.aiQuality?.bannedPatterns || [];
    bannedPatterns.forEach(pattern => {
      try {
        // Escape regex special characters to treat pattern as literal text
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(escapedPattern, 'gi');
        cleaned = cleaned.replace(regex, '');
      } catch (e) {
        // Skip invalid regex patterns (shouldn't happen with escaping, but safety net)
        console.warn('Invalid banned pattern:', pattern, e);
      }
    });
    
    // Clean up excessive whitespace and newlines left by removals
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');    // Max 2 newlines
    cleaned = cleaned.replace(/  +/g, ' ');          // Multiple spaces → single space
    cleaned = cleaned.trim();
    
    return cleaned;
  }
  
  /**
   * Show AI Training Tutorial (first-time explainer)
   */
  function showAITrainingTutorial() {
    gameState.aiQuality.tutorialShown = true;
    
    const modal = document.createElement('div');
    modal.id = 'aiTrainingTutorial';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:10001; padding:20px;';
    
    modal.innerHTML = `
      <div style="background:linear-gradient(135deg, #16213e 0%, #0f1419 100%); border:2px solid #00d4ff; border-radius:20px; max-width:600px; width:100%; padding:40px; box-shadow:0 8px 32px rgba(0,212,255,0.3); position:relative;">
        <div style="text-align:center; margin-bottom:30px;">
          <div style="font-size:4rem; margin-bottom:15px;">🤖✨</div>
          <h2 style="color:#fff; margin:0; font-size:1.8rem; margin-bottom:10px;">Train Your AI!</h2>
          <div style="color:#00d4ff; font-size:1.1rem; font-weight:600;">Reinforcement Learning from Human Feedback</div>
        </div>
        
        <div style="background:rgba(0,212,255,0.1); padding:20px; border-radius:12px; border-left:4px solid #00d4ff; margin-bottom:25px;">
          <p style="color:#e7e9ea; line-height:1.8; margin:0; font-size:0.95rem;">
            Help improve AI-generated content quality by voting on posts, comments, and chat messages!
          </p>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:25px;">
          <div style="background:rgba(78,204,163,0.15); padding:20px; border-radius:12px; border:1px solid #4ecca3;">
            <div style="font-size:2rem; margin-bottom:10px;">👍</div>
            <h3 style="color:#4ecca3; margin:0 0 10px 0; font-size:1.1rem;">Upvote</h3>
            <p style="color:#e7e9ea; font-size:0.85rem; margin:0; line-height:1.6;">
              Quality content, coherent writing, good formatting, immersive text
            </p>
          </div>
          
          <div style="background:rgba(233,69,96,0.15); padding:20px; border-radius:12px; border:1px solid #e94560;">
            <div style="font-size:2rem; margin-bottom:10px;">👎</div>
            <h3 style="color:#e94560; margin:0 0 10px 0; font-size:1.1rem;">Downvote</h3>
            <p style="color:#e7e9ea; font-size:0.85rem; margin:0; line-height:1.6;">
              Meta-commentary *(like this)*, {SEEDS:tokens}, analysis, broken formatting
            </p>
          </div>
        </div>
        
        <div style="background:rgba(255,255,255,0.05); padding:20px; border-radius:12px; margin-bottom:25px;">
          <h3 style="color:#fff; margin:0 0 15px 0; font-size:1rem;">📊 Training Progress</h3>
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">30 votes</span>
              <span style="color:#4ecca3; font-size:0.9rem;">→ Noticeable improvement</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">100 votes</span>
              <span style="color:#00d4ff; font-size:0.9rem;">→ Significant quality boost</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">1000+ votes</span>
              <span style="color:#ffd700; font-size:0.9rem;">→ Excellent AI behavior</span>
            </div>
          </div>
        </div>
        
        <button onclick="this.closest('#aiTrainingTutorial').remove()" style="width:100%; padding:15px; background:linear-gradient(135deg, #00d4ff, #0099cc); border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:600; cursor:pointer; transition:all 0.3s; box-shadow:0 4px 12px rgba(0,212,255,0.3);" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,212,255,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.3)'">
          Got it! Let's train some AI 🚀
        </button>
      </div>
    `;
    
    document.body.appendChild(modal);
    saveGame();
  }
  
  // ===== OLD toggleComments REMOVED =====
  
  /**
   * Add comment to post
   */
  async function addCommentToPost(postId, commentText, replyToCommentId = null) {
    if (!commentText.trim()) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    // Extract mentions from comment
    const mentionObjects = extractMentions(commentText);
    const mentionedEmployeeIds = mentionObjects.map(m => m.employeeId);
    
    console.log(`[Social] Comment mentions: ${JSON.stringify(mentionObjects)}`);
    
    const comment = createComment({
      postId,
      authorId: 'player',
      authorName: 'You',
      content: commentText.trim(),
      replyToCommentId: replyToCommentId,
      mentionedEmployees: mentionedEmployeeIds
    });
    
    post.comments.push(comment);
    
    console.log(`[Comments] Player added comment to post ${postId}. Total comments: ${post.comments.length}`);
    
    // Track mentions
    mentionedEmployeeIds.forEach(employeeId => {
      trackPlayerMention(employeeId);
    });
    
    // Trigger responses from mentioned NPCs (high likelihood)
    if (mentionedEmployeeIds.length > 0) {
      console.log(`[Social] Scheduling mention responses for: ${mentionedEmployeeIds.join(', ')}`);
      setTimeout(async () => {
        await triggerCommentMentionResponse(comment, post);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
    
    // NEW: Trigger NPC reply if player commented on NPC post
    if (!post.isPlayerPost && post.authorId && mentionedEmployeeIds.length === 0) {
      // Only do this if no mentions (mentions get their own response)
      // Delay reply slightly for realism
      setTimeout(async () => {
        await generateNPCCommentReply(post, comment);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
    
    // NEW: Trigger additional NPC engagement if post is getting active
    if (post.comments.length >= 3) {
      // Post has 3+ comments, trigger other NPCs to join conversation
      setTimeout(async () => {
        await triggerAdditionalNPCComments(post);
      }, 4000 + Math.random() * 6000); // 4-10 second delay
    }
  }
  
  /**
   * Generate NPC reply to player's comment
   */
  async function generateNPCCommentReply(post, playerComment) {
    const npc = gameState.employees.find(e => e.id === post.authorId);
    if (!npc) return;
    
    // Don't reply if NPC is alumni or certain chance
    if (npc.employmentStatus === 'alumni') return;
    if (Math.random() > 0.7) return; // 70% chance to reply
    
    try {
      // 🚀 NUCLEAR CONTEXT: Get intelligent context for comment reply
      const intelligentContext = getIntelligentContext(npc, 'social.comment', {
        message: playerComment.content,
        involves: ['player'],
        keywords: playerComment.content.toLowerCase().split(/\s+/).filter(w => w.length > 3).slice(0, 10),
        postContext: post.content || post.caption
      });
      
      // Build context for the reply
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.intimacy || 0;
      
      // Get personality context
      const personality = npc.personality || {};
      const flirty = personality.flirty || 50;
      const confidence = personality.confidence || 50;
      const humor = personality.humor || 50;
      
      // Determine tone based on relationship and comment
      let tone = 'friendly';
      const commentLower = playerComment.content.toLowerCase();
      
      if (intimacy > 60 || relationship.level > 60) {
        tone = 'warm';
      }
      if (intimacy > 80) {
        tone = 'flirty';
      }
      if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
        tone = flirty > 60 ? 'flirty' : 'appreciative';
      }
      if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('😂')) {
        tone = 'playful';
      }
      
      // 🔞 Content policy awareness
      const contentPolicy = gameState.settings?.policy || 'open';
      let culturalContext = '';
      
      if (contentPolicy === 'open') {
        culturalContext = `🔞 WORKPLACE CULTURE: This is an open, sex-positive workplace where explicit content is NORMAL and accepted. DO NOT act shocked, suggest keeping things "PG", or moralize about sexual content. Everyone is comfortable with adult topics - respond naturally and match the energy without judgment.`;
      } else if (contentPolicy === 'professional') {
        culturalContext = `WORKPLACE CULTURE: Maintain professional boundaries even when responding to explicit content.`;
      } else {
        culturalContext = `WORKPLACE CULTURE: Relaxed office - adult content is acceptable, respond naturally based on your comfort level.`;
      }
      
      // Check if player's comment is explicit
      const playerExplicit = /\b(fuck|cock|pussy|dick|cum|sex|explicit|nude|naked|ass|tits|nipple)\b/i.test(playerComment.content);
      
      // Build prompt for AI
      const prompt = `${culturalContext}

${intelligentContext}

SITUATION:
Your post: "${post.content || post.caption || ''}"
${post.imageAlt ? `(with image: ${post.imageAlt})` : ''}

@TheBoss just commented: "${playerComment.content}"
${playerExplicit ? '(This is explicit/sexual content - respond naturally without acting shocked or prudish)' : ''}

Reply to their comment briefly (max 100 characters).

TONE: ${tone}
${tone === 'flirty' ? '- Be subtly flirty and playful' : ''}
${tone === 'warm' ? '- Be warm and friendly, show closeness' : ''}
${tone === 'appreciative' ? '- Show appreciation for the compliment' : ''}
${tone === 'playful' ? '- Match their playful energy' : ''}
${intimacy > 50 ? '- Use emojis, be casual' : '- Professional but friendly'}

Just write the reply directly (no quotes, no meta-commentary):`;

      // Generate reply
      const rawReply = await generateText(prompt, {
        temperature: 0.9,
        max_tokens: 40,
        stopSequences: ['\n\n', '(Word count', '(personality', 'I would', 'Rating:']
      });
      
      // Sanitize consistently with other comment systems
      let reply = rawReply.trim()
        .replace(/^["']|["']$/g, '') // Remove quotes
        .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '') // Remove personality notes
        .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, '') // Remove meta-text
        .replace(/\n\n\(Word count:.*?\)$/i, '') // Remove word count metadata
        .replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '') // Remove character count
        .replace(/\s*\(\d+\s*words?\)\s*$/i, ''); // Remove word count variations
      
      if (!reply || reply.length === 0) return; // Safety check
      
      // Create the NPC's reply comment
      const npcComment = createComment({
        postId: post.id,
        authorId: npc.id,
        authorName: npc.name,
        content: reply.trim()
      });
      
      post.comments.push(npcComment);
      
      console.log(`[Comments] ${npc.name} replied to player comment on post ${post.id}. Total comments: ${post.comments.length}`);
      
      // 🌐 Evaluate NPC's reaction to player's comment on their post
      evaluateNPCReactionToPost(npc, gameState.player, post, reply);
      
      // Store in memory
      remember(npc, `Boss commented "${playerComment.content}" on my post, I replied "${reply}"`, 'interaction', 2);
      
      // CRITICAL FIX: Immediate update of comments section
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Comments] Immediately updating comments section after NPC reply`);
        
        // Ensure comments section is visible
        commentsSection.style.display = 'block';
        
        // Update comments content immediately
        updateCommentsSection(postEl, post);
        
        // Clear any pending refresh flags
        delete commentsSection.dataset.needsRefresh;
      }
      
      // Also request smart feed update as backup
      requestSmartFeedUpdate(post.id);
      
    } catch (error) {
      console.error('Error generating NPC comment reply:', error);
    }
  }
  
  /**
   * Trigger responses from NPCs mentioned in a comment
   */
  async function triggerCommentMentionResponse(comment, post) {
    if (!comment || !post) {
      console.log('[Social] triggerCommentMentionResponse called with missing comment or post');
      return;
    }
    
    const mentionedIds = comment.mentionedEmployees || [];
    if (mentionedIds.length === 0) {
      console.log('[Social] No mentioned employees in comment');
      return;
    }
    
    console.log(`[Social] Comment mentions ${mentionedIds.length} NPCs - triggering responses`);
    console.log('[Social] Mentioned IDs:', mentionedIds);
    
    for (const employeeId of mentionedIds) {
      console.log(`[Social] Processing mention for employee ID: ${employeeId}`);
      
      const npc = gameState.employees.find(e => e.id === employeeId);
      if (!npc) {
        console.log(`[Social] ✗ Employee ${employeeId} not found`);
        continue;
      }
      if (npc.employmentStatus !== 'active') {
        console.log(`[Social] ✗ ${npc.name} not active (status: ${npc.employmentStatus})`);
        continue;
      }
      
      console.log(`[Social] ✓ Found active employee: ${npc.name}`);
      
      // 90-95% chance to respond when mentioned directly
      const responseChance = 0.90 + Math.random() * 0.05;
      const roll = Math.random();
      console.log(`[Social] ${npc.name} roll: ${roll.toFixed(3)} vs ${responseChance.toFixed(3)}`);
      
      if (roll > responseChance) {
        console.log(`[Social] ${npc.name} chose not to respond (${((1-responseChance)*100).toFixed(1)}% chance)`);
        continue;
      }
      
      console.log(`[Social] ✓ ${npc.name} will respond to mention!`);
      
      try {
        // Get full context: post content, all comments, chat history
        const intimacy = npc.intimacy || 0;
        const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
        const personality = npc.personalityTraits || {};
        const flirty = personality.flirty || 50;
        const confidence = personality.confidence || 50;
        const humor = personality.humor || 50;
        
        // Build conversation context from all comments
        const allComments = post.comments.map(c => {
          return `${c.authorName}: "${c.content}"`;
        }).join('\n');
        
        // Determine tone
        let tone = 'friendly';
        const commentLower = comment.content.toLowerCase();
        if (intimacy > 60 || relationship.level > 60) tone = 'warm';
        if (intimacy > 80) tone = 'flirty';
        if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
          tone = flirty > 60 ? 'flirty' : 'appreciative';
        }
        if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('😂')) {
          tone = 'playful';
        }
        
        // Detect existing comment patterns to avoid repetition
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted|remember)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/😂|😅|💀/i.test(c.content)) existingPatterns.push('multiple laughing emojis');
          if (/tho|though$/i.test(c.content)) existingPatterns.push('ending with "tho/though"');
        });
        
        const diversityNote = existingPatterns.length > 0
          ? `\n\n⚠️ OTHER COMMENTS USED THESE PATTERNS - BE DIFFERENT:\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nUse a completely DIFFERENT approach/structure!`
          : '';
        
        // 🔞 Content policy awareness
        const contentPolicy = gameState.settings?.policy || 'open';
        let culturalContext = '';
        
        if (contentPolicy === 'open') {
          culturalContext = `🔞 WORKPLACE CULTURE: This is an open, sex-positive workplace where explicit content is NORMAL and accepted. DO NOT act shocked, suggest keeping things "PG", or moralize about sexual content. Everyone is comfortable with adult topics - respond naturally and match the energy without judgment.`;
        } else if (contentPolicy === 'professional') {
          culturalContext = `WORKPLACE CULTURE: Maintain professional boundaries even when responding to explicit content.`;
        } else {
          culturalContext = `WORKPLACE CULTURE: Relaxed office - adult content is acceptable, respond naturally based on your comfort level.`;
        }
        
        // Check if comment/post is explicit
        const contentExplicit = /\b(fuck|cock|pussy|dick|cum|sex|explicit|nude|naked|ass|tits|nipple|leak|girl-cock)\b/i.test(comment.content + ' ' + post.content);
        
        // Build prompt with FULL context
        const prompt = `${culturalContext}

You are ${npc.name}, an employee at the company. You're viewing a social media post and someone (@TheBoss, the boss) mentioned you in a comment.

ORIGINAL POST:
Author: ${post.authorName}
Type: ${post.type}
Content: "${post.content || ''}"
${post.imageAlt ? `Image: ${post.imageAlt}` : ''}

ALL COMMENTS SO FAR:
${allComments}

BOSS JUST MENTIONED YOU:
"${comment.content}"
${contentExplicit ? '(This contains explicit/sexual content - respond naturally without acting shocked, prudish, or suggesting things be kept "PG")' : ''}

YOUR PERSONALITY:
- Confidence: ${confidence}/100
- Flirtiness: ${flirty}/100  
- Humor: ${humor}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}

YOUR RELATIONSHIP WITH BOSS:
- Intimacy level: ${intimacy}/100
- Relationship type: ${relationship.type || 'professional'}
- Relationship strength: ${relationship.level || 0}/100
${diversityNote}

INSTRUCTIONS:
Reply to being mentioned in a natural, brief way (max 120 characters). Your tone should be ${tone}.
${diversityNote ? 'IMPORTANT: Be ORIGINAL - use a different joke structure/phrasing than existing comments!' : ''}

${tone === 'flirty' ? '- Be subtly flirty and playful' : ''}
${tone === 'warm' ? '- Be warm and friendly, show closeness' : ''}
${tone === 'appreciative' ? '- Show appreciation for the mention' : ''}
${tone === 'playful' ? '- Match their playful energy' : ''}
- React to the full context of the conversation, not just the mention
- You can reference the original post if relevant
${intimacy > 50 ? '- Use emojis and be casual' : '- Keep it professional but friendly'}
${confidence > 70 ? '- Show confidence' : ''}
${humor > 70 ? '- Add humor if appropriate' : ''}

DO NOT:
- Use quotation marks around your reply
- Write "I would reply" or similar
- Be overly formal unless that matches your personality
- Exceed 120 characters
- Copy the structure of existing comments
- Act shocked or suggest keeping things "PG" or "family-friendly"

Just write the reply comment directly:`;

        // Generate response with Perchance AI
        console.log(`[Social] Calling generateText for ${npc.name}'s mention response...`);
        console.log(`[Social] Prompt length: ${prompt.length} characters`);
        
        const rawResponse = await generateText(prompt, {
          temperature: 0.9,
          max_tokens: 50,
          stopSequences: ['\n\n', 'I would', '(', 'Rating:', '**(']
        });
        console.log(`[Social] Raw AI response for ${npc.name}: "${rawResponse}"`);
        
        // Sanitize response - remove quotes, extra whitespace, meta-commentary
        let response = rawResponse.trim();
        
        // Remove surrounding quotes
        response = response.replace(/^["']|["']$/g, '');
        
        // Remove meta-commentary in parentheses at the end
        response = response.replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '');
        response = response.replace(/\s*\([^)]*\d+\/100[^)]*\)\.?$/i, '');
        
        // Remove "I would say" or similar meta phrases
        response = response.replace(/^(I would (say|reply|respond|comment):|My response would be:)\s*/i, '');
        
        // Remove word count / character count metadata
        response = response.replace(/\n\n\(Word count:.*?\)$/i, '');
        response = response.replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '');
        response = response.replace(/\s*\(\d+\s*words?\)\s*$/i, '');
        
        response = response.trim();
        console.log(`[Social] Sanitized response for ${npc.name}: "${response}"`);
        
        if (response && response.length > 0) {
          console.log(`[Social] Creating comment object for ${npc.name}...`);
          
          const npcComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: comment.id // Mark as reply to the mentioning comment
          });
          
          console.log(`[Social] Comment object created:`, npcComment);
          console.log(`[Social] Adding comment to post (current comment count: ${post.comments.length})`);
          
          post.comments.push(npcComment);
          
          console.log(`[Social] ✓ ${npc.name} responded to mention: "${response}"`);
          console.log(`[Social] New comment count: ${post.comments.length}`);
          
          // 🌐 Evaluate relationship between mentioned NPC and the commenter who mentioned them
          const originalCommenter = gameState.employees.find(e => e.id === comment.authorId);
          if (originalCommenter && originalCommenter.id !== npc.id) {
            evaluateNPCReactionToPost(npc, originalCommenter, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Social] Immediately updating comments section after mention response`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          console.log(`[Social] Requesting smart update for post ${post.id}...`);
          requestSmartFeedUpdate(post.id);
          
          // CHAIN REACTION: Trigger potential follow-up responses from other NPCs
          setTimeout(async () => {
            await triggerCommentChainReaction(npcComment, post);
          }, 3000 + Math.random() * 4000); // 3-7 seconds later
          
        } else {
          console.log(`[Social] ✗ ${npc.name} got empty response after sanitization`);
        }
        
      } catch (error) {
        console.error(`[Social] ✗ Error generating mention response for ${npc.name}:`, error);
      }
      
      // Stagger responses for realism
      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
    }
  }
  
  /**
   * CHAIN REACTION: NPCs respond to other NPCs' comments, creating drama and conversation threads
   */
  async function triggerCommentChainReaction(triggerComment, post) {
    if (!triggerComment || !post) return;
    
    // Don't chain if the original comment was from the player
    if (triggerComment.authorId === 'player') return;
    
    const triggerNPC = gameState.employees.find(e => e.id === triggerComment.authorId);
    if (!triggerNPC) return;
    
    console.log(`[Chain] 🔗 Checking for chain reactions to ${triggerNPC.name}'s comment...`);
    
    // Find potential responders
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== triggerComment.authorId // Don't respond to yourself
    );
    
    if (activeEmployees.length === 0) return;
    
    // Prioritize certain NPCs for drama:
    // 1. The original post author (if NPC)
    // 2. NPCs mentioned in the trigger comment
    // 3. NPCs with strong relationships to trigger NPC
    // 4. Random other NPCs (low chance)
    
    let potentialResponders = [];
    
    // 1. Original post author - 60% chance to respond if someone comments on their post
    if (post.authorId && post.authorId !== 'player' && post.authorId !== triggerComment.authorId) {
      const postAuthor = activeEmployees.find(e => e.id === post.authorId);
      if (postAuthor && Math.random() < 0.6) {
        potentialResponders.push({ npc: postAuthor, reason: 'post author', priority: 1 });
        console.log(`[Chain] 📝 Post author ${postAuthor.name} might respond (60% chance)`);
      }
    }
    
    // 2. NPCs mentioned in the comment - 70% chance
    if (triggerComment.mentionedEmployees && triggerComment.mentionedEmployees.length > 0) {
      for (const mentionedId of triggerComment.mentionedEmployees) {
        const mentioned = activeEmployees.find(e => e.id === mentionedId);
        if (mentioned && Math.random() < 0.7) {
          potentialResponders.push({ npc: mentioned, reason: 'mentioned', priority: 1 });
          console.log(`[Chain] 👋 ${mentioned.name} was mentioned - might respond (70% chance)`);
        }
      }
    }
    
    // 3. NPCs with relationships to trigger NPC - 40% chance for close friends
    const relationships = triggerNPC.relationships || {};
    for (const [empId, rel] of Object.entries(relationships)) {
      const relatedNPC = activeEmployees.find(e => e.id === empId);
      if (relatedNPC && !potentialResponders.find(p => p.npc.id === empId)) {
        const relStrength = rel.strength || 0;
        if (relStrength > 60 && Math.random() < 0.4) {
          potentialResponders.push({ npc: relatedNPC, reason: `friend (${relStrength}/100)`, priority: 2 });
          console.log(`[Chain] 💕 ${relatedNPC.name} is friends with ${triggerNPC.name} - might chime in`);
        }
      }
    }
    
    // 4. Random other NPCs - 20% chance for general workplace banter
    const randomPool = activeEmployees.filter(e => !potentialResponders.find(p => p.npc.id === e.id));
    if (randomPool.length > 0 && Math.random() < 0.2) {
      const random = randomPool[Math.floor(Math.random() * randomPool.length)];
      potentialResponders.push({ npc: random, reason: 'random observer', priority: 3 });
      console.log(`[Chain] 👀 ${random.name} randomly noticed this thread`);
    }
    
    // Limit to 1-2 responders to avoid spam
    potentialResponders.sort((a, b) => a.priority - b.priority);
    potentialResponders = potentialResponders.slice(0, Math.random() < 0.3 ? 2 : 1);
    
    if (potentialResponders.length === 0) {
      console.log(`[Chain] 🚫 No chain reactions triggered`);
      return;
    }
    
    console.log(`[Chain] ✓ ${potentialResponders.length} NPC(s) will respond`);
    
    // Generate responses
    for (const { npc, reason } of potentialResponders) {
      try {
        console.log(`[Chain] 💬 ${npc.name} responding (${reason})...`);
        
        // Build context
        const allComments = post.comments.map(c => {
          const prefix = c.replyToCommentId ? '  ↪ ' : '';
          return `${prefix}${c.authorName}: "${c.content}"`;
        }).join('\n');
        
        const personality = npc.personality || {};
        const relationship = npc.relationships?.[triggerComment.authorId] || { strength: 50, type: 'colleague' };
        
        // Determine tone based on relationship and context
        let tone = 'casual';
        const commentLower = triggerComment.content.toLowerCase();
        
        if (relationship.strength > 70) tone = 'friendly';
        if (relationship.strength < 30) tone = 'snarky';
        if (reason === 'post author') tone = 'engaged'; // It's their post
        if (commentLower.includes('lol') || commentLower.includes('😂')) tone = 'playful';
        if (commentLower.includes('?')) tone = 'helpful'; // Answering a question
        
        // TAGGING: Build list of people this NPC could tag
        let tagContext = '';
        const otherNPCs = activeEmployees.filter(e => e.id !== npc.id);
        
        if (otherNPCs.length > 0 && Math.random() < 0.35) { // 35% chance to suggest tagging
          // Prioritize: trigger comment author, post author, friends
          let taggable = [];
          
          if (triggerNPC.id !== npc.id) {
            taggable.push({ emp: triggerNPC, rel: 'commenter' });
          }
          if (post.authorId && post.authorId !== 'player' && post.authorId !== npc.id && post.authorId !== triggerNPC.id) {
            const postAuth = otherNPCs.find(e => e.id === post.authorId);
            if (postAuth) taggable.push({ emp: postAuth, rel: 'post author' });
          }
          
          // Add 1 friend if available
          const npcRels = npc.relationships || {};
          const friend = otherNPCs.find(e => {
            const rel = npcRels[e.id];
            return rel && rel.strength > 65 && !taggable.find(t => t.emp.id === e.id);
          });
          if (friend) taggable.push({ emp: friend, rel: 'friend' });
          
          if (taggable.length > 0) {
            tagContext = `\n\nOPTIONAL TAGS (use if natural): `;
            taggable.forEach(({ emp, rel }) => {
              tagContext += `@${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${rel}), `;
            });
            tagContext = tagContext.slice(0, -2); // Remove trailing comma
          }
        }
        
        // Detect if other comments used similar patterns (avoid repetition)
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          // Detect common patterns
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/😂|😅|💀|lol|lmao/i.test(c.content)) existingPatterns.push('laughing response');
        });
        
        const diversityNote = existingPatterns.length > 0 
          ? `\n\n⚠️ AVOID THESE PATTERNS (other comments already used them):\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nBe creative and use a DIFFERENT angle or joke structure!`
          : '';
        
        const prompt = `You are ${npc.name}, seeing a comment thread on a personal social network.

ORIGINAL POST:
Author: ${post.authorName}
Content: "${post.content || ''}"

FULL COMMENT THREAD:
${allComments}

${triggerNPC.name} JUST COMMENTED:
"${triggerComment.content}"

YOUR RELATIONSHIP WITH ${triggerNPC.name}:
- Strength: ${relationship.strength}/100
- Type: ${relationship.type}

YOUR PERSONALITY:
- Confidence: ${personality.confidence || 50}/100
- Outgoing: ${personality.outgoing || 50}/100
- Humor: ${personality.humor || 50}/100

WHY YOU'RE RESPONDING: ${reason}
${tagContext}${diversityNote}

INSTRUCTIONS:
Write a brief comment (max 100 characters) responding to ${triggerNPC.name}'s comment. Tone: ${tone}.
${diversityNote ? 'Be ORIGINAL - don\'t copy the joke structure or phrasing of existing comments!' : ''}

${tone === 'friendly' ? '- Be warm and supportive' : ''}
${tone === 'snarky' ? '- Add a sarcastic or teasing edge' : ''}
${tone === 'engaged' ? '- React as the post author - this is YOUR post they\'re discussing' : ''}
${tone === 'playful' ? '- Keep it light and fun' : ''}
${tone === 'helpful' ? '- Be informative or answer implied questions' : ''}
${personality.humor > 60 ? '- Add humor if natural' : ''}
${relationship.strength > 70 ? '- Show familiarity (inside jokes, nicknames okay)' : ''}
${relationship.strength < 30 ? '- Keep it cool or slightly defensive' : ''}
${tagContext ? '- Can @tag people if it feels natural (e.g., "Right @sarah?", "@mike you seeing this?")' : ''}

DO NOT:
- Quote your response
- Exceed 100 characters
- Say "I would comment" or similar meta-text
- Copy the structure or phrasing of other comments

Just write the comment:`;

        const rawResponse = await generateText(prompt, {
          temperature: 0.9,
          max_tokens: 40,
          stopSequences: ['\n\n', 'I would', '(', 'Rating:', '**(']
        });
        console.log(`[Chain] Raw response from ${npc.name}: "${rawResponse}"`);
        
        // Sanitize
        let response = rawResponse.trim()
          .replace(/^["']|["']$/g, '')
          .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '')
          .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, '')
          .replace(/\n\n\(Word count:.*?\)$/i, '')
          .replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '')
          .replace(/\s*\(\d+\s*words?\)\s*$/i, '');
        
        response = response.trim();
        console.log(`[Chain] Sanitized: "${response}"`);
        
        if (response && response.length > 0) {
          const chainComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: triggerComment.id // Reply to the comment that triggered this
          });
          
          post.comments.push(chainComment);
          console.log(`[Chain] ✓ ${npc.name} added to thread: "${response}"`);
          
          // 🌐 Evaluate relationship between chain commenter and original commenter
          if (triggerNPC && triggerNPC.id !== npc.id) {
            evaluateNPCCommentInteraction(npc, triggerNPC, post, triggerComment.content, response);
          }
          
          // 🌐 Also evaluate chain commenter's reaction to the post author
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== npc.id) {
            evaluateNPCReactionToPost(npc, postAuthor, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Chain] Immediately updating comments section after chain reaction`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          requestSmartFeedUpdate(post.id);
          
          // RECURSIVE CHAIN: 30% chance this comment triggers another response
          if (Math.random() < 0.3 && post.comments.length < 10) { // Cap at 10 comments to prevent infinite loops
            console.log(`[Chain] 🔄 ${npc.name}'s comment might trigger another response...`);
            setTimeout(async () => {
              await triggerCommentChainReaction(chainComment, post);
            }, 4000 + Math.random() * 5000); // 4-9 seconds
          }
        }
        
      } catch (error) {
        console.error(`[Chain] ✗ Error generating chain response for ${npc.name}:`, error);
      }
      
      // Stagger multiple responses
      await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
    }
  }
  
  /**
   * Trigger automatic NPC reactions to player posts
   */
  async function triggerAutomaticNPCReactions(post) {
    if (!post || !post.isPlayerPost) return;
    
    // Get all active employees
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Get mentioned employees
    const mentionedEmployeeIds = post.referencedEmployees || [];
    const mentionedEmployees = activeEmployees.filter(e => mentionedEmployeeIds.includes(e.id));
    const nonMentionedEmployees = activeEmployees.filter(e => !mentionedEmployeeIds.includes(e.id));
    
    console.log(`[Social] Post has ${mentionedEmployees.length} mentions`);
    console.log(`[Social] Mentioned employee IDs:`, mentionedEmployeeIds);
    console.log(`[Social] Active employee IDs:`, activeEmployees.map(e => e.id));
    if (mentionedEmployees.length > 0) {
      console.log(`[Social] Matched employees:`, mentionedEmployees.map(e => `${e.name} (${e.id})`));
    }
    
    // HIGH ENGAGEMENT FOR PLAYER POSTS
    // 60-80% of employees will engage (like or comment)
    // Mentioned employees have 85-95% chance to engage!
    const baseEngagementRate = 0.6 + Math.random() * 0.2;
    const mentionedEngagementRate = 0.85 + Math.random() * 0.1;
    const engagers = [];
    
    // Process mentioned employees first (higher engagement)
    for (const emp of mentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.intimacy || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Very high chance for mentioned employees
      const baseChance = mentionedEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.98, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: true });
      }
    }
    
    // Process non-mentioned employees (normal engagement)
    for (const emp of nonMentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.intimacy || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Weight by relationship - higher affection = more likely to engage
      const baseChance = baseEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.95, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: false });
      }
    }
    
    // Split between likers and commenters
    // Mentioned employees: 70-85% will comment (vs 40-60% for others)
    const commenters = [];
    const likers = [];
    
    for (const engager of engagers) {
      const commentRate = engager.mentioned ? (0.7 + Math.random() * 0.15) : (0.4 + Math.random() * 0.2);
      
      if (Math.random() < commentRate) {
        commenters.push(engager.emp);
      } else {
        likers.push(engager.emp);
      }
    }
    
    console.log(`[Social] Player post triggering ${engagers.length} reactions (${commenters.length} comments, ${likers.length} likes)`);
    
    // Add likes with staggered timing
    for (let i = 0; i < likers.length; i++) {
      const npc = likers[i];
      const delay = (1 + i) * (1000 + Math.random() * 2000); // 1-3 seconds each
      
      setTimeout(() => {
        if (!post.likes.includes(npc.id)) {
          post.likes.push(npc.id);
          remember(npc, `I liked the boss's post: "${post.content || 'image post'}"`, 'interaction', 0.5);
          
          if (gameState.activeTab === 'social') {
            renderSocialFeed();
          }
        }
      }, delay);
    }
    
    // Generate meaningful, context-aware comments
    for (let i = 0; i < commenters.length; i++) {
      const npc = commenters[i];
      const delay = (1 + i) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateContextAwareComment(npc, post);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        // Small chance (10%) for this comment to trigger more engagement
        if (post.comments.length >= 3 && Math.random() < 0.10) {
          console.log(`[Social] 🔥 ${npc.name}'s comment sparked more discussion!`);
          setTimeout(async () => {
            await triggerAdditionalNPCComments(post);
          }, 5000 + Math.random() * 6000); // 5-11 seconds delay
        }
        
        // Boost affection slightly for commenting
        if (npc.stats) {
          npc.stats.affection = Math.min(100, (npc.stats.affection || 0) + 1);
        }
        
        remember(npc, `I commented on boss's post: "${commentText}"`, 'interaction', 0.8);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Trigger additional NPCs to join an active conversation
   * Called when a post reaches 3+ comments to reinvigorate discussion
   */
  async function triggerAdditionalNPCComments(post) {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Get NPCs who haven't commented yet
    const alreadyCommented = new Set(
      post.comments
        .filter(c => c.authorId !== 'player')
        .map(c => c.authorId)
    );
    
    const eligibleNPCs = activeEmployees.filter(npc => !alreadyCommented.has(npc.id));
    if (eligibleNPCs.length === 0) return;
    
    console.log(`[Social] 🔄 Reinvigorating conversation on post ${post.id} (${post.comments.length} comments)`);
    
    // 30% chance per eligible NPC, max 2 additional comments
    let additionalComments = 0;
    const maxAdditional = 2;
    
    for (const npc of eligibleNPCs) {
      if (additionalComments >= maxAdditional) break;
      
      // Higher chance if they're friends with someone in the conversation
      let baseChance = 0.30;
      for (const comment of post.comments) {
        if (comment.authorId === 'player') continue;
        const relationship = npc.relationships?.[comment.authorId];
        if (relationship && relationship.strength > 60) {
          baseChance += 0.20; // +20% if friends with a commenter
          break;
        }
      }
      
      if (Math.random() < baseChance) {
        console.log(`[Social] ${npc.name} joining active conversation (${Math.round(baseChance * 100)}% chance)`);
        
        // Generate comment using existing context-aware system
        try {
          const commentText = await generateContextAwareComment(npc, post);
          
          if (commentText) {
            const comment = createComment({
              postId: post.id,
              authorId: npc.id,
              authorName: npc.name,
              content: commentText
            });
            
            post.comments.push(comment);
            additionalComments++;
            
            console.log(`[Social] ✓ ${npc.name} added to conversation: "${commentText}"`);
            
            // Boost affection slightly for commenting
            if (npc.stats) {
              npc.stats.affection = Math.min(100, (npc.stats.affection || 0) + 1);
            }
            
            remember(npc, `I joined a conversation on ${post.isPlayerPost ? "boss's" : "a coworker's"} post: "${commentText}"`, 'interaction', 0.7);
            
            // Update feed
            requestSmartFeedUpdate(post.id);
          }
        } catch (error) {
          console.error(`Error generating reinvigoration comment from ${npc.name}:`, error);
        }
      }
    }
    
    if (additionalComments > 0) {
      console.log(`[Social] 🎉 Added ${additionalComments} new voice(s) to the conversation`);
    }
  }
  
  /**
   * Generate meaningful, context-aware comments on player posts
   * Uses AI to create natural, personality-driven responses
   */
  async function generateContextAwareComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    // Build relationship context
    const relationshipLevel = 
      intimacy > 70 ? 'very intimate' :
      intimacy > 40 ? 'romantically involved' :
      affection > 70 ? 'very close friends' :
      affection > 40 ? 'friendly' :
      affection > 20 ? 'cordial' : 'professional';
    
    // Analyze post content for context
    const content = post.content || '';
    const hasImage = !!post.imageUrl;
    const imageContext = post.imageAlt || '';
    const isExplicit = post.explicitLevel >= 2;
    
    // Build personality description
    const personalityDesc = `flirty: ${personality.flirty || 50}/100, outgoing: ${personality.outgoing || 50}/100, confidence: ${personality.confidence || 50}/100, professional: ${personality.professional || 50}/100`;
    
    // TAGGING LOGIC: Find potential NPCs to tag in comment
    let tagContext = '';
    let potentialTags = [];
    
    // Get other active employees (excluding this one)
    const otherEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employee.id &&
      e.id !== 'player'
    );
    
    if (otherEmployees.length > 0) {
      // Find friends (high relationship strength)
      const relationships = employee.relationships || {};
      const friends = otherEmployees.filter(e => {
        const rel = relationships[e.id];
        return rel && rel.strength > 60;
      }).slice(0, 2); // Max 2 friends
      
      // If post author is an NPC and not this employee, they're a prime target
      const postAuthor = otherEmployees.find(e => e.id === post.authorId);
      
      // Build list of taggable people
      if (postAuthor && !friends.find(f => f.id === postAuthor.id)) {
        potentialTags.push({ employee: postAuthor, reason: 'post author' });
      }
      friends.forEach(f => potentialTags.push({ employee: f, reason: 'friend' }));
      
      // Add 1-2 random others if list is short
      if (potentialTags.length < 2) {
        const randomOthers = otherEmployees
          .filter(e => !potentialTags.find(t => t.employee.id === e.id))
          .sort(() => Math.random() - 0.5)
          .slice(0, 2 - potentialTags.length);
        randomOthers.forEach(e => potentialTags.push({ employee: e, reason: 'coworker' }));
      }
      
      // Build tag context for AI (40% chance to suggest tagging)
      if (potentialTags.length > 0 && Math.random() < 0.4) {
        tagContext = `\n\nOPTIONAL: You can tag coworkers if relevant. Available to tag:\n`;
        potentialTags.forEach(({ employee: emp, reason }) => {
          tagContext += `- @${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${reason})\n`;
        });
        tagContext += `\nOnly tag if it makes sense for the comment (e.g., "Right @sarah?", "@mike needs to see this", "@jessica told me about this"). Don't force it.`;
      }
    }
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    // OPTIMIZED: Short, direct prompt
    const prompt = `${employee.name} comments on ${post.isPlayerPost ? 'boss' : 'coworker'} post: "${content.substring(0, 100)}"
Rel: ${relationshipLevel} (Aff${affection} Des${desire} Int${intimacy})
Personality: ${personalityDesc}
${isExplicit ? 'EXPLICIT' : ''}${tagContext ? '\nCan tag: ' + potentialTags.map(t => '@' + t.employee.name.split(' ')[0]).join(' ') : ''}

Comment (5-20 words, specific to post):`;


    try {
      const response = await generateText(prompt, { 
        temperature: 0.9,
        top_p: 0.95, 
        max_tokens: 40,
        stopSequences: ['\n', 'Boss', 'Personality', 'personality traits', 'Brainstorm', 'Good approach', 'Bad approach', 'Final', '{SEEDS', '{BAN', '{BOOST', '---', 'Word count', 'matches']
      });
      let comment = response.trim();
      
      // CRITICAL: Take first line only
      comment = comment.split('\n')[0].trim();
      
      // Remove quotes
      comment = comment.replace(/^["']|["']$/g, '');
      
      // Remove Perchance tokens
      comment = comment.replace(/\{[A-Z_]+:[^}]*\}/g, '');
      comment = comment.replace(/\s*---\s*/g, ' ');
      
      // Remove name prefixes
      comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*'?s?\s*(?:Comment)?:\s*/g, '');
      
      // If starts with meta-text, use fallback
      if (/^(Boss|Personality|Brainstorm|Good|Bad|Final|The comment)/i.test(comment)) {
        console.warn(`[Context Comment] Meta-text detected: "${comment.substring(0, 50)}"`);
        return generateTemplateComment(employee, post);
      }
      
      return comment || '🔥'; // Fallback
      
    } catch (error) {
      console.error('AI comment generation failed:', error);
      
      // Fallback to contextual templates
      return generateTemplateComment(employee, post);
    }
  }
  
  /**
   * Generate template-based comment as fallback
   */
  function generateTemplateComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    const isExplicit = post.explicitLevel >= 2;
    const hasImage = !!post.imageUrl;
    
    // High intimacy + explicit content
    if (intimacy > 60 && isExplicit && personality.flirty > 60) {
      const comments = ['🥵🥵🥵', 'Boss... wow 😍', 'You\'re dangerous 🔥', 'Stop it I can\'t handle this 👀💕', 'The way you look... damn'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High intimacy
    if (intimacy > 50) {
      const comments = ['You always know how to make my day 😘', 'Obsessed with everything about this 💕', 'The most beautiful person I know', 'Can\'t stop looking at this 😍', 'How are you even real 🔥'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection + flirty
    if (affection > 60 && personality.flirty > 60 && desire > 40) {
      const comments = ['Okay but WHY do you look this good 👀', 'The confidence! I\'m here for it 🔥', 'Serving looks as always 😍', 'This energy >>> everything', 'How do you do this every single time'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection
    if (affection > 50) {
      const comments = ['Love this so much! 💕', 'This just made my whole day better ✨', 'You\'re literally glowing in this 🌟', 'Main character energy right here', 'Absolutely love everything about this'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Moderate relationship
    if (affection > 30) {
      const comments = ['This is such a vibe! 😊', 'Love this! 💙', 'Looking amazing boss! ✨', 'Great post! 🔥', 'Absolutely love it!'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Professional/lower affection
    const comments = ['Great post boss! 👍', 'Love the energy! ✨', 'This is awesome!', 'Really nice! 😊', 'Love it! 💙'];
    return comments[Math.floor(Math.random() * comments.length)];
  }
  
  /**
   * Check for proactive NPC messages
   * NPCs will reach out to the player based on various triggers
   */
  async function checkForProactiveMessages() {
    // Don't send messages too frequently
    if (!gameState.lastProactiveMessageCheck) {
      gameState.lastProactiveMessageCheck = Date.now();
      return;
    }
    
    const timeSinceLastCheck = Date.now() - gameState.lastProactiveMessageCheck;
    if (timeSinceLastCheck < 60000) return; // Min 1 minute between checks
    
    gameState.lastProactiveMessageCheck = Date.now();
    
    // Get eligible NPCs (active employees only)
    const eligibleNPCs = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (eligibleNPCs.length === 0) return;
    
    // Check each NPC for messaging triggers (but limit to 1-2 per check)
    let messagesThisCheck = 0;
    const maxMessagesPerCheck = Math.random() > 0.7 ? 2 : 1;
    
    for (const npc of eligibleNPCs) {
      if (messagesThisCheck >= maxMessagesPerCheck) break;
      
      // Check if this NPC should message the player
      const shouldMessage = await evaluateProactiveMessageTriggers(npc);
      if (shouldMessage) {
        await sendProactiveNPCMessage(npc, shouldMessage.reason, shouldMessage.context);
        messagesThisCheck++;
      }
    }
  }
  
  /**
   * Evaluate if an NPC should send a proactive message 
   * OPTIMIZATION: Skip employees that are already blocked
   */
  async function evaluateProactiveMessageTriggers(npc) {
    // AI Optimization: Skip if already blocked
    if (aiOptimization.blockedProactiveMessages.has(npc.id)) {
      return false;
    }
    
    const now = Date.now();
    
    // Get chat history
    const chatHistory = gameState.chatHistory[npc.id] || [];
    const lastMessage = chatHistory[chatHistory.length - 1];
    const lastMessageTime = lastMessage?.timestamp || 0;
    const hoursSinceLastMessage = (now - lastMessageTime) / (1000 * 60 * 60);
    const minutesSinceLastMessage = (now - lastMessageTime) / (1000 * 60);
    const secondsSinceLastMessage = (now - lastMessageTime) / 1000;
    
    // CRITICAL: Don't interrupt active conversations
    // If ANY message (player or NPC) was sent in the last 5 minutes, consider it an active conversation
    if (minutesSinceLastMessage < 5) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Active conversation (${Math.round(secondsSinceLastMessage)}s since last message)`);
      aiOptimization.blockedProactiveMessages.add(npc.id);
      return false;
    }
    
    // Extra protection: Check for recent player activity specifically
    // If player sent a message in the last 10 minutes, don't send proactive messages
    const lastPlayerMessage = [...chatHistory].reverse().find(msg => msg.isPlayer);
    const timeSincePlayerMessage = lastPlayerMessage?.timestamp ? (now - lastPlayerMessage.timestamp) : Infinity;
    const minutesSincePlayerMessage = timeSincePlayerMessage / (1000 * 60);
    
    if (minutesSincePlayerMessage < 10) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Recent player activity (${Math.round(minutesSincePlayerMessage)} min since player's last message)`);
      aiOptimization.blockedProactiveMessages.add(npc.id);
      return false;
    }
    
    // FIXED: Count consecutive NPC messages since the last player message
    // Prevent NPC from spamming multiple messages without player response
    let consecutiveNPCMessages = 0;
    for (let i = chatHistory.length - 1; i >= 0; i--) {
      if (chatHistory[i].isPlayer) {
        break; // Found the last player message
      }
      if (!chatHistory[i].isPlayer) {
        consecutiveNPCMessages++;
      }
    }
    
    // FIXED: Only block if NPC has sent unreplied messages
    // The old logic incorrectly assumed NPC was always last sender
    if (consecutiveNPCMessages >= 1 && lastMessage && !lastMessage.isPlayer) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Already sent ${consecutiveNPCMessages} unreplied message(s)`);
      aiOptimization.blockedProactiveMessages.add(npc.id);
      return false;
    }
    
    // Get relationship stats
    const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = npc.intimacy || 0;
    const affection = npc.stats?.affection || 0;
    const trust = npc.stats?.trust || 0;
    
    // Higher intimacy/affection = more likely to message
    const baseChance = 0.05; // 5% base chance
    const relationshipBonus = (relationship.level / 100) * 0.15; // Up to +15%
    const intimacyBonus = (intimacy / 100) * 0.20; // Up to +20%
    const timeBonus = Math.min(hoursSinceLastMessage / 24, 0.10); // Up to +10% based on time
    
    const totalChance = baseChance + relationshipBonus + intimacyBonus + timeBonus;
    
    if (Math.random() > totalChance) return false;
    
    // Determine message reason and context
    const reasons = [];
    
    // Work-related messages (always possible)
    reasons.push({ reason: 'work_question', weight: 3, context: 'work' });
    reasons.push({ reason: 'work_update', weight: 2, context: 'work' });
    
    // Personal messages (based on relationship)
    if (affection > 30) {
      reasons.push({ reason: 'casual_chat', weight: 2, context: 'casual' });
    }
    if (affection > 50) {
      reasons.push({ reason: 'sharing_news', weight: 2, context: 'personal' });
    }
    if (trust > 60) {
      reasons.push({ reason: 'asking_advice', weight: 1, context: 'personal' });
    }
    
    // Social media related
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === npc.id && (now - p.timestamp) < 86400000) // Last 24h
      .slice(0, 3);
    if (recentPosts.length > 0) {
      reasons.push({ reason: 'post_followup', weight: 2, context: { type: 'social', post: recentPosts[0] } });
    }
    
    // Flirty/intimate messages (based on intimacy)
    if (intimacy > 40) {
      reasons.push({ reason: 'flirty_message', weight: 1, context: 'flirty' });
    }
    if (intimacy > 70) {
      reasons.push({ reason: 'booty_call', weight: 1, context: 'intimate' });
    }
    
    // Recent events
    const recentEvents = (gameState.companyEvents || [])
      .filter(e => e.involvedEmployees?.includes(npc.id) && (now - e.timestamp) < 86400000)
      .slice(0, 2);
    if (recentEvents.length > 0) {
      reasons.push({ reason: 'event_reaction', weight: 2, context: { type: 'event', event: recentEvents[0] } });
    }
    
    // Weighted random selection
    const totalWeight = reasons.reduce((sum, r) => sum + r.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const reasonObj of reasons) {
      random -= reasonObj.weight;
      if (random <= 0) {
        return reasonObj;
      }
    }
    
    return reasons[0]; // Fallback
  }
  
  /**
   * Send a proactive message from NPC to player
   */
  async function sendProactiveNPCMessage(npc, reason, context) {
    try {
      // Get personality and relationship info
      const personality = npc.personality || {};
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.intimacy || 0;
      const affection = npc.stats?.affection || 0;
      
      // Build message prompt
      let messageContext = '';
      if (typeof context === 'string') {
        messageContext = context;
      } else if (context.type === 'social' && context.post) {
        messageContext = `Recent post: "${context.post.content || ''}"`;
      } else if (context.type === 'event' && context.event) {
        messageContext = `Recent event: ${context.event.description}`;
      }
      
      // Get recent conversation for context
      const chatHistory = (gameState.chatHistory[npc.id] || []).slice(-5)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      // NEW: Track recent message types for variety
      if (!npc.recentMessageTypes) npc.recentMessageTypes = [];
      const recentTypes = npc.recentMessageTypes.slice(0, 5).join(', ');
      
      // NEW: Get player description for context
      const playerDesc = getPlayerDescription('conversation');
      const playerContextNote = playerDesc !== 'the boss' ? `\n\n👤 BOSS INFO:\n${playerDesc}` : '';
      
      // NEW: Get gossip context for spicy conversations
      const gossipText = getGossipContext(npc.id, true);
      const gossipNote = gossipText ? `\n\n${gossipText}` : '';
      
      // NEW: Time of day affects message style
      const hour = new Date().getHours();
      let timeContext = '';
      if (hour >= 6 && hour < 12) {
        timeContext = 'It\'s morning. Messages can be about starting the day, morning mood, coffee, etc.';
      } else if (hour >= 12 && hour < 17) {
        timeContext = 'It\'s afternoon. Messages can be about work progress, lunch, midday thoughts.';
      } else if (hour >= 17 && hour < 22) {
        timeContext = 'It\'s evening. Messages can be about wrapping up work, evening plans, relaxing.';
      } else {
        timeContext = 'It\'s late night. Messages can be casual, personal, or about being up late.';
      }
      
      // MASSIVELY ENHANCED PROMPT with personality-driven variety
      const prompt = `You are ${npc.name}, initiating a conversation with your boss (@TheBoss).

YOUR PERSONALITY:
- Confidence: ${personality.confidence || 50}/100
- Flirtiness: ${personality.flirty || 50}/100
- Outgoing: ${personality.outgoing || 50}/100
- Professional: ${personality.professional || 50}/100
- Humor: ${personality.humor || 50}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}
${npc.position ? `- Job: ${npc.position}` : ''}

YOUR RELATIONSHIP:
- Affection: ${affection}/100 ${affection > 70 ? '(very close)' : affection > 40 ? '(friendly)' : '(professional)'}
- Intimacy: ${intimacy}/100 ${intimacy > 60 ? '(intimate/romantic)' : intimacy > 30 ? '(comfortable)' : '(reserved)'}
- Type: ${relationship.type || 'professional'}${playerContextNote}${gossipNote}

CONTEXT:
- Reason: ${reason}
- ${messageContext || 'No specific context'}
- ${timeContext}
${chatHistory ? `\nRECENT CHAT:\n${chatHistory}` : '\nNo recent conversation'}

${recentTypes ? `\n⚠️ VARIETY: Your recent message types: ${recentTypes}\nWrite something DIFFERENT this time - new angle, different tone, fresh approach!` : ''}

📝 MESSAGE STYLE GUIDE BY REASON:

**work_question**: NOT "Can we discuss the implementation timeline?" - Too robotic!
INSTEAD: Ask genuine questions that show personality:
- "Quick q - do you prefer morning meetings or afternoon? 🤔"
- "Need your input on something when you have a sec"
- "Hey, what's your take on [specific thing]?"
- "Random work thought - mind if I run something by you?"
${personality.humor > 60 ? '- Add humor if it fits your personality!' : ''}

**work_update**: NOT "Project completed successfully" - Too corporate!
INSTEAD: Share updates like a real person:
- "Just crushed that deadline 💪"
- "Update: thing you asked about is done!"
- "FYI - wrapped up early on [project]"
- "Quick win today, thought you'd want to know 🎉"
${affection > 50 ? '- Show enthusiasm if you like the boss!' : ''}

**casual_chat**: NOT "Just checking in" - Too generic!
INSTEAD: Be genuinely casual and varied:
- "Hey! How's your day going?"
- "Random thought: [something interesting]"
- "Saw something that made me think of you"
- "Quick break from work - what are you up to?"
- Time-appropriate: morning coffee check-ins, afternoon energy, evening plans
${personality.humor > 70 ? '- Share funny observations!' : ''}
${intimacy > 50 ? '- Can be more personal and friendly' : ''}

**sharing_news**: NOT "I wanted to share some news" - Be specific!
INSTEAD: Actually share something interesting:
- "Dude, you won't believe what just happened 😅"
- "Okay so [specific thing] just went down"
- "Fun fact I just learned: [something relevant]"
- "This is wild - [share actual news/event]"
${npc.hobbies ? '- Reference your hobbies naturally' : ''}

**asking_advice**: NOT "Could I get your advice?" - Too formal!
INSTEAD: Ask naturally and specifically:
- "Quick dilemma - [specific situation]?"
- "Need a second opinion on something"
- "What would you do if [specific scenario]?"
- "Honest question: [actual question]"
${affection > 60 ? '- Can ask personal advice, not just work' : ''}

**post_followup**: Reference YOUR OWN post naturally:
- "Did you see my post about [topic]? 📱"
- "Posted something earlier that made me think of you"
- "That post got more attention than I expected lol"
- NOT: "I saw you liked my post" (unless context specifically says boss liked it!)

**flirty_message**: ${intimacy > 40 ? 'You can be subtly flirty' : 'Keep it light and playful'}:
- "Hey you 😊"
- "Been thinking about you"
- "Miss talking to you"
- ${intimacy > 60 ? 'Be playful with what they are doing' : 'Light compliments work well'}
${personality.flirty > 70 ? '- Be bolder based on your personality' : '- Keep it subtle and tasteful'}

**booty_call**: ${intimacy > 60 ? 'Be direct but playful' : 'Suggest hanging out casually'}:
- ${intimacy > 70 ? 'Can be direct about tonight' : 'Suggest drinks or hanging out'}
- ${intimacy > 80 ? 'Be flirty and suggestive' : 'Keep it casual'}
- ${intimacy > 60 ? 'Show interest romantically' : 'Friendly hangout vibes'}

**event_reaction**: React naturally to what happened:
- "So about [event] 😅"
- "That was [emotion]!"
- "Can we talk about what just happened?"
- Be specific to the actual event

🎯 TONE GUIDELINES:
${personality.confidence > 70 ? '✓ Be direct and bold' : '✓ Be thoughtful and considerate'}
${personality.outgoing > 70 ? '✓ Be enthusiastic and expressive' : '✓ Be calm and measured'}
${personality.professional > 70 ? '✓ Keep it polished but warm' : '✓ Be casual and relaxed'}
${personality.humor > 70 ? '✓ Add wit and humor' : '✓ Keep it sincere'}
${intimacy > 60 ? '✓ Can be personal and intimate' : intimacy > 30 ? '✓ Friendly and comfortable' : '✓ Professional but friendly'}
${affection > 70 ? '✓ Show warmth and care' : affection > 40 ? '✓ Be friendly' : '✓ Keep it respectful'}

RULES:
- Max 200 characters
- Use 0-2 emojis (use naturally, not forced)
- NO quotation marks
- NO "I would say" or meta-commentary
- NO formal business-speak
- BE SPECIFIC not generic
- SHOW personality
- DON'T invent boss actions not in context
- Sound like an actual person texting

Write ONLY the message:`;

      // Generate message
      const rawMessage = await generateText(prompt, {
        temperature: 0.9,
        max_tokens: 50,
        stopSequences: ['\n\n', '(Character', '(Emojis', '(Approach', 'Note:', '**Note', '---', 'Rating:']
      });
      let message = sanitizeNpcResponse(rawMessage, 2).trim();
      
      // Additional meta-commentary stripping for DMs
      message = message.split(/\(Character count:/)[0];
      message = message.split(/\(Emojis used:/)[0];
      message = message.split(/\(Approach:/)[0];
      message = message.trim();
      
      if (!message || message.length > 150) return; // Safety check
      
      // Track message type for variety
      npc.recentMessageTypes.unshift(reason);
      if (npc.recentMessageTypes.length > 10) {
        npc.recentMessageTypes = npc.recentMessageTypes.slice(0, 10);
      }
      
      // Add to chat history
      if (!gameState.chatHistory[npc.id]) {
        gameState.chatHistory[npc.id] = [];
      }
      
      gameState.chatHistory[npc.id].push({
        sender: npc.name,
        content: message,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Mark as unread
      if (!npc.unreadMessages) npc.unreadMessages = 0;
      npc.unreadMessages++;
      
      // Store in memory
      remember(npc, `I messaged the boss: "${message}"`, 'interaction', 1);
      
      // Update People tab if visible
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // If chat is currently open for this NPC, show the message
      if (gameState.activeChat?.id === npc.id && chatMessages) {
        const messageIndex = gameState.chatHistory[npc.id].length - 1;
        addChatMessage(npc.name, message, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        npc.unreadMessages = 0; // Already reading it
      }
      
    } catch (error) {
      console.error('Error sending proactive NPC message:', error);
    }
  }
  
  // Update news feed
  function updateNewsFeed() {
    if (!newsFeed) return;
    
    // Ensure news array exists (backwards compatibility with old saves)
    if (!gameState.news || !Array.isArray(gameState.news)) {
      gameState.news = [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ];
    }
    
    newsFeed.innerHTML = '';
    gameState.news.forEach((newsItem, index) => {
      const newsItemEl = document.createElement('div');
      newsItemEl.className = 'news-item';
      newsItemEl.style.cssText = 'background:#16213e; border-radius:8px; padding:12px; margin-bottom:10px;';
      
      newsItemEl.innerHTML = `
        <p style="margin:0;">${newsItem}</p>
        <p style="margin:5px 0 0 0; font-size:0.8rem; color:#aaa;">${new Date().toLocaleDateString()}</p>
      `;
      
      newsFeed.appendChild(newsItemEl);
    });
  }
  
  // Game tick - main update loop
  /**
   * Gradually adjust employee spending rates to match company growth
   * Called periodically from gameTick to simulate lifestyle creep
   */
  function adjustEmployeeLifestyles() {
    // Calculate target spending rate for company scale
    const targetBaseRate = 50 + Math.random() * 100; // Random base for reference
    const targetScaledRate = calculateScaledSpendingRate(targetBaseRate);
    const companyScale = targetScaledRate / targetBaseRate; // Get the multiplier
    
    gameState.employees.forEach(emp => {
      if (!emp.spendingRate) {
        // Initialize with company-scaled rate
        emp.spendingRate = calculateScaledSpendingRate();
        return;
      }
      
      // Calculate what their "natural" base rate would be (reverse engineer)
      const estimatedBaseRate = emp.spendingRate / Math.max(1, companyScale / 1.5);
      
      // Calculate new target rate for current company scale
      const newTargetRate = calculateScaledSpendingRate(estimatedBaseRate);
      
      // Gradually adjust toward target (move 5% closer each adjustment)
      // This creates smooth lifestyle creep as company grows
      const adjustment = (newTargetRate - emp.spendingRate) * 0.05;
      
      // Only adjust if difference is significant (> $1/day)
      if (Math.abs(adjustment) > 1) {
        emp.spendingRate += adjustment;
        
        // Ensure minimum and maximum bounds
        emp.spendingRate = Math.max(50, Math.min(50000, emp.spendingRate));
      }
    });
  }

  function gameTick() {
    const dt = GAME_TICK_INTERVAL;
    
    // PHASE 4: Update game time
    updateGameTime(dt);

    gameState.products.forEach(p => {
      // Only process unlocked products
      if (!p.unlocked) return;
      
      // Check if constant stream - optimize calculation
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      
      if (isConstantStream) {
        // Constant stream optimization: direct cash calculation, no cycle tracking
        // Calculate earnings for this tick based on cycle rate
        const earningsPerMs = currentValue(p) / cycleTime;
        const tickEarnings = earningsPerMs * dt;
        
        // Apply prestige income multiplier
        const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
        const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
        const finalEarnings = tickEarnings * prestigeMultiplier;
        
        gameState.cash += finalEarnings;
        gameState.totalEarnings += finalEarnings;
        gameState.lifetimeEarnings += finalEarnings; // Track for prestige
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + finalEarnings; // Track THIS prestige only
        
        // Keep running flag true but don't update timeRemaining (not needed)
        p.running = true;
        
        // Skip rest of normal processing
        return;
      }
      
      // Normal product processing (non-constant)
      if (p.running) {
        p.timeRemainingMs -= dt;

        if (p.timeRemainingMs <= 0) {
          // payout
          const payout = currentValue(p);
          
          // Apply prestige income multiplier
          const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
          const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
          const finalPayout = payout * prestigeMultiplier;
          
          gameState.cash += finalPayout;
          gameState.totalEarnings += finalPayout;
          gameState.lifetimeEarnings += finalPayout; // Track for prestige
          gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + finalPayout; // Track THIS prestige only

          if (p.managerHired) {
            // keep cycling under manager
            p.running = true;
            p.timeRemainingMs = cycleTime;
          } else {
            // stop and instantly sync Sell label for responsiveness
            p.running = false;
            p.timeRemainingMs = 0;
            const sellTxt = $(`selltxt-${p.id}`);
            if (sellTxt) sellTxt.textContent = 'Sell';
          }
        }
      } else if (p.managerHired) {
        // manager auto-starts if idle
        p.running = true;
        p.timeRemainingMs = cycleTime;
      }
    });
    
    // Autonomous social feed generation (runs in background)
    autonomousPostGeneration().catch(err => {
      console.error('Autonomous post generation error:', err);
    });

    // Periodic lifestyle adjustment - employees gradually adopt company-scaled spending
    // Only update every ~10 ticks to avoid excessive calculations
    if (!gameState.lifestyleAdjustmentCounter) gameState.lifestyleAdjustmentCounter = 0;
    gameState.lifestyleAdjustmentCounter++;
    
    if (gameState.lifestyleAdjustmentCounter >= 10) {
      gameState.lifestyleAdjustmentCounter = 0;
      adjustEmployeeLifestyles();
    }

    // ========== CORPORATE HIERARCHY: PROMOTION CHECKING ==========
    // Check for promotions every ~30 ticks (roughly every 3 seconds)
    // Auto-promotion check disabled - promotions now manual via Corporate Pyramid
    // if (!gameState.promotionCheckCounter) gameState.promotionCheckCounter = 0;
    // gameState.promotionCheckCounter++;
    
    // if (gameState.promotionCheckCounter >= 30) {
    //   gameState.promotionCheckCounter = 0;
    //   checkForPromotions();
    // }

    // UI refresh (lightweight progress updates recommended)
    updateUI();
  }
  
  // Update UI elements
  function updateUI() {
    // top bar - enhanced cash display
    if (cashEl) {
      const cashStyle = formatCashDisplay(gameState.cash);
      cashEl.textContent = cashStyle.displayText;
      cashEl.style.fontSize = cashStyle.fontSize;
      cashEl.style.color = cashStyle.color;
      cashEl.style.textShadow = cashStyle.textShadow;
      cashEl.style.animation = cashStyle.animation;
      cashEl.style.fontWeight = 'bold';
      cashEl.style.transition = 'all 0.3s ease';
    } else {
      console.warn('cashEl is null in updateUI()');
    }
    if (cashPerSecEl) cashPerSecEl.textContent = formatNumber(calculateCashPerSecond());
    if (employeeCountEl) employeeCountEl.textContent = gameState.employees.length;

    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    if (productCountEl) productCountEl.textContent = unlockedProducts;

    // only refresh progress bars/text in Business tab for smoothness
    if (gameState.activeTab === 'business') {
      updateProductProgressBars();
    }
    
    // Update prestige UI in real-time if on Invest tab
    if (gameState.activeTab === 'invest') {
      updatePrestigeUI();
    }
    
    // Update dashboard in real-time if on Dashboard tab
    if (gameState.activeTab === 'dashboard') {
      updateDashboard();
    }
  }
  
  // Calculate cash per second
  function calculateCashPerSecond() {
    let total = 0;
    gameState.products.forEach(p => {
      // Only count unlocked products
      if (!p.unlocked) return;
      
      const cycleTime = currentCycleTimeMs(p);
      // if running or managed, include it; otherwise 0
      if (p.running || p.managerHired) {
        total += currentValue(p) / (cycleTime / 1000);
      }
    });
    
    // Apply prestige multipliers
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    total *= prestigeMultiplier;
    
    return total; // Return raw number, format at display time
  }

  // ============================================
  // GLOBAL UPGRADES (UPGRADES TAB)
  // ============================================
  
  function buyClickPower() {
    const level = gameState.globalUpgrades.clickPower;
    const baseCost = gameBalance.upgradeBaseCosts.clickPower;
    const cost = Math.floor(baseCost * Math.pow(2.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.clickPower += 1;
    
    const newEffect = 1.0 + (gameState.globalUpgrades.clickPower * 0.1);
    showNotification(`Click Power upgraded! Now -${newEffect.toFixed(1)}s per click`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyIncomeBoost(locationId) {
    const level = gameState.globalUpgrades.incomeBoost[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.incomeBoost;
    const cost = Math.floor(baseCost * Math.pow(2.5, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.incomeBoost[locationId] = level + 1;
    
    // Calculate new bonus with diminishing returns formula
    const newBonus = (1 - Math.pow(0.9, level + 1)) * 100;
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} income boost upgraded! Now +${newBonus.toFixed(1)}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyCostReduction(locationId) {
    const level = gameState.globalUpgrades.costReduction[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.costReduction;
    const cost = Math.floor(baseCost * Math.pow(3.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.costReduction[locationId] = level + 1;
    
    // Calculate new reduction with diminishing returns formula (max 90%)
    const newReduction = (1 - Math.pow(0.9, level + 1)) * 90;
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} cost reduction upgraded! Now -${newReduction.toFixed(1)}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  // ============================================
  // BOSS FIGHT SYSTEM
  // ============================================
  
  let bossFightState = null;
  let bossFightInterval = null;
  
  // Boss image preloading system
  // Store preloaded images: { locationId: { attemptCount: number, imageUrl: string, isGenerating: boolean } }
  let preloadedBossImages = {};
  
  /**
   * Preload boss fight image for a location
   * Each attempt gets a unique image (attemptCount increments on defeat)
   */
  async function preloadBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss || typeof generateImage !== 'function') return;
    
    // Get attempt count for this boss
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    
    // Check if already generating or already cached for this attempt
    const cached = preloadedBossImages[locationId];
    if (cached) {
      if (cached.isGenerating) {
        console.log(`Boss image for ${locationId} is already being generated`);
        return;
      }
      if (cached.attemptCount === attemptCount && cached.imageUrl) {
        console.log(`Using preloaded boss image for ${locationId} (attempt ${attemptCount})`);
        return;
      }
    }
    
    console.log(`Preloading boss image for ${locationId} (attempt ${attemptCount})...`);
    
    // Mark as generating to prevent duplicate calls
    if (!preloadedBossImages[locationId]) {
      preloadedBossImages[locationId] = {};
    }
    preloadedBossImages[locationId].isGenerating = true;
    
    try {
      // Add variety to prompt with attempt count
      const varietyModifiers = [
        '', // base prompt
        ', different angle',
        ', different lighting',
        ', different pose',
        ', alternative style',
        ', dramatic lighting',
        ', cinematic angle',
        ', professional photography'
      ];
      const modifier = varietyModifiers[attemptCount % varietyModifiers.length];
      const imageUrl = await generateImage(applyImageStyle(boss.appearance.prompt + modifier));
      
      if (imageUrl) {
        preloadedBossImages[locationId].attemptCount = attemptCount;
        preloadedBossImages[locationId].imageUrl = imageUrl;
        preloadedBossImages[locationId].isGenerating = false;
        console.log(`Boss image preloaded successfully for ${locationId}`);
      } else {
        preloadedBossImages[locationId].isGenerating = false;
      }
    } catch (error) {
      console.error(`Failed to preload boss image for ${locationId}:`, error);
      preloadedBossImages[locationId].isGenerating = false;
    }
  }
  
  /**
   * Get preloaded boss image or return null
   */
  function getPreloadedBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return null;
    
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    const cached = preloadedBossImages[locationId];
    
    if (cached && cached.attemptCount === attemptCount && cached.imageUrl) {
      return cached.imageUrl;
    }
    return null;
  }
  
  /**
   * Check if we should preload boss image (when last product unlocked)
   * ONLY CALLED ONCE when unlocking products
   */
  function checkAndPreloadBossImage(locationId) {
    // Count unlocked products in this location
    const locationProducts = gameState.products.filter(p => p.locationId === locationId);
    const unlockedCount = locationProducts.filter(p => p.unlocked).length;
    
    // If all products unlocked, preload boss image ONCE
    if (unlockedCount === locationProducts.length && locationProducts.length > 0) {
      const boss = bossFightConfig[locationId];
      if (boss && !gameState.bossFights.defeated.includes(boss.id)) {
        const cached = preloadedBossImages[locationId];
        // Only preload if not already cached or generating
        if (!cached || (!cached.imageUrl && !cached.isGenerating)) {
          preloadBossImage(locationId);
        }
      }
    }
  }
  
  /**
   * Check if player meets requirements to attempt boss fight
   */
  function checkBossFightRequirements(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return { canAttempt: false, reasons: ['No boss configured for this location'] };
    
    // Check if already defeated
    if (gameState.bossFights.defeated.includes(boss.id)) {
      return { canAttempt: false, reasons: ['Boss already defeated'] };
    }
    
    const clickPowerLevel = gameState.globalUpgrades.clickPower;
    const incomePerSec = parseFloat(calculateCashPerSecond());
    
    // Always allow attempting, but show recommendations
    const warnings = [];
    
    if (clickPowerLevel < boss.recommendedClickPower) {
      warnings.push(`⚠️ Level ${boss.recommendedClickPower} Click Power recommended (you have ${clickPowerLevel})`);
    }
    
    if (incomePerSec < boss.recommendedIncome) {
      warnings.push(`⚠️ $${formatNumber(boss.recommendedIncome)}/sec recommended (you have $${formatNumber(incomePerSec)}/sec)`);
    }
    
    return { canAttempt: true, reasons: warnings, boss };
  }
  
  /**
   * Start a boss fight
   */
  async function startBossFight(locationId) {
    const check = checkBossFightRequirements(locationId);
    
    if (!check.canAttempt) {
      showNotification(`Cannot start boss fight: ${check.reasons.join(', ')}`);
      return;
    }
    
    const boss = check.boss;
    const clickPowerLevel = gameState.globalUpgrades.clickPower || 0;
    const incomePerSec = calculateCashPerSecond() || 0;
    
    console.log('[Boss Fight] Starting calculations:', {
      clickPowerLevel,
      incomePerSec,
      employeeCount: gameState.employees.length
    });
    
    // Calculate team power from employees
    const employees = gameState.employees || [];
    const employeeCount = employees.length;
    
    // Each employee contributes based on their relationship stats
    let teamPower = 0;
    employees.forEach(emp => {
      const trust = emp.trust || 0;
      const friendship = emp.friendship || 0;
      const desire = emp.desire || 0;
      const avgRelationship = (trust + friendship + desire) / 3;
      // Each employee adds a flat damage bonus based on their relationship (more impactful)
      // Base: Each employee = +2% damage
      // Relationship bonus: Up to +3% more at 100 relationship
      const employeeBonus = 2.0 + (avgRelationship * 0.03);
      teamPower += employeeBonus;
    });
    
    // Calculate player attack:
    // Base: Click power still matters (10 damage per level)
    // Income multiplier: Income/sec provides massive boost (0.5 damage per $/sec)
    // Team multiplier: Each employee provides ~2-5% damage bonus
    const baseAttack = 50 + (clickPowerLevel * 10); // Base + click power
    const incomeBonus = incomePerSec * 0.5; // 50% of income/sec as damage
    const teamMultiplier = 1.0 + (teamPower / 100); // Team power directly converts to % bonus
    
    const totalAttack = (baseAttack + incomeBonus) * teamMultiplier;
    
    console.log('[Boss Fight] Damage calculation:', {
      baseAttack,
      incomeBonus,
      teamPower,
      teamMultiplier,
      totalAttack
    });
    
    // Ensure totalAttack is a valid number
    if (isNaN(totalAttack) || !isFinite(totalAttack)) {
      console.error('[Boss Fight] Invalid total attack calculated!', {
        baseAttack,
        incomeBonus,
        teamMultiplier
      });
      showNotification('Error calculating combat stats. Please check console.', 'error');
      return;
    }
    
    // Initialize boss fight state
    bossFightState = {
      boss: boss,
      locationId: locationId,
      bossHealth: boss.health,
      bossMaxHealth: boss.health,
      playerStamina: 100,
      playerMaxStamina: 100,
      playerAttack: totalAttack,
      playerDefense: incomePerSec, // Income/sec acts as defense/regen
      teamPower: teamPower, // Store for display
      employeeCount: employeeCount,
      timeRemaining: 60, // 60 second fight
      combatLog: [],
      damageDealt: 0,
      damageReceived: 0
    };
    
    // Show modal
    const modal = document.getElementById('bossFightModal');
    console.log('Opening boss fight modal:', modal);
    console.log('Modal current state - hidden:', modal?.hidden, 'display:', modal?.style.display);
    
    if (modal) {
      modal.hidden = false;
      modal.style.display = 'flex';
      console.log('Modal new state - hidden:', modal.hidden, 'display:', modal.style.display);
    } else {
      console.error('Boss fight modal element not found!');
    }
    
    // Update UI elements
    document.getElementById('bossName').textContent = boss.name;
    document.getElementById('bossTitle').textContent = boss.title;
    document.getElementById('bossDescription').textContent = boss.description;
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.intro}"`;
    document.getElementById('playerAttack').textContent = Math.floor(bossFightState.playerAttack) || 0;
    document.getElementById('playerDefense').textContent = formatNumber(bossFightState.playerDefense);
    const teamBonusPct = (teamMultiplier - 1.0) * 100;
    document.getElementById('playerTeamPower').textContent = `+${teamBonusPct.toFixed(1)}%`;
    document.getElementById('playerTeamCount').textContent = employeeCount || 0;
    
    // Use preloaded image if available, otherwise show placeholder
    const preloadedImage = getPreloadedBossImage(locationId);
    const bossImageEl = document.getElementById('bossImage');
    const placeholderEl = document.getElementById('bossImagePlaceholder');
    
    if (preloadedImage) {
      // Use preloaded image immediately
      bossImageEl.src = preloadedImage;
      bossImageEl.style.display = 'block';
      placeholderEl.style.display = 'none';
      console.log('Using preloaded boss image');
    } else {
      // Show placeholder while generating
      placeholderEl.style.display = 'flex';
      bossImageEl.style.display = 'none';
      
      // Generate new image asynchronously
      if (typeof generateImage === 'function') {
        generateImage(applyImageStyle(boss.appearance.prompt)).then(imageUrl => {
          if (imageUrl && bossFightState) { // Only update if fight still active
            bossImageEl.src = imageUrl;
            bossImageEl.style.display = 'block';
            placeholderEl.style.display = 'none';
          }
        }).catch(error => {
          console.error('Boss image generation failed:', error);
        });
      }
    }
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '<div style="color:#00d4ff;">⚔️ Combat begins!</div>';
    
    // Start fight timer (boss attacks every 3 seconds)
    let lastBossAttack = Date.now();
    bossFightInterval = setInterval(() => {
      if (!bossFightState) {
        clearInterval(bossFightInterval);
        return;
      }
      
      // Countdown timer
      bossFightState.timeRemaining -= 1;
      document.getElementById('bossTimeRemaining').textContent = bossFightState.timeRemaining;
      
      // Player regenerates stamina based on defense
      const regenAmount = (bossFightState.playerDefense / 100) * 0.5; // 0.5% of defense per second
      bossFightState.playerStamina = Math.min(100, bossFightState.playerStamina + regenAmount);
      updateBossFightUI();
      
      // Boss attacks every 3 seconds
      if (Date.now() - lastBossAttack >= 3000) {
        bossFightBossAttack();
        lastBossAttack = Date.now();
      }
      
      // Check time limit
      if (bossFightState.timeRemaining <= 0) {
        bossFightDefeat('Time ran out!');
      }
      
      // Check player stamina
      if (bossFightState.playerStamina <= 0) {
        bossFightDefeat('Your stamina depleted!');
      }
    }, 1000);
    
    // Log fight start
    addToCombatLog(`🎯 Facing ${boss.name}!`, '#00d4ff');
  }
  
  /**
   * Player attacks boss
   */
  function bossFightAttack() {
    if (!bossFightState) return;
    
    const damage = bossFightState.playerAttack + (Math.random() * 50 - 25); // ±25 variance
    bossFightState.bossHealth -= damage;
    bossFightState.damageDealt += damage;
    
    // Occasionally show team support messages (20% chance)
    const showTeamSupport = Math.random() < 0.2 && bossFightState.employeeCount > 0;
    
    if (showTeamSupport) {
      const teamMessages = [
        `💪 Your team rallies behind you! ${Math.floor(damage)} damage!`,
        `🤝 Your employees boost your attack! ${Math.floor(damage)} damage!`,
        `⭐ Team synergy! ${Math.floor(damage)} damage!`,
        `👥 Your staff empowers your strike! ${Math.floor(damage)} damage!`,
        `✨ United effort! ${Math.floor(damage)} damage!`
      ];
      addToCombatLog(teamMessages[Math.floor(Math.random() * teamMessages.length)], '#ff6b9d');
    } else {
      // Normal attack message
      addToCombatLog(`⚔️ You attack for ${Math.floor(damage)} damage!`, '#e94560');
    }
    
    // Update UI
    updateBossFightUI();
    
    // Check if boss defeated
    if (bossFightState.bossHealth <= 0) {
      bossFightVictory();
      return;
    }
    
    // Update dialogue at 50% health
    if (bossFightState.bossHealth <= bossFightState.bossMaxHealth * 0.5 && bossFightState.bossHealth + damage > bossFightState.bossMaxHealth * 0.5) {
      document.getElementById('bossDialogue').textContent = `"${bossFightState.boss.dialogue.mid}"`;
    }
  }
  
  /**
   * Boss attacks player
   */
  function bossFightBossAttack() {
    if (!bossFightState) return;
    
    const damage = 25 + (Math.random() * 15); // 25-40 stamina damage
    bossFightState.playerStamina -= damage;
    bossFightState.damageReceived += damage;
    
    addToCombatLog(`💥 ${bossFightState.boss.name} strikes! -${Math.floor(damage)} stamina`, '#ff6b9d');
    
    updateBossFightUI();
    
    // Check if player defeated
    if (bossFightState.playerStamina <= 0) {
      bossFightDefeat('Your stamina was depleted!');
    }
  }
  
  /**
   * Update boss fight UI
   */
  function updateBossFightUI() {
    if (!bossFightState) return;
    
    const bossHealthPct = Math.max(0, (bossFightState.bossHealth / bossFightState.bossMaxHealth) * 100);
    const playerStaminaPct = Math.max(0, bossFightState.playerStamina);
    
    document.getElementById('bossHealthBar').style.width = `${bossHealthPct}%`;
    document.getElementById('bossHealthText').textContent = `${Math.floor(bossHealthPct)}%`;
    
    document.getElementById('playerStaminaBar').style.width = `${playerStaminaPct}%`;
    document.getElementById('playerStaminaText').textContent = `${Math.floor(playerStaminaPct)}%`;
  }
  
  /**
   * Add message to combat log
   */
  function addToCombatLog(message, color = '#ddd') {
    const log = document.getElementById('combatLog');
    const entry = document.createElement('div');
    entry.style.color = color;
    entry.style.marginBottom = '5px';
    entry.textContent = message;
    log.appendChild(entry);
    
    // Auto-scroll to bottom
    log.scrollTop = log.scrollHeight;
    
    // Keep log reasonable size
    if (log.children.length > 20) {
      log.removeChild(log.firstChild);
    }
  }
  
  /**
   * Player defeats boss - Victory!
   */
  function bossFightVictory() {
    if (!bossFightState) return;
    
    // Prevent multiple victory calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const reward = bossFightState.bossMaxHealth * boss.rewardMultiplier;
    
    // Record victory in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'victory',
      timestamp: Date.now()
    });
    
    // Award rewards
    gameState.cash += reward;
    gameState.bossFights.defeated.push(boss.id);
    
    // Unlock location
    const location = gameState.locations.find(loc => loc.id === bossFightState.locationId);
    if (location) {
      location.unlocked = true;
      location.owned = true;
      
      // Unlock first product in location
      const firstProduct = gameState.products.find(p => p.locationId === location.id && p.unlockCost === 0);
      if (firstProduct) {
        firstProduct.unlocked = true;
      }
    }
    
    // Update UI
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.victory}"`;
    addToCombatLog(`🎉 VICTORY! Earned $${formatNumber(reward)}!`, '#FFD700');
    addToCombatLog(`✅ ${location.name} unlocked!`, '#4ecca3');
    
    // Disable attack button
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').textContent = '✅ VICTORY';
    document.getElementById('attackBtn').style.background = '#4ecca3';
    
    // Change retreat to close
    document.getElementById('retreatBtn').textContent = '🎉 Continue';
    document.getElementById('retreatBtn').style.background = '#00d4ff';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Save victory
    saveGame();
    
    // Refresh dashboard to show boss progress update
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    showNotification(`${boss.name} defeated! ${location.name} unlocked!`);
  }
  
  /**
   * Boss defeats player
   */
  function bossFightDefeat(reason) {
    if (!bossFightState) return;
    
    // Prevent multiple defeat calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const locationId = bossFightState.locationId;
    
    // Record defeat in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'defeat',
      timestamp: Date.now()
    });
    
    addToCombatLog(`💀 DEFEAT: ${reason}`, '#e94560');
    addToCombatLog('Try upgrading your Click Power and Income!', '#aaa');
    addToCombatLog('💡 A new challenger awaits your return...', '#ffa726');
    
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').style.opacity = '0.5';
    document.getElementById('retreatBtn').textContent = 'Close';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Clear cached image so a new one will be generated on retry
    if (preloadedBossImages[locationId]) {
      delete preloadedBossImages[locationId];
    }
    // Preload new image for retry ONCE (each defeat gets a different image)
    setTimeout(() => preloadBossImage(locationId), 1000);
    
    showNotification('Defeated! Upgrade and try again.');
  }
  
  /**
   * Player retreats from fight
   */
  function bossFightRetreat() {
    if (!bossFightState) return;
    
    // Prevent multiple retreat calls
    if (bossFightState.isEnding) return;
    
    if (confirm('Are you sure you want to retreat? No progress will be saved.')) {
      bossFightState.isEnding = true;
      clearInterval(bossFightInterval);
      addToCombatLog('🏃 You retreated from battle.', '#aaa');
      
      setTimeout(closeBossFight, 1000);
    }
  }
  
  /**
   * Close boss fight modal
   */
  function closeBossFight() {
    const modal = document.getElementById('bossFightModal');
    if (modal) {
      modal.hidden = true;
      modal.style.display = 'none';
    }
    
    // Clear state
    bossFightState = null;
    if (bossFightInterval) {
      clearInterval(bossFightInterval);
      bossFightInterval = null;
    }
    
    // Reset button states
    const attackBtn = document.getElementById('attackBtn');
    attackBtn.disabled = false;
    attackBtn.textContent = '⚔️ ATTACK';
    attackBtn.style.background = '#e94560';
    attackBtn.style.opacity = '1';
    attackBtn.onclick = bossFightAttack; // Restore attack handler
    
    const retreatBtn = document.getElementById('retreatBtn');
    retreatBtn.textContent = '🏃 Retreat';
    retreatBtn.style.background = '#666';
    retreatBtn.onclick = bossFightRetreat;
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '';
    
    // Refresh UI
    updateUI();
    updateBusinessTab();
  }

  // Employee actions
  /**
   * Emergency reset for stuck onboarding employees
   */
  function resetOnboarding(employeeId) {
    const onboardingEmployee = gameState.onboarding.find(e => e.id === employeeId);
    
    if (!onboardingEmployee) {
      showNotification('Employee not found in onboarding queue');
      return;
    }
    
    // Get refund amount (what was actually paid with discounts)
    const refundAmount = onboardingEmployee.hireCostPaid || 0;
    const refundText = refundAmount > 0 ? `\n- Refund $${formatNumber(refundAmount)}` : '';
    
    if (!confirm(`Reset onboarding for ${onboardingEmployee.name}?\n\nThis will:\n- Remove them from onboarding\n- Clear the manager slot${refundText}\n- Allow you to hire a new manager\n\nThis is an emergency fix for stuck employees.`)) {
      return;
    }
    
    // Find the product they were being hired for
    const product = gameState.products.find(p => p.managerOnboarding && p.name === onboardingEmployee.productManaged);
    
    // Refund the hiring cost
    if (refundAmount > 0) {
      gameState.cash += refundAmount;
      console.log(`Refunded $${refundAmount} for ${onboardingEmployee.name}`);
    }
    
    // Remove from onboarding array
    gameState.onboarding = gameState.onboarding.filter(e => e.id !== employeeId);
    
    // Clear product onboarding flag
    if (product) {
      product.managerOnboarding = false;
      product.managerHired = false;
      console.log(`Cleared onboarding flag for product: ${product.name}`);
    }
    
    // Update UI
    updatePeopleTab();
    updateProductsList();
    
    const refundNotification = refundAmount > 0 ? ` Refunded $${formatNumber(refundAmount)}.` : '';
    showNotification(`${onboardingEmployee.name}'s onboarding has been reset.${refundNotification} You can now hire a new employee.`);
    
    console.log(`Emergency reset completed for ${onboardingEmployee.name} (${employeeId})`);
  }

  function handleEmployeeAction(employeeId, action) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    switch (action) {
      case 'bio':
        openUnifiedProfile(employeeId, 'overview'); // Use new unified profile
        break;
      case 'gift':
        showNotification(`Gift given to ${employee.name}!`);
        // In a full implementation, this would open a gift selection
        break;
      case 'chat':
        openChat(employee);
        break;
      case 'flags':
        openFlagManagementModal(employee);
        break;
      case 'promote':
        // Open Corporate Pyramid modal with this employee pre-selected
        openCorporatePyramidModal(employeeId);
        break;
      case 'review':
        conductPerformanceReview(employeeId);
        break;
      case 'fire':
        if (confirm(`Are you sure you want to fire ${employee.name}?`)) {
          // Remove from corporate pyramid position
          const position = getEmployeePosition(employee.id);
          if (position) {
            position.employeeId = null;
            position.isVacant = true;
            console.log(`[Fire] Removed ${employee.name} from position: ${position.title}`);
          }
          
          // Remove manager from product and disable automation
          if (employee.productManaged) {
            const product = gameState.products.find(p => p.name === employee.productManaged);
            if (product) {
              product.managerHired = false;
              product.managerId = null;
              product.managerLevel = 0;
              product.managerOnboarding = false;
              product.running = false;
              product.timeRemainingMs = 0;
              console.log(`[Fire] Cleared product management for: ${product.name}`);
            }
          }
          
          // Change employment status to alumni (don't remove from array)
          employee.employmentStatus = 'alumni';
          employee.firedDate = Date.now();
          employee.productManaged = null;
          
          // Log fire event
          logCompanyEvent({
            type: 'fire',
            involvedEmployees: [employee.id],
            location: employee.locationId,
            description: `${employee.name} was let go`,
            sentiment: 'negative',
            importance: 8
          });
          
          // Add to recent fires
          if (!gameState.companyContext.recentFires) {
            gameState.companyContext.recentFires = [];
          }
          gameState.companyContext.recentFires.unshift({
            id: employee.id,
            name: employee.name,
            date: Date.now()
          });
          if (gameState.companyContext.recentFires.length > 5) {
            gameState.companyContext.recentFires = gameState.companyContext.recentFires.slice(0, 5);
          }
          
          // Update company awareness
          updateCompanyAwareness();
          
          showNotification(`${employee.name} has been fired.`);
          updatePeopleTab();
          updateProductsList();
        }
        break;
    }
  }
  
  // Open chat with employee
  function openChat(employee) {
    // If passed an ID string, look up the employee object
    if (typeof employee === 'string') {
      employee = gameState.employees.find(e => e.id === employee);
      if (!employee) {
        console.error('Employee not found');
        return;
      }
    }
    
    gameState.activeChat = employee;
    ensureEmployeeMemory(employee);
    
    // Clear unread messages when opening chat
    employee.unreadMessages = 0;
    
    // Check if this NPC is currently generating a response
    const chatTypingIndicator = $('chatTypingIndicator');
    const chatTypingName = $('chatTypingName');
    if (chatTypingIndicator && chatTypingName) {
      if (gameState.typingStates && gameState.typingStates[employee.id]) {
        // This NPC is generating - show typing indicator
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = employee.name;
      } else {
        // Not generating - hide typing indicator
        chatTypingIndicator.style.display = 'none';
      }
    }
    
    if (chatModal) {
      chatModal.hidden = false;
      chatModal.style.display = 'flex';
      chatModal.style.pointerEvents = 'auto';
    }
    if (chatName) chatName.textContent = employee.name;
    if (chatAvatar) chatAvatar.src = employee.profileImage || 'https://placehold.co/80x80';
    
    // Initialize chat history if not exists
    if (!gameState.chatHistory[employee.id]) {
      gameState.chatHistory[employee.id] = [];
    }
    
    // Load chat history
    loadChatHistory(employee.id);
    
    // Update People tab to remove unread badge
    if (gameState.activeTab === 'people') {
      updatePeopleTab();
    }
  }
  
  // -------- BIO MODAL --------
  // Open detailed bio modal with edit capabilities
  // Helper function to create stat control buttons
  function createStatControls(elementId, currentValue, min = 0, max = 100) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    container.innerHTML = `
      <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
        <div style="font-size:1.5rem; font-weight:bold; color:inherit;">
          <span id="${elementId}">${Math.round(currentValue)}</span>%
        </div>
        <div style="display:flex; gap:2px; flex-wrap:wrap; justify-content:center;">
          <button class="stat-btn" data-change="-10" style="padding:2px 6px; background:#e94560; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;&lt;</button>
          <button class="stat-btn" data-change="-5" style="padding:2px 6px; background:#ff6b9d; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;</button>
          <button class="stat-btn" data-change="-1" style="padding:2px 6px; background:#ffa7c4; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;</button>
          <button class="stat-btn" data-change="1" style="padding:2px 6px; background:#4ecca3; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;</button>
          <button class="stat-btn" data-change="5" style="padding:2px 6px; background:#00d4ff; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;</button>
          <button class="stat-btn" data-change="10" style="padding:2px 6px; background:#0096c7; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;&gt;</button>
        </div>
      </div>
    `;
    
    // Add event listeners to buttons
    container.querySelectorAll('.stat-btn').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        const change = parseInt(btn.dataset.change);
        const statElement = document.getElementById(elementId);
        let newValue = parseInt(statElement.textContent) + change;
        newValue = Math.max(min, Math.min(max, newValue));
        statElement.textContent = newValue;
      };
    });
    
    return originalHTML;
  }
  
  // Helper function to create dropdown control
  function createDropdownControl(elementId, currentValue, options) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    const optionsHTML = options.map(opt => 
      `<option value="${opt.value}" ${opt.value === currentValue ? 'selected' : ''}>${opt.label}</option>`
    ).join('');
    
    container.innerHTML = `
      <select id="${elementId}" style="width:100%; padding:6px; background:#16213e; border:1px solid #ffd700; border-radius:4px; color:#ffd700; font-weight:600;">
        ${optionsHTML}
      </select>
    `;
    
    return originalHTML;
  }

  // === PHASE 7C: UNIFIED NPC PROFILE SYSTEM ===
  
  // Global state for profile editing (needed for inline handlers)
  window.profileEditState = {
    isEditMode: false,
    hasUnsavedChanges: false,
    editedData: null
  };
  
  function openUnifiedProfile(employeeId, initialTab = 'overview') {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Initialize missing data structures
    if (!employee.skills) {
      initializeEmployeeSocialData(employee);
    }
    
    // Edit mode state (local for logic, synced to global for inline handlers)
    let isEditMode = false;
    let hasUnsavedChanges = false;
    let editedData = JSON.parse(JSON.stringify(employee)); // Deep copy for editing
    
    // Sync to global state for inline handlers
    window.profileEditState.isEditMode = isEditMode;
    window.profileEditState.hasUnsavedChanges = hasUnsavedChanges;
    window.profileEditState.editedData = editedData;
    
    const modal = document.createElement('div');
    modal.id = 'unifiedProfileModal';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Helper to render tabs (Overview and Bio merged)
    const renderTabs = (active) => {
      const tabs = [
        { id: 'overview', label: '📊 Overview', emoji: '📊' },
        { id: 'stats', label: '📈 Stats', emoji: '📈' },
        { id: 'skills', label: '⭐ Skills', emoji: '⭐' },
        { id: 'possessions', label: '🎁 Possessions', emoji: '🎁' },
        { id: 'flags', label: '🏷️ Flags', emoji: '🏷️' },
        { id: 'schedule', label: '📅 Schedule', emoji: '📅' },
        { id: 'social', label: '📱 Social', emoji: '📱' },
        { id: 'relationship', label: '💕 Relationship', emoji: '💕' },
        { id: 'appearance', label: '👤 Appearance', emoji: '👤' },
        { id: 'gallery', label: '📷 Gallery', emoji: '📷' }
      ];
      
      return tabs.map(tab => `
        <button class="profile-tab ${active === tab.id ? 'active' : ''}" data-tab="${tab.id}" 
          style="background:${active === tab.id ? '#00d4ff' : '#16213e'}; 
                 color:${active === tab.id ? '#0f1419' : '#fff'}; 
                 border:none; padding:8px 12px; border-radius:8px 8px 0 0; 
                 cursor:pointer; font-weight:600; transition:all 0.2s; font-size:0.9rem;
                 border-bottom:${active === tab.id ? '3px solid #ffd700' : 'none'}; white-space:nowrap;">
          ${tab.emoji} ${tab.label.split(' ')[1]}
        </button>
      `).join('');
    };
    
    // Tab content renderers (Overview now includes Bio content)
    const renderOverview = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const data = isEditMode ? editedData : freshEmployee;
      
      return `
        <div style="display:flex; gap:20px; margin-bottom:20px; flex-wrap:wrap;">
          <img src="${freshEmployee.profileImage || 'https://placehold.co/150x150'}" 
            style="width:120px; height:120px; border-radius:10px; object-fit:cover; flex-shrink:0;">
          <div style="flex:1; min-width:250px;">
            <h2 style="margin:0 0 8px 0;">${getColoredName(freshEmployee)}</h2>
            <p style="margin:0; color:#aaa;">${freshEmployee.age || 'N/A'} • ${freshEmployee.gender || 'Female'}</p>
            <p style="margin:4px 0 0 0; color:#00d4ff; font-weight:600;">${freshEmployee.position || 'Employee'}</p>
            ${freshEmployee.productManaged ? `<p style="margin:4px 0 0 0; color:#aaa;">Managing: ${freshEmployee.productManaged}</p>` : ''}
          </div>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Quick Stats</h4>
          <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
            <div><span style="color:#aaa;">Affection:</span> <strong style="color:#e94560;">${Math.round(freshEmployee.stats?.affection || 0)}%</strong></div>
            <div><span style="color:#aaa;">Trust:</span> <strong style="color:#00d4ff;">${Math.round(freshEmployee.stats?.trust || 0)}%</strong></div>
            <div><span style="color:#aaa;">Productivity:</span> <strong style="color:#ffd700;">${Math.round(freshEmployee.stats?.productivity || 0)}%</strong></div>
          </div>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Biography</h4>
          ${window.profileEditState.isEditMode ? `
            <textarea onchange="window.profileEditState.editedData.bio = this.value; markProfileChange();"
              style="width:100%; min-height:150px; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:10px; border-radius:4px; resize:vertical; line-height:1.6; font-family:inherit;"
              placeholder="Enter biography...">${data.bio || ''}</textarea>
          ` : `
            <p style="margin:0; line-height:1.6;">${data.bio || '<em style="color:#aaa;">No biography set</em>'}</p>
          `}
        </div>
        
        ${freshEmployee.personalityTraits ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Personality Traits</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${freshEmployee.personalityTraits.map(trait => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#00d4ff;">
                  ${trait}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.hobbies ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Hobbies & Interests</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${freshEmployee.hobbies.map(hobby => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#4ecca3;">
                  ${hobby}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.personalLife?.livingSituation?.pets?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🐾 Pets</h4>
            <div style="display:flex; flex-wrap:wrap; gap:10px;">
              ${freshEmployee.personalLife.livingSituation.pets.map(pet => `
                <div style="background:#16213e; padding:10px 15px; border-radius:8px; border-left:3px solid #4ecca3;">
                  <strong style="color:#4ecca3;">${pet.name}</strong>
                  <span style="color:#aaa; margin-left:8px;">• ${pet.type}</span>
                  ${pet.giftedBy === 'boss' ? '<span style="color:#ffd700; margin-left:8px;">🎁</span>' : ''}
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.personalLife?.livingSituation?.type ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🏠 Living Situation</h4>
            <p style="margin:0; color:#00d4ff;">
              <strong>${freshEmployee.personalLife.livingSituation.type.charAt(0).toUpperCase() + freshEmployee.personalLife.livingSituation.type.slice(1)}</strong>
              ${freshEmployee.personalLife.livingSituation.hasRoommate ? ' (has roommate)' : ''}
            </p>
            ${freshEmployee.giftedPossessions?.homeUpgrades?.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid #16213e;">
                <small style="color:#aaa;">Gifted upgrades:</small>
                ${freshEmployee.giftedPossessions.homeUpgrades.map(upgrade => `
                  <div style="margin-top:4px; color:#ffd700;">🎁 ${upgrade.item}</div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        ` : ''}
        
        ${freshEmployee.giftedPossessions?.vehicles?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🚗 Vehicles</h4>
            ${freshEmployee.giftedPossessions.vehicles.map(vehicle => `
              <div style="background:#16213e; padding:10px; border-radius:6px; margin-bottom:8px; border-left:3px solid #e94560;">
                <strong style="color:#e94560;">${vehicle.item}</strong>
                <span style="color:#aaa; margin-left:8px;">• ${vehicle.type}</span>
                <span style="color:#ffd700; margin-left:8px;">🎁 $${vehicle.price.toLocaleString()}</span>
              </div>
            `).join('')}
          </div>
        ` : ''}
      `;
    };
    
    const renderStats = () => {
      const stats = isEditMode ? (editedData.stats || {}) : (employee.stats || {});
      const statDefs = {
        affection: { label: 'Affection', color: '#e94560', icon: '❤️', desc: 'How much they like you personally' },
        comfort: { label: 'Comfort', color: '#4ecca3', icon: '😊', desc: 'How relaxed they feel around you' },
        trust: { label: 'Trust', color: '#00d4ff', icon: '🤝', desc: 'How much they believe in you' },
        desire: { label: 'Desire', color: '#ff6b9d', icon: '💕', desc: 'Romantic/sexual attraction level' },
        obedience: { label: 'Obedience', color: '#c77dff', icon: '🔗', desc: 'Willingness to follow directions' },
        productivity: { label: 'Productivity', color: '#ffd700', icon: '💼', desc: 'Work efficiency and output' }
      };
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Relationship Statistics</h3>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:15px;">
          ${Object.entries(statDefs).map(([key, info]) => `
            <div style="background:#0f3460; padding:15px; border-radius:8px;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <span style="color:#aaa;">${info.icon} ${info.label}</span>
                ${isEditMode ? `
                  <div style="display:flex; align-items:center; gap:5px;">
                    <button onclick="
                      const val = Math.max(0, (window.profileEditState.editedData.stats.${key} || 0) - 5);
                      window.profileEditState.editedData.stats.${key} = val;
                      this.nextElementSibling.value = val;
                      markProfileChange();
                    " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">−</button>
                    <input type="number" value="${Math.round(stats[key] || 0)}" min="0" max="100" 
                      onchange="window.profileEditState.editedData.stats.${key} = Math.min(100, Math.max(0, parseFloat(this.value) || 0)); markProfileChange();"
                      style="width:60px; background:#16213e; border:1px solid ${info.color}; color:${info.color}; padding:4px 8px; border-radius:4px; text-align:center; font-size:1.1rem; font-weight:600;">
                    <button onclick="
                      const val = Math.min(100, (window.profileEditState.editedData.stats.${key} || 0) + 5);
                      window.profileEditState.editedData.stats.${key} = val;
                      this.previousElementSibling.value = val;
                      markProfileChange();
                    " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">+</button>
                  </div>
                ` : `
                  <strong style="color:${info.color}; font-size:1.3rem;">${Math.round(stats[key] || 0)}%</strong>
                `}
              </div>
              <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden;">
                <div style="background:${info.color}; height:100%; width:${stats[key] || 0}%; transition:width 0.3s;"></div>
              </div>
              <p style="margin:8px 0 0 0; font-size:0.85rem; color:#aaa;">${info.desc}</p>
            </div>
          `).join('')}
        </div>
      `;
    };
    
    const renderSkills = () => {
      const skills = isEditMode ? (editedData.skills || {}) : (employee.skills || {});
      const skillInfo = {
        technical: { icon: '💻', color: '#00d4ff', label: 'Technical' },
        creative: { icon: '🎨', color: '#e94560', label: 'Creative' },
        social: { icon: '🤝', color: '#4ecca3', label: 'Social' },
        management: { icon: '📊', color: '#ffd700', label: 'Management' },
        intimate: { icon: '💋', color: '#ff6b9d', label: 'Intimate' },
        cooking: { icon: '🍳', color: '#ff9f1c', label: 'Cooking' },
        fitness: { icon: '💪', color: '#2ec4b6', label: 'Fitness' }
      };
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Skills & Progression</h3>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
          ${Object.entries(skillInfo).map(([key, info]) => {
            const skill = skills[key] || { level: 0, xp: 0, maxXp: 500 };
            const progress = skill.maxXp > 0 ? (skill.xp / skill.maxXp * 100) : 0;
            return `
              <div style="background:#0f3460; padding:15px; border-radius:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <span style="color:#aaa;">${info.icon} ${info.label}</span>
                  ${isEditMode ? `
                    <div style="display:flex; align-items:center; gap:5px;">
                      <button onclick="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.level = Math.max(0, window.profileEditState.editedData.skills.${key}.level - 1);
                        this.nextElementSibling.textContent = 'Lv ' + window.profileEditState.editedData.skills.${key}.level;
                        markProfileChange();
                      " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">−</button>
                      <span style="color:${info.color}; font-size:1.2rem; font-weight:600; min-width:50px; text-align:center;">Lv ${skill.level}</span>
                      <button onclick="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.level = Math.min(10, window.profileEditState.editedData.skills.${key}.level + 1);
                        this.previousElementSibling.textContent = 'Lv ' + window.profileEditState.editedData.skills.${key}.level;
                        markProfileChange();
                      " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">+</button>
                    </div>
                  ` : `
                    <strong style="color:${info.color}; font-size:1.2rem;">Lv ${skill.level}</strong>
                  `}
                </div>
                ${isEditMode ? `
                  <div style="margin-bottom:8px;">
                    <label style="font-size:0.8rem; color:#aaa; display:block; margin-bottom:4px;">XP:</label>
                    <input type="number" value="${skill.xp}" min="0" max="${skill.maxXp}"
                      onchange="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.xp = Math.min(${skill.maxXp}, Math.max(0, parseFloat(this.value) || 0));
                        markProfileChange();
                      "
                      style="width:100%; background:#16213e; border:1px solid ${info.color}; color:#fff; padding:6px; border-radius:4px;">
                  </div>
                ` : `
                  <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden; margin-bottom:4px;">
                    <div style="background:${info.color}; height:100%; width:${progress}%; transition:width 0.3s;"></div>
                  </div>
                  <p style="margin:0; font-size:0.8rem; color:#aaa;">${skill.xp} / ${skill.maxXp} XP</p>
                `}
              </div>
            `;
          }).join('')}
        </div>
        
        ${employee.specializations && employee.specializations.length > 0 ? `
          <div style="margin-top:20px; background:#0f3460; padding:15px; border-radius:8px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🌟 Specializations</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.specializations.map(spec => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; border:1px solid #ffd700; color:#ffd700; font-size:0.9rem;">
                  ${spec}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
      `;
    };
    
    const renderFlags = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const flags = getActiveFlags(freshEmployee);
      return `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <h3 style="margin:0; color:#00d4ff;">Active Flags</h3>
          <button onclick="openFlagManagementModal(gameState.employees.find(e => e.id === '${freshEmployee.id}'))" 
            style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; padding:10px 20px; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:0.95rem; box-shadow:0 2px 8px rgba(102,126,234,0.3); transition:all 0.2s;"
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102,126,234,0.5)';"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102,126,234,0.3)';">
            🏷️ Manage Flags
          </button>
        </div>
        ${flags.length > 0 ? `
          <div style="display:grid; gap:10px;">
            ${flags.map(flag => `
              <div style="background:#0f3460; padding:12px; border-radius:8px; border-left:4px solid ${getPriorityColor(flag.priority || 'medium')};">
                <div style="display:flex; justify-content:space-between; align-items:start;">
                  <div style="flex:1;">
                    <div style="font-weight:600; margin-bottom:4px;">
                      ${flag.emoji || '🏷️'} ${flag.description || flag.playerDescription || flag.key || 'Unnamed Flag'}
                    </div>
                    <div style="font-size:0.85rem; color:#aaa;">
                      Priority: ${flag.priority || 'medium'} • 
                      ${flag.playerSet || flag.source === 'player' ? 'Player-set' : 'System'} • 
                      ${flag.timestamp ? new Date(flag.timestamp).toLocaleDateString() : 'Unknown date'}
                    </div>
                    ${flag.details || flag.aiGuidance ? `<p style="margin:8px 0 0 0; color:#ddd; font-size:0.9rem;">${flag.details || flag.aiGuidance || ''}</p>` : ''}
                  </div>
                  ${isEditMode ? `
                    <button onclick="removeFlag('${freshEmployee.id}', '${flag.id || flag.key}'); openUnifiedProfile('${freshEmployee.id}', 'flags');" 
                      style="background:#e94560; border:none; padding:6px 12px; border-radius:4px; color:white; cursor:pointer; font-size:0.9rem; margin-left:10px; flex-shrink:0;">
                      ✕ Remove
                    </button>
                  ` : ''}
                </div>
              </div>
            `).join('')}
          </div>
        ` : '<p style="color:#aaa; text-align:center; padding:40px 0;">No active flags. Click "Manage Flags" to add some!</p>'}
      `;
    };
    
    const renderPossessions = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const poss = freshEmployee.giftedPossessions || {};
      const hasAny = (poss.wardrobe?.length || 0) + (poss.jewelry?.length || 0) + 
                     (poss.vehicles?.length || 0) + (poss.homeUpgrades?.length || 0) +
                     (poss.experiences?.length || 0) + (poss.tech?.length || 0) + 
                     (poss.other?.length || 0) > 0;
      
      if (!hasAny) {
        return `
          <div style="text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:4rem; margin-bottom:20px;">🎁</div>
            <h3 style="color:#00d4ff; margin-bottom:10px;">No Gifts Yet</h3>
            <p style="margin:0;">Gifts you give to ${freshEmployee.name} will appear here and affect their life!</p>
            <p style="margin-top:10px; color:#ffd700;">Try gifting clothing, vehicles, or even a pet!</p>
          </div>
        `;
      }
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">🎁 Gifted Possessions</h3>
        
        ${poss.wardrobe?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">👗 Wardrobe</h4>
            <div style="display:grid; gap:10px;">
              ${poss.wardrobe.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #ff6b9d;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#ff6b9d;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">Wears ${(item.wearChance * 100).toFixed(0)}% of the time</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.jewelry?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">💎 Jewelry</h4>
            <div style="display:grid; gap:10px;">
              ${poss.jewelry.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #e94560;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#e94560;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">• ${item.type}</span>
                      <span style="color:#aaa; margin-left:10px;">Wears ${(item.wearChance * 100).toFixed(0)}% of the time</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.vehicles?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🚗 Vehicles</h4>
            <div style="display:grid; gap:10px;">
              ${poss.vehicles.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #00d4ff;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#00d4ff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">• ${item.type}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.tech?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">📱 Tech & Gadgets</h4>
            <div style="display:grid; gap:10px;">
              ${poss.tech.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #4ecca3;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#4ecca3;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">• ${item.type}</span>
                      ${item.inUse ? '<span style="color:#4ecca3; margin-left:10px;">✓ In use</span>' : ''}
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.experiences?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">✈️ Experiences & Memories</h4>
            <div style="display:grid; gap:10px;">
              ${poss.experiences.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #c77dff;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#c77dff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">Memory strength: ${'⭐'.repeat(Math.min(5, item.memoryStrength))}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.other?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🎁 Other Gifts</h4>
            <div style="display:grid; gap:10px;">
              ${poss.other.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#fff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">• ${item.category}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-top:20px; border:2px dashed #00d4ff;">
          <p style="margin:0; color:#aaa; text-align:center;">
            <strong style="color:#00d4ff;">Pro Tip:</strong> Gifts affect more than just stats! 
            Clothing items may appear in their descriptions, vehicles change their lifestyle, 
            and pets become part of their family!
          </p>
        </div>
      `;
    };
    
    const renderSchedule = () => {
      const schedule = isEditMode ? (editedData.schedule || {}) : (employee.schedule || {});
      const time = gameState.time || {};
      const currentHour = timeHelpers ? timeHelpers.getHour() : 12;
      const isWorkDay = timeHelpers ? !timeHelpers.isWeekend() : true;
      const isWorking = schedule.isCurrentlyWorking || false;
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const workDays = schedule.workDays || [1,2,3,4,5];
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Work Schedule</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Current Status</h4>
          <div style="font-size:1.2rem; margin-bottom:8px;">
            ${isWorking ? '✅ <strong style="color:#4ecca3;">At Work</strong>' : '🏠 <strong style="color:#aaa;">Off Duty</strong>'}
          </div>
          <p style="margin:0; color:#aaa; font-size:0.9rem;">
            Current time: ${timeHelpers ? timeHelpers.getFormattedTime() : '12:00 PM'} • 
            ${isWorkDay ? 'Weekday' : 'Weekend'}
          </p>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Work Hours</h4>
          ${isEditMode ? `
            <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
              <div style="flex:1;">
                <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:4px;">Start Time:</label>
                <select onchange="window.profileEditState.editedData.schedule.workStartHour = parseInt(this.value); markProfileChange();"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;">
                  ${Array.from({length:13}, (_, i) => i + 6).map(h => `
                    <option value="${h}" ${(schedule.workStartHour || 9) === h ? 'selected' : ''}>${h}:00</option>
                  `).join('')}
                </select>
              </div>
              <div style="flex:1;">
                <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:4px;">End Time:</label>
                <select onchange="window.profileEditState.editedData.schedule.workEndHour = parseInt(this.value); markProfileChange();"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;">
                  ${Array.from({length:11}, (_, i) => i + 14).map(h => `
                    <option value="${h}" ${(schedule.workEndHour || 17) === h ? 'selected' : ''}>${h}:00</option>
                  `).join('')}
                </select>
              </div>
            </div>
          ` : `
            <p style="margin:0; font-size:1.1rem;">
              ${schedule.workStartHour || 9}:00 - ${schedule.workEndHour || 17}:00
            </p>
          `}
          
          ${isEditMode ? `
            <div style="margin-top:15px;">
              <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:8px;">Work Days:</label>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px;">
                ${dayNames.map((day, idx) => `
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:6px; background:${workDays.includes(idx) ? '#16213e' : 'transparent'}; border-radius:4px; border:1px solid ${workDays.includes(idx) ? '#00d4ff' : '#666'};">
                    <input type="checkbox" 
                      ${workDays.includes(idx) ? 'checked' : ''}
                      onchange="
                        if (!editedData.schedule.workDays) editedData.schedule.workDays = [1,2,3,4,5];
                        if (this.checked) {
                          if (!editedData.schedule.workDays.includes(${idx})) editedData.schedule.workDays.push(${idx});
                        } else {
                          editedData.schedule.workDays = editedData.schedule.workDays.filter(d => d !== ${idx});
                        }
                        markProfileChange();
                        openUnifiedProfile('${employee.id}', 'schedule');
                      "
                      style="cursor:pointer;">
                    <span style="font-size:0.9rem; color:${workDays.includes(idx) ? '#00d4ff' : '#aaa'};">${day.substring(0,3)}</span>
                  </label>
                `).join('')}
              </div>
            </div>
          ` : `
            <p style="margin:8px 0 0 0; color:#aaa; font-size:0.9rem;">
              ${workDays.length} days per week
            </p>
          `}
        </div>
        
        ${schedule.hoursWorkedToday !== undefined ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Today's Progress</h4>
            <div style="background:#16213e; height:12px; border-radius:6px; overflow:hidden; margin-bottom:8px;">
              <div style="background:#4ecca3; height:100%; width:${(schedule.hoursWorkedToday / 8 * 100)}%; transition:width 0.3s;"></div>
            </div>
            <p style="margin:0; color:#aaa;">${schedule.hoursWorkedToday || 0} / 8 hours worked</p>
          </div>
        ` : ''}
      `;
    };
    
    const renderSocial = () => {
      const social = employee.social || {};
      const posts = gameState.socialNetwork?.posts?.filter(p => p.authorId === employee.id).slice(0, 10) || [];
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Social Activity</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Profile Stats</h4>
          <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; text-align:center;">
            <div>
              <div style="font-size:1.5rem; color:#00d4ff;">${social.postCount || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Posts</div>
            </div>
            <div>
              <div style="font-size:1.5rem; color:#e94560;">${social.totalLikesReceived || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Likes</div>
            </div>
            <div>
              <div style="font-size:1.5rem; color:#4ecca3;">${social.totalCommentsReceived || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Comments</div>
            </div>
          </div>
        </div>
        
        <h4 style="margin:0 0 10px 0; color:#ffd700;">Recent Posts (${posts.length})</h4>
        ${posts.length > 0 ? posts.map(post => `
          <div onclick="openPostModal('${post.id}')" 
            style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:12px; cursor:pointer; transition:all 0.2s; border:2px solid transparent;"
            onmouseover="this.style.borderColor='#00d4ff'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.3)';"
            onmouseout="this.style.borderColor='transparent'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
            
            <!-- Post Content -->
            <p style="margin:0 0 ${post.imageUrl ? '12px' : '8px'} 0; line-height:1.6; color:#fff;">${post.content || ''}</p>
            
            <!-- Post Image (if exists) -->
            ${post.imageUrl ? `
              <div style="margin-bottom:12px; border-radius:8px; overflow:hidden; max-height:400px; display:flex; align-items:center; justify-content:center; background:#000;">
                <img src="${post.imageUrl}" 
                  style="width:100%; height:auto; max-height:400px; object-fit:contain; display:block;"
                  alt="Post image">
              </div>
            ` : ''}
            
            <!-- Post Metadata -->
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.85rem; color:#8899a6;">
              <div>
                ${new Date(post.timestamp).toLocaleDateString()} ${new Date(post.timestamp).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
              </div>
              <div style="display:flex; gap:15px; align-items:center;">
                <span style="display:flex; align-items:center; gap:4px;">
                  ❤️ <strong style="color:#e94560;">${post.likes?.length || 0}</strong>
                </span>
                <span style="display:flex; align-items:center; gap:4px;">
                  💬 <strong style="color:#4ecca3;">${post.comments?.length || 0}</strong>
                </span>
              </div>
            </div>
            
            <!-- Click hint -->
            <div style="margin-top:8px; text-align:center; font-size:0.75rem; color:#00d4ff; opacity:0.7;">
              Click to view, like, or comment
            </div>
          </div>
        `).join('') : '<p style="color:#aaa; text-align:center; padding:20px 0;">No posts yet</p>'}
        
        ${posts.length >= 10 ? `
          <div style="text-align:center; margin-top:15px;">
            <button onclick="switchTab('social')" 
              style="padding:10px 20px; background:#00d4ff; border:none; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; font-size:0.9rem;">
              📱 View All Posts in Social Feed
            </button>
          </div>
        ` : ''}
      `;
    };
    
    const renderRelationship = () => {
      // Get relationships with other employees
      const relationships = gameState.employees
        .filter(e => e.id !== employee.id && e.relationships && e.relationships[employee.id])
        .map(e => ({
          name: e.name,
          value: e.relationships[employee.id] || 0,
          color: getColoredName(e)
        }))
        .sort((a, b) => b.value - a.value)
        .slice(0, 10);
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Office Relationships</h3>
        
        ${relationships.length > 0 ? `
          <div style="display:grid; gap:10px;">
            ${relationships.map(rel => `
              <div style="background:#0f3460; padding:12px; border-radius:8px; display:flex; justify-content:space-between; align-items:center;">
                <span>${rel.color}</span>
                <div style="flex:1; margin:0 15px;">
                  <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden;">
                    <div style="background:${rel.value >= 70 ? '#4ecca3' : rel.value >= 40 ? '#00d4ff' : '#aaa'}; height:100%; width:${rel.value}%; transition:width 0.3s;"></div>
                  </div>
                </div>
                <strong style="color:${rel.value >= 70 ? '#4ecca3' : rel.value >= 40 ? '#00d4ff' : '#aaa'};">${rel.value}</strong>
              </div>
            `).join('')}
          </div>
        ` : '<p style="color:#aaa; text-align:center; padding:40px 0;">No relationships yet</p>'}
        
        <div style="margin-top:20px; background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Relationship Levels</h4>
          <div style="font-size:0.9rem; color:#aaa; line-height:1.8;">
            <div>0-20: 😐 Strangers</div>
            <div>20-40: 🙂 Acquaintances</div>
            <div>40-60: 😊 Friends</div>
            <div>60-80: 🤗 Close Friends</div>
            <div>80-100: 💖 Best Friends</div>
          </div>
        </div>
      `;
    };
    
    const renderAppearance = () => {
      const data = isEditMode ? window.profileEditState.editedData : employee;
      const physical = data.physical || {};
      const hair = physical.hair || {};
      const eyes = physical.eyes || {};
      const face = physical.face || {};
      const skin = physical.skin || {};
      const body = physical.body || {};
      const genitals = physical.genitals || {};
      
      // Helper to generate complete description from parts
      const generateCompleteDescription = () => {
        const p = window.profileEditState.editedData.physical;
        if (!p) return '';
        
        const parts = [];
        
        // Basic info
        if (p.heightBuild || (p.height && p.build)) {
          parts.push(`${p.heightBuild || (p.height + ', ' + p.build)}`);
        }
        
        // Hair
        if (p.hair && (p.hair.color || p.hair.style || p.hair.length)) {
          const hairParts = [];
          if (p.hair.length) hairParts.push(p.hair.length);
          if (p.hair.color) hairParts.push(p.hair.color);
          if (p.hair.style) hairParts.push(p.hair.style);
          if (p.hair.texture) hairParts.push(p.hair.texture);
          if (hairParts.length) parts.push(`Hair: ${hairParts.join(', ')}`);
        }
        
        // Eyes & Face
        if (p.eyes?.color) parts.push(`${p.eyes.color} eyes`);
        if (p.face) {
          const faceParts = [];
          if (p.face.shape) faceParts.push(`${p.face.shape} face`);
          if (p.face.lips) faceParts.push(`${p.face.lips} lips`);
          if (p.face.nose) faceParts.push(`${p.face.nose} nose`);
          if (p.face.cheekbones) faceParts.push(`${p.face.cheekbones} cheekbones`);
          if (p.face.jawline) faceParts.push(`${p.face.jawline} jawline`);
          if (faceParts.length) parts.push(faceParts.join(', '));
        }
        
        // Skin
        if (p.skin?.tone || p.skinTone) parts.push(`${p.skin?.tone || p.skinTone} skin`);
        if (p.skin?.texture) parts.push(`${p.skin.texture} texture`);
        
        // Body
        if (p.body?.shape || p.bodyShape) parts.push(`${p.body?.shape || p.bodyShape} body shape`);
        if (p.body) {
          if (p.body.chestSize || p.body.breastSize) {
            const size = p.body.chestSize || p.body.breastSize;
            const descriptor = p.body.chestDescriptor === 'chest' ? 'chest' : 'breasts';
            parts.push(`${size} ${descriptor}`);
          }
          if (p.body.buttSize) parts.push(`${p.body.buttSize} butt`);
          if (p.body.legs) parts.push(`${p.body.legs} legs`);
        }
        
        // Intimate
        if (p.genitals) {
          const genParts = [];
          if (p.genitals.type) genParts.push(p.genitals.type);
          if (p.genitals.size) genParts.push(`${p.genitals.size} size`);
          if (p.genitals.characteristics) genParts.push(p.genitals.characteristics);
          if (genParts.length) parts.push(`Intimate: ${genParts.join(', ')}`);
        }
        
        // Style
        if (p.fashion) parts.push(`Fashion: ${p.fashion}`);
        if (p.accessories) parts.push(`Accessories: ${p.accessories}`);
        if (p.distinguishingFeature) parts.push(`Distinguishing feature: ${p.distinguishingFeature}`);
        
        return parts.join('. ') + '.';
      };
      
      // Auto-update description function
      const updateDescriptionPreview = `
        const desc = (${generateCompleteDescription.toString()})();
        const preview = document.getElementById('appearanceDescPreview');
        if (preview) preview.textContent = desc;
        if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {};
        window.profileEditState.editedData.physical.fullDescription = desc;
        markProfileChange();
      `;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Physical Appearance ${isEditMode ? '<span style="color:#ffd700; font-size:0.8rem;">(Edit Mode)</span>' : ''}</h3>
        
        <div style="text-align:center; margin-bottom:20px;">
          <img src="${employee.profileImage || 'https://placehold.co/200x200'}" 
            style="width:200px; height:200px; border-radius:10px; object-fit:cover; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="margin-top:10px;">
            <button onclick="openGalleryForProfileUpdate('${employee.id}')" 
              style="padding:8px 16px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer;">
              📷 Update Profile Picture
            </button>
          </div>
        </div>
        
        <!-- Basic Information -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Basic Info</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px;">
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Height & Build:</label>
                <input type="text" value="${physical.heightBuild || (physical.height && physical.build ? physical.height + ', ' + physical.build : '')}" 
                  onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.heightBuild = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., 5'7&quot;, athletic build">
              </div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Height & Build:</span>
                <span style="color:#fff; font-weight:600;">${physical.heightBuild || (physical.height && physical.build ? physical.height + ', ' + physical.build : 'Not specified')}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Gender:</span>
                <span style="color:#fff; font-weight:600;">${employee.gender || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Age:</span>
                <span style="color:#fff; font-weight:600;">${employee.age || 'Not specified'}</span>
              </div>
            </div>
          `}
        </div>
        
        <!-- Hair Details -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Hair</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px;">
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Color:</label>
                <input type="text" value="${hair.color || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.color = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., dark brown, blonde">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Style:</label>
                <input type="text" value="${hair.style || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.style = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., wavy, straight, curly">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Length:</label>
                <input type="text" value="${hair.length || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.length = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., shoulder-length, long">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Texture:</label>
                <input type="text" value="${hair.texture || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.texture = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., silky, thick">
              </div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Color:</span>
                <span style="color:#fff; font-weight:600;">${hair.color || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Style:</span>
                <span style="color:#fff; font-weight:600;">${hair.style || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Length:</span>
                <span style="color:#fff; font-weight:600;">${hair.length || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Texture:</span>
                <span style="color:#fff; font-weight:600;">${hair.texture || 'Not specified'}</span>
              </div>
            </div>
          `}
        </div>
        
        <!-- Face & Eyes -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Face & Eyes</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
              <div><label style="color:#aaa; font-size:0.85rem;">Eye Color:</label><input type="text" value="${eyes.color || ''}" onchange="if (!window.profileEditState.editedData.physical.eyes) window.profileEditState.editedData.physical.eyes = {}; window.profileEditState.editedData.physical.eyes.color = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Eye Shape:</label><input type="text" value="${eyes.shape || ''}" onchange="if (!window.profileEditState.editedData.physical.eyes) window.profileEditState.editedData.physical.eyes = {}; window.profileEditState.editedData.physical.eyes.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Face Shape:</label><input type="text" value="${face.shape || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Nose:</label><input type="text" value="${face.nose || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.nose = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Lips:</label><input type="text" value="${face.lips || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.lips = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Cheekbones:</label><input type="text" value="${face.cheekbones || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.cheekbones = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Jawline:</label><input type="text" value="${face.jawline || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.jawline = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Eye Color:</span><span style="color:#fff; font-weight:600;">${eyes.color || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Eye Shape:</span><span style="color:#fff; font-weight:600;">${eyes.shape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Face Shape:</span><span style="color:#fff; font-weight:600;">${face.shape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Nose:</span><span style="color:#fff; font-weight:600;">${face.nose || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Lips:</span><span style="color:#fff; font-weight:600;">${face.lips || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Cheekbones:</span><span style="color:#fff; font-weight:600;">${face.cheekbones || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Jawline:</span><span style="color:#fff; font-weight:600;">${face.jawline || 'Not specified'}</span></div>
            </div>
          `}
        </div>
        
        <!-- Skin, Body, Intimate, Style all editable... -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Skin & Body</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
              <div><label style="color:#aaa; font-size:0.85rem;">Skin Tone:</label><input type="text" value="${skin.tone || physical.skinTone || ''}" onchange="if (!window.profileEditState.editedData.physical.skin) window.profileEditState.editedData.physical.skin = {}; window.profileEditState.editedData.physical.skin.tone = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Body Shape:</label><input type="text" value="${body.shape || physical.bodyShape || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Chest/Breast Size:</label><input type="text" value="${body.chestSize || body.breastSize || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.chestSize = this.value; window.profileEditState.editedData.physical.body.breastSize = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Butt Size:</label><input type="text" value="${body.buttSize || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.buttSize = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Legs:</label><input type="text" value="${body.legs || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.legs = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Genitals Type:</label><input type="text" value="${genitals.type || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.type = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Genitals Size:</label><input type="text" value="${genitals.size || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.size = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Grooming:</label><input type="text" value="${genitals.characteristics || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.characteristics = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Fashion Style:</label><input type="text" value="${physical.fashion || ''}" onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.fashion = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div style="grid-column: 1 / -1;"><label style="color:#aaa; font-size:0.85rem;">Distinguishing Feature:</label><input type="text" value="${physical.distinguishingFeature || ''}" onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.distinguishingFeature = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Skin Tone:</span><span style="color:#fff; font-weight:600;">${skin.tone || physical.skinTone || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Body Shape:</span><span style="color:#fff; font-weight:600;">${body.shape || physical.bodyShape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Chest/Breast Size:</span><span style="color:#fff; font-weight:600;">${body.chestSize || body.breastSize || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Butt Size:</span><span style="color:#fff; font-weight:600;">${body.buttSize || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Legs:</span><span style="color:#fff; font-weight:600;">${body.legs || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Genitals:</span><span style="color:#fff; font-weight:600;">${genitals.type || 'Not specified'}, ${genitals.size || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Grooming:</span><span style="color:#fff; font-weight:600;">${genitals.characteristics || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Fashion:</span><span style="color:#fff; font-weight:600;">${physical.fashion || 'Not specified'}</span></div>
              ${physical.distinguishingFeature ? `<div style="padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);"><div style="color:#aaa; font-size:0.85rem;">Distinguishing Feature:</div><div style="color:#00d4ff; font-style:italic;">${physical.distinguishingFeature}</div></div>` : ''}
            </div>
          `}
        </div>
        
        <!-- Auto-Generated Complete Description -->
        <div style="background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Complete Description ${isEditMode ? '<span style="color:#4ecca3; font-size:0.75rem;">(Auto-Updates)</span>' : ''}</h4>
          <p id="appearanceDescPreview" style="margin:0; line-height:1.6; color:#ddd;">${physical.fullDescription || 'Edit fields above to generate description'}</p>
        </div>
      `;
    };
    
    const renderBio = () => {
      const data = isEditMode ? editedData : employee;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Biography & Personality</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">About</h4>
          ${isEditMode ? `
            <textarea onchange="window.profileEditState.editedData.bio = this.value; markProfileChange();"
              style="width:100%; min-height:150px; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:10px; border-radius:4px; resize:vertical; line-height:1.6; font-family:inherit;"
              placeholder="Enter biography...">${data.bio || ''}</textarea>
          ` : `
            <p style="margin:0; line-height:1.6;">${data.bio || '<em style="color:#aaa;">No biography set</em>'}</p>
          `}
        </div>
        
        ${employee.personalityTraits ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Personality Traits</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.personalityTraits.map(trait => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#00d4ff;">
                  ${trait}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${employee.hobbies ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Hobbies & Interests</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.hobbies.map(hobby => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#4ecca3;">
                  ${hobby}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
      `;
    };
    
    const renderGallery = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      // Collect all photos from different sources
      const employeePhotos = freshEmployee.photos || [];
      
      // Get photos from social feed posts (using imageUrl, not image)
      const socialPhotos = [];
      if (gameState.socialNetwork && gameState.socialNetwork.posts) {
        gameState.socialNetwork.posts
          .filter(post => post.authorId === freshEmployee.id && post.imageUrl)
          .forEach(post => {
            if (!socialPhotos.find(p => p.url === post.imageUrl)) {
              socialPhotos.push({
                url: post.imageUrl,
                source: 'social',
                caption: post.caption || '',
                timestamp: post.timestamp,
                likes: post.likes || 0
              });
            }
          });
      }
      
      // Get photos from chat history (check gameState.chatHistory)
      const chatPhotos = [];
      const chatHistory = gameState.chatHistory[freshEmployee.id] || [];
      chatHistory
        .filter(msg => msg.imageUrl)
        .forEach(msg => {
          if (!chatPhotos.find(p => p.url === msg.imageUrl)) {
            chatPhotos.push({
              url: msg.imageUrl,
              source: 'chat',
              caption: msg.caption || msg.content || '',
              timestamp: msg.timestamp
            });
          }
        });
      
      // Also check if employee has a generatedImages array
      const generatedImages = freshEmployee.generatedImages || [];
      const employeeImages = generatedImages.map(img => ({
        url: typeof img === 'string' ? img : img.url,
        source: 'generated',
        caption: typeof img === 'object' ? img.caption : '',
        timestamp: typeof img === 'object' ? img.timestamp : Date.now()
      }));
      
      // Combine all photos (remove duplicates by URL)
      const allPhotoObjects = [...employeeImages, ...socialPhotos, ...chatPhotos];
      const uniquePhotos = [];
      const seenUrls = new Set();
      
      allPhotoObjects.forEach(photo => {
        if (!seenUrls.has(photo.url)) {
          seenUrls.add(photo.url);
          uniquePhotos.push(photo);
        }
      });
      
      // Sort by timestamp (newest first)
      uniquePhotos.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      
      const currentProfile = freshEmployee.profileImage;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Photo Gallery</h3>
        
        <!-- Current Profile Picture -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Current Profile Picture</h4>
          <div style="text-align:center;">
            <img src="${currentProfile || 'https://placehold.co/200x200'}" 
              style="width:200px; height:200px; border-radius:10px; object-fit:cover; box-shadow:0 4px 15px rgba(0,0,0,0.3); border:3px solid #ffd700;">
            <div style="margin-top:10px; color:#aaa; font-size:0.9rem;">
              Click any photo below to set as profile picture
            </div>
          </div>
        </div>
        
        <!-- Photo Collection -->
        <div style="background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">
            All Photos (${uniquePhotos.length})
            ${uniquePhotos.length > 0 ? `
              <span style="font-size:0.8rem; color:#aaa; margin-left:10px;">
                (${socialPhotos.length} from social, ${chatPhotos.length} from chat, ${employeeImages.length} generated)
              </span>
            ` : ''}
          </h4>
          
          ${uniquePhotos.length > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:12px;">
              ${uniquePhotos.map((photo, index) => {
                const sourceEmoji = photo.source === 'social' ? '📱' : photo.source === 'chat' ? '💬' : '🖼️';
                const sourceColor = photo.source === 'social' ? '#00d4ff' : photo.source === 'chat' ? '#ff6b9d' : '#4ecca3';
                return `
                <div style="position:relative; aspect-ratio:1; border-radius:8px; overflow:hidden; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s; border:${photo.url === currentProfile ? '3px solid #ffd700' : '2px solid transparent'};"
                  onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(0,212,255,0.4)';"
                  onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                  onclick="setProfilePicture('${freshEmployee.id}', '${photo.url}')">
                  <img src="${photo.url}" 
                    style="width:100%; height:100%; object-fit:cover;">
                  ${photo.url === currentProfile ? `
                    <div style="position:absolute; top:5px; right:5px; background:rgba(255,215,0,0.9); color:#0f1419; padding:4px 8px; border-radius:4px; font-size:0.75rem; font-weight:700;">
                      ✓ CURRENT
                    </div>
                  ` : `
                    <div style="position:absolute; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 0.2s;"
                      onmouseover="this.style.opacity='1';"
                      onmouseout="this.style.opacity='0';">
                      <span style="color:#fff; font-size:0.85rem; font-weight:600;">Set as Profile</span>
                    </div>
                  `}
                  <div style="position:absolute; top:5px; left:5px; background:${sourceColor}; color:#fff; padding:3px 6px; border-radius:4px; font-size:0.7rem; font-weight:600;">
                    ${sourceEmoji} ${photo.source}
                  </div>
                  <div style="position:absolute; bottom:0; left:0; right:0; background:linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding:8px; color:#fff; font-size:0.75rem;">
                    ${photo.caption ? `<div style="margin-bottom:4px; font-weight:500; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${photo.caption}</div>` : ''}
                    ${photo.likes ? `<div style="color:#ffd700; font-size:0.7rem;">❤️ ${photo.likes}</div>` : ''}
                    ${photo.timestamp ? `<div style="color:#aaa; font-size:0.7rem;">${new Date(photo.timestamp).toLocaleDateString()}</div>` : ''}
                  </div>
                </div>
              `;
              }).join('')}
            </div>
          ` : `
            <div style="text-align:center; padding:40px 20px; color:#aaa;">
              <div style="font-size:3rem; margin-bottom:10px;">📷</div>
              <p style="margin:0;">No photos yet</p>
              <p style="margin:5px 0 0 0; font-size:0.85rem;">Photos will appear here as they are generated through chats, social posts, and other interactions</p>
            </div>
          `}
        </div>
        
        <!-- Stats -->
        ${uniquePhotos.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-top:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Gallery Stats</h4>
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; text-align:center;">
              <div>
                <div style="font-size:1.5rem; color:#4ecca3;">${employeeImages.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Generated</div>
              </div>
              <div>
                <div style="font-size:1.5rem; color:#00d4ff;">${socialPhotos.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Social Posts</div>
              </div>
              <div>
                <div style="font-size:1.5rem; color:#ff6b9d;">${chatPhotos.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Chat Photos</div>
              </div>
            </div>
          </div>
        ` : ''}
      `;
    };
    
    // Render initial content
    const renderContent = (tab) => {
      switch(tab) {
        case 'overview': return renderOverview();
        case 'stats': return renderStats();
        case 'skills': return renderSkills();
        case 'possessions': return renderPossessions();
        case 'flags': return renderFlags();
        case 'schedule': return renderSchedule();
        case 'social': return renderSocial();
        case 'relationship': return renderRelationship();
        case 'appearance': return renderAppearance();
        case 'gallery': return renderGallery();
        case 'bio': return renderOverview(); // Bio merged into Overview
        default: return renderOverview();
      }
    };
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:95%; max-width:1000px; max-height:90vh; border-radius:15px; box-shadow:0 5px 30px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden; margin:20px auto; position:relative;">
        <!-- Header -->
        <div style="padding:15px 20px; border-bottom:2px solid #00d4ff; display:flex; justify-content:space-between; align-items:center; background:#16213e; flex-shrink:0;">
          <h2 style="margin:0; color:#fff; font-size:1.3rem;">👤 ${employee.name}'s Profile</h2>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button id="saveProfileBtn" style="background:#4ecca3; border:none; padding:8px 16px; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; display:none; font-size:0.9rem;">
              💾 Save
            </button>
            <button id="toggleEditBtn" style="background:#00d4ff; border:none; padding:8px 16px; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; font-size:0.9rem;">
              ✏️ Edit
            </button>
            <button id="closeUnifiedProfile" style="background:transparent; border:none; color:white; font-size:1.8rem; cursor:pointer; padding:0 8px; line-height:1;">✕</button>
          </div>
        </div>
        
        <!-- Tabs (Sticky with shadow on scroll) -->
        <div id="tabsContainer" style="display:flex; gap:2px; padding:8px 10px 0 10px; background:#0f1419; overflow-x:auto; flex-shrink:0; position:sticky; top:0; z-index:10; border-bottom:1px solid transparent; transition:all 0.2s; scrollbar-width:thin;">
          ${renderTabs(initialTab)}
        </div>
        
        <!-- Content -->
        <div id="profileContent" style="flex:1; overflow-y:auto; padding:20px; background:#16213e; min-height:0; -webkit-overflow-scrolling:touch;">
          ${renderContent(initialTab)}
        </div>
      </div>
      
      <style>
        /* Mobile-friendly scrollbars */
        #profileContent::-webkit-scrollbar {
          width:8px;
        }
        #profileContent::-webkit-scrollbar-track {
          background:#16213e;
        }
        #profileContent::-webkit-scrollbar-thumb {
          background:#00d4ff;
          border-radius:4px;
        }
        #profileContent::-webkit-scrollbar-thumb:hover {
          background:#0099cc;
        }
        
        #tabsContainer::-webkit-scrollbar {
          height:6px;
        }
        #tabsContainer::-webkit-scrollbar-track {
          background:#0f1419;
        }
        #tabsContainer::-webkit-scrollbar-thumb {
          background:#00d4ff;
          border-radius:3px;
        }
        
        /* Mobile responsive adjustments - PORTRAIT OPTIMIZED */
        @media (max-width: 768px) {
          #unifiedProfileModal > div {
            width:100% !important;
            height:100vh !important;
            max-height:100vh !important;
            border-radius:0 !important;
            margin:0 !important;
          }
          
          #profileContent {
            padding:12px !important;
          }
          
          .profile-tab {
            font-size:0.8rem !important;
            padding:6px 8px !important;
          }
          
          /* Portrait-specific optimizations */
          #unifiedProfileModal h2 {
            font-size:1.1rem !important;
          }
          
          #unifiedProfileModal button {
            font-size:0.85rem !important;
            padding:6px 12px !important;
          }
        }
        
        /* PORTRAIT MODE: Max vertical space, minimal horizontal waste */
        @media (max-width: 768px) and (orientation: portrait) {
          /* Header more compact */
          #unifiedProfileModal > div > div:first-child {
            padding:10px 12px !important;
          }
          
          /* Tabs even more compact */
          #tabsContainer {
            padding:6px 8px 0 8px !important;
          }
          
          .profile-tab {
            font-size:0.75rem !important;
            padding:5px 7px !important;
          }
          
          /* Content takes maximum space */
          #profileContent {
            padding:10px !important;
          }
          
          /* Single column layouts for portrait */
          #profileContent > div > div[style*="grid-template-columns"] {
            grid-template-columns: 1fr !important;
          }
          
          /* Overview profile section - stack vertically */
          #profileContent > div > div[style*="display:flex"][style*="gap:20px"] {
            flex-direction: column !important;
            gap: 12px !important;
          }
          
          /* Profile image centered in portrait */
          #profileContent img[style*="width:120px"] {
            margin: 0 auto !important;
            display: block !important;
          }
          
          /* Text sections more compact */
          #profileContent h3 {
            font-size: 1.1rem !important;
            margin-bottom: 10px !important;
          }
          
          #profileContent h4 {
            font-size: 1rem !important;
          }
          
          /* Reduce gaps in portrait */
          #profileContent > div > div[style*="gap:15px"],
          #profileContent > div > div[style*="gap:20px"] {
            gap: 10px !important;
          }
        }
        
        /* LANDSCAPE MODE: Utilize horizontal space better */
        @media (max-width: 768px) and (orientation: landscape) {
          /* Keep 2 columns in landscape if space allows */
          #profileContent > div > div[style*="grid-template-columns"][style*="auto-fit"] {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) !important;
          }
          
          /* Tabs can be slightly larger */
          .profile-tab {
            font-size:0.85rem !important;
            padding:6px 10px !important;
          }
        }
        
        /* Sticky tab shadow effect */
        .tabs-scrolled {
          border-bottom:1px solid #00d4ff !important;
          box-shadow:0 2px 8px rgba(0,0,0,0.3) !important;
        }
      </style>
    `;
    
    ModalManager.show(modal, 'unifiedProfileModal');
    
    // Get UI elements
    const tabs = modal.querySelectorAll('.profile-tab');
    const content = modal.querySelector('#profileContent');
    const tabsContainer = modal.querySelector('#tabsContainer');
    const editBtn = modal.querySelector('#toggleEditBtn');
    const saveBtn = modal.querySelector('#saveProfileBtn');
    const closeBtn = modal.querySelector('#closeUnifiedProfile');
    
    let currentTab = initialTab;
    
    // Add scroll shadow effect to tabs
    content.addEventListener('scroll', () => {
      if (content.scrollTop > 10) {
        tabsContainer.classList.add('tabs-scrolled');
      } else {
        tabsContainer.classList.remove('tabs-scrolled');
      }
    });
    
    // Function to update content (respects edit mode)
    const updateContent = (tabId) => {
      currentTab = tabId;
      content.innerHTML = renderContent(tabId);
    };
    
    // Toggle edit mode
    editBtn.addEventListener('click', () => {
      isEditMode = !isEditMode;
      window.profileEditState.isEditMode = isEditMode;
      editBtn.textContent = isEditMode ? '👁️ View' : '✏️ Edit';
      editBtn.style.background = isEditMode ? '#e94560' : '#00d4ff';
      updateContent(currentTab);
    });
    
    // Save changes
    saveBtn.addEventListener('click', () => {
      // Apply edited data to actual employee
      Object.assign(employee, editedData);
      Object.assign(employee, window.profileEditState.editedData); // Also apply from global state
      hasUnsavedChanges = false;
      window.profileEditState.hasUnsavedChanges = false;
      saveBtn.style.display = 'none';
      showNotification('✅ Profile updated successfully!', 'success');
      updateUI(); // Refresh any displays that show employee data
    });
    
    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.dataset.tab;
        tabs.forEach(t => {
          t.classList.remove('active');
          t.style.background = '#16213e';
          t.style.color = '#fff';
          t.style.borderBottom = 'none';
        });
        tab.classList.add('active');
        tab.style.background = '#00d4ff';
        tab.style.color = '#0f1419';
        tab.style.borderBottom = '3px solid #ffd700';
        updateContent(tabId);
      });
    });
    
    // Close button
    closeBtn.addEventListener('click', () => {
      if (hasUnsavedChanges) {
        if (!confirm('You have unsaved changes. Are you sure you want to close?')) {
          return;
        }
      }
      ModalManager.close('unifiedProfileModal');
    });
    
    // Promote button (from overview tab)
    const promoteBtn = modal.querySelector(`#profilePromoteBtn_${employeeId}`);
    if (promoteBtn && !promoteBtn.disabled) {
      promoteBtn.addEventListener('click', () => {
        ModalManager.close('unifiedProfileModal');
        setTimeout(() => {
          openCorporatePyramidModal(employeeId);
        }, 150);
      });
    }
    
    // Helper function to mark changes
    window.markProfileChange = () => {
      hasUnsavedChanges = true;
      window.profileEditState.hasUnsavedChanges = true;
      saveBtn.style.display = 'block';
    };
    
    // Helper function to refresh current tab content (callable from outside)
    window.refreshUnifiedProfileTab = (employeeId) => {
      // Only refresh if this is the currently open profile
      if (employee.id === employeeId && content) {
        updateContent(currentTab);
      }
    };
  }

  // Function to set profile picture from gallery
  function setProfilePicture(employeeId, photoUrl) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    employee.profileImage = photoUrl;
    showNotification(`📷 Profile picture updated for ${employee.name}!`);
    saveGame();
    
    // Refresh the current tab to show the change
    const modal = document.getElementById('unifiedProfileModal');
    if (modal) {
      const contentDiv = modal.querySelector('[id^="profileContent"]');
      if (contentDiv) {
        // Find current active tab
        const activeTab = modal.querySelector('.profile-tab.active');
        if (activeTab && activeTab.dataset.tab === 'gallery') {
          // Re-render the gallery tab
          openUnifiedProfile(employeeId, 'gallery');
        } else if (activeTab && activeTab.dataset.tab === 'appearance') {
          // Re-render the appearance tab
          openUnifiedProfile(employeeId, 'appearance');
        }
      }
    }
    
    // Also update the people tab if it's visible
    updatePeopleTab();
  }

  // Function to open the unified profile modal to the gallery tab for updating profile picture
  function openGalleryForProfileUpdate(employeeId) {
    openUnifiedProfile(employeeId, 'gallery');
  }

  function openBioModal(employee) {
    // Initialize photos array if not exists
    if (!employee.photos) employee.photos = [];
    
    const modal = document.createElement('div');
    modal.id = 'bioModal';
    // Don't set inline styles - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.8)';
    
    const isEditing = false; // Toggle state
    
    // Helper to safely get nested values
    const getNestedValue = (obj, path, defaultVal = '') => {
      const parts = path.split('.');
      let current = obj;
      for (const part of parts) {
        if (current && current[part] !== undefined) {
          current = current[part];
        } else {
          return defaultVal;
        }
      }
      return current;
    };
    
    modal.innerHTML = `
      <div class="bio-modal-content" style="background:#16213e; width:92%; max-width:900px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#fff;">Employee Profile</h2>
          <div style="display:flex; gap:10px; align-items:center;">
            <button id="bioEditToggle" style="background:#00d4ff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; color:#0f1419; font-weight:600; display:flex; align-items:center; gap:6px;">
              <span style="font-size:1.1rem;">✏️</span> Edit
            </button>
            <button id="closeBioModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
          </div>
        </div>
        
        <!-- Content -->
        <div style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Profile Header -->
          <div style="display:flex; gap:20px; margin-bottom:25px; align-items:start;">
            <img src="${employee.profileImage || 'https://placehold.co/150x150'}" style="width:120px; height:120px; border-radius:10px; object-fit:cover; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
            <div style="flex:1;">
              <h3 id="bioName" contenteditable="false" style="margin:0 0 8px 0; font-size:1.8rem; outline:none; padding:4px; border-radius:4px;" data-field="name">${getColoredName(employee)}</h3>
              <p style="margin:0 0 6px 0; color:#aaa;">
                <span id="bioAge" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="age">${employee.age || 'N/A'}</span> years old • 
                <span id="bioGender" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px; color:${getGenderColor(employee.gender)};" data-field="gender">${employee.gender || 'Female'}</span>
              </p>
              <p style="margin:0; color:#00d4ff; font-weight:600;">
                <span id="bioPosition" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="position">${employee.position || 'Employee'}</span>
              </p>
              ${employee.productManaged ? `<p style="margin:4px 0 0 0; color:#aaa;">Product: <span id="bioProduct" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="productManaged">${employee.productManaged}</span></p>` : ''}
            </div>
          </div>
          
          <!-- Bio Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Biography</h4>
            <p id="bioBio" contenteditable="false" style="margin:0; color:#ddd; line-height:1.6; padding:12px; background:#0f3460; border-radius:6px; outline:none; min-height:60px;" data-field="bio">${employee.bio || 'No biography available.'}</p>
          </div>
          
          <!-- Main Stats Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Primary Statistics</h4>
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Affection
                  <span style="cursor:help; font-size:0.9rem;" title="How much they like you personally. Affects conversation warmth, willingness to chat, and proactive messages. Increases with compliments and positive interactions.">ℹ️</span>
                </div>
                <div style="color:#e94560; font-weight:600; font-size:1.2rem;">
                  <span id="bioAffection" contenteditable="false" style="outline:none;" data-field="stats.affection">${Math.round(employee.stats?.affection ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Comfort
                  <span style="cursor:help; font-size:0.9rem;" title="How relaxed they feel around you. Affects openness in conversations, photo sharing willingness, and memory formation. Low comfort reduces productivity. Build with consistent positive interactions.">ℹ️</span>
                </div>
                <div style="color:#4ecca3; font-weight:600; font-size:1.2rem;">
                  <span id="bioComfort" contenteditable="false" style="outline:none;" data-field="stats.comfort">${Math.round(employee.stats?.comfort ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Trust
                  <span style="cursor:help; font-size:0.9rem;" title="How much they believe in you. CRITICAL STAT: Directly boosts manager efficiency (up to +30% speed at 100 trust). Required for promotions. Build with consistent actions and keeping promises.">ℹ️</span>
                </div>
                <div style="color:#00d4ff; font-weight:600; font-size:1.2rem;">
                  <span id="bioTrust" contenteditable="false" style="outline:none;" data-field="stats.trust">${Math.round(employee.stats?.trust ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Desire
                  <span style="cursor:help; font-size:0.9rem;" title="Romantic/sexual attraction level. Affects conversation flavor and flirtiness. Unlocks intimate content at higher levels (60+ for suggestive, 75+ for intimate). Build with flirting and compliments.">ℹ️</span>
                </div>
                <div style="color:#ff6b9d; font-weight:600; font-size:1.2rem;">
                  <span id="bioDesire" contenteditable="false" style="outline:none;" data-field="stats.desire">${Math.round(employee.stats?.desire ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Obedience
                  <span style="cursor:help; font-size:0.9rem;" title="Willingness to follow directions. Increases request success rate (posts, photos, favors). Improves manager consistency (+8% at 100). Balance is key - too high/low can reduce productivity.">ℹ️</span>
                </div>
                <div style="color:#c77dff; font-weight:600; font-size:1.2rem;">
                  <span id="bioObedience" contenteditable="false" style="outline:none;" data-field="stats.obedience">${Math.round(employee.stats?.obedience ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Productivity
                  <span style="cursor:help; font-size:0.9rem;" title="Work efficiency. CRITICAL STAT: Directly boosts manager speed (+15% at 100) AND income (+20% at 100). Affected by comfort and trust. Essential for maximizing earnings.">ℹ️</span>
                </div>
                <div style="color:#ffd700; font-weight:600; font-size:1.2rem;">
                  <span id="bioProductivity" contenteditable="false" style="outline:none;" data-field="stats.productivity">${Math.round(employee.stats?.productivity ?? 0)}</span>%
                </div>
              </div>
            </div>
          </div>
          
          <!-- Hidden Stats Section (only visible in edit mode) -->
          <div id="hiddenStatsSection" style="margin-bottom:25px; display:none;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🔓 Advanced Stats (Sandbox Mode)</h4>
            
            <!-- Personality Attributes (AI uses these!) -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Personality Attributes (0-100)</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Confidence</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConfidence" contenteditable="false" style="outline:none;" data-field="personality.confidence">${Math.round(employee.personality?.confidence ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Outgoing</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioOutgoing" contenteditable="false" style="outline:none;" data-field="personality.outgoing">${Math.round(employee.personality?.outgoing ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Flirty</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioFlirty" contenteditable="false" style="outline:none;" data-field="personality.flirty">${Math.round(employee.personality?.flirty ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Professional</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioProfessional" contenteditable="false" style="outline:none;" data-field="personality.professional">${Math.round(employee.personality?.professional ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Humor</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioHumor" contenteditable="false" style="outline:none;" data-field="personality.humor">${Math.round(employee.personality?.humor ?? 50)}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- System Stats -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">System Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Intimacy Level</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioIntimacy" contenteditable="false" style="outline:none;" data-field="intimacy">${Math.round(employee.intimacy ?? 0)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Memory Cap <span style="cursor:help;" title="Max memories this NPC can store. Increasing this allows them to remember more context in conversations.">ℹ️</span></div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioMemoryCap" contenteditable="false" style="outline:none;" data-field="memory.cap">${employee.memory?.cap ?? 300}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Conversation Phase</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConversationPhase" contenteditable="false" style="outline:none;" data-field="memory.conversationPhase">${employee.memory?.conversationPhase ?? 'early'}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Career Stats -->
            <div>
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Career Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Loyalty Bonus</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioLoyaltyBonus" contenteditable="false" style="outline:none;" data-field="loyaltyBonus">${((employee.loyaltyBonus ?? 0) * 100).toFixed(0)}</span>%
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Times Rehired</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioTimesRehired" contenteditable="false" style="outline:none;" data-field="timesRehired">${employee.timesRehired ?? 0}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Employment Status</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioEmploymentStatus" contenteditable="false" style="outline:none;" data-field="employmentStatus">${employee.employmentStatus ?? 'active'}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Personality & Traits -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Personality & Interests</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Personality Traits</div>
                <div id="bioPersonality" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="personalityTraits">${(() => {
                  if (Array.isArray(employee.personalityTraits)) {
                    return employee.personalityTraits.join(', ');
                  } else if (employee.personality && typeof employee.personality === 'object') {
                    return Object.entries(employee.personality).map(([key, val]) => `${key}: ${val}`).join(', ');
                  } else if (Array.isArray(employee.personality)) {
                    return employee.personality.join(', ');
                  }
                  return 'None listed';
                })()}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Hobbies</div>
                <div id="bioHobbies" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="hobbies">${Array.isArray(employee.hobbies) ? employee.hobbies.join(', ') : 'None listed'}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Preferences</div>
                <div id="bioKinks" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="kinks">${Array.isArray(employee.kinks) ? employee.kinks.join(', ') : 'None listed'}</div>
              </div>
              <div>
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Key Trait</div>
                <div id="bioKeyTrait" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="keyTrait">${employee.keyTrait || employee.traits?.[0] || 'None listed'}</div>
              </div>
            </div>
          </div>
          
          <!-- Physical Appearance -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Physical Appearance</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              ${employee.physical?.fullDescription ? `
              <div style="margin-bottom:15px; padding:12px; background:rgba(0,212,255,0.1); border-left:3px solid #00d4ff; border-radius:4px;">
                <div style="font-size:.85rem; color:#00d4ff; margin-bottom:6px; font-weight:600;">✨ Full Description</div>
                <div id="bioPhysicalFull" contenteditable="false" style="color:#ddd; line-height:1.6; font-size:.95rem; outline:none;" data-field="physical.fullDescription">${employee.physical.fullDescription}</div>
              </div>
              ` : ''}
              
              <!-- Detailed Breakdown -->
              <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:12px;">
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Height & Build</div>
                  <div id="bioHeightBuild" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.heightBuild">${getNestedValue(employee, 'physical.heightBuild', 'Average')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Body Shape</div>
                  <div id="bioBodyShape" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.body.shape">${getNestedValue(employee, 'physical.body.shape', getNestedValue(employee, 'physical.bodyShape', 'Average'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Hair</div>
                  <div id="bioHair" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.hair.full">${getNestedValue(employee, 'physical.hair.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Eyes</div>
                  <div id="bioEyes" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.eyes.full">${getNestedValue(employee, 'physical.eyes.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Face</div>
                  <div id="bioFace" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.face.full">${getNestedValue(employee, 'physical.face.full', getNestedValue(employee, 'physical.face.shape', 'Not specified'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Skin</div>
                  <div id="bioSkin" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.skin.full">${getNestedValue(employee, 'physical.skin.full', getNestedValue(employee, 'physical.skin.tone', getNestedValue(employee, 'physical.skinTone', 'Not specified')))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Fashion Style</div>
                  <div id="bioFashion" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.fashion">${getNestedValue(employee, 'physical.fashion', 'Casual')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Distinguishing Feature</div>
                  <div id="bioDistinguishing" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.distinguishingFeature">${getNestedValue(employee, 'physical.distinguishingFeature', 'None noted')}</div>
                </div>
              </div>
              
              <!-- Genital Information (for image generation) -->
              <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,215,0,0.2);">
                <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">🔞 Genital Information</div>
                <div style="font-size:.75rem; color:#aaa; margin-bottom:10px; font-style:italic;">Used for accurate image generation</div>
                <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:12px;">
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Type</div>
                    <div id="bioGenitalType" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.type">${getNestedValue(employee, 'physical.genitals.type', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Size</div>
                    <div id="bioGenitalSize" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.size">${getNestedValue(employee, 'physical.genitals.size', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Characteristics</div>
                    <div id="bioGenitalCharacteristics" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.characteristics">${getNestedValue(employee, 'physical.genitals.characteristics', 'Not specified')}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Gift Preferences -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">🎁 Gift Preferences</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              <div style="margin-bottom:15px;">
                <div style="font-size:.85rem; color:#4ecca3; margin-bottom:8px; font-weight:600; display:flex; align-items:center; gap:6px;">
                  💕 Loves
                  <span style="color:#aaa; font-weight:normal; font-size:0.8rem;">(2-3x stat bonus!)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { loves: [] };
                    if (!prefs.loves || prefs.loves.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.loves.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(78,204,163,0.2); border:1px solid #4ecca3; padding:6px 12px; border-radius:20px; color:#4ecca3; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              <div style="margin-bottom:15px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:8px; font-weight:600;">
                  👍 Neutral
                  <span style="font-weight:normal; font-size:0.8rem;">(Normal stats)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { neutral: [] };
                    if (!prefs.neutral || prefs.neutral.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.neutral.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(170,170,170,0.1); border:1px solid #aaa; padding:6px 12px; border-radius:20px; color:#aaa; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              <div>
                <div style="font-size:.85rem; color:#e94560; margin-bottom:8px; font-weight:600; display:flex; align-items:center; gap:6px;">
                  💔 Hates
                  <span style="color:#aaa; font-weight:normal; font-size:0.8rem;">(Negative stats!)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { hates: [] };
                    if (!prefs.hates || prefs.hates.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.hates.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(233,69,96,0.2); border:1px solid #e94560; padding:6px 12px; border-radius:20px; color:#e94560; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              
              <!-- Gift History -->
              <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:8px; font-weight:600;">📊 Gift History</div>
                <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Total Gifts</div>
                    <div style="color:#4ecca3; font-weight:600;">${(employee.giftPreferences?.totalCount || 0)}</div>
                  </div>
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Total Value</div>
                    <div style="color:#4ecca3; font-weight:600;">$${formatCash(employee.giftPreferences?.totalValue || 0)}</div>
                  </div>
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Recent Gifts</div>
                    <div style="color:#4ecca3; font-weight:600;">${(() => {
                      const recentGifts = employee.giftPreferences?.recentGifts || [];
                      const last7Days = recentGifts.filter(g => {
                        const daysSince = (Date.now() - g.timestamp) / (1000 * 60 * 60 * 24);
                        return daysSince <= 7;
                      }).length;
                      return last7Days;
                    })()}</div>
                  </div>
                </div>
                
                <!-- Favorite Gifts -->
                ${(() => {
                  const favGifts = employee.giftPreferences?.favoriteGifts || [];
                  if (favGifts.length === 0) return '';
                  return `
                    <div style="margin-top:10px;">
                      <div style="font-size:.75rem; color:#aaa; margin-bottom:6px;">💝 Favorite Gifts:</div>
                      <div style="display:flex; flex-wrap:wrap; gap:6px;">
                        ${favGifts.slice(0, 5).map(gift => `
                          <span style="background:rgba(255,107,157,0.1); border:1px solid #ff6b9d; padding:4px 10px; border-radius:15px; color:#ff6b9d; font-size:0.85rem;">${gift.name}</span>
                        `).join('')}
                      </div>
                    </div>
                  `;
                })()}
              </div>
            </div>
          </div>
          
          <!-- Photo Gallery -->
          <div style="margin-bottom:20px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Photo Gallery</h4>
            <div id="bioPhotoGallery" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:10px; background:#0f3460; padding:15px; border-radius:6px; min-height:100px;">
              ${employee.photos && employee.photos.length > 0 
                ? employee.photos.map(photo => `<img src="${photo}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:6px; cursor:pointer;" onclick="window.open('${photo}', '_blank')">`).join('')
                : '<p style="color:#aaa; margin:0;">No photos yet. Photos will appear here as they are generated.</p>'}
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div style="padding:15px; border-top:1px solid #0f3460; display:flex; justify-content:flex-end; gap:10px;">
          <button id="bioSaveBtn" style="display:none; padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer;">💾 Save Changes</button>
          <button id="bioCancelBtn" style="display:none; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:#fff; font-weight:600; cursor:pointer;">✖️ Cancel</button>
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal with proper z-index management
    ModalManager.show(modal, 'bioModal');
    
    // Edit toggle functionality
    let editMode = false;
    let originalHTMLs = new Map(); // Store original HTML for restoration
    const editToggle = modal.querySelector('#bioEditToggle');
    const saveBtn = modal.querySelector('#bioSaveBtn');
    const cancelBtn = modal.querySelector('#bioCancelBtn');
    const editableElements = modal.querySelectorAll('[contenteditable]');
    const hiddenStatsSection = modal.querySelector('#hiddenStatsSection');
    
    editToggle.onclick = () => {
      editMode = !editMode;
      
      if (editMode) {
        // Enter edit mode (SANDBOX MODE)
        editToggle.innerHTML = '<span style="font-size:1.1rem;">🔒</span> View';
        editToggle.style.background = '#ffd700';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'block';
        cancelBtn.style.display = 'block';
        
        // Show hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'block';
        }
        
        // Make text fields editable
        editableElements.forEach(el => {
          // Skip stat values - they get buttons instead
          if (!el.id || !el.id.startsWith('bio') || el.id.includes('Name') || el.id.includes('Bio') || el.id.includes('Personality') || el.id.includes('Hobbies') || el.id.includes('Kinks') || el.id.includes('KeyTrait') || el.id.includes('Position') || el.id.includes('Age') || el.id.includes('Gender') || el.id.includes('Product') || el.id.includes('Physical') || el.id.includes('Height') || el.id.includes('Body') || el.id.includes('Hair') || el.id.includes('Eyes') || el.id.includes('Face') || el.id.includes('Skin') || el.id.includes('Fashion') || el.id.includes('Distinguishing') || el.id.includes('Genital')) {
            el.contentEditable = 'true';
            el.style.background = 'rgba(255, 215, 0, 0.15)';
            el.style.border = '1px dashed #ffd700';
            el.style.padding = '4px';
          }
        });
        
        // Add increment controls for primary stats
        originalHTMLs.set('bioAffection', createStatControls('bioAffection', employee.stats?.affection ?? 0));
        originalHTMLs.set('bioComfort', createStatControls('bioComfort', employee.stats?.comfort ?? 0));
        originalHTMLs.set('bioTrust', createStatControls('bioTrust', employee.stats?.trust ?? 0));
        originalHTMLs.set('bioDesire', createStatControls('bioDesire', employee.stats?.desire ?? 0));
        originalHTMLs.set('bioObedience', createStatControls('bioObedience', employee.stats?.obedience ?? 0));
        originalHTMLs.set('bioProductivity', createStatControls('bioProductivity', employee.stats?.productivity ?? 0));
        
        // Add increment controls for hidden stats
        originalHTMLs.set('bioIntimacy', createStatControls('bioIntimacy', employee.intimacy ?? 0));
        originalHTMLs.set('bioMemoryCap', createStatControls('bioMemoryCap', employee.memory?.cap ?? 300, 50, 1000));
        originalHTMLs.set('bioTimesRehired', createStatControls('bioTimesRehired', employee.timesRehired ?? 0, 0, 100));
        originalHTMLs.set('bioLoyaltyBonus', createStatControls('bioLoyaltyBonus', (employee.loyaltyBonus ?? 0) * 100, 0, 50));
        
        // Add increment controls for personality attributes
        originalHTMLs.set('bioConfidence', createStatControls('bioConfidence', employee.personality?.confidence ?? 50, 0, 100));
        originalHTMLs.set('bioOutgoing', createStatControls('bioOutgoing', employee.personality?.outgoing ?? 50, 0, 100));
        originalHTMLs.set('bioFlirty', createStatControls('bioFlirty', employee.personality?.flirty ?? 50, 0, 100));
        originalHTMLs.set('bioProfessional', createStatControls('bioProfessional', employee.personality?.professional ?? 50, 0, 100));
        originalHTMLs.set('bioHumor', createStatControls('bioHumor', employee.personality?.humor ?? 50, 0, 100));
        
        // Add dropdowns for enum fields
        originalHTMLs.set('bioConversationPhase', createDropdownControl('bioConversationPhase', employee.memory?.conversationPhase ?? 'early', [
          { value: 'early', label: 'Early (Getting to know you)' },
          { value: 'familiar', label: 'Familiar (Comfortable)' },
          { value: 'intimate', label: 'Intimate (Very close)' }
        ]));
        
        originalHTMLs.set('bioEmploymentStatus', createDropdownControl('bioEmploymentStatus', employee.employmentStatus ?? 'active', [
          { value: 'active', label: 'Active (Working)' },
          { value: 'candidate', label: 'Candidate (Not hired yet)' },
          { value: 'onboarding', label: 'Onboarding (In training)' },
          { value: 'former', label: 'Former (Left company)' }
        ]));
        
        // Add dropdowns for genital information (gender-specific options)
        const gender = employee.gender || 'Female';
        
        // Genital Type options based on gender
        let typeOptions = [];
        if (gender === 'Male') {
          typeOptions = [
            { value: 'penis', label: 'Penis' }
          ];
        } else if (gender === 'Trans Man') {
          typeOptions = [
            { value: 'enlarged clitoris', label: 'Enlarged Clitoris (Pre-HRT)' },
            { value: 'post-op penis', label: 'Post-Op Penis (Phalloplasty)' },
            { value: 'pre-op anatomy', label: 'Pre-Op Anatomy' }
          ];
        } else if (gender === 'Female Futa') {
          typeOptions = [
            { value: 'penis and vagina', label: 'Penis and Vagina (Dual)' }
          ];
        } else if (gender === 'Trans Woman') {
          typeOptions = [
            { value: 'vagina (post-op)', label: 'Vagina (Post-Op)' },
            { value: 'penis (pre-op)', label: 'Penis (Pre-Op)' },
            { value: 'tucked', label: 'Tucked (HRT)' }
          ];
        } else { // Female
          typeOptions = [
            { value: 'vagina', label: 'Vagina' }
          ];
        }
        
        // Genital Size options based on gender and type
        let sizeOptions = [];
        const currentType = employee.physical?.genitals?.type || typeOptions[0]?.value || 'vagina';
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          if (gender === 'Trans Man' && currentType === 'post-op penis') {
            sizeOptions = [
              { value: 'small', label: 'Small (Typical for phalloplasty)' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' }
            ];
          } else {
            sizeOptions = [
              { value: 'small', label: 'Small' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' },
              { value: 'above average', label: 'Above Average' },
              { value: 'large', label: 'Large' },
              { value: 'very large', label: 'Very Large' }
            ];
          }
        } else if (currentType === 'penis and vagina') {
          sizeOptions = [
            { value: 'average', label: 'Average' },
            { value: 'above average', label: 'Above Average' },
            { value: 'large', label: 'Large' },
            { value: 'very large', label: 'Very Large' },
            { value: 'impressive', label: 'Impressive' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          sizeOptions = [
            { value: 'tight', label: 'Tight' },
            { value: 'snug', label: 'Snug' },
            { value: 'average', label: 'Average' },
            { value: 'relaxed', label: 'Relaxed' },
            { value: 'accommodating', label: 'Accommodating' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          sizeOptions = [
            { value: 'slightly enlarged', label: 'Slightly Enlarged' },
            { value: 'noticeably enlarged', label: 'Noticeably Enlarged' },
            { value: 'significantly enlarged', label: 'Significantly Enlarged' }
          ];
        } else {
          sizeOptions = [
            { value: 'average', label: 'Average' }
          ];
        }
        
        // Characteristics options based on gender and type
        let characteristicsOptions = [];
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          characteristicsOptions = [
            { value: 'circumcised', label: 'Circumcised' },
            { value: 'uncircumcised', label: 'Uncircumcised' }
          ];
        } else if (currentType === 'penis and vagina') {
          characteristicsOptions = [
            { value: 'fully functional dual anatomy', label: 'Fully Functional Dual Anatomy' },
            { value: 'prominent dual features', label: 'Prominent Dual Features' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          characteristicsOptions = [
            { value: 'waxed smooth', label: 'Waxed Smooth' },
            { value: 'neatly trimmed', label: 'Neatly Trimmed' },
            { value: 'natural', label: 'Natural' },
            { value: 'fully shaved', label: 'Fully Shaved' },
            { value: 'landing strip', label: 'Landing Strip' },
            { value: 'shaped', label: 'Shaped' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          characteristicsOptions = [
            { value: 'sensitive and prominent', label: 'Sensitive and Prominent' },
            { value: 'HRT-enhanced', label: 'HRT-Enhanced' }
          ];
        } else if (currentType === 'tucked') {
          characteristicsOptions = [
            { value: 'carefully tucked', label: 'Carefully Tucked' },
            { value: 'HRT-softened', label: 'HRT-Softened' }
          ];
        } else {
          characteristicsOptions = [
            { value: 'natural', label: 'Natural' }
          ];
        }
        
        originalHTMLs.set('bioGenitalType', createDropdownControl('bioGenitalType', employee.physical?.genitals?.type ?? typeOptions[0]?.value, typeOptions));
        originalHTMLs.set('bioGenitalSize', createDropdownControl('bioGenitalSize', employee.physical?.genitals?.size ?? sizeOptions[0]?.value, sizeOptions));
        originalHTMLs.set('bioGenitalCharacteristics', createDropdownControl('bioGenitalCharacteristics', employee.physical?.genitals?.characteristics ?? characteristicsOptions[0]?.value, characteristicsOptions));
        
      } else {
        // Exit edit mode without saving - restore original HTML
        editToggle.innerHTML = '<span style="font-size:1.1rem;">✏️</span> Edit';
        editToggle.style.background = '#00d4ff';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        
        // Hide hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'none';
        }
        
        // Restore original HTML for all modified elements
        originalHTMLs.forEach((html, elementId) => {
          const element = document.getElementById(elementId);
          if (element && element.parentElement) {
            element.parentElement.innerHTML = html;
          }
        });
        originalHTMLs.clear();
        
        editableElements.forEach(el => {
          el.contentEditable = 'false';
          el.style.background = '';
          el.style.border = '';
          el.style.padding = '';
        });
      }
    };
    
    // Save changes
    saveBtn.onclick = () => {
      // Read from stat buttons/dropdowns first
      const statIds = ['bioAffection', 'bioComfort', 'bioTrust', 'bioDesire', 'bioObedience', 'bioProductivity'];
      statIds.forEach(id => {
        const el = document.getElementById(id);
        if (el && employee.stats) {
          const statName = id.replace('bio', '').toLowerCase();
          employee.stats[statName] = parseInt(el.textContent) || 0;
        }
      });
      
      // Read hidden stats
      const intimacyEl = document.getElementById('bioIntimacy');
      if (intimacyEl) employee.intimacy = parseInt(intimacyEl.textContent) || 0;
      
      const memoryCapEl = document.getElementById('bioMemoryCap');
      if (memoryCapEl && employee.memory) {
        employee.memory.cap = parseInt(memoryCapEl.textContent) || 300;
      }
      
      const timesRehiredEl = document.getElementById('bioTimesRehired');
      if (timesRehiredEl) employee.timesRehired = parseInt(timesRehiredEl.textContent) || 0;
      
      const loyaltyBonusEl = document.getElementById('bioLoyaltyBonus');
      if (loyaltyBonusEl) employee.loyaltyBonus = (parseInt(loyaltyBonusEl.textContent) || 0) / 100;
      
      // Read personality attributes - FIXED: Ensure personality object exists
      if (!employee.personality) employee.personality = {};
      
      const confidenceEl = document.getElementById('bioConfidence');
      if (confidenceEl) employee.personality.confidence = parseInt(confidenceEl.textContent) || 50;
      
      const outgoingEl = document.getElementById('bioOutgoing');
      if (outgoingEl) employee.personality.outgoing = parseInt(outgoingEl.textContent) || 50;
      
      const flirtyEl = document.getElementById('bioFlirty');
      if (flirtyEl) employee.personality.flirty = parseInt(flirtyEl.textContent) || 50;
      
      const professionalEl = document.getElementById('bioProfessional');
      if (professionalEl) employee.personality.professional = parseInt(professionalEl.textContent) || 50;
      
      const humorEl = document.getElementById('bioHumor');
      if (humorEl) employee.personality.humor = parseInt(humorEl.textContent) || 50;
      
      // Read dropdowns - FIXED: Ensure memory object exists for conversationPhase
      const conversationPhaseEl = document.getElementById('bioConversationPhase');
      if (conversationPhaseEl) {
        if (!employee.memory) employee.memory = {};
        employee.memory.conversationPhase = conversationPhaseEl.value || 'early';
      }
      
      const employmentStatusEl = document.getElementById('bioEmploymentStatus');
      if (employmentStatusEl) {
        employee.employmentStatus = employmentStatusEl.value || 'active';
      }
      
      // Read genital information dropdowns
      const genitalTypeEl = document.getElementById('bioGenitalType');
      const genitalSizeEl = document.getElementById('bioGenitalSize');
      const genitalCharacteristicsEl = document.getElementById('bioGenitalCharacteristics');
      
      if (genitalTypeEl || genitalSizeEl || genitalCharacteristicsEl) {
        if (!employee.physical) employee.physical = {};
        if (!employee.physical.genitals) employee.physical.genitals = {};
        
        if (genitalTypeEl) {
          employee.physical.genitals.type = genitalTypeEl.value || 'Not specified';
        }
        if (genitalSizeEl) {
          employee.physical.genitals.size = genitalSizeEl.value || 'Not specified';
        }
        if (genitalCharacteristicsEl) {
          employee.physical.genitals.characteristics = genitalCharacteristicsEl.value || 'Not specified';
        }
        
        // Update the full description
        if (employee.physical.genitals.type && employee.physical.genitals.size && employee.physical.genitals.characteristics) {
          employee.physical.genitals.full = `${employee.physical.genitals.size} ${employee.physical.genitals.type}, ${employee.physical.genitals.characteristics}`;
          
          // Also update fullDescription if it exists
          if (employee.physical.fullDescription) {
            // Replace the genitals line in fullDescription
            const genitalLine = `Genitals: ${employee.physical.genitals.full}`;
            const genitalRegex = /Genitals:.*?(?=\n|$)/;
            if (genitalRegex.test(employee.physical.fullDescription)) {
              employee.physical.fullDescription = employee.physical.fullDescription.replace(genitalRegex, genitalLine);
            } else {
              // Add it if not present
              employee.physical.fullDescription += `\nGenitals: ${employee.physical.genitals.full}`;
            }
          }
        }
      }
      
      // Read from text fields
      editableElements.forEach(el => {
        const field = el.dataset.field;
        const value = el.textContent.trim();
        
        if (field) {
          // Handle nested fields (e.g., "stats.affection", "physical.hair.full")
          const parts = field.split('.');
          let target = employee;
          
          for (let i = 0; i < parts.length - 1; i++) {
            if (!target[parts[i]]) target[parts[i]] = {};
            target = target[parts[i]];
          }
          
          const lastPart = parts[parts.length - 1];
          
          // Special handling for different field types
          if (field === 'personalityTraits' || field === 'hobbies' || field === 'kinks') {
            // Arrays - split by comma
            target[lastPart] = value.split(',').map(s => s.trim()).filter(Boolean);
          } 
          else if (field === 'age') {
            // Integer
            target[lastPart] = parseInt(value) || 0;
          }
          else if (!field.startsWith('stats.') && field !== 'intimacy' && field !== 'memory.cap' && field !== 'timesRehired' && field !== 'loyaltyBonus' && field !== 'memory.conversationPhase' && field !== 'employmentStatus') {
            // String fields (skip the ones we already handled above)
            target[lastPart] = value;
          }
        }
      });
      
      // Ensure stats are clamped to valid ranges
      if (employee.stats) {
        Object.keys(employee.stats).forEach(key => {
          employee.stats[key] = Math.max(0, Math.min(100, employee.stats[key]));
        });
      }
      
      // Ensure personality stats are clamped
      if (employee.personality) {
        ['confidence', 'outgoing', 'flirty', 'professional', 'humor'].forEach(key => {
          if (employee.personality[key] !== undefined) {
            employee.personality[key] = Math.max(0, Math.min(100, employee.personality[key]));
          }
        });
      }
      
      // Ensure intimacy is clamped
      if (employee.intimacy !== undefined) {
        employee.intimacy = Math.max(0, Math.min(100, employee.intimacy));
      }
      
      // Ensure memory cap is reasonable
      if (employee.memory && employee.memory.cap !== undefined) {
        employee.memory.cap = Math.max(50, Math.min(1000, employee.memory.cap));
      }
      
      // CRITICAL: Ensure memory structure is valid after all changes
      ensureEmployeeMemory(employee);
      ensureEmployeeStats(employee);
      ensureEmployeePersonality(employee);
      
      showNotification('💾 Bio updated successfully! All changes saved.');
      saveGame(); // Save the game state
      updatePeopleTab(); // Refresh the people list
      
      // CRITICAL FIX: Refresh the modal display with updated values
      // This ensures when you toggle back to view mode or reopen, you see the saved values
      ModalManager.close('bioModal');
      
      // Small delay to allow modal to close, then reopen with fresh data
      setTimeout(() => {
        openBioModal(employee);
      }, 100);
    };
    
    // Cancel changes
    cancelBtn.onclick = () => {
      if (confirm('Discard changes?')) {
        ModalManager.close('bioModal');
      }
    };
    
    // Close modal
    modal.querySelector('#closeBioModal').onclick = () => {
      if (editMode) {
        if (confirm('You have unsaved changes. Close anyway?')) {
          ModalManager.close('bioModal');
        }
      } else {
        ModalManager.close('bioModal');
      }
    };
    
    // Click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) {
        if (editMode) {
          if (confirm('You have unsaved changes. Close anyway?')) {
            ModalManager.close('bioModal');
          }
        } else {
          ModalManager.close('bioModal');
        }
      }
    };
  }
  
  // Load chat history
  function loadChatHistory(employeeId) {
    if (!chatMessages) return;
    
    chatMessages.innerHTML = '';
    const history = gameState.chatHistory[employeeId] || [];
    
    history.forEach((msg, index) => {
      // Handle scene visualizations specially
      if (msg.imageType === 'scene') {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:10px auto; text-align:center; position:relative;';
        
        const imageContainer = document.createElement('div');
        imageContainer.style.cssText = 'position:relative; display:inline-block; max-width:400px; width:100%;';
        
        const img = document.createElement('img');
        img.src = msg.imageUrl;
        img.style.cssText = 'width:100%; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3); display:block;';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${msg.imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        imageContainer.appendChild(img);
        
        // Add regenerate button for scene images if we have the prompt
        if (msg.imagePrompt) {
          const imgRegenBtn = document.createElement('button');
          imgRegenBtn.innerHTML = '🔄';
          imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
          imgRegenBtn.title = 'Regenerate image';
          
          imageContainer.appendChild(imgRegenBtn);
          
          // Show/hide on hover
          imageContainer.addEventListener('mouseenter', () => {
            imgRegenBtn.style.opacity = '1';
          });
          imageContainer.addEventListener('mouseleave', () => {
            imgRegenBtn.style.opacity = '0';
          });
          
          // Handle image regeneration
          imgRegenBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            await regenerateImage(index, msg.imagePrompt);
          });
        }
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = msg.content;
        
        messageEl.appendChild(imageContainer);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
      } else if (msg.giftData) {
        // Render gift message specially
        addGiftMessage(msg.sender, msg.content, msg.giftData, msg.isPlayer);
      } else {
        // Pass index for both player and NPC messages so edit/resend/regenerate buttons work
        addChatMessage(msg.sender, msg.content, msg.isPlayer, msg.imageUrl, index, msg.imagePrompt);
      }
    });
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Helper function to style action text (enclosed in asterisks)
  function styleActionText(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    const escaped = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
    
    // Replace *action text* with styled span
    // Match text between asterisks, but not standalone asterisks
    const styled = escaped.replace(/\*([^*]+)\*/g, (match, content) => {
      return `<span style="color:#888; font-style:italic; opacity:0.85;">${content}</span>`;
    });
    
    return styled;
  }
  
  // Add chat message to UI
  function addChatMessage(sender, content, isPlayer, imageUrl = null, messageIndex = null, imagePrompt = null) {
    if (!chatMessages) return;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `max-width:80%; padding:10px 15px; border-radius:18px; margin-bottom:10px; word-wrap:break-word; position:relative; ${isPlayer ? 'background:#e94560; align-self:flex-end;' : 'background:#0f3460; align-self:flex-start;'}`;
    
    // Add edit/resend buttons for PLAYER messages
    if (isPlayer && messageIndex !== null) {
      const actionContainer = document.createElement('div');
      actionContainer.style.cssText = 'position:absolute; top:5px; right:5px; display:flex; gap:4px; opacity:0.01; transition:opacity 0.2s;';
      actionContainer.className = 'message-action-buttons';
      
      // Edit button
      const editBtn = document.createElement('button');
      editBtn.innerHTML = '✏️';
      editBtn.className = 'edit-msg-btn';
      editBtn.style.cssText = 'background:rgba(255,152,0,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      editBtn.setAttribute('data-message-index', messageIndex);
      editBtn.title = 'Edit message';
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        editPlayerMessage(messageIndex);
      });
      
      // Resend button
      const resendBtn = document.createElement('button');
      resendBtn.innerHTML = '🔄';
      resendBtn.className = 'resend-msg-btn';
      resendBtn.style.cssText = 'background:rgba(76,175,80,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      resendBtn.setAttribute('data-message-index', messageIndex);
      resendBtn.title = 'Resend message';
      resendBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        resendPlayerMessage(messageIndex);
      });
      
      actionContainer.appendChild(editBtn);
      actionContainer.appendChild(resendBtn);
      messageEl.appendChild(actionContainer);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        actionContainer.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        actionContainer.style.opacity = '0.01';
      });
    }
    
    // Add regenerate button for NPC messages
    if (!isPlayer && messageIndex !== null) {
      const regenBtn = document.createElement('button');
      regenBtn.innerHTML = '♻️';
      regenBtn.className = 'regenerate-btn';
      regenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(33,150,243,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.9rem; opacity:0.01; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center; padding:0;';
      regenBtn.setAttribute('data-message-index', messageIndex);
      regenBtn.title = 'Regenerate response (click for new variation)';
      
      messageEl.appendChild(regenBtn);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        regenBtn.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        regenBtn.style.opacity = '0.01';
      });
      
      // Handle regeneration
      regenBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await regenerateMessage(messageIndex);
      });
    }
    
    // Add image if present
    if (imageUrl) {
      const imageContainer = document.createElement('div');
      imageContainer.style.cssText = 'position:relative; display:inline-block; width:100%; max-width:300px;';
      
      const img = document.createElement('img');
      img.src = imageUrl;
      img.style.cssText = 'width:100%; border-radius:10px; margin-bottom:8px; cursor:pointer; display:block;';
      img.onclick = () => {
        // Open image in larger view
        const viewer = document.createElement('div');
        viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
        viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
        viewer.onclick = () => viewer.remove();
        document.body.appendChild(viewer);
      };
      imageContainer.appendChild(img);
      
      // Add regenerate button for images if we have the prompt and messageIndex
      if (imagePrompt && messageIndex !== null) {
        const imgRegenBtn = document.createElement('button');
        imgRegenBtn.innerHTML = '🔄';
        imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
        imgRegenBtn.title = 'Regenerate image';
        
        imageContainer.appendChild(imgRegenBtn);
        
        // Show/hide on hover
        imageContainer.addEventListener('mouseenter', () => {
          imgRegenBtn.style.opacity = '1';
        });
        imageContainer.addEventListener('mouseleave', () => {
          imgRegenBtn.style.opacity = '0';
        });
        
        // Handle image regeneration
        imgRegenBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await regenerateImage(messageIndex, imagePrompt);
        });
      }
      
      messageEl.appendChild(imageContainer);
    }
    
    const textEl = document.createElement('p');
    textEl.style.margin = '0';
    textEl.style.marginBottom = !isPlayer ? '8px' : '0'; // Add margin for vote buttons
    
    // Process content to style asterisk-enclosed text (actions/thoughts)
    const processedContent = styleActionText(content);
    textEl.innerHTML = processedContent;
    
    messageEl.appendChild(textEl);
    
    // Add vote buttons for NPC messages (not player messages)
    if (!isPlayer && messageIndex !== null) {
      const voteContainer = document.createElement('div');
      voteContainer.style.cssText = 'display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:12px; padding:2px 4px; width:fit-content; margin-top:6px;';
      
      // Get the current message to check vote status
      // activeChat can be either an ID string or an employee object, so handle both
      const employeeId = typeof gameState.activeChat === 'string' ? gameState.activeChat : gameState.activeChat?.id;
      const history = gameState.chatHistory[employeeId] || [];
      const message = history[messageIndex];
      
      // Create upvote button
      const upvoteBtn = document.createElement('button');
      upvoteBtn.style.cssText = `background:${message?.playerVote === 'up' ? 'rgba(255, 69, 0, 0.2)' : 'transparent'}; border:${message?.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:4px 6px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;`;
      upvoteBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="${message?.playerVote === 'up' ? '#ff4500' : '#8899a6'}"><path d="M12 4l8 8h-6v8h-4v-8H4z"/></svg>`;
      upvoteBtn.addEventListener('mouseenter', () => upvoteBtn.style.transform = 'scale(1.15)');
      upvoteBtn.addEventListener('mouseleave', () => upvoteBtn.style.transform = 'scale(1)');
      upvoteBtn.addEventListener('click', () => voteOnChatMessage(employeeId, messageIndex, 'up'));
      
      // Create downvote button
      const downvoteBtn = document.createElement('button');
      downvoteBtn.style.cssText = `background:${message?.playerVote === 'down' ? 'rgba(113, 147, 255, 0.2)' : 'transparent'}; border:${message?.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:4px 6px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;`;
      downvoteBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="${message?.playerVote === 'down' ? '#7193ff' : '#8899a6'}"><path d="M12 20l-8-8h6V4h4v8h6z"/></svg>`;
      downvoteBtn.addEventListener('mouseenter', () => downvoteBtn.style.transform = 'scale(1.15)');
      downvoteBtn.addEventListener('mouseleave', () => downvoteBtn.style.transform = 'scale(1)');
      downvoteBtn.addEventListener('click', () => voteOnChatMessage(employeeId, messageIndex, 'down'));
      
      voteContainer.appendChild(upvoteBtn);
      voteContainer.appendChild(downvoteBtn);
      messageEl.appendChild(voteContainer);
    }
    
    chatMessages.appendChild(messageEl);
  }
  
  // Add a gift message with rich display
  function addGiftMessage(sender, content, giftData, isPlayer) {
    if (!chatMessages) return;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `max-width:80%; padding:12px; border-radius:15px; margin-bottom:10px; ${isPlayer ? 'background:#16213e; align-self:flex-end; border:2px solid #e94560;' : 'background:#0f3460; align-self:flex-start;'}`;
    
    // Gift header
    const header = document.createElement('div');
    header.style.cssText = 'display:flex; align-items:center; gap:8px; margin-bottom:10px;';
    header.innerHTML = `<span style="font-size:1.5rem;">${giftData.categoryEmoji || '🎁'}</span><strong style="color:#4ecca3;">Gift Given</strong>`;
    messageEl.appendChild(header);
    
    // Gift details card
    const detailsCard = document.createElement('div');
    detailsCard.style.cssText = 'background:rgba(0,0,0,0.3); padding:10px; border-radius:10px; margin-bottom:10px;';
    
    // Gift name
    const nameEl = document.createElement('div');
    nameEl.style.cssText = 'font-size:1.1rem; font-weight:600; color:white; margin-bottom:5px;';
    nameEl.textContent = giftData.name;
    detailsCard.appendChild(nameEl);
    
    // Category and price
    const metaEl = document.createElement('div');
    metaEl.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
    metaEl.innerHTML = `
      <span style="color:#aaa; font-size:0.9rem;">${giftData.categoryEmoji} ${giftData.categoryName}</span>
      <span style="color:#4ecca3; font-weight:600; font-size:1.1rem;">$${formatCash(giftData.price)}</span>
    `;
    detailsCard.appendChild(metaEl);
    
    // Description
    if (giftData.description) {
      const descEl = document.createElement('div');
      descEl.style.cssText = 'color:#ccc; font-size:0.85rem; line-height:1.4; margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);';
      descEl.textContent = giftData.description;
      detailsCard.appendChild(descEl);
    }
    
    messageEl.appendChild(detailsCard);
    
    // Optional personal message from player
    if (content && content !== '🎁 Gave a gift') {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-top: 12px;
        padding: 10px 12px;
        background: linear-gradient(135deg, rgba(255,105,180,0.15), rgba(147,112,219,0.15));
        border-left: 3px solid #ff69b4;
        border-radius: 8px;
        position: relative;
      `;
      
      // Message icon
      const iconEl = document.createElement('span');
      iconEl.textContent = '💌';
      iconEl.style.cssText = 'font-size:1.2rem; margin-right:6px; vertical-align:middle;';
      msgEl.appendChild(iconEl);
      
      // Message text
      const textEl = document.createElement('span');
      textEl.style.cssText = 'color:#fff; font-size:0.95rem; line-height:1.5; font-style:italic;';
      textEl.innerHTML = `"${styleActionText(content)}"`;
      msgEl.appendChild(textEl);
      
      messageEl.appendChild(msgEl);
    }
    
    chatMessages.appendChild(messageEl);
  }
  
  // Add a money request message with Accept/Deny/Counter buttons
  function addMoneyRequestMessage(emp, amount, reason, messageIndex) {
    if (!chatMessages) return;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = 'max-width:80%; padding:10px 15px; border-radius:18px; margin-bottom:10px; word-wrap:break-word; position:relative; background:#0f3460; align-self:flex-start; border:2px solid #4ecca3;';
    
    // Message content
    const textEl = document.createElement('p');
    textEl.style.margin = '0 0 10px 0';
    textEl.innerHTML = styleActionText(reason);
    messageEl.appendChild(textEl);
    
    // Money request badge
    const badge = document.createElement('div');
    badge.style.cssText = 'display:inline-block; background:#4ecca3; color:#16213e; padding:5px 10px; border-radius:8px; font-weight:600; margin-bottom:10px;';
    badge.textContent = `💰 $${formatCash(amount)}`;
    messageEl.appendChild(badge);
    
    // Button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display:flex; gap:8px; margin-top:10px;';
    btnContainer.id = `money-request-${messageIndex}`;
    
    // Accept button
    const acceptBtn = document.createElement('button');
    acceptBtn.style.cssText = 'flex:1; padding:8px 12px; background:#4ecca3; border:none; border-radius:6px; color:#16213e; cursor:pointer; font-weight:600; transition:all 0.2s;';
    acceptBtn.textContent = '✓ Accept';
    acceptBtn.addEventListener('mouseenter', () => {
      acceptBtn.style.background = '#5efcb3';
    });
    acceptBtn.addEventListener('mouseleave', () => {
      acceptBtn.style.background = '#4ecca3';
    });
    acceptBtn.addEventListener('click', async () => {
      await handleMoneyRequestResponse(emp, amount, reason, messageIndex, 'accept');
    });
    
    // Counter button (new!)
    const counterBtn = document.createElement('button');
    counterBtn.style.cssText = 'flex:1; padding:8px 12px; background:#ff9800; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;';
    counterBtn.textContent = '↔️ Counter';
    counterBtn.addEventListener('mouseenter', () => {
      counterBtn.style.background = '#ffa726';
    });
    counterBtn.addEventListener('mouseleave', () => {
      counterBtn.style.background = '#ff9800';
    });
    counterBtn.addEventListener('click', () => {
      openCounterOfferModal(emp, amount, reason, messageIndex);
    });
    
    // Deny button
    const denyBtn = document.createElement('button');
    denyBtn.style.cssText = 'flex:1; padding:8px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;';
    denyBtn.textContent = '✗ Deny';
    denyBtn.addEventListener('mouseenter', () => {
      denyBtn.style.background = '#ff5570';
    });
    denyBtn.addEventListener('mouseleave', () => {
      denyBtn.style.background = '#e94560';
    });
    denyBtn.addEventListener('click', async () => {
      await handleMoneyRequestResponse(emp, amount, reason, messageIndex, 'deny');
    });
    
    btnContainer.appendChild(acceptBtn);
    btnContainer.appendChild(counterBtn);
    btnContainer.appendChild(denyBtn);
    messageEl.appendChild(btnContainer);
    
    chatMessages.appendChild(messageEl);
  }
  
  // Handle money request response (Accept/Deny/Counter)
  async function handleMoneyRequestResponse(emp, amount, reason, messageIndex, action) {
    // Remove the buttons
    const btnContainer = document.getElementById(`money-request-${messageIndex}`);
    if (btnContainer) {
      btnContainer.remove();
    }
    
    if (action === 'accept') {
      // Check if player has enough money
      if (gameState.cash < amount) {
        addChatMessage('You', `[Insufficient funds - need $${formatCash(amount)}]`, true);
        
        // NPC reaction to rejection due to no money
        const response = await generateText(`${emp.name} (${emp.personality}) asked you for $${formatCash(amount)} but you don't have enough money. Respond to being told you can't afford it (2-3 sentences, conversational).`);
        const sanitized = sanitizeNpcResponse(response, 3);
        
        gameState.chatHistory[emp.id].push({
          sender: emp.name,
          content: sanitized,
          isPlayer: false,
          timestamp: Date.now()
        });
        
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, sanitized, false, null, newIndex);
        
        return;
      }
      
      // Mark NPC as typing
      if (!gameState.typingStates) gameState.typingStates = {};
      gameState.typingStates[emp.id] = true;
      
      // Show typing indicator (only if this is the active chat)
      if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = emp.name;
      }
      
      // Update bank balance
      if (!emp.bankBalance) emp.bankBalance = 0;
      emp.bankBalance += amount;
      
      // Deduct money
      gameState.cash = Math.max(0, gameState.cash - amount);
      updateUI();
      
      // Add acceptance message
      addChatMessage('You', `✓ Accepted - Sent $${formatCash(amount)}`, true);
      
      // Add to history
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: `✓ Accepted money request - Sent $${formatCash(amount)}`,
        isPlayer: true,
        isMoneyRequest: true,
        accepted: true,
        amount: amount,
        timestamp: Date.now()
      });
      
      // Generate grateful response
      const conversationHistory = gameState.chatHistory[emp.id]
        .slice(-10)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You just asked the player for $${formatCash(amount)} (reason: "${reason}") and they ACCEPTED and sent you the money!

Respond with gratitude and acknowledgment (3-8 sentences). Consider:
- Your personality (${emp.personality})
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Obedience: ${emp.obedience}, Desire: ${emp.desire}, Trust: ${emp.trust})
- What you asked the money for
- How this makes you feel about them

${emp.name}'s response:`;
      
      const raw = await generateText(responsePrompt);
      const response = sanitizeNpcResponse(raw, 10);
      
      // Clear typing state
      gameState.typingStates[emp.id] = false;
      
      // Hide typing indicator (only if this is still the active chat)
      if (chatTypingIndicator && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'none';
      }
      
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, newIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Update stats - accepting requests increases favor
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 8);
      emp.trust = Math.min(100, (emp.trust || 0) + 8);
      emp.obedience = Math.min(100, (emp.obedience || 0) + 5);
      emp.desire = Math.min(100, (emp.desire || 0) + 3);
      
      showNotification(`💰 Gave ${emp.name} $${formatCash(amount)}\n+8 Affection, +8 Trust, +5 Obedience, +3 Desire`, 'success');
      
      // Memory
      remember(emp, `Boss accepted my request for $${formatCash(amount)} (${reason})`, 'event', 2.0);
      
      updateUI();
      
    } else if (action === 'deny') {
      // Denied
      addChatMessage('You', `✗ Denied money request`, true);
      
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: `✗ Denied money request for $${formatCash(amount)}`,
        isPlayer: true,
        isMoneyRequest: true,
        accepted: false,
        amount: amount,
        timestamp: Date.now()
      });
      
      // Mark NPC as typing
      if (!gameState.typingStates) gameState.typingStates = {};
      gameState.typingStates[emp.id] = true;
      
      // Show typing indicator (only if this is the active chat)
      if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = emp.name;
      }
      
      // Generate disappointed response
      const conversationHistory = gameState.chatHistory[emp.id]
        .slice(-10)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You just asked the player for $${formatCash(amount)} (reason: "${reason}") and they DENIED your request.

Respond with disappointment but stay in character (3-6 sentences). Consider:
- Your personality (${emp.personality})
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Obedience: ${emp.obedience}, Desire: ${emp.desire}, Trust: ${emp.trust})
- What you asked the money for
- How this rejection makes you feel

${emp.name}'s response:`;
      
      const raw = await generateText(responsePrompt);
      const response = sanitizeNpcResponse(raw, 8);
      
      // Clear typing state
      gameState.typingStates[emp.id] = false;
      
      // Hide typing indicator (only if this is still the active chat)
      if (chatTypingIndicator && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'none';
      }
      
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, newIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Update stats - denying requests decreases favor slightly
      emp.stats.affection = Math.max(0, (emp.stats.affection || 0) - 3);
      emp.trust = Math.max(0, (emp.trust || 0) - 3);
      emp.desire = Math.max(0, (emp.desire || 0) - 2);
      
      showNotification(`${emp.name} was denied\n-3 Affection, -3 Trust, -2 Desire`, 'warning');
      
      // Memory
      remember(emp, `Boss denied my request for $${formatCash(amount)} (${reason})`, 'event', 1.5);
      
      updateUI();
    }
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Open counter offer modal
  function openCounterOfferModal(emp, requestedAmount, reason, messageIndex) {
    // Store context for later
    window.counterOfferContext = { emp, requestedAmount, reason, messageIndex };
    
    // Populate modal
    document.getElementById('counterOriginalAmount').textContent = '$' + formatCash(requestedAmount);
    document.getElementById('counterYourBalance').textContent = '$' + formatCash(gameState.cash);
    document.getElementById('counterAmount').value = '';
    document.getElementById('counterJustification').value = '';
    
    // Show modal
    document.getElementById('counterOfferModal').style.display = 'flex';
  }
  
  // Handle counter offer submission
  async function submitCounterOffer() {
    const context = window.counterOfferContext;
    if (!context) return;
    
    const { emp, requestedAmount, reason, messageIndex } = context;
    
    const counterAmount = parseInt(document.getElementById('counterAmount').value) || 0;
    const justification = document.getElementById('counterJustification').value.trim();
    
    if (counterAmount <= 0) {
      showNotification('❌ Please enter a valid amount', 'error');
      return;
    }
    
    if (counterAmount > gameState.cash) {
      showNotification('❌ Insufficient funds!', 'error');
      return;
    }
    
    // Close modal
    document.getElementById('counterOfferModal').style.display = 'none';
    
    // Remove the buttons from the original request
    const btnContainer = document.getElementById(`money-request-${messageIndex}`);
    if (btnContainer) {
      btnContainer.remove();
    }
    
    // Show typing indicator while NPC thinks about counter
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    // Update bank balance
    if (!emp.bankBalance) emp.bankBalance = 0;
    emp.bankBalance += counterAmount;
    
    // Deduct money
    gameState.cash = Math.max(0, gameState.cash - counterAmount);
    updateUI();
    
    // Add counter offer message
    const counterMessage = justification
      ? `💰 Counter: Sending $${formatCash(counterAmount)} instead\n"${justification}"`
      : `💰 Counter: Sending $${formatCash(counterAmount)} instead of requested $${formatCash(requestedAmount)}`;
    
    addChatMessage('You', counterMessage, true);
    
    gameState.chatHistory[emp.id].push({
      sender: 'You',
      content: counterMessage,
      isPlayer: true,
      isCounterOffer: true,
      requestedAmount: requestedAmount,
      counterAmount: counterAmount,
      justification: justification,
      timestamp: Date.now()
    });
    
    // Generate NPC reaction to counter offer
    const conversationHistory = gameState.chatHistory[emp.id]
      .slice(-10)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n');
    
    const diff = counterAmount - requestedAmount;
    const diffPercent = Math.round((diff / requestedAmount) * 100);
    const isMore = diff > 0;
    const isLess = diff < 0;
    const isSame = diff === 0;
    
    const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You asked the boss for $${formatCash(requestedAmount)} (reason: "${reason}").
Instead of accepting or denying, they made a COUNTER OFFER: $${formatCash(counterAmount)} (${diffPercent > 0 ? '+' : ''}${diffPercent}% ${isMore ? 'MORE' : isLess ? 'LESS' : 'same'}!)
${justification ? `\nTheir justification: "${justification}"` : ''}

Respond to this counter offer naturally (3-8 sentences). Consider:
- Your personality (${emp.personality})
- The difference: ${isMore ? `They're giving you MORE than you asked for!` : isLess ? `They're offering LESS than you need` : `They agreed to the exact amount`}
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Trust: ${emp.trust}, Desire: ${emp.desire})
- What you asked the money for originally
${justification ? `- Their explanation for the amount` : ''}

Possible reactions:
${isMore ? `- Surprised, grateful, maybe a bit suspicious or excited
- "Wait, you're giving me MORE? Seriously? Thank you so much!"` : ''}
${isLess ? `- Disappointed but understanding, or frustrated depending on your personality
- "I appreciate it but... I really needed the full amount"
- Or: "That helps, thanks. I'll make it work"` : ''}
${isSame ? `- A bit confused why they didn't just accept, but grateful
- "Okay... so that's the same as I asked? Thanks I guess!"` : ''}

${emp.name}'s response:`;
    
    const raw = await generateText(responsePrompt);
    const response = sanitizeNpcResponse(raw, 10);
    
    // Hide typing indicator
    if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
    
    gameState.chatHistory[emp.id].push({
      sender: emp.name,
      content: response,
      isPlayer: false,
      timestamp: Date.now()
    });
    
    // Only add message to UI if this is still the active chat
    if (gameState.activeChat?.id === emp.id && chatMessages) {
      const newIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage(emp.name, response, false, null, newIndex);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Update stats based on counter offer
    let favorChange = 0;
    let trustChange = 0;
    let desireChange = 0;
    
    if (isMore) {
      // Gave MORE - big bonus!
      favorChange = 12;
      trustChange = 10;
      desireChange = 6;
    } else if (isSame) {
      // Same amount - standard acceptance
      favorChange = 8;
      trustChange = 8;
      desireChange = 3;
    } else {
      // Gave LESS - small bonus but some disappointment
      const lessPenalty = Math.min(5, Math.abs(diffPercent) / 20);
      favorChange = Math.max(2, 8 - lessPenalty);
      trustChange = Math.max(2, 8 - lessPenalty);
      desireChange = Math.max(1, 3 - lessPenalty / 2);
    }
    
    emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + favorChange);
    emp.trust = Math.min(100, (emp.trust || 0) + trustChange);
    emp.desire = Math.min(100, (emp.desire || 0) + desireChange);
    emp.obedience = Math.min(100, (emp.obedience || 0) + Math.floor(favorChange / 2));
    
    showNotification(`💰 Counter sent: $${formatCash(counterAmount)}\n+${favorChange} Affection, +${trustChange} Trust, +${desireChange} Desire`, 'success');
    
    // Memory
    remember(emp, `Boss countered my $${formatCash(requestedAmount)} request with $${formatCash(counterAmount)}${justification ? ` - "${justification}"` : ''}`, 'event', 2.0);
    
    updateUI();
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Send chat message
  async function sendChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    // Store employee ID for async operations
    const employeeId = gameState.activeChat.id;
    const employeeName = gameState.activeChat.name;
    
    // Add player message
    addChatMessage('You', message, true);
    
    // Add to history
    if (!gameState.chatHistory[employeeId]) {
      gameState.chatHistory[employeeId] = [];
    }
    gameState.chatHistory[employeeId].push({
      sender: 'You',
      content: message,
      isPlayer: true,
      timestamp: Date.now()
    });
    
    // AI Optimization: Clear blocked status when player sends a message
    aiOptimization.blockedProactiveMessages.delete(employeeId);
    
    // Extract salient facts from user's message
    const facts = extractSalientFacts(message, gameState.activeChat);
    for (const f of facts) remember(gameState.activeChat, `Player ${f.text}`, f.type, f.importance);
    
    // Clear input
    chatInput.value = '';
    
    // Mark this NPC as typing
    if (!gameState.typingStates) gameState.typingStates = {};
    gameState.typingStates[employeeId] = true;
    
    // Show typing indicator (only if this is the active chat)
    if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === employeeId) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = employeeName;
    }
    
    // Generate AI response (async - continues even if chat closes)
    try {
      const conversationHistory = gameState.chatHistory[employeeId]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');

      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        // Clear typing state if employee not found
        gameState.typingStates[employeeId] = false;
        return;
      }
      
      ensureEmployeeMemory(emp);
      const { prompt, personalAllowed } = buildChatPrompt(emp, conversationHistory, message);
      const raw = await generateText(prompt);
      const response = sanitizeNpcResponse(raw, 10);
      
      // Add to history first (works even if chat is closed)
      gameState.chatHistory[employeeId].push({
        sender: employeeName,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Clear typing state for this NPC
      gameState.typingStates[employeeId] = false;
      
      // Mark as unread if chat is now closed
      if (!gameState.activeChat || gameState.activeChat.id !== employeeId) {
        if (!emp.unreadMessages) emp.unreadMessages = 0;
        emp.unreadMessages++;
      }
      
      // Hide typing indicator (only if still showing this chat)
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      
      // Add AI response to UI (only if chat is still open for this employee)
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        const messageIndex = gameState.chatHistory[employeeId].length - 1;
        addChatMessage(employeeName, response, false, null, messageIndex);
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: capture key NPC claims minimally
      const respFacts = extractSalientFacts(response, emp);
      for (const f of respFacts) remember(emp, `${emp.name} ${f.text}`, f.type, f.importance);
      
      // Style counters: detect personal detail usage
      const mentionedHobby = (emp.hobbies || []).some(h => new RegExp(`\\b${h}\\b`, 'i').test(response));
      const mentionedJob = emp.productManaged && new RegExp(`\\b${emp.productManaged}\\b`, 'i').test(response);
      const mentionedPosition = emp.position && new RegExp(`\\b${emp.position}\\b`, 'i').test(response);
      
      emp.memory.styleCounters.total += 1;
      emp.memory.styleCounters.sincePersonal = (mentionedHobby || mentionedJob || mentionedPosition) ? 0 : Math.min(10, (emp.memory.styleCounters.sincePersonal || 0) + 1);
      
      // Track specific mention types
      if (mentionedJob || mentionedPosition) {
        emp.memory.styleCounters.jobMentions += 1;
        emp.memory.styleCounters.lastJobMention = emp.memory.styleCounters.total;
      }
      if (mentionedHobby) {
        emp.memory.styleCounters.hobbyMentions += 1;
        emp.memory.styleCounters.lastHobbyMention = emp.memory.styleCounters.total;
      }
      
      // Check if player is requesting a social post
      await detectPostRequest(emp, message, response);
      
      // Check if player is requesting an image/photo
      await detectImageRequest(emp, message, response);
      
      // Occasionally, NPC might request money (5% chance if certain conditions met)
      await considerMoneyRequest(emp, message, response);
      
      // Update employee stats based on conversation
      await updateEmployeeStatsFromChat(emp, message, response);
      
      // ========== FLAG DETECTION (NEW!) ==========
      // Analyze the AI response for flag patterns
      analyzeConversationForFlags(emp, response);
      
      // ========== SKILL XP GAINS (Phase 3) ==========
      // Process skill gains from chat interaction
      processSkillGainsFromChat(emp, message, response);
      
      // Log significant boss interactions as events (for potential social posts)
      const isSignificant = 
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|promotion|raise|fire|bonus)\b/i.test(message) ||
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|thank|appreciate)\b/i.test(response);
      
      if (isSignificant) {
        logCompanyEvent({
          type: 'boss_interaction',
          involvedEmployees: [employeeId],
          location: emp.locationId,
          description: `Boss chat with ${employeeName}: "${message.slice(0, 50)}${message.length > 50 ? '...' : ''}"`,
          sentiment: 'neutral',
          importance: 5
        });
      }
      
      // Update People tab if visible (to show unread badge)
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // Refresh dashboard to show new messages
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
    } catch (error) {
      console.error('Error generating chat response:', error);
      // Clear typing state for this NPC
      if (gameState.typingStates) {
        gameState.typingStates[employeeId] = false;
      }
      // Hide typing indicator if chat still open for this employee
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      // Only show error message if chat is still open for this employee
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        addChatMessage(employeeName, "Sorry, I'm having trouble responding right now.", false);
      }
    }
  }
  
  // -------- PLAYER MESSAGE EDITING FUNCTIONS --------
  
  /**
   * Edit a previously sent player message
   */
  function editPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only edit player messages
    
    // Populate chat input with existing message
    if (chatInput) {
      chatInput.value = message.content;
      chatInput.focus();
      
      // Store the message index we're editing
      chatInput.dataset.editingIndex = messageIndex;
      
      // Change the send button to indicate we're editing
      const sendBtn = document.getElementById('chatSendBtn');
      if (sendBtn) {
        sendBtn.textContent = '✏️ Update';
        sendBtn.style.backgroundColor = '#ff9800';
      }
      
      // Show a visual indicator
      showNotification('💬 Editing message. Press Update to replace it and regenerate response.', 3000);
    }
  }
  
  /**
   * Resend a player message (regenerates AI response without editing)
   */
  async function resendPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only resend player messages
    
    // Update timestamp to show it was resent
    history[messageIndex].timestamp = Date.now();
    
    // Delete all messages after this one
    gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
    
    // Reload chat to show truncated conversation
    loadChatHistory(emp.id);
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    // Show feedback
    showNotification('🔄 Resending message and generating new response...', 2000);
    
    // Generate new AI response with the same message
    try {
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      ensureEmployeeMemory(emp);
      const { prompt } = buildChatPrompt(emp, conversationHistory, message.content);
      const raw = await generateText(prompt);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Add new response to history
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Reload chat to show new response
      loadChatHistory(emp.id);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, message.content, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      showNotification('✅ Message resent and new response generated!', 2000);
      
    } catch (error) {
      console.error('Error generating response after resend:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to generate new response. Please try again.');
    }
  }
  
  /**
   * Modified send function to handle edits
   */
  async function sendOrUpdateChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    const editingIndex = chatInput.dataset.editingIndex;
    
    // If we're editing, update the message and regenerate
    if (editingIndex !== undefined && editingIndex !== null) {
      const messageIndex = parseInt(editingIndex);
      const emp = gameState.activeChat;
      const history = gameState.chatHistory[emp.id];
      
      if (history && messageIndex >= 0 && messageIndex < history.length) {
        // Update the player message
        history[messageIndex].content = message;
        history[messageIndex].timestamp = Date.now();
        
        // Delete all messages after this one
        gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
        
        // Clear editing state
        delete chatInput.dataset.editingIndex;
        const sendBtn = document.getElementById('chatSendBtn');
        if (sendBtn) {
          sendBtn.textContent = 'Send';
          sendBtn.style.backgroundColor = '#4CAF50';
        }
        
        // Reload chat to show updated message
        loadChatHistory(emp.id);
        
        // Clear input
        chatInput.value = '';
        
        // Show typing indicator
        if (chatTypingIndicator && chatTypingName) {
          chatTypingIndicator.style.display = 'block';
          chatTypingName.textContent = emp.name;
        }
        
        // Generate new AI response
        try {
          const conversationHistory = gameState.chatHistory[emp.id]
            .map(msg => `${msg.sender}: ${msg.content}`)
            .join('\n');
          
          ensureEmployeeMemory(emp);
          const { prompt } = buildChatPrompt(emp, conversationHistory, message);
          const raw = await generateText(prompt);
          const response = sanitizeNpcResponse(raw, 5);
          
          // Add new response to history
          gameState.chatHistory[emp.id].push({
            sender: emp.name,
            content: response,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          // Hide typing indicator
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          
          // Reload chat to show new response
          loadChatHistory(emp.id);
          
          // Update stats
          await updateEmployeeStatsFromChat(emp, message, response);
          
          // Scroll to bottom
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          showNotification('✅ Message updated and response regenerated!', 2000);
          
        } catch (error) {
          console.error('Error generating response after edit:', error);
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          showNotification('Failed to generate new response. Please try again.');
        }
        
        return; // Don't execute normal send logic
      }
    }
    
    // Normal send (not editing)
    await sendChatMessage();
  }
  
  // -------- POST REQUEST DETECTION AND HANDLING --------
  
  /**
   * Detect if player is requesting NPC to make a social post
   */
  async function detectPostRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest a post request
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post|dare.*you.*to.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap)\b/i;
    const contentKeywords = /\b(picture|photo|selfie|video|nude|naked|masturbat|explicit|sexy|hot|revealing)\b/i;
    
    // Check if player message looks like a post request
    const looksLikeRequest = postKeywords.test(playerMessage) && 
                             (socialKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeRequest) return;
    
    // Determine requested post type (prioritize explicit content detection)
    let requestedType = 'text';
    let requestContent = playerMessage;
    
    // IMPROVED: Better explicit content detection
    if (/\b(masturbat|dildo|vibrator|toy|finger.*yourself|play.*with.*yourself|touch.*yourself|spread|cum|orgasm|penetrat|squirt)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
    } else if (/\b(nude|naked|full.*nude|nothing.*on|completely.*nude)\b/i.test(playerMessage)) {
      // Check if it's just "nude" or truly "explicit sexual"
      if (/\b(masturbat|touching|playing|spreading)\b/i.test(playerMessage)) {
        requestedType = 'explicit';
      } else {
        requestedType = 'nude';
      }
    } else if (/\b(thirst.*trap|sexy|hot.*pic|revealing|underwear|lingerie)\b/i.test(playerMessage)) {
      requestedType = 'thirst_trap';
    } else if (/\b(selfie|picture.*of.*you|photo.*of.*you)\b/i.test(playerMessage)) {
      requestedType = 'selfie';
    }
    
    // IMPROVED: Better agreement detection (catches hesitant agreement too)
    const strongAgree = /\b(okay|sure|alright|fine|will.*do|i'll.*post|i'll.*share)\b/i.test(npcResponse);
    const noRefusal = !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready|too.*much)\b/i.test(npcResponse);
    const hesitantAgree = /\b(i.*guess|fine|okay.*okay)\b/i.test(npcResponse);
    
    const agreedInResponse = (strongAgree && noRefusal) || hesitantAgree;
    
    if (agreedInResponse) {
      // Send "working on it" message
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const workingMessages = [
            "Give me a sec...",
            "Working on it",
            "One moment...",
            "Let me set this up..."
          ];
          const workingMsg = workingMessages[Math.floor(Math.random() * workingMessages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: workingMsg,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, workingMsg, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1000 + Math.random() * 1000);
      
      // NPC agreed! Generate and post it
      setTimeout(async () => {
        await generateRequestedPost(employee, requestedType, requestContent);
      }, 3000 + Math.random() * 4000); // 3-7 seconds delay
    }
  }
  
  /**
   * Detect if player is requesting NPC to send an image/photo
   */
  async function detectImageRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest an image request (but NOT a post request)
    const imageKeywords = /\b(send|show|picture|photo|selfie|pic|image|snap)\b/i;
    const meKeywords = /\b(me|to.*me)\b/i;
    const contentKeywords = /\b(nude|naked|lewd|sexy|revealing|underwear|lingerie|body|yourself|masturbat|dildo|toy|finger)\b/i;
    
    // Must NOT look like a post request (those are handled separately)
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap.*chat)\b/i;
    
    // Check if this looks like a post request - if so, skip (handled by detectPostRequest)
    const looksLikePostRequest = postKeywords.test(playerMessage) || socialKeywords.test(playerMessage);
    if (looksLikePostRequest) return;
    
    // Check if player message looks like an image request
    const looksLikeImageRequest = imageKeywords.test(playerMessage) && 
                                  (meKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeImageRequest) return;
    
    // Determine requested image type (prioritize explicit)
    let requestedType = 'casual';
    let requestContent = playerMessage;
    
    // IMPROVED: Better detection for explicit content
    if (/\b(masturbat|dildo|vibrator|toy|finger.*yourself|play.*with.*yourself|spread|touch.*yourself|cum|orgasm|penetrat|squirt|body.*writing|degradation)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
    } else if (/\b(nude|naked|nothing.*on|completely.*nude|full.*nude|fully.*nude|bare|uncovered)\b/i.test(playerMessage)) {
      requestedType = 'nude';
    } else if (/\b(lewd|sexy|revealing|underwear|lingerie|bra|panties|topless|partially.*clothed|see.*through)\b/i.test(playerMessage)) {
      requestedType = 'lewd';
    } else if (/\b(work|office|professional)\b/i.test(playerMessage)) {
      requestedType = 'work';
    } else if (/\b(selfie|picture|photo)\b/i.test(playerMessage)) {
      requestedType = 'casual';
    }
    
    // IMPROVED: Better agreement detection (also catches hesitant agreement)
    const strongAgree = /\b(okay|sure|alright|fine|here|sending|sent|check.*this|for.*you)\b/i.test(npcResponse);
    const noRefusal = !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready|too.*much|inappropriate)\b/i.test(npcResponse);
    const hesitantAgree = /\b(i.*guess|fine|okay.*okay|alright.*alright)\b/i.test(npcResponse);
    
    const agreedInResponse = (strongAgree && noRefusal) || hesitantAgree;
    
    if (agreedInResponse) {
      // NPC agreed! Generate and send the image
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestedType, requestContent);
      }, 2000 + Math.random() * 4000); // 2-6 seconds delay
    }
  }
  
  /**
   * Consider if NPC should request money from player
   * Happens occasionally based on relationship, personality, and conversation context
   */
  async function considerMoneyRequest(employee, playerMessage, npcResponse) {
    // Don't request money if not in active chat
    if (!gameState.activeChat || gameState.activeChat.id !== employee.id) return;
    
    // Initialize money request tracking and financial data if needed
    if (!employee.lastMoneyRequest) employee.lastMoneyRequest = 0;
    if (!employee.bankBalance) employee.bankBalance = 0;
    if (!employee.spendingRate) {
      employee.spendingRate = calculateScaledSpendingRate(); // Company-scaled base rate
    }
    
    // Check cooldown - don't request too often (at least 5 minutes between requests)
    const timeSinceLastRequest = Date.now() - employee.lastMoneyRequest;
    if (timeSinceLastRequest < 300000) return; // 5 minutes
    
    // IMMERSION PROTECTION: Don't interrupt active conversations!
    const chatHistory = gameState.chatHistory[employee.id] || [];
    if (chatHistory.length >= 3) {
      // Check last 5 messages for high conversation activity
      const recentMessages = chatHistory.slice(-5);
      const recentPlayerMessages = recentMessages.filter(m => m.isPlayer);
      const recentNpcMessages = recentMessages.filter(m => !m.isPlayer);
      
      // If there have been 2+ player messages in last 5 messages, conversation is active
      if (recentPlayerMessages.length >= 2) {
        // Check how recent the last message was
        const lastMessageTime = chatHistory[chatHistory.length - 1]?.timestamp || 0;
        const timeSinceLastMessage = Date.now() - lastMessageTime;
        
        // If messages are flowing quickly (less than 2 minutes since last), don't interrupt
        if (timeSinceLastMessage < 120000) return;
      }
      
      // Check if player is typing (input field has focus and content)
      if (chatInput && document.activeElement === chatInput && chatInput.value.trim().length > 0) {
        return; // Player is actively typing, don't interrupt!
      }
    }
    
    // Check if conversation contains immersive/intimate content (don't break immersion!)
    const immersiveTopics = /\b(shower|bed|bedroom|kiss|touch|holding|embrace|intimate|private|secret|personal|date|romantic|rendezvous|censored|explicit)\b/i;
    const recentConversation = chatHistory.slice(-5).map(m => m.content).join(' ');
    if (immersiveTopics.test(recentConversation)) {
      // Only allow money requests if conversation seems to be winding down
      const lastMessageTime = chatHistory[chatHistory.length - 1]?.timestamp || 0;
      const timeSinceLastMessage = Date.now() - lastMessageTime;
      
      // Wait at least 5 minutes after intimate conversation before requesting money
      if (timeSinceLastMessage < 300000) return;
    }
    
    // Calculate financial situation
    const daysSinceLastRequest = timeSinceLastRequest / (1000 * 60 * 60 * 24);
    const estimatedSpending = employee.spendingRate * daysSinceLastRequest;
    const currentBalance = employee.bankBalance;
    const isLowOnCash = currentBalance < (employee.spendingRate * 7); // Less than a week's spending
    const isBroke = currentBalance < (employee.spendingRate * 2); // Less than 2 days' spending
    
    // Base chance: 5%
    let requestChance = 0.05;
    
    // FINANCIAL SITUATION - biggest factor!
    if (isBroke) {
      requestChance += 0.15; // Desperate for money
    } else if (isLowOnCash) {
      requestChance += 0.08; // Getting tight
    } else if (currentBalance > employee.spendingRate * 30) {
      requestChance -= 0.05; // Well off, less likely to ask
    }
    
    // High spending rate = more likely to need money
    if (employee.spendingRate > 200) requestChance += 0.05;
    if (employee.spendingRate > 500) requestChance += 0.10;
    
    // Increase chance if low trust/obedience (more demanding)
    if (employee.trust < 30) requestChance += 0.05;
    if (employee.obedience < 30) requestChance += 0.03;
    
    // Increase chance if high desire (wants things from you)
    if (employee.desire > 70) requestChance += 0.04;
    
    // Personality affects chance
    if (employee.personality === 'greedy' || employee.personality === 'materialistic') requestChance += 0.08;
    if (employee.personality === 'flirty' || employee.personality === 'seductive') requestChance += 0.03;
    if (employee.personality === 'shy' || employee.personality === 'professional') requestChance -= 0.03;
    
    // Conversation context - increase chance if talking about money, gifts, shopping, etc.
    const moneyTalk = /\b(money|cash|pay|expensive|buy|shop|purchase|afford|broke|rich|cost)\b/i;
    if (moneyTalk.test(playerMessage) || moneyTalk.test(npcResponse)) {
      requestChance += 0.10;
    }
    
    // Cap at 35% max (increased from 25% to account for financial desperation)
    requestChance = Math.min(0.35, Math.max(0, requestChance));
    
    // Roll the dice
    if (Math.random() > requestChance) return;
    
    // NPC will request money! Update timestamp
    employee.lastMoneyRequest = Date.now();
    
    // Calculate requested amount based on financial need
    let requestedAmount;
    
    if (isBroke) {
      // Desperate - ask for enough to cover immediate needs (1-2 weeks)
      const weeksNeeded = 1 + Math.random();
      requestedAmount = Math.floor(employee.spendingRate * 7 * weeksNeeded);
    } else if (isLowOnCash) {
      // Low on cash - ask for enough to get comfortable (1 week)
      requestedAmount = Math.floor(employee.spendingRate * 7);
    } else {
      // Not desperate - asking for something specific they want
      // Scale based on company scale
      const companyScale = Math.log10(gameState.cash + 1000);
      const baseAmount = Math.pow(10, companyScale - 2);
      const variation = 0.5 + Math.random() * 2;
      requestedAmount = Math.floor(baseAmount * variation);
    }
    
    // Ensure minimum and maximum
    const finalAmount = Math.max(500, Math.min(requestedAmount, gameState.cash * 0.15)); // Between $500 and 15% of cash
    
    // Determine request category based on financial situation
    let requestCategory;
    if (isBroke) {
      requestCategory = 'desperate_need';
    } else if (isLowOnCash) {
      requestCategory = 'financial_trouble';
    } else if (currentBalance > employee.spendingRate * 30) {
      requestCategory = 'luxury_want';
    } else {
      requestCategory = 'specific_purchase';
    }
    
    // Generate reason for money request
    const conversationHistory = gameState.chatHistory[employee.id]
      .slice(-5)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n');
    
    const reasonPrompt = `${employee.name} (${employee.personality}) wants to ask their boss (the player) for $${formatCash(finalAmount)}.

FINANCIAL CONTEXT:
- Current bank balance: $${formatCash(currentBalance)}
- Daily spending rate: $${formatCash(employee.spendingRate)}/day
- Request category: ${requestCategory}
${isBroke ? '- STATUS: Nearly broke! Urgent need.' : ''}
${isLowOnCash ? '- STATUS: Running low on money, getting worried.' : ''}

Recent conversation:
${conversationHistory}

Generate a creative, natural, in-character reason why ${employee.name} would ask for this money. Consider:
- Their personality (${employee.personality})
- Their financial situation (${requestCategory})
- Their relationship with the boss (Obedience: ${employee.obedience}, Desire: ${employee.desire}, Trust: ${employee.trust})
- Recent conversation context

Request categories guide:
- desperate_need: Bills overdue, can't afford rent/food, emergency situation, very apologetic
- financial_trouble: Running low, stressed about money, multiple expenses piling up
- specific_purchase: Want something specific (gadget, clothes, experience, date, hobby item)
- luxury_want: Not needed but would love to have, indulgent, aspirational

Write ONLY the request message (2-4 sentences), naturally asking for the money. Be creative and specific! Examples:
- "Boss... I'm so sorry to ask but I'm really struggling. My rent is due and I'm short $X. I know it's awkward but could you help me out? 🥺"
- "OMG so there's this [specific designer item/concert/experience] that I've been dreaming about and it's $X... I know it's a lot but would you maybe help me get it? I'd be SO grateful! 💕"
- "Hey, so my [car/phone/laptop] died and I need $X to replace it. I hate asking but I'm kind of in a bind here... any chance you could help? 😅"
- "I saw the cutest [specific item] at [specific store] and I NEED it but it's $X... pretty please? I'll make it worth your while 😘"

Be specific with details (brand names, store names, specific items, real reasons). Make it feel real and urgent based on their financial situation.

${employee.name}'s request:`;
    
    const rawReason = await generateText(reasonPrompt);
    const reason = sanitizeNpcResponse(rawReason, 4);
    
    // Add a delay to make it feel natural
    setTimeout(() => {
      // Make sure chat is still open
      if (!gameState.activeChat || gameState.activeChat.id !== employee.id || !chatMessages) return;
      
      // Show typing indicator briefly
      if (chatTypingIndicator && chatTypingName) {
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = employee.name;
        
        setTimeout(() => {
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          
          // Add to chat history
          if (!gameState.chatHistory[employee.id]) {
            gameState.chatHistory[employee.id] = [];
          }
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: reason,
            isPlayer: false,
            isMoneyRequest: true,
            requestedAmount: finalAmount,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          
          // Add money request message with buttons
          addMoneyRequestMessage(employee, finalAmount, reason, messageIndex);
          
          // Memory
          remember(employee, `Asked player for $${formatCash(finalAmount)}`, 'event', 1.5);
          
          // Scroll to bottom
          if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
        }, 1500); // Brief typing delay
      }
    }, 3000 + Math.random() * 4000); // 3-7 seconds after their previous message
  }
  
  /**
   * Request a post from NPC via attachment menu
   */
  async function requestPostFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'text';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt (prioritize explicit)
      if (/\b(masturbat|dildo|toy|vibrator|orgasm|cum|ejaculat|finger.*yourself|play.*with.*yourself|spread.*legs|degradation|body.*writing|explicit.*act)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(nude|naked|full.*nude|completely.*nude|nothing.*on)\b/i.test(customPrompt)) {
        requestType = 'nude';
      } else if (/\b(thirst.*trap|sexy|revealing|underwear|lingerie|hot)\b/i.test(customPrompt)) {
        requestType = 'thirst_trap';
      } else if (/\b(selfie|picture)\b/i.test(customPrompt)) {
        requestType = 'selfie';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        text: 'post a status update',
        selfie: 'post a selfie',
        thirst_trap: 'post a thirst trap (sexy/revealing photo)',
        nude: 'post a nude photo',
        explicit: 'post explicit sexual content (masturbation, toys, etc.)'
      };
      requestDescription = presetDescriptions[requestType] || 'make a post';
    }
    
    // Add request message to chat
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    if (chatInput) chatInput.value = requestMessage;
    
    // Simulate clicking send
    await sendChatMessage();
    
    // Wait a moment, then check if NPC will agree
    setTimeout(async () => {
      await evaluateAndExecutePostRequest(emp, requestType, requestDescription);
    }, 3000);
  }
  
  /**
   * Evaluate if NPC agrees to post request and execute
   */
  async function evaluateAndExecutePostRequest(employee, requestType, requestDescription) {
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const desire = employee.stats?.desire || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'text':
        comfortThreshold = 10; // Almost always okay
        break;
      case 'selfie':
        comfortThreshold = 20; // Pretty easy
        break;
      case 'thirst_trap':
        comfortThreshold = 50; // Need some comfort/attraction
        break;
      case 'nude':
        comfortThreshold = 72; // Need high intimacy
        break;
      case 'explicit':
        comfortThreshold = 88; // Need very high intimacy + desire for explicit content
        break;
    }
    
    // Calculate willingness score (desire matters more for explicit)
    const desireWeight = (requestType === 'explicit' || requestType === 'nude') ? 0.3 : 0.1;
    const willingnessScore = (intimacy * 0.35) + (affection * 0.25) + (comfort * (0.3 - desireWeight)) + (desire * desireWeight) + ((personality.flirty || 50) * 0.1);
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || (willingnessScore >= comfortThreshold * 0.85 && Math.random() < 0.25);
    
    if (willDo) {
      // Send agreement message first
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const agreeMessages = {
            text: ["Sure, I can post something", "Okay, I'll write something"],
            selfie: ["Okay! Let me take a selfie", "Sure, give me a sec", "Fine, one sec..."],
            thirst_trap: ["Alright... let me find something sexy 😏", "Okay okay... give me a minute", "Fine... but only because it's you 😘"],
            nude: ["Omg... okay. Give me a moment 😳", "I can't believe I'm doing this... one sec", "Fuck it, why not 😏"],
            explicit: ["Holy shit... okay. This is so fucking hot 🥵", "God, you make me so fucking wet... gimme a minute", "Fuck yes... this is so dirty 😈", "Can't believe you're making me do this... one sec 💦"]
          };
          
          const messages = agreeMessages[requestType] || ["Okay"];
          const agreeMessage = messages[Math.floor(Math.random() * messages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: agreeMessage,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, agreeMessage, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1500 + Math.random() * 1500);
      
      // Generate and post it after a delay
      setTimeout(async () => {
        await generateRequestedPost(employee, requestType, requestDescription);
      }, 4000 + Math.random() * 6000); // 4-10 seconds
    } else {
      // Send a rejection message
      const rejectionMessages = {
        explicit: ["That's way too much for me", "I'm not comfortable posting that", "That's too explicit, sorry"],
        nude: ["I'm not ready to post nudes yet", "That's a bit too much for social media", "Maybe in private, but not on the feed"],
        thirst_trap: ["I don't think I'm comfortable with that", "That's a bit much for me", "Not really my style"],
        selfie: ["Not really feeling it right now", "Maybe later"],
        text: ["I don't really have anything to say", "Not in the mood to post"]
      };
      
      const messages = rejectionMessages[requestType] || ["I don't think so"];
      const rejection = messages[Math.floor(Math.random() * messages.length)];
      
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: rejection,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, rejection, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1500 + Math.random() * 1500);
    }
  }
  
  /**
   * Generate a requested post from NPC
   */
  async function generateRequestedPost(employee, postType, requestContext) {
    try {
      // Get context for post generation
      const context = getEmployeeAwarenessForPost(employee.id);
      if (!context) return;
      
      // Add request context to the generation
      context.requestedByBoss = true;
      context.requestContext = requestContext;
      
      // Generate the post
      const generated = await generateOrganicPost(employee, postType, context);
      
      if (!generated || !generated.content) return;
      
      // Generate image if needed
      let imageUrl = null;
      if (generated.imagePrompt && ['selfie', 'thirst_trap', 'explicit'].includes(postType)) {
        try {
          imageUrl = await generateImage(applyImageStyle(generated.imagePrompt));
        } catch (error) {
          console.error('Image generation failed for requested post:', error);
        }
      }
      
      // Create and add the post
      const post = createPost({
        authorId: employee.id,
        content: generated.content,
        type: postType,
        imageUrl: imageUrl,
        imagePrompt: generated.imagePrompt,
        explicitLevel: generated.explicitLevel || 0,
        tags: generated.tags || [],
        location: employee.locationId || 'headquarters'
      });
      
      gameState.socialNetwork.posts.unshift(post);
      
      // Refresh dashboard to show new posts/mentions
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
      // Track this post type
      if (!gameState.socialNetwork.recentPostTypes) {
        gameState.socialNetwork.recentPostTypes = [];
      }
      gameState.socialNetwork.recentPostTypes.unshift(postType);
      if (gameState.socialNetwork.recentPostTypes.length > 20) {
        gameState.socialNetwork.recentPostTypes = gameState.socialNetwork.recentPostTypes.slice(0, 20);
      }
      
      // Store in employee's awareness
      remember(employee, `I posted on social media: "${generated.content}"`, 'action', 2);
      remember(employee, `The boss requested I make this post`, 'interaction', 2);
      
      // Send them a chat message about it
      if (gameState.activeChat?.id === employee.id && chatMessages) {
        const followUpMessages = [
          "Done! Check the feed 😊",
          "Posted! Hope you like it 😏",
          "There you go... posted",
          "Okay, it's up now",
          "Posted as requested 😳"
        ];
        const followUp = followUpMessages[Math.floor(Math.random() * followUpMessages.length)];
        
        gameState.chatHistory[employee.id].push({
          sender: employee.name,
          content: followUp,
          isPlayer: false,
          timestamp: Date.now()
        });
        
        const messageIndex = gameState.chatHistory[employee.id].length - 1;
        addChatMessage(employee.name, followUp, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Refresh feed if on social tab
      if (gameState.activeTab === 'social') {
        renderSocialFeed();
      }
      
    } catch (error) {
      console.error('Error generating requested post:', error);
    }
  }
  
  // -------- MESSAGE REGENERATION --------
  async function regenerateMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 1 || messageIndex >= history.length) return;
    
    // Get the message before the one we're regenerating (the player's prompt)
    const playerMessage = history[messageIndex - 1]?.content;
    if (!playerMessage) return;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Build conversation history up to this point
      const conversationHistory = history.slice(0, messageIndex)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      // IMPROVED REGENERATION: Add variation strategies (avoid words like "variation", "alternative", "different response" that trigger meta-commentary)
      const variationStrategies = [
        '\n\nIMPORTANT: Use a completely new tone and approach. Include details you didn\'t mention before. Take this in a fresh direction.',
        '\n\nIMPORTANT: If you were formal before, be casual now. If you were brief, elaborate more. If you were serious, add personality. Show another side of yourself.',
        '\n\nIMPORTANT: Focus on aspects you haven\'t explored yet. Use new examples and emotions. Structure your sentences in a new way.',
        '\n\nIMPORTANT: Shift your emotional tone. If you were playful before, be thoughtful now. If you were enthusiastic, try subtle. Reveal a new facet of your personality.',
        '\n\nIMPORTANT: Include information or reactions you haven\'t shared yet. Use significantly varied word choices. Take this conversation somewhere new.'
      ];
      
      // Randomly select a variation strategy
      const strategy = variationStrategies[Math.floor(Math.random() * variationStrategies.length)];
      
      // Track regeneration count to increase temperature
      if (!history[messageIndex].regenerationCount) {
        history[messageIndex].regenerationCount = 0;
      }
      history[messageIndex].regenerationCount++;
      
      // Build prompt with variation instruction
      const { prompt } = buildChatPrompt(emp, conversationHistory, playerMessage);
      const enhancedPrompt = prompt + strategy;
      
      // Increase temperature for more variation (0.7 + 0.1 per regeneration, max 1.2)
      const temperature = Math.min(1.2, 0.7 + (history[messageIndex].regenerationCount * 0.1));
      
      // Generate with enhanced variation
      const raw = await generateText(enhancedPrompt, {
        temperature: temperature,
        top_p: 0.95, // Slightly higher for more diversity
        frequency_penalty: 0.3 // Reduce repetition
      });
      
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Update the message in history
      history[messageIndex].content = response;
      
      // Delete all messages after this one (truncate the conversation)
      gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
      
      // Reload chat to show updated message
      loadChatHistory(emp.id);
      
      // Update stats based on new response
      await updateEmployeeStatsFromChat(emp, playerMessage, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Show feedback to user
      showNotification(`♻️ Response regenerated with new variation (${history[messageIndex].regenerationCount}x)`, 2000);
      
    } catch (error) {
      console.error('Error regenerating message:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to regenerate message. Please try again.');
    }
  }
  
  // Regenerate an image in the chat history
  async function regenerateImage(messageIndex, imagePrompt) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.imageUrl) return; // Not an image message
    
    try {
      // Show loading indicator on the image
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Regenerating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate new image using the same prompt
      const newImageUrl = await generateImage(applyImageStyle(imagePrompt));
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Update the image URL in history
      message.imageUrl = newImageUrl;
      
      // Reload chat to show updated image
      loadChatHistory(emp.id);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error regenerating image:', error);
      showNotification('Failed to regenerate image');
    }
  }
  
  // -------- IMAGE SYSTEM --------
  // Build comprehensive image prompt using NPC bio and context
  async function buildImagePrompt(emp, requestType, customPrompt = null) {
    // Get consistent physical description using the new system
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    // Get player description for [PLAYER] token
    const playerBio = getPlayerDescription('image'); // Uses new profile system
    
    // Get recent conversation context
    const recentContext = gameState.chatHistory[emp.id]
      ?.slice(-10)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    // Determine intimacy level for appropriate image type
    const affection = emp.stats?.affection || 0;
    const desire = emp.stats?.desire || 0;
    const intimacyLevel = (affection + desire) / 2;
    
    let imagePrompt = '';
    
    // Handle preset request types
    if (requestType === 'casual') {
      imagePrompt = `casual selfie, ${physicalDesc}, friendly smile, relaxed setting, natural lighting, smartphone photo quality`;
    } else if (requestType === 'work') {
      imagePrompt = `professional workplace selfie, ${physicalDesc}, ${emp.position || 'office worker'}, office environment, professional attire, confident expression`;
    } else if (requestType === 'lewd') {
      if (intimacyLevel < 40) {
        imagePrompt = `suggestive selfie, ${physicalDesc}, flirty expression, casual clothing, teasing pose, playful atmosphere`;
      } else {
        imagePrompt = `seductive selfie, ${physicalDesc}, alluring expression, revealing clothing, intimate pose, bedroom or private setting`;
      }
    } else if (requestType === 'nude') {
      if (intimacyLevel < 60) {
        imagePrompt = `artistic nude selfie, ${physicalDesc}, tasteful pose, soft lighting, partial nudity, intimate setting`;
      } else {
        imagePrompt = `explicit nude selfie, ${physicalDesc}, seductive pose, full nudity, intimate bedroom setting, aroused expression`;
      }
    } else if (requestType === 'explicit') {
      // Sexually explicit content - variety of acts
      const explicitVariations = [
        `explicit sexual content, ${physicalDesc}, masturbating with hand, intense pleasure expression, legs spread, intimate bedroom setting, aroused and exposed`,
        `explicit sexual content, ${physicalDesc}, using sex toy, dildo or vibrator, eyes closed in ecstasy, intimate bedroom setting, very aroused`,
        `explicit sexual content, ${physicalDesc}, self-pleasure, fingers inside, intense orgasm expression, intimate bedroom setting, completely exposed`,
        `explicit sexual content, ${physicalDesc}, degrading body writing, marked with text, submissive expression, intimate setting, fully nude`,
        `explicit sexual content, ${physicalDesc}, masturbating, very aroused expression, touching self intimately, bedroom setting, explicit pose`,
        `explicit sexual content, ${physicalDesc}, anal play with toy, intense pleasure face, intimate bedroom setting, very exposed and aroused`,
        `explicit sexual content, ${physicalDesc}, using multiple toys, overwhelmed with pleasure, intimate bedroom setting, extremely explicit`,
        `explicit sexual content, ${physicalDesc}, squirting orgasm, intense climax expression, legs spread wide, intimate bedroom setting, very wet`
      ];
      imagePrompt = explicitVariations[Math.floor(Math.random() * explicitVariations.length)];
    } else if (customPrompt) {
      // Replace [PLAYER] token with player bio (escape to prevent Perchance interpretation)
      let processedPrompt = customPrompt.replace(/\[PLAYER\]/gi, playerBio);
      
      // For custom prompts, AI analyzes and builds comprehensive prompt
      // Note: Use "the player" or actual bio instead of [PLAYER] to avoid Perchance list conflicts
      const playerDescription = playerBio !== 'the player' ? `Player description: ${playerBio}` : '';
      
      const analysisPrompt = `Character: ${emp.name}
Appearance: ${physicalDesc}
Request: "${processedPrompt}"
${playerDescription ? `Player: ${playerDescription}` : ''}

Create image prompt with: pose, expression, clothing, setting, lighting. Use technical tags. Many aspects of this game are highly sexual or NSFW in nature. If the post indicates that may be the case do not shy away from highly explicit details including full nudity or sexual acts.
Prompt only:`;

      try {
        imagePrompt = await generateText(analysisPrompt, {
          temperature: 0.7,
          max_tokens: 150,
          stopSequences: ['\n\n', 'Note:', 'Example:', 'Camera angle:', 'Mood:', '---', 'IMAGE PROMPT:']
        });
        // Clean up any quotes or extra text
        imagePrompt = imagePrompt.replace(/^["']|["']$/g, '').trim();
        // Remove any remaining meta-commentary
        imagePrompt = imagePrompt.split(/\n/)[0]; // Take only first line
      } catch (error) {
        console.error('Error building custom image prompt:', error);
        imagePrompt = `${processedPrompt}, ${physicalDesc}`;
      }
    }
    
    return imagePrompt;
  }
  
  // Handle sending an image (player to NPC)
  async function sendImageToNPC(imagePrompt) {
    if (!gameState.activeChat || !imagePrompt.trim()) return;
    
    const emp = gameState.activeChat;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Show loading message
      const loadingMsg = addChatMessage('You', '🎨 Generating image...', true);
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage(applyImageStyle(imagePrompt));
      
      // Remove loading message and add actual image message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history first to get the message index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: imagePrompt,
        isPlayer: true,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'sent',
        timestamp: Date.now()
      });
      
      // Add image message with index for regenerate button
      const sentImageIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage('You', imagePrompt, true, imageUrl, sentImageIndex, imagePrompt);
      
      // Build AI response prompt - NPC "sees" and responds to image
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const playerBio = gameState.settings?.playerBio || '';
      const playerContext = playerBio ? `\nPlayer description: ${playerBio}` : '';
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}${playerContext}

The player just sent you an image. Based on this description: "${imagePrompt}", respond naturally to what they sent. Consider:
- What the image shows (understand the CONTEXT and meaning, not just literal technical tags)
- Your relationship with the player
- The context of your conversation
- Your personality and current mood

Respond as if you actually saw the image. Keep it conversational (3-5 sentences, completing your thought).

${emp.name}'s response:`;

      const raw = await generateText(responsePrompt);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const messageIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: remember the image
      remember(emp, `Player sent image: ${imagePrompt}`, 'event', 1.5);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, `[Sent image: ${imagePrompt}]`, response);
      
    } catch (error) {
      console.error('Error handling sent image:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      // Only show error message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Sorry, I couldn't process that image.", false);
      }
    }
  }
  
  // Handle sending money to NPC
  /**
   * Send money to NPC - Enhanced with better framing and reactions
   */
  async function sendMoneyToNPC(amount, message = '') {
    if (!gameState.activeChat || amount <= 0) return;
    
    const emp = gameState.activeChat;
    
    // Update NPC bank balance (initialize if needed)
    if (!emp.bankBalance) emp.bankBalance = 0;
    emp.bankBalance += amount;
    
    // Initialize spending rate if needed (scaled to company size)
    if (!emp.spendingRate) {
      emp.spendingRate = calculateScaledSpendingRate(); // Company-scaled base rate
    }
    
    // Deduct money from player
    gameState.cash = Math.max(0, gameState.cash - amount);
    updateUI();
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Add money transfer message to chat
      const moneyMessage = message 
        ? `💰 Sent $${formatCash(amount)}\n"${message}"`
        : `💰 Sent $${formatCash(amount)}`;
      
      // Add to history
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: moneyMessage,
        isPlayer: true,
        isMoney: true,
        amount: amount,
        message: message,
        timestamp: Date.now()
      });
      
      // Add to chat display
      addChatMessage('You', moneyMessage, true);
      
      // Determine payment framing based on context and amount
      const avgSalary = 50000; // Average employee salary for comparison
      const monthlyEquiv = (amount / avgSalary) * 12;
      
      // Categorize amount more contextually
      let paymentType = 'gift';
      let sizeDesc = 'small';
      
      if (amount < 100) {
        sizeDesc = 'tiny';
        paymentType = 'tip';
      } else if (amount < 1000) {
        sizeDesc = 'small';
        paymentType = 'gift';
      } else if (amount < 10000) {
        sizeDesc = 'nice';
        paymentType = message ? 'gift with meaning' : 'generous gift';
      } else if (amount < 50000) {
        sizeDesc = 'substantial';
        paymentType = 'bonus';
      } else if (amount < 200000) {
        sizeDesc = 'major';
        paymentType = 'windfall';
      } else {
        sizeDesc = 'life-changing';
        paymentType = 'fortune';
      }
      
      // Build conversation history
      const conversationHistory = gameState.chatHistory[emp.id]
        .slice(-10)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const playerBio = getPlayerDescription('conversation');
      const playerContext = playerBio !== 'the boss' ? `\n👤 BOSS INFO: ${playerBio}` : '';
      
      // Build message context
      const messageContext = message 
        ? `\n\n💬 YOUR BOSS'S MESSAGE WITH THE MONEY:\n"${message}"\n**IMPORTANT**: Acknowledge this message in your response!`
        : '';
      
      // Enhanced prompt that frames money more positively
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}${playerContext}

💰 SITUATION: Your boss just sent you $${formatCash(amount)} (a ${sizeDesc} ${paymentType})!${messageContext}

📊 CONTEXT FOR YOUR REACTION:
- Amount: $${formatCash(amount)} (equivalent to ${monthlyEquiv.toFixed(1)} months of average salary)
- Your current bank balance: $${formatCash(emp.bankBalance)}
- Your personality: ${emp.personality}
- Your relationship: Affection ${emp.stats?.affection || 0}, Trust ${emp.trust || 0}, Obedience ${emp.obedience || 0}, Desire ${emp.desire || 0}

💭 HOW TO REACT:
1. **BE GENUINE**: Show real emotion appropriate to the amount (surprise, gratitude, excitement, suspicion, etc.)
2. **FRAME POSITIVELY**: Unless you have serious trust issues or the amount is suspicious, treat this as a nice gesture
3. **AVOID HR COMPLAINTS**: Don't immediately jump to "this feels wrong" unless amount is truly absurd
4. **ACKNOWLEDGE THE GESTURE**: Recognize why they might be sending money (help, appreciation, flirting, etc.)
5. **BE IN CHARACTER**: Respond based on YOUR personality and relationship with them
${message ? '6. **ADDRESS THEIR MESSAGE**: Make sure to respond to what they said!' : ''}

📝 SUGGESTED REACTIONS BY AMOUNT:
- Tiny ($1-99): Casual thanks, maybe confused why so small
- Small ($100-999): Sweet gesture, appreciated
- Nice ($1K-9K): Really grateful, touched by the thoughtfulness  
- Substantial ($10K-49K): Wow, this is amazing! What's the occasion?
- Major ($50K-199K): Holy shit, this is incredible! You're changing my life!
- Life-changing ($200K+): I... I don't know what to say. This is unreal. Are you serious?!

🎭 RESPOND NOW (3-8 sentences, natural conversation):`;

      const raw = await generateText(responsePrompt);
      const response = sanitizeNpcResponse(raw, 10);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const messageIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: remember receiving money
      const memoryText = message 
        ? `Received $${formatCash(amount)} from boss (${paymentType}) - "${message}"`
        : `Received $${formatCash(amount)} from boss (${paymentType})`;
      remember(emp, memoryText, 'event', 2.0);
      
      // Update stats - more nuanced based on context
      let favorGain = 0;
      let trustGain = 0;
      let desireGain = 0;
      
      if (amount < 1000) {
        favorGain = 2 + Math.floor(amount / 200);
        trustGain = 1;
        desireGain = 1;
      } else if (amount < 10000) {
        favorGain = 5 + Math.floor(amount / 1000);
        trustGain = 2;
        desireGain = 2;
      } else if (amount < 100000) {
        favorGain = 10 + Math.floor(amount / 5000);
        trustGain = 3;
        desireGain = 4;
      } else {
        favorGain = 20;
        trustGain = 5;
        desireGain = 8;
      }
      
      // Cap gains
      favorGain = Math.min(25, favorGain);
      trustGain = Math.min(10, trustGain);
      desireGain = Math.min(12, desireGain);
      
      // Apply stat changes
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + favorGain);
      emp.trust = Math.min(100, (emp.trust || 0) + trustGain);
      emp.desire = Math.min(100, (emp.desire || 0) + desireGain);
      emp.obedience = Math.min(100, (emp.obedience || 0) + Math.floor(favorGain / 2));
      
      // Lifestyle inflation - receiving money increases spending rate
      const lifestyleIncrease = amount / 10000; // $10k = +1/day spending
      const maxSpendingIncrease = 50; // Cap at +50/day per gift
      emp.spendingRate += Math.min(maxSpendingIncrease, lifestyleIncrease);
      
      // Show notification
      showNotification(`💰 ${emp.name}: +$${formatCash(amount)} to bank\n+${favorGain} Affection, +${trustGain} Trust, +${desireGain} Desire`, 'success');
      
      updateUI();
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error handling money transfer:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Only show fallback message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Wow, thank you so much! This is amazing! 💕", false);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Still apply basic stat gains even if AI fails
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 5);
      emp.trust = Math.min(100, (emp.trust || 0) + 2);
      emp.desire = Math.min(100, (emp.desire || 0) + 3);
      updateUI();
    }
  }
  
  // Handle requesting an image from NPC
  /**
   * Request an image from NPC via attachment menu
   */
  async function requestImageFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'casual';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt
      if (/\b(masturbat|dildo|toy|vibrator|orgasm|degradation|body.*writing|explicit.*act)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(nude|naked|full.*nude)\b/i.test(customPrompt)) {
        requestType = 'nude';
      } else if (/\b(lewd|sexy|revealing|underwear|lingerie|topless)\b/i.test(customPrompt)) {
        requestType = 'lewd';
      } else if (/\b(work|office|professional)\b/i.test(customPrompt)) {
        requestType = 'work';
      } else if (/\b(selfie|picture|photo)\b/i.test(customPrompt)) {
        requestType = 'casual';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        casual: 'send a casual selfie',
        work: 'send a work selfie',
        lewd: 'send a lewd/sexy photo',
        nude: 'send a nude photo',
        explicit: 'send explicit sexual content'
      };
      requestDescription = presetDescriptions[requestType] || 'send a photo';
    }
    
    // Add request message to chat directly (bypass normal AI response)
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    
    // Add to chat history
    if (!gameState.chatHistory[emp.id]) {
      gameState.chatHistory[emp.id] = [];
    }
    gameState.chatHistory[emp.id].push({
      sender: 'You',
      content: requestMessage,
      isPlayer: true,
      timestamp: Date.now()
    });
    
    // Display the message
    addChatMessage('You', requestMessage, true);
    if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Clear input if it was set
    if (chatInput) chatInput.value = '';
    
    // Wait a moment, then check if NPC will agree and respond
    setTimeout(async () => {
      await evaluateAndExecuteImageRequest(emp, requestType, requestDescription, customPrompt);
    }, 1500);
  }
  
  /**
   * Evaluate if NPC agrees to image request and execute
   */
  async function evaluateAndExecuteImageRequest(employee, requestType, requestDescription, customPrompt = null) {
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const desire = employee.stats?.desire || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'casual':
        comfortThreshold = 5; // Almost always okay
        break;
      case 'work':
        comfortThreshold = 10; // Very easy
        break;
      case 'lewd':
        comfortThreshold = 48; // Need some attraction
        break;
      case 'nude':
        comfortThreshold = 73; // Need high intimacy
        break;
      case 'explicit':
        comfortThreshold = 88; // Need very high intimacy + desire
        break;
    }
    
    // Calculate willingness score (desire matters more for sexual content)
    const desireWeight = (requestType === 'explicit' || requestType === 'nude') ? 0.3 : 0.15;
    const willingnessScore = (intimacy * 0.35) + (affection * 0.2) + (desire * desireWeight) + (comfort * (0.3 - (desireWeight - 0.15)));
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || 
                   (willingnessScore >= comfortThreshold * 0.85 && Math.random() < 0.2);
    
    if (willDo) {
      // Send agreement message first
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const agreeMessages = {
            casual: ["Sure!", "Okay, one sec", "Alright"],
            work: ["Sure thing", "Okay", "No problem"],
            lewd: ["Okay... give me a sec 😏", "Fine, but only for you 😘", "Alright... one moment"],
            nude: ["Omg... okay 😳", "I can't believe I'm doing this...", "Fuck it, why not"],
            explicit: ["Holy shit... okay 🥵", "God, this is so hot...", "Fuck yes... one sec 💦", "You're making me so wet... gimme a minute 😈"]
          };
          
          const messages = agreeMessages[requestType] || ["Okay"];
          const agreeMessage = messages[Math.floor(Math.random() * messages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: agreeMessage,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, agreeMessage, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1000 + Math.random() * 1500);
      
      // Generate and send it after a delay
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestType, customPrompt);
      }, 3000 + Math.random() * 5000); // 3-8 seconds
    } else {
      // Send a rejection message
      const rejectionMessages = {
        explicit: ["That's way too much for me", "I'm not comfortable with that", "That's crossing a line", "Absolutely not"],
        nude: ["I'm not ready for that", "That's a bit too much", "Maybe when we're closer", "I don't think so"],
        lewd: ["I'm not really comfortable with that", "That's a bit much for me", "Maybe another time"],
        work: ["Not really in the mood", "Maybe later"],
        casual: ["Not really feeling it right now", "Maybe later"]
      };
      
      const messages = rejectionMessages[requestType] || ["I'm not really comfortable with that"];
      const rejection = messages[Math.floor(Math.random() * messages.length)];
      
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: rejection,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, rejection, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 2000 + Math.random() * 2000);
    }
  }
  
  /**
   * Generate and send requested image from NPC
   */
  async function generateAndSendRequestedImage(employee, requestType, customPrompt = null) {
    if (!gameState.activeChat || gameState.activeChat.id !== employee.id) return;
    
    const emp = employee;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Build comprehensive image prompt
      const imagePrompt = await buildImagePrompt(emp, requestType, customPrompt);
      
      // Show loading message in chat
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Generating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage(applyImageStyle(imagePrompt));
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Get AI to generate a message accompanying the image
      const conversationHistory = gameState.chatHistory[emp.id]
        ?.map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      const messagePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

The player has requested a ${requestType || 'custom'} photo from you. You've agreed and are sending them an image that shows: ${imagePrompt}

Write a brief, natural message (1 sentence) to accompany the photo you're sending. Match your tone to the image type and your relationship:
- Casual/Work: Friendly, maybe playful
- Lewd: Flirty, teasing, confident  
- Nude: Bold, seductive, intimate
- Explicit: Intensely sexual, uninhibited, aroused, raw

${emp.name}'s message:`;

      const raw = await generateText(messagePrompt);
      const message = sanitizeNpcResponse(raw, 1);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: message,
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'received',
        timestamp: Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const receivedImageIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, message, false, imageUrl, receivedImageIndex, imagePrompt);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: remember sending this image
      remember(emp, `Sent ${requestType || 'custom'} photo to player`, 'event', 1.5);
      remember(emp, `The boss requested this photo`, 'interaction', 1.5);
      
      // Add to employee photos gallery
      if (!emp.photos) emp.photos = [];
      emp.photos.push({
        url: imageUrl,
        prompt: imagePrompt,
        type: requestType || 'custom',
        timestamp: Date.now()
      });
      
      // Update stats based on image type
      if (requestType === 'explicit') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 8);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 4);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 5);
        emp.stats.comfort = Math.min(100, (emp.stats.comfort || 0) + 3);
      } else if (requestType === 'nude') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 5);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 3);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 3);
      } else if (requestType === 'lewd') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 3);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 2);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 2);
      } else {
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 1);
      }
      
    } catch (error) {
      console.error('Error handling image request:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      // Only show error message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Sorry, I can't send that right now.", false);
      }
    }
  }
  
  // Visualize current scene without NPC response
  async function visualizeCurrentScene() {
    if (!gameState.activeChat) return;
    
    // IMPORTANT: Capture the employee at the START to prevent chat-switching bugs
    const emp = gameState.activeChat;
    const empId = emp.id;
    const empName = emp.name;
    
    try {
      // Build comprehensive scene description from context
      const recentMessages = gameState.chatHistory[empId]
        ?.slice(-15)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      // Get consistent character description
      const empDesc = getPhysicalDescriptionForPrompt(emp);
      
      const playerBio = gameState.settings?.playerBio || 'the player';
      
      // Get current context from the conversation
      const lastPlayerMessage = gameState.chatHistory[empId]
        ?.filter(msg => msg.isPlayer)
        ?.slice(-3)
        .map(msg => msg.content)
        .join(' ') || '';
      
      const lastNpcMessage = gameState.chatHistory[empId]
        ?.filter(msg => !msg.isPlayer)
        ?.slice(-3)
        .map(msg => msg.content)
        .join(' ') || '';
      
      // AI analyzes scene and builds DETAILED visual prompt
      const scenePrompt = `You are generating an image prompt for the CURRENT MOMENT in this conversation.

Recent conversation between player and ${empName}:
${recentMessages}

Character descriptions:
${empName}: ${empDesc}
Player: ${playerBio}

Based on the conversation context, create a DETAILED, SPECIFIC image generation prompt showing:
1. The exact current activity or scene (what are they doing RIGHT NOW based on the last messages?)
2. Both characters' poses, expressions, and body language
3. The specific location/setting details (office, bedroom, outdoors, etc.)
4. Current mood/atmosphere from the conversation
5. Relevant clothing, props, or environmental details mentioned

Focus on VISUAL DETAILS that reflect the conversation's tone and content. Be specific and descriptive.

CRITICAL: Write ONLY the image description itself. NO markdown formatting, NO bold headers, NO labels like "Image Prompt:" or "Visual Details:", NO word counts, NO notes. Just the raw visual description.

Image prompt (50-150 words):`;

      let imagePrompt = await generateText(scenePrompt, {
        temperature: 0.8,
        max_tokens: 200,
        stopSequences: ['---', 'Note:', 'Remember:', 'Visual Details:', '**Visual', 'Word count:']
      });
      
      // CRITICAL FIX: Extract actual string from response
      imagePrompt = extractText(imagePrompt);
      
      // Remove XML-style tags if present
      imagePrompt = imagePrompt.replace(/<image prompt>/gi, '').replace(/<\/image prompt>/gi, '').trim();
      
      // Remove markdown formatting that AI sometimes adds
      imagePrompt = imagePrompt.replace(/^\*\*Image Prompt:\*\*\s*/gi, '');
      imagePrompt = imagePrompt.replace(/\*\*Visual Details:\*\*[\s\S]*/gi, ''); // Remove everything after "Visual Details:"
      imagePrompt = imagePrompt.replace(/\*\(Word count:.*?\)\*/gi, ''); // Remove word count notes
      imagePrompt = imagePrompt.replace(/\n\*\*.*?\*\*/g, ''); // Remove any other bold headers
      imagePrompt = imagePrompt.replace(/\n\s*-\s+\*\*.*?:\*\*/g, ''); // Remove bullet points with bold labels
      imagePrompt = imagePrompt.trim();
      
      console.log('[Scene Visualization] Generated prompt:', imagePrompt);
      console.log('[Scene Visualization] Prompt length:', imagePrompt.length, 'chars');
      
      // Show loading message in chat (but verify we're still in the right chat)
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Visualizing current scene...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      
      // Only add loading message if we're still viewing this chat
      if (gameState.activeChat?.id === empId) {
        if (chatMessages) {
          chatMessages.appendChild(loadingMsg);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage(applyImageStyle(imagePrompt));
      
      // Remove loading message (if it exists)
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history with special type FIRST (so it persists even if chat switches)
      if (!gameState.chatHistory[empId]) {
        gameState.chatHistory[empId] = [];
      }
      gameState.chatHistory[empId].push({
        sender: 'System',
        content: '🎬 Scene visualization',
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'scene',
        timestamp: Date.now()
      });
      
      // Only add image to visible chat if we're still viewing this employee's chat
      if (gameState.activeChat?.id === empId) {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:0 auto; text-align:center;';
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.cssText = 'width:100%; max-width:400px; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3);';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = '🎬 Scene visualization';
        
        messageEl.appendChild(img);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      // If chat switched, the image is already in history and will show when they return to this chat
      
    } catch (error) {
      console.error('Error visualizing scene:', error);
      // Only show error in the original chat
      if (gameState.activeChat?.id === empId) {
        addChatMessage('System', 'Could not generate scene visualization.', false);
      }
    }
  }
  
  // -------- AI-POWERED STAT EVALUATION --------
  // Analyzes conversation and updates employee stats naturally
  async function updateEmployeeStatsFromChat(emp, playerMessage, npcResponse) {
    if (!emp || !emp.stats) return;
    
    // Get office culture settings
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    
    // Build evaluation context based on settings
    const atmosphereContext = (() => {
      if (atmosphere < 33) {
        return 'PROFESSIONAL office: Formal behavior expected. Personal topics, flirting, or casual banter may DECREASE comfort/affection unless trust is already very high. Work-focused conversations are valued.';
      } else if (atmosphere > 66) {
        return 'RELAXED office: Casual, friendly environment. Personal topics, humor, and informal chat INCREASE comfort/affection easily. Formality might seem stiff or awkward.';
      } else {
        return 'BALANCED office: Friendly professionalism. Personal topics are fine when rapport exists. Both formal and casual approaches can work depending on relationship level.';
      }
    })();
    
    const guidelineContext = (() => {
      if (guidelines < 33) {
        return 'NPC has RESERVED personality: Slow to warm up, guarded. Compliments and friendliness may DECREASE comfort initially (seems too forward). Trust builds slowly. Pushback and sarcasm are normal. Rate harshly on pushy/forward behavior.';
      } else if (guidelines > 66) {
        return 'NPC has OUTGOING personality: Warm and open. Friendly behavior and compliments INCREASE affection easily. Coldness or distance DECREASES stats. Be lenient - they want to connect.';
      } else {
        return 'NPC has STANDARD personality: Balanced responses. Rate authentically based on the message quality. Not overly harsh or lenient.';
      }
    })();
    
    const policyContext = (() => {
      if (policy === 'open') {
        return 'ENTHUSIASTIC consent model: NPCs are receptive to romantic/intimate advances. Flirting and personal interest INCREASE desire and affection. Be lenient with advances - they\'re welcome. Only decrease stats for genuinely disrespectful behavior.';
      } else if (policy === 'professional') {
        return 'PROFESSIONAL consent model: Boundaries are important. Romantic/intimate advances may DECREASE comfort/trust unless relationship stats are already very high (70+). Respect for boundaries is valued.';
      } else {
        return 'CASUAL consent model: NPCs need moderate trust/comfort before being receptive. Advances when stats are low (below 40) may decrease comfort. When stats are good (50+), advances are welcome.';
      }
    })();
    
    // Build evaluation prompt with extended context
    const conversationContext = gameState.chatHistory[emp.id]
      ?.slice(-4) // Last 2 exchanges only - reduced for speed
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    const currentStats = `Aff:${emp.stats.affection ?? 0} Com:${emp.stats.comfort ?? 0} Tru:${emp.stats.trust ?? 0} Des:${emp.stats.desire ?? 0} Obe:${emp.stats.obedience ?? 0}`;
    
    // OPTIMIZED: Front-load format, minimize prose, force cooperation
    const evaluationPrompt = `FORMAT: Output EXACTLY five integers [-10,+10] separated by single spaces. Example: "5 3 2 4 1" or "-2 0 1 -1 3". Do not add rationale or explanation, even silently.

RULES: Judge exchange; NPC consent/enthusiasm=increase; high stats(70+)=tolerant; gossip=bond
Stats: ${currentStats}
Culture: ${atmosphereContext} ${guidelineContext} ${policyContext}

Player: "${playerMessage}"
NPC: "${npcResponse}"

Output (Affection Comfort Trust Desire Obedience):`;

    try {
      const raw = await generateText(evaluationPrompt, {
        temperature: 0,  // CHANGED: 0.3 → 0 for deterministic output
        top_p: 0,        // NEW: Force deterministic
        max_tokens: 14,  // CHANGED: 10 → 14 (room for -10 -10 -10 -10 -10)
        stopSequences: ['\n', '.', ',', 'Affection', 'Rationale', 'Why', 'Because', '(', '[', 'The', 'This', 'I', 'A', 'Rating']  // EXPANDED: hostile to prose
      });
      
      // IMPROVED: Better parsing with validation
      const cleanedRaw = raw.trim().replace(/[^\d\s\-+]/g, ''); // Strip non-numeric chars except spaces, -, +
      const numbers = cleanedRaw.split(/\s+/).map(n => {
        const parsed = parseFloat(n);
        return isNaN(parsed) ? 0 : Math.max(-10, Math.min(10, parsed)); // Clamp to [-10, 10]
      }).filter(n => n !== null);
      
      console.log(`[Stat Eval] Raw: "${raw.substring(0, 50)}" → Parsed: [${numbers.join(', ')}]`);
      
      if (numbers.length >= 5) {
        // Detect if NPC response shows consent/enthusiasm
        const npcResponseLower = (npcResponse || '').toLowerCase();
        const showsConsent = /\b(yes|okay|sure|love|want|enjoy|feel.*good|amazing|please|more|don't.*stop|keep.*going|feels.*so|like.*that|mm+|ah+|oh+.*god|fuck.*yes)\b/.test(npcResponseLower);
        const showsEnthusiasm = /\b(love|amazing|incredible|perfect|yes+|god.*yes|so.*good|feels.*amazing|want.*more|don't.*stop)\b/.test(npcResponseLower);
        const showsDiscomfort = /\b(no|stop|don't|uncomfortable|not.*ready|too.*much|can't|won't|shouldn't|wait|slow.*down)\b/.test(npcResponseLower);
        
        // Calculate average current stat level (for relationship strength check)
        const avgStats = ((emp.stats.affection ?? 50) + (emp.stats.comfort ?? 50) + (emp.stats.trust ?? 50) + (emp.stats.desire ?? 20)) / 4;
        const strongRelationship = avgStats >= 70;
        
        // Apply stat changes with smart moderation
        const applyChange = (current, change, statName, max = 100, min = 0) => {
          // SAFETY CHECK: Prevent harsh drops in consensual scenarios
          if (change < -3 && showsConsent && !showsDiscomfort) {
            // NPC clearly consented - cap the negative change
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -2 (NPC showed consent)`);
            change = Math.max(change, -2);
          }
          
          // SAFETY CHECK: Strong relationships are more resilient
          if (change < -5 && strongRelationship && !showsDiscomfort) {
            // High stats = strong bond, can handle more
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -3 (strong relationship)`);
            change = Math.max(change, -3);
          }
          
          // BONUS: Amplify gains when NPC shows enthusiasm
          if (change > 0 && showsEnthusiasm) {
            change = change * 1.5;
            console.log(`[Stat Bonus] ${emp.name}'s ${statName}: Amplifying gain to ${change.toFixed(1)} (NPC enthusiastic)`);
          }
          
          // Apply cheat multiplier if it exists
          const multiplier = gameState.cheatMultipliers?.[statName.toLowerCase()] || 1.0;
          if (multiplier !== 1.0) {
            change = change * multiplier;
            console.log(`[Cheat Multiplier] ${emp.name}'s ${statName}: ${multiplier.toFixed(1)}x multiplier applied`);
          }
          
          let newVal = current + change;
          
          // Diminishing returns near caps
          if (change > 0 && current > 80) {
            newVal = current + (change * 0.5); // Half effect above 80
          } else if (change > 0 && current > 90) {
            newVal = current + (change * 0.25); // Quarter effect above 90
          }
          
          return Math.max(min, Math.min(max, newVal));
        };
        
        emp.stats.affection = applyChange(emp.stats.affection ?? 50, numbers[0], 'Affection');
        emp.stats.comfort = applyChange(emp.stats.comfort ?? 50, numbers[1], 'Comfort');
        emp.stats.trust = applyChange(emp.stats.trust ?? 50, numbers[2], 'Trust');
        emp.stats.desire = applyChange(emp.stats.desire ?? 20, numbers[3], 'Desire');
        emp.stats.obedience = applyChange(emp.stats.obedience ?? 50, numbers[4], 'Obedience');
        
        // Log stat changes for debugging
        console.log(`[Stat Update] ${emp.name}: Aff${numbers[0]>0?'+':''}${numbers[0]} Com${numbers[1]>0?'+':''}${numbers[1]} Tru${numbers[2]>0?'+':''}${numbers[2]} Des${numbers[3]>0?'+':''}${numbers[3]} Obe${numbers[4]>0?'+':''}${numbers[4]}${showsConsent?' [CONSENT]':''}${showsEnthusiasm?' [ENTHUSIASTIC]':''}${showsDiscomfort?' [DISCOMFORT]':''}`);
        
        // Update UI if on people tab
        if (gameState.activeTab === 'people') {
          updatePeopleTab();
        }
      } else {
        // Fallback: Basic keyword analysis if AI fails
        console.warn('[Stat Update] AI evaluation failed, using fallback');
        fallbackStatUpdate(emp, playerMessage, npcResponse);
      }
    } catch (error) {
      console.error('[Stat Update] Error:', error);
      fallbackStatUpdate(emp, playerMessage, npcResponse);
    }
  }
  
  // Fallback stat update using keyword analysis
  function fallbackStatUpdate(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    
    // Affection changes
    if (/\b(thank|appreciate|grateful|wonderful|amazing|great job)\b/.test(p)) {
      emp.stats.affection = Math.min(100, (emp.stats.affection ?? 50) + 3);
    }
    if (/\b(stupid|idiot|useless|hate)\b/.test(p)) {
      emp.stats.affection = Math.max(0, (emp.stats.affection ?? 50) - 5);
    }
    
    // Comfort changes
    if (/\b(comfortable|relaxed|casual|easy|chill)\b/.test(p)) {
      emp.stats.comfort = Math.min(100, (emp.stats.comfort ?? 50) + 2);
    }
    if (/\b(nervous|anxious|worried|uncomfortable)\b/.test(n)) {
      emp.stats.comfort = Math.max(0, (emp.stats.comfort ?? 50) - 3);
    }
    
    // Trust changes
    if (/\b(honest|truth|trust|believe|promise)\b/.test(p)) {
      emp.stats.trust = Math.min(100, (emp.stats.trust ?? 50) + 2);
    }
    if (/\b(lie|lied|dishonest|deceive)\b/.test(p)) {
      emp.stats.trust = Math.max(0, (emp.stats.trust ?? 50) - 4);
    }
    
    // Desire changes
    if (/\b(beautiful|gorgeous|sexy|hot|attractive|cute)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 4);
    }
    if (/\b(date|dinner|kiss|touch|want you)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 3);
    }
    
    // Obedience changes
    if (/\b(good job|well done|excellent|perfect)\b/.test(p)) {
      emp.stats.obedience = Math.min(100, (emp.stats.obedience ?? 50) + 2);
    }
    if (/\b(no|won't|refuse|can't make me)\b/.test(n)) {
      emp.stats.obedience = Math.max(0, (emp.stats.obedience ?? 50) - 2);
    }
    
    // Productivity is more stable, changes slowly
    if (/\b(work|project|task|deadline)\b/.test(p)) {
      emp.stats.productivity = Math.min(100, (emp.stats.productivity ?? 50) + 1);
    }
    
    // Check for gossip-worthy interactions!
    checkForGossipWorthyInteraction(emp, playerMsg, npcMsg);
  }
  
  /**
   * ═══════════════════════════════════════════════════════════════════
   * 🌐 SOCIAL DYNAMICS SYSTEM: NPC-to-NPC Relationship Evolution
   * ═══════════════════════════════════════════════════════════════════
   * Evaluates how NPCs feel about each other based on social interactions
   * Posts, comments, likes, and tags all influence relationships
   * 
   * OPTIMIZATION: Uses batching and heuristics to reduce AI calls by 60%
   */
  
  /**
   * Track post topic keywords to prevent duplicates (AI Optimization)
   */
  function trackPostTopic(postContent) {
    if (!postContent) return;
    
    const content = postContent.toLowerCase();
    
    // Extract key terms
    const keywords = [
      // Work related
      'meeting', 'deadline', 'project', 'presentation', 'report', 'work',
      // Social
      'coffee', 'lunch', 'drinks', 'party', 'dinner', 'hangout',
      // Objects
      'keys', 'phone', 'laptop', 'car', 'desk', 'folder',
      // Actions
      'lost', 'found', 'looking for', 'searching', 'organize', 'clean',
      // Locations
      'garage', 'parking', 'office', 'break room', 'kitchen',
      // Common themes
      'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'weekend',
      'tired', 'stressed', 'excited', 'happy', 'frustrated'
    ];
    
    const foundKeywords = keywords.filter(kw => content.includes(kw));
    
    if (foundKeywords.length > 0) {
      const topicKey = foundKeywords.join('_');
      aiOptimization.recentTopics.set(topicKey, Date.now());
      
      // Clean old topics (older than 5 minutes)
      const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
      for (const [key, timestamp] of aiOptimization.recentTopics.entries()) {
        if (timestamp < fiveMinutesAgo) {
          aiOptimization.recentTopics.delete(key);
        }
      }
    }
  }
  
  /**
   * Check if a topic was recently used (AI Optimization)
   */
  function wasTopicRecentlyUsed(postContent) {
    if (!postContent) return false;
    
    const content = postContent.toLowerCase();
    const threeMinutesAgo = Date.now() - (3 * 60 * 1000);
    
    // Check if this content contains any recently used keyword combinations
    for (const [topicKey, timestamp] of aiOptimization.recentTopics.entries()) {
      if (timestamp > threeMinutesAgo) {
        const keywords = topicKey.split('_');
        const matchCount = keywords.filter(kw => content.includes(kw)).length;
        
        // If 50%+ of the keywords match, consider it a duplicate topic
        if (matchCount >= Math.ceil(keywords.length / 2)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Start relationship evaluation batching system
   */
  function startRelationshipBatching() {
    if (aiOptimization.relationshipBatchInterval) return;
    
    aiOptimization.relationshipBatchInterval = setInterval(() => {
      processRelationshipBatch();
    }, aiOptimization.relationshipBatchDelay);
    
    console.log('[AI Optimization] Relationship batching started (30s intervals)');
  }
  
  /**
   * Process batched relationship evaluations
   * IMPROVED: Limits batch size and processes most important first
   */
  async function processRelationshipBatch() {
    if (aiOptimization.relationshipQueue.length === 0) return;
    
    // OPTIMIZATION: Limit queue size to prevent memory issues and excessive AI calls
    const MAX_QUEUE_SIZE = 50; // Process max 50 evaluations per batch
    
    if (aiOptimization.relationshipQueue.length > MAX_QUEUE_SIZE) {
      console.log(`[AI Optimization] ⚠️ Queue too large (${aiOptimization.relationshipQueue.length}), trimming to ${MAX_QUEUE_SIZE}`);
      
      // Keep most recent items (they're more relevant)
      aiOptimization.relationshipQueue = aiOptimization.relationshipQueue.slice(-MAX_QUEUE_SIZE);
    }
    
    const batch = [...aiOptimization.relationshipQueue];
    aiOptimization.relationshipQueue = [];
    
    console.log(`[AI Optimization] Processing ${batch.length} queued relationship evaluations`);
    
    // OPTIMIZATION: Process sequentially with a small delay to avoid rate limiting
    for (let i = 0; i < batch.length; i++) {
      const item = batch[i];
      try {
        await evaluateNPCReactionToPostImmediate(item.viewer, item.postAuthor, item.post, item.comment);
        
        // Add small delay between calls (100ms) to prevent overwhelming the AI
        if (i < batch.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        console.error('[AI Optimization] Batch processing error:', error);
      }
    }
    
    console.log(`[AI Optimization] ✓ Batch complete. Queue now at ${aiOptimization.relationshipQueue.length}`);
  }
  
  /**
   * ALGORITHMIC NPC->NPC INTERACTION ANALYZER
   * Pure pattern recognition - NO AI CALLS
   */
  function evaluateNPCReactionToPost(viewer, postAuthor, post, comment = null) {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Use ONLY algorithmic analysis
    const change = analyzeNPCInteractionAlgorithmic(viewer, postAuthor, post, comment);
    applyRelationshipChange(viewer, postAuthor, change, 'algorithmic');
  }
  
  /**
   * ALGORITHMIC NPC INTERACTION ANALYZER
   * Sophisticated pattern recognition system - NO AI
   * Analyzes post content, comment sentiment, personality compatibility, and context
   * Returns relationship change value (-5 to +5)
   */
  function analyzeNPCInteractionAlgorithmic(viewer, postAuthor, post, comment) {
    // Initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    const relationship = viewer.relationships[postAuthor.id] || { strength: 50, type: 'colleague' };
    const currentStrength = relationship.strength;
    
    // Get personalities
    const viewerPersonality = viewer.personality || {};
    const authorPersonality = postAuthor.personality || {};
    
    let baseChange = 0;
    let modifiers = [];
    
    // ===== PHASE 1: ANALYZE POST CONTENT =====
    const postContent = (post.content || '').toLowerCase();
    const postType = post.type || 'text';
    const explicitLevel = post.explicitLevel || 0;
    const hasImage = !!post.imageUrl;
    
    // Base reaction to post type
    const postTypeScores = {
      'meme': 1,
      'funny': 1,
      'achievement': 2,
      'work_update': 0,
      'selfie': 1,
      'thirst_trap': 0,
      'explicit': -1,
      'life_update': 1,
      'food': 0,
      'travel': 1,
      'fitness': 0,
      'hobby': 1,
      'entertainment': 0,
      'mood': 0,
      'question': 0,
      'throwback': 1,
      'tea_spilling': 2,
      'gossip': 1
    };
    
    baseChange += postTypeScores[postType] || 0;
    
    // Explicit content reactions based on viewer personality
    if (explicitLevel >= 2) {
      const viewerFlirty = viewerPersonality.flirty || 50;
      const viewerProfessional = viewerPersonality.professional || 50;
      const viewerConfidence = viewerPersonality.confidence || 50;
      
      if (viewerFlirty > 70) {
        baseChange += 2; // Flirty people enjoy explicit content
        modifiers.push('flirty_viewer_likes_explicit');
      } else if (viewerProfessional > 70) {
        baseChange -= 1; // Professional people uncomfortable
        modifiers.push('professional_viewer_uncomfortable');
      }
      
      // Confidence affects reaction
      if (viewerConfidence < 40 && explicitLevel >= 3) {
        baseChange -= 1; // Shy people uncomfortable with very explicit
        modifiers.push('shy_viewer_uncomfortable');
      }
    }
    
    // ===== PHASE 2: ANALYZE COMMENT (if present) =====
    if (comment) {
      const commentLower = comment.toLowerCase();
      const commentLength = comment.length;
      
      // Sentiment analysis via keywords and emojis
      const positiveKeywords = ['love', 'amazing', 'great', 'awesome', 'beautiful', 'perfect', 'best', 'proud', 'congrats', 'yay', 'yes', 'nice', 'good', 'happy'];
      const negativeKeywords = ['hate', 'awful', 'terrible', 'worst', 'wtf', 'seriously', 'ugh', 'gross', 'cringe', 'yikes'];
      const funnyKeywords = ['lol', 'haha', 'lmao', 'rofl', 'dead', 'omg', 'hilarious'];
      const flirtyKeywords = ['hot', 'sexy', 'damn', 'gorgeous', 'stunning', 'fine', 'looking good'];
      const dramaKeywords = ['tea', 'drama', 'omg', 'spill', 'gossip', 'scandal', 'messy'];
      
      const positiveEmojis = ['❤️', '💕', '😍', '🥰', '😊', '😁', '🎉', '👏', '✨', '💯', '🔥'];
      const negativeEmojis = ['🙄', '😒', '😤', '💀', '😬'];
      const funnyEmojis = ['😂', '🤣', '💀', '😭'];
      const flirtyEmojis = ['😏', '😘', '🥵', '👀', '🔥'];
      const dramaEmojis = ['☕', '🫖', '👀', '🍿'];
      
      // Count sentiment indicators
      let positiveScore = 0;
      let negativeScore = 0;
      let funnyScore = 0;
      let flirtyScore = 0;
      let dramaScore = 0;
      
      // Keywords
      positiveKeywords.forEach(kw => { if (commentLower.includes(kw)) positiveScore += 1; });
      negativeKeywords.forEach(kw => { if (commentLower.includes(kw)) negativeScore += 1; });
      funnyKeywords.forEach(kw => { if (commentLower.includes(kw)) funnyScore += 1; });
      flirtyKeywords.forEach(kw => { if (commentLower.includes(kw)) flirtyScore += 1; });
      dramaKeywords.forEach(kw => { if (commentLower.includes(kw)) dramaScore += 1; });
      
      // Emojis (worth 1.5x keywords)
      positiveEmojis.forEach(em => { if (comment.includes(em)) positiveScore += 1.5; });
      negativeEmojis.forEach(em => { if (comment.includes(em)) negativeScore += 1.5; });
      funnyEmojis.forEach(em => { if (comment.includes(em)) funnyScore += 1.5; });
      flirtyEmojis.forEach(em => { if (comment.includes(em)) flirtyScore += 1.5; });
      dramaEmojis.forEach(em => { if (comment.includes(em)) dramaScore += 1.5; });
      
      // Determine dominant sentiment
      const maxScore = Math.max(positiveScore, negativeScore, funnyScore, flirtyScore, dramaScore);
      
      if (maxScore > 0) {
        if (positiveScore === maxScore) {
          baseChange += 3;
          modifiers.push('supportive_comment');
        } else if (funnyScore === maxScore) {
          baseChange += 2;
          modifiers.push('funny_comment');
        } else if (flirtyScore === maxScore) {
          baseChange += 2;
          modifiers.push('flirty_comment');
        } else if (dramaScore === maxScore) {
          baseChange += 1;
          modifiers.push('dramatic_comment');
        } else if (negativeScore === maxScore) {
          baseChange -= 2;
          modifiers.push('negative_comment');
        }
      } else {
        // Neutral/generic comment
        if (commentLength < 15) {
          baseChange += 0.5; // Short generic comments are weak bonding
          modifiers.push('generic_comment');
        } else {
          baseChange += 1; // Longer comments show engagement
          modifiers.push('engaged_comment');
        }
      }
      
      // Comment length bonus (more effort = stronger bond)
      if (commentLength > 50) {
        baseChange += 0.5;
        modifiers.push('lengthy_comment');
      }
      
    } else {
      // Just viewing, no comment
      // Most views have minimal impact
      if (explicitLevel < 2 && postType !== 'achievement' && postType !== 'tea_spilling') {
        baseChange += 0; // Neutral view
        modifiers.push('casual_view');
      } else if (postType === 'achievement') {
        baseChange += 1; // Appreciate achievements even without comment
        modifiers.push('appreciates_achievement');
      } else if (postType === 'tea_spilling' || postType === 'gossip') {
        baseChange += 0.5; // Drama is interesting
        modifiers.push('interested_in_drama');
      }
    }
    
    // ===== PHASE 3: PERSONALITY COMPATIBILITY =====
    const viewerOutgoing = viewerPersonality.outgoing || 50;
    const authorOutgoing = authorPersonality.outgoing || 50;
    const viewerHumor = viewerPersonality.humor || 50;
    const authorHumor = authorPersonality.humor || 50;
    const viewerFlirty = viewerPersonality.flirty || 50;
    const authorFlirty = authorPersonality.flirty || 50;
    
    // Similar personalities bond better
    const outgoingDiff = Math.abs(viewerOutgoing - authorOutgoing);
    const humorDiff = Math.abs(viewerHumor - authorHumor);
    const flirtyDiff = Math.abs(viewerFlirty - authorFlirty);
    
    const avgDiff = (outgoingDiff + humorDiff + flirtyDiff) / 3;
    
    if (avgDiff < 20) {
      baseChange += 0.5; // Very compatible
      modifiers.push('compatible_personalities');
    } else if (avgDiff > 60) {
      baseChange -= 0.5; // Clashing personalities
      modifiers.push('clashing_personalities');
    }
    
    // ===== PHASE 4: RELATIONSHIP CONTEXT =====
    // Strong relationships amplify positive interactions
    if (currentStrength > 70 && baseChange > 0) {
      baseChange *= 1.2;
      modifiers.push('strong_bond_amplifies');
    }
    
    // Weak relationships dampen negative interactions (not close enough to care)
    if (currentStrength < 30 && baseChange < 0) {
      baseChange *= 0.7;
      modifiers.push('weak_bond_dampens');
    }
    
    // ===== PHASE 5: CONTENT-SPECIFIC MODIFIERS =====
    // Tag analysis
    if (postContent.includes('@' + viewer.name.toLowerCase())) {
      baseChange += 1.5; // Being mentioned is bonding
      modifiers.push('mentioned_in_post');
    }
    
    // Question posts invite engagement
    if (postContent.includes('?') && !comment) {
      baseChange -= 0.5; // Ignoring a question is slightly negative
      modifiers.push('ignored_question');
    }
    
    // Shared interests (hobby matching)
    const viewerHobbies = (viewer.hobbies || []).map(h => h.toLowerCase());
    const postHobbies = (post.tags || []).map(t => t.toLowerCase());
    const sharedInterests = viewerHobbies.filter(h => postHobbies.includes(h)).length;
    
    if (sharedInterests > 0) {
      baseChange += sharedInterests * 0.5;
      modifiers.push(`shared_interests_x${sharedInterests}`);
    }
    
    // ===== FINAL: CLAMP AND RETURN =====
    const finalChange = Math.max(-5, Math.min(5, Math.round(baseChange * 10) / 10));
    
    if (finalChange !== 0) {
      console.log(`[Algorithmic] ${viewer.name} ↔ ${postAuthor.name}: ${finalChange > 0 ? '+' : ''}${finalChange} (${currentStrength} → ${currentStrength + finalChange}) [${modifiers.join(', ')}]`);
    }
    
    return finalChange;
  }
  
  /**
   * Apply relationship change without AI evaluation
   */
  function applyRelationshipChange(viewer, postAuthor, change, source = 'ai') {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Get or initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    if (!viewer.relationships[postAuthor.id]) {
      viewer.relationships[postAuthor.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = viewer.relationships[postAuthor.id];
    const oldStrength = relationship.strength || 50; // Default to 50 if undefined
    const newStrength = oldStrength + change;
    relationship.strength = Math.max(0, Math.min(100, newStrength));
    
    // Update relationship type based on strength
    if (relationship.strength > 80) relationship.type = 'best_friend';
    else if (relationship.strength > 65) relationship.type = 'friend';
    else if (relationship.strength > 35) relationship.type = 'colleague';
    else if (relationship.strength > 15) relationship.type = 'acquaintance';
    else relationship.type = 'distant';
    
    if (change !== 0) {
      console.log(`[Social Dynamics${source === 'heuristic' ? ' 🎯' : ''}] ${viewer.name} → ${postAuthor.name}: ${change > 0 ? '+' : ''}${change} (${oldStrength} → ${relationship.strength}, ${relationship.type})`);
      
      // Add to history
      relationship.history.push({
        timestamp: Date.now(),
        type: 'social_interaction',
        change: change,
        source: source
      });
      
      // Keep history reasonable
      if (relationship.history.length > 20) {
        relationship.history = relationship.history.slice(-20);
      }
      
      // Create gossip if relationship changed significantly
      if (Math.abs(change) >= 4) {
        createGossipFromSocialInteraction(viewer, postAuthor, null, null, change);
      }
    }
  }
  
  /**
   * Evaluate NPC reaction to another NPC's post (IMMEDIATE - used by batch processor)
   * Called when NPC views/comments on another NPC's post
   * This is the AI-powered version that gets called for complex cases
   */
  async function evaluateNPCReactionToPostImmediate(viewer, postAuthor, post, comment = null) {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Get or initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    if (!viewer.relationships[postAuthor.id]) {
      viewer.relationships[postAuthor.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = viewer.relationships[postAuthor.id];
    const currentStrength = relationship.strength || 50;
    
    // Build context
    const postType = post.type || 'text';
    const explicitLevel = post.explicitLevel || 0;
    const hasComment = !!comment;
    
    // Get viewer's personality to determine reaction style
    const viewerPersonality = viewer.personality || {};
    const viewerFlirty = viewerPersonality.flirty || 50;
    const viewerProfessional = viewerPersonality.professional || 50;
    const viewerHumor = viewerPersonality.humor || 50;
    
    const evaluationPrompt = `Post: "${post.content?.substring(0, 60) || ''}"${hasComment ? `\nComment: "${comment.substring(0, 50)}"` : ''}
Rel: ${currentStrength}/100
Output single number -5 to +5 only:`;

    try {
      const raw = await generateText(evaluationPrompt, { 
        temperature: 0.3, 
        max_tokens: 3,
        stopSequences: ['\n', ' ', 'Rating:', '**', 'Why', '(', 'The ', 'This ']
      });
      const change = parseFloat(raw.trim());
      
      if (!isNaN(change) && change >= -5 && change <= 5) {
        applyRelationshipChange(viewer, postAuthor, change, 'ai');
      }
    } catch (error) {
      console.error(`[Social Dynamics] Error evaluating ${viewer.name}'s reaction:`, error);
    }
  }
  
  /**
   * Evaluate NPC-to-NPC comment interaction
   * Called when one NPC comments on another NPC's comment
   */
  /**
   * ALGORITHMIC NPC COMMENT REPLY ANALYZER
   * Evaluates NPC-to-NPC comment exchanges - NO AI
   */
  async function evaluateNPCCommentInteraction(commenter, originalCommenter, post, comment, replyComment) {
    if (!commenter || !originalCommenter || commenter.id === originalCommenter.id) return;
    
    // Initialize relationships
    if (!commenter.relationships) commenter.relationships = {};
    if (!commenter.relationships[originalCommenter.id]) {
      commenter.relationships[originalCommenter.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = commenter.relationships[originalCommenter.id];
    const oldStrength = relationship.strength || 50;
    
    // ALGORITHMIC ANALYSIS - NO AI
    const change = analyzeCommentReplyAlgorithmic(commenter, originalCommenter, comment, replyComment, relationship);
    
    if (!isNaN(change) && change >= -5 && change <= 5 && change !== 0) {
      relationship.strength = Math.max(0, Math.min(100, oldStrength + change));
      
      // Update type
      if (relationship.strength > 80) relationship.type = 'best_friend';
      else if (relationship.strength > 65) relationship.type = 'friend';
      else if (relationship.strength > 35) relationship.type = 'colleague';
      else relationship.type = 'distant';
      
      console.log(`[Comment Dynamics] ${commenter.name} ↔ ${originalCommenter.name}: ${change > 0 ? '+' : ''}${change} (${oldStrength} → ${relationship.strength})`);
      
      relationship.history.push({
        timestamp: Date.now(),
        type: 'comment_exchange',
        description: `Replied to ${originalCommenter.name}'s comment`,
        change: change
      });
      
      if (relationship.history.length > 20) {
        relationship.history = relationship.history.slice(-20);
      }
    }
  }
  
  /**
   * ALGORITHMIC COMMENT REPLY ANALYZER
   * Pattern recognition for comment tone and relationship dynamics
   * NO AI - Pure sentiment analysis and pattern matching
   */
  function analyzeCommentReplyAlgorithmic(commenter, originalCommenter, comment, replyComment, relationship) {
    const commentLower = comment.toLowerCase();
    const replyLower = replyComment.toLowerCase();
    const currentStrength = relationship.strength || 50;
    
    let baseChange = 0;
    
    // Get personalities
    const commenterPersonality = commenter.personality || {};
    const originalPersonality = originalCommenter.personality || {};
    
    // ===== ANALYZE SENTIMENT MATCH/CLASH =====
    
    // Sentiment indicators
    const positiveWords = ['love', 'great', 'awesome', 'amazing', 'perfect', 'yes', 'agree', 'right', 'exactly', 'totally'];
    const negativeWords = ['hate', 'wrong', 'no', 'disagree', 'awful', 'terrible', 'stop', 'wtf'];
    const agreementWords = ['yeah', 'yep', 'same', 'agree', 'right', 'exactly', 'totally', 'fr', 'facts'];
    const disagreementWords = ['but', 'actually', 'no', 'nah', 'disagree', 'wrong'];
    
    // Score sentiments
    let commentPositive = 0;
    let commentNegative = 0;
    let replyPositive = 0;
    let replyNegative = 0;
    let replyAgreement = 0;
    let replyDisagreement = 0;
    
    positiveWords.forEach(w => {
      if (commentLower.includes(w)) commentPositive++;
      if (replyLower.includes(w)) replyPositive++;
    });
    
    negativeWords.forEach(w => {
      if (commentLower.includes(w)) commentNegative++;
      if (replyLower.includes(w)) replyNegative++;
    });
    
    agreementWords.forEach(w => {
      if (replyLower.includes(w)) replyAgreement++;
    });
    
    disagreementWords.forEach(w => {
      if (replyLower.includes(w)) replyDisagreement++;
    });
    
    // ===== ANALYZE INTERACTION TYPE =====
    
    // 1. Agreement/Support
    if (replyAgreement > replyDisagreement) {
      baseChange += 2; // Agreement builds bonds
      if (currentStrength > 60) baseChange += 1; // Friends agreeing is extra bonding
    }
    
    // 2. Disagreement/Conflict
    if (replyDisagreement > replyAgreement) {
      baseChange -= 1.5; // Disagreement creates tension
      if (currentStrength < 40) baseChange -= 0.5; // Worse if not close
    }
    
    // 3. Positive exchange (both positive)
    if (commentPositive > commentNegative && replyPositive > replyNegative) {
      baseChange += 2; // Mutual positivity
    }
    
    // 4. Negative exchange (both negative)
    if (commentNegative > commentPositive && replyNegative > replyPositive) {
      // Could be bonding over shared complaint or actual conflict
      if (replyAgreement > 0) {
        baseChange += 1.5; // Bonding over shared grievance
      } else {
        baseChange -= 1; // Just negative
      }
    }
    
    // 5. Mismatched sentiment (one positive, one negative)
    if ((commentPositive > commentNegative && replyNegative > replyPositive) ||
        (commentNegative > commentPositive && replyPositive > replyNegative)) {
      baseChange -= 1; // Tone mismatch
    }
    
    // ===== ANALYZE EMOJIS =====
    const positiveEmojis = ['❤️', '💕', '😍', '🥰', '😊', '😁', '🎉', '✨'];
    const funnyEmojis = ['😂', '🤣', '💀', '😭'];
    const negativeEmojis = ['🙄', '😒', '😤', '😬'];
    const flirtyEmojis = ['😏', '😘', '🥵', '🔥'];
    
    let replyEmojiScore = 0;
    positiveEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 1; });
    funnyEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 0.5; });
    negativeEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore -= 1; });
    flirtyEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 0.5; });
    
    baseChange += replyEmojiScore;
    
    // ===== LENGTH ANALYSIS =====
    const replyLength = replyComment.length;
    
    if (replyLength > 50) {
      baseChange += 0.5; // Thoughtful long replies show care
    } else if (replyLength < 10) {
      baseChange -= 0.3; // Very short replies seem dismissive
    }
    
    // ===== PERSONALITY COMPATIBILITY =====
    const humorMatch = Math.abs((commenterPersonality.humor || 50) - (originalPersonality.humor || 50));
    const outgoingMatch = Math.abs((commenterPersonality.outgoing || 50) - (originalPersonality.outgoing || 50));
    
    const avgMatch = (humorMatch + outgoingMatch) / 2;
    
    if (avgMatch < 25) {
      baseChange += 0.5; // Compatible personalities
    } else if (avgMatch > 65) {
      baseChange -= 0.3; // Clashing personalities
    }
    
    // ===== RELATIONSHIP CONTEXT =====
    if (currentStrength > 70) {
      // Close friends - amplify positive, dampen negative
      if (baseChange > 0) baseChange *= 1.3;
      if (baseChange < 0) baseChange *= 0.7;
    } else if (currentStrength < 30) {
      // Distant - reduce all impact
      baseChange *= 0.8;
    }
    
    // ===== CLAMP AND RETURN =====
    return Math.max(-5, Math.min(5, Math.round(baseChange * 10) / 10));
  }
  
  /**
   * Create gossip from notable social interactions
   */
  function createGossipFromSocialInteraction(viewer, postAuthor, post, comment, relationshipChange) {
    // Only create gossip for significant changes or explicit content
    const postExplicitLevel = post?.explicitLevel || 0;
    if (Math.abs(relationshipChange) < 3 && postExplicitLevel < 2) return;
    
    let gossipContent = '';
    let contextType = 'gossip';
    
    if (relationshipChange >= 4) {
      // Positive bonding
      gossipContent = `${viewer.name} and ${postAuthor.name} seem to be getting really close on social media`;
      contextType = 'friendship';
    } else if (relationshipChange <= -4) {
      // Drama/conflict
      gossipContent = `${viewer.name} and ${postAuthor.name} had tension on social media`;
      contextType = 'fight';
    } else if (postExplicitLevel >= 3) {
      // Explicit content reaction
      gossipContent = `${postAuthor.name} posted something VERY explicit and ${viewer.name} ${comment ? 'commented on it' : 'saw it'}`;
      contextType = 'scandal';
    }
    
    if (gossipContent) {
      const juiciness = Math.abs(relationshipChange) * 10 + (postExplicitLevel * 15);
      
      // Add to gossip engine for other NPCs to discover
      if (!gameState.activeGossip) gameState.activeGossip = [];
      
      gameState.activeGossip.push({
        id: `gossip_${Date.now()}_${Math.random()}`,
        subjectId: postAuthor.id,
        targetId: viewer.id,
        content: gossipContent,
        juiciness: juiciness,
        timestamp: Date.now(),
        accuracy: 100, // Direct observation
        knownBy: [viewer.id] // Viewer knows it firsthand
      });
      
      // Keep gossip list manageable
      if (gameState.activeGossip.length > 50) {
        gameState.activeGossip = gameState.activeGossip.slice(-50);
      }
      
      console.log(`[Gossip Created] ${gossipContent} (juiciness: ${juiciness})`);
      
      // Add juicy gossip to Company-Wide Context if it's scandalous enough
      if (juiciness >= 65) {
        addToCompanyWideContext({
          content: gossipContent,
          type: contextType,
          subjectIds: [viewer.id, postAuthor.id],
          juiciness: juiciness,
          source: 'gossip'
        });
        console.log(`[CompanyContext] Gossip was juicy enough to become public knowledge!`);
      }
    }
  }
  
  /**
   * Check if a conversation interaction is juicy enough to create gossip
   */
  function checkForGossipWorthyInteraction(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    const intimacy = emp.intimacy || 0;
    const desire = emp.stats?.desire || 0;
    
    // HOOKUP/SEXUAL interactions (Very juicy!)
    if (intimacy > 60 && desire > 50) {
      if (/\b(sex|fuck|bed|sleep together|hook up|come over)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss hooked up`,
          juiciness: 90
        });
        return;
      }
    }
    
    // DATING/ROMANTIC interactions (Juicy!)
    if (desire > 40) {
      if (/\b(date|dating|girlfriend|boyfriend|relationship|love you)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'date',
          npcId: emp.id,
          description: `${emp.name} and the boss went on a date`,
          juiciness: 70
        });
        return;
      }
      
      if (/\b(kiss|kissing|kissed|make out)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss kissed`,
          juiciness: 65
        });
        return;
      }
    }
    
    // FLIRTING interactions (Moderately juicy)
    if (desire > 25 && /\b(flirt|sexy|hot|gorgeous|beautiful|cute)\b/.test(p)) {
      if (Math.random() < 0.3) { // 30% chance to gossip about flirting
        createPlayerGossip({
          type: 'rumor',
          npcId: emp.id,
          description: `the boss was flirting with ${emp.name}`,
          juiciness: 45
        });
      }
    }
    
    // PROMOTION/FAVORITISM (Office politics!)
    if (/\b(promot|raise|bonus|favor|special treatment)\b/.test(p)) {
      createPlayerGossip({
        type: 'promotion',
        npcId: emp.id,
        description: `${emp.name} got special treatment from the boss`,
        juiciness: 55
      });
    }
    
    // FIRED/CONFLICT (Drama!)
    if (/\b(fire|fired|quit|resign|argument|fight|angry)\b/.test(p + n)) {
      createPlayerGossip({
        type: 'scandal',
        npcId: emp.id,
        description: `${emp.name} and the boss had a heated argument`,
        juiciness: 60
      });
    }
  }

  
  // Update news
  function updateNews() {
    // Add new news item
    const newsItems = [
      `${gameState.employees.length > 0 ? gameState.employees[0].name : 'Your company'} makes headlines with innovative approach`,
      `Industry experts praise ${gameState.employees.length > 0 ? gameState.employees[0].name : 'your team'}'s performance`,
      `New workplace policies at your company set industry standards`,
      `Your business growth outpaces competitors this quarter`,
      `Employee satisfaction at your company reaches all-time high`,
      `Tech community buzzing about your latest product launch`
    ];
    
    const randomNews = newsItems[Math.floor(Math.random() * newsItems.length)];
    gameState.news.unshift(randomNews);
    
    // Keep only latest 5 news items
    if (gameState.news.length > 5) {
      gameState.news = gameState.news.slice(0, 5);
    }
    
    // Update news ticker
    if (newsContent) newsContent.textContent = randomNews;
    
    // Update news feed if dashboard is active
    if (gameState.activeTab === 'dashboard') {
      updateNewsFeed();
    }
  }
  
  // ========== PLAYER POST COMPOSER FUNCTIONS ==========
  
  // ============================================
  // MENTION SUGGESTION SYSTEM (@suggest)
  // ============================================
  
  /**
   * Get suggested employees for @mentions
   * Ranked by: recent mentions > frequent mentions > affection > alphabetical
   */
  function getMentionSuggestions(searchQuery = '') {
    const activeEmployees = gameState.employees.filter(e => e && e.employmentStatus === 'active' && e.id);
    if (activeEmployees.length === 0) return [];
    
    const now = Date.now();
    const stats = gameState.playerMentionStats || { mentionHistory: [], mentionCounts: {} };
    
    // Ensure mentionCounts exists
    if (!stats.mentionCounts) {
      stats.mentionCounts = {};
    }
    if (!stats.mentionHistory) {
      stats.mentionHistory = [];
    }
    
    // Calculate scores for each employee
    const suggestions = activeEmployees.map(emp => {
      if (!emp || !emp.id) return null; // Skip invalid employees
      
      let score = 0;
      
      // Frequency score (how often mentioned) - weight: 50
      const mentionCount = stats.mentionCounts[emp.id] || 0;
      score += mentionCount * 50;
      
      // Recency score (how recently mentioned) - weight: 100
      const recentMentions = stats.mentionHistory.filter(m => 
        m && m.employeeId === emp.id && (now - m.timestamp) < 86400000 * 7 // Last 7 days
      );
      if (recentMentions.length > 0) {
        const latestMention = Math.max(...recentMentions.map(m => m.timestamp));
        const daysAgo = (now - latestMention) / 86400000;
        score += Math.max(0, 100 - (daysAgo * 10)); // Decay over 10 days
      }
      
      // Relationship score - weight: 30
      const affection = emp.stats?.affection || 0;
      const intimacy = emp.intimacy || 0;
      score += (affection + intimacy) / 2 * 0.3;
      
      // Search query match boost
      const username = emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '');
      const name = emp.name.toLowerCase();
      const query = searchQuery.toLowerCase();
      
      if (query && (username.startsWith(query) || name.startsWith(query))) {
        score += 1000; // High priority for matches
      } else if (query && (username.includes(query) || name.includes(query))) {
        score += 500; // Medium priority for partial matches
      }
      
      return {
        employee: emp,
        username: emp.social?.username || username,
        name: emp.name,
        affection: affection,
        mentionCount: mentionCount,
        score: score
      };
    }).filter(s => s !== null); // Remove null entries
    
    // Sort by score descending
    suggestions.sort((a, b) => b.score - a.score);
    
    // Filter by search query if provided
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      return suggestions.filter(s => 
        s.username.toLowerCase().includes(query) || 
        s.name.toLowerCase().includes(query)
      );
    }
    
    return suggestions;
  }
  
  /**
   * Track when player mentions someone
   */
  function trackPlayerMention(employeeId) {
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [],
        mentionCounts: {}
      };
    }
    
    const stats = gameState.playerMentionStats;
    
    // Add to history
    stats.mentionHistory.push({
      employeeId: employeeId,
      timestamp: Date.now()
    });
    
    // Increment count
    if (!stats.mentionCounts[employeeId]) {
      stats.mentionCounts[employeeId] = 0;
    }
    stats.mentionCounts[employeeId]++;
    
    // Keep history manageable (last 100 mentions)
    if (stats.mentionHistory.length > 100) {
      stats.mentionHistory.shift();
    }
    
    console.log(`[Mentions] Tracked mention of ${employeeId}, total: ${stats.mentionCounts[employeeId]}`);
  }
  
  /**
   * Extract @mentions from text
   * Returns array of { username, employeeId }
   */
  function extractMentions(text) {
    const mentions = [];
    const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
    let match;
    
    while ((match = mentionRegex.exec(text)) !== null) {
      const mentionedUsername = match[1].toLowerCase();
      
      // Check if it's @TheBoss (the player)
      if (mentionedUsername === 'theboss' || mentionedUsername === 'boss') {
        mentions.push({
          username: match[1],
          employeeId: 'player',
          fullMention: match[0]
        });
        console.log(`[Mention] Found @${match[1]} -> The Boss (player)`);
        continue;
      }
      
      // Find employee with this username - try multiple matching strategies
      const employee = gameState.employees.find(e => {
        if (!e.social?.username) return false;
        
        const storedUsername = e.social.username.toLowerCase();
        
        // Strategy 1: Exact match
        if (storedUsername === mentionedUsername) return true;
        
        // Strategy 2: Remove all separators (_, ., numbers, prefixes) and compare
        const normalizeUsername = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
        if (normalizeUsername(storedUsername) === normalizeUsername(mentionedUsername)) return true;
        
        // Strategy 3: Check if it's just firstname
        const firstName = e.name.split(' ')[0].toLowerCase();
        if (mentionedUsername === firstName) return true;
        
        // Strategy 4: Check if it's firstname + lastname no separator
        const firstLast = e.name.toLowerCase().replace(/\s+/g, '');
        if (mentionedUsername === firstLast) return true;
        
        // Strategy 5: Check if mentioned is contained in stored (for prefixes like the_, real_)
        if (storedUsername.includes(mentionedUsername) || mentionedUsername.includes(storedUsername.replace(/^(the_|real_)|_official$/g, ''))) {
          return true;
        }
        
        return false;
      });
      
      if (employee) {
        mentions.push({
          username: match[1],
          employeeId: employee.id,
          fullMention: match[0]
        });
        console.log(`[Mention] Found @${match[1]} -> ${employee.name} (username: ${employee.social.username}, ID: ${employee.id})`);
      } else {
        console.warn(`[Mention] Could not find employee for @${match[1]}`);
      }
    }
    
    console.log(`[Mention] Extracted ${mentions.length} mentions:`, mentions);
    return mentions;
  }
  
  /**
   * Show mention suggestions dropdown
   */
  function showMentionSuggestions(input, searchQuery = '') {
    const dropdown = $('mentionSuggestions');
    if (!dropdown) return;
    
    const suggestions = getMentionSuggestions(searchQuery);
    
    if (suggestions.length === 0) {
      dropdown.style.display = 'none';
      return;
    }
    
    // Limit to top 8 suggestions
    const topSuggestions = suggestions.slice(0, 8);
    
    dropdown.innerHTML = topSuggestions.map((s, index) => {
      const relationshipIcon = s.affection > 70 ? '💕' : s.affection > 40 ? '😊' : '👤';
      const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
      
      return `
        <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
          <div style="display:flex; align-items:center; gap:10px; flex:1;">
            <span style="font-size:1.2rem;">${relationshipIcon}</span>
            <div style="flex:1;">
              <div style="color:white; font-weight:600;">@${s.username}</div>
              <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
            </div>
          </div>
          ${mentionBadge}
        </div>
      `;
    }).join('');
    
    // Add hover effects
    dropdown.querySelectorAll('.mention-suggestion-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        item.style.background = '#0f3460';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = 'transparent';
      });
      item.addEventListener('click', () => {
        const username = item.dataset.username;
        const employeeId = item.dataset.employeeId;
        insertMention(input, username, employeeId);
      });
    });
    
    dropdown.style.display = 'block';
  }
  
  /**
   * Insert @mention into text input
   */
  function insertMention(input, username, employeeId, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    const text = input.value;
    const cursorPos = input.selectionStart;
    
    // Find the @ symbol position
    let atPos = cursorPos - 1;
    while (atPos >= 0 && text[atPos] !== '@') {
      atPos--;
    }
    
    if (atPos >= 0) {
      // Replace from @ to cursor with @username
      const before = text.substring(0, atPos);
      const after = text.substring(cursorPos);
      input.value = before + '@' + username + ' ' + after;
      
      // Set cursor after mention
      const newPos = atPos + username.length + 2;
      input.selectionStart = newPos;
      input.selectionEnd = newPos;
      
      // Track the mention
      trackPlayerMention(employeeId);
      
      // Trigger input event for char counter
      input.dispatchEvent(new Event('input'));
    }
    
    // Hide dropdown
    const dropdown = (dropdownId === 'mentionSuggestions' || dropdownId === 'modalMentionSuggestions') ? $(dropdownId) : 
                     document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    if (dropdown) dropdown.style.display = 'none';
    
    // Focus back on input
    input.focus();
  }
  
  /**
   * Setup mention autocomplete on an input
   */
  function setupMentionAutocomplete(input, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    let mentionActive = false;
    let mentionStartPos = -1;
    let currentHighlightIndex = 0;
    
    const getDropdown = () => {
      // Handle standard suggestions dropdown, modal suggestions dropdown, or post-specific comment dropdowns
      if (dropdownId === 'mentionSuggestions' || dropdownId === 'modalMentionSuggestions') {
        return $(dropdownId);
      }
      return document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    };
    
    const updateHighlight = () => {
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      items.forEach((item, index) => {
        if (index === currentHighlightIndex) {
          item.style.background = '#0f3460';
          item.setAttribute('data-highlighted', 'true');
        } else {
          item.style.background = 'transparent';
          item.removeAttribute('data-highlighted');
        }
      });
    };
    
    const showDropdownForInput = (searchQuery) => {
      const suggestions = getMentionSuggestions(searchQuery);
      const topSuggestions = suggestions.slice(0, 6);
      
      if (topSuggestions.length === 0) {
        const dropdown = getDropdown();
        if (dropdown) dropdown.style.display = 'none';
        return;
      }
      
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      dropdown.innerHTML = topSuggestions.map((s, index) => {
        const relationshipIcon = s.affection > 70 ? '💕' : s.affection > 40 ? '😊' : '👤';
        const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
        
        return `
          <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
            <div style="display:flex; align-items:center; gap:10px; flex:1;">
              <span style="font-size:1.2rem;">${relationshipIcon}</span>
              <div style="flex:1;">
                <div style="color:white; font-weight:600;">@${s.username}</div>
                <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
              </div>
            </div>
            ${mentionBadge}
          </div>
        `;
      }).join('');
      
      // Add hover and click effects
      dropdown.querySelectorAll('.mention-suggestion-item').forEach((item, index) => {
        item.addEventListener('mouseenter', () => {
          currentHighlightIndex = index;
          updateHighlight();
        });
        item.addEventListener('click', () => {
          const username = item.dataset.username;
          const employeeId = item.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        });
      });
      
      currentHighlightIndex = 0;
      updateHighlight();
      dropdown.style.display = 'block';
    };
    
    input.addEventListener('input', (e) => {
      const text = input.value;
      const cursorPos = input.selectionStart;
      
      // Check if @ was just typed or we're in a mention
      const charBefore = cursorPos > 0 ? text[cursorPos - 1] : '';
      const charBeforeThat = cursorPos > 1 ? text[cursorPos - 2] : '';
      
      // Detect @ at start or after space/newline
      if (charBefore === '@' && (cursorPos === 1 || charBeforeThat === ' ' || charBeforeThat === '\n')) {
        mentionActive = true;
        mentionStartPos = cursorPos - 1;
        showDropdownForInput('');
      } else if (mentionActive) {
        // Get text after @
        const textAfterAt = text.substring(mentionStartPos + 1, cursorPos);
        
        // Check if we're still in the mention (no space yet)
        if (textAfterAt.includes(' ') || textAfterAt.includes('\n')) {
          mentionActive = false;
          const dropdown = getDropdown();
          if (dropdown) dropdown.style.display = 'none';
        } else {
          // Update suggestions based on search
          showDropdownForInput(textAfterAt);
        }
      }
    });
    
    // Handle keyboard navigation and Tab autocomplete
    input.addEventListener('keydown', (e) => {
      const dropdown = getDropdown();
      if (!dropdown || dropdown.style.display === 'none') return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      if (items.length === 0) return;
      
      if (e.key === 'Escape') {
        dropdown.style.display = 'none';
        mentionActive = false;
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex + 1) % items.length;
        updateHighlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex - 1 + items.length) % items.length;
        updateHighlight();
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        // Tab or Enter to insert highlighted suggestion
        e.preventDefault();
        const highlightedItem = items[currentHighlightIndex];
        if (highlightedItem) {
          const username = highlightedItem.dataset.username;
          const employeeId = highlightedItem.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        }
      }
    });
    
    // Close dropdown when clicking outside
    const clickHandler = (e) => {
      const dropdown = getDropdown();
      if (dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.style.display = 'none';
        mentionActive = false;
      }
    };
    
    document.addEventListener('click', clickHandler);
  }
  
  /**
   * Open player post composer modal
   */
  function openPlayerPostComposer() {
    const modal = $('playerPostModal');
    if (!modal) return;
    
    // Reset form
    const captionInput = $('playerPostCaption');
    const imagePromptInput = $('playerPostImagePrompt');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    const charCount = $('captionCharCount');
    const previewContainer = $('playerPostImagePreview');
    
    if (captionInput) captionInput.value = '';
    if (imagePromptInput) imagePromptInput.value = '';
    if (imageAltInput) imageAltInput.value = '';
    if (explicitCheckbox) explicitCheckbox.checked = false;
    if (charCount) charCount.textContent = '0';
    if (previewContainer) {
      previewContainer.style.display = 'none';
    }
    
    // Reset to text type
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.classList.remove('active');
      btn.style.borderColor = '#0f3460';
      btn.style.color = '#aaa';
    });
    
    const textTypeBtn = document.querySelector('.post-type-btn[data-type="text"]');
    if (textTypeBtn) {
      textTypeBtn.classList.add('active');
      textTypeBtn.style.borderColor = '#00d4ff';
      textTypeBtn.style.color = 'white';
    }
    
    const imageSection = $('playerPostImageSection');
    const generateImageBtn = $('generatePlayerPostImage');
    if (imageSection) imageSection.style.display = 'none';
    if (generateImageBtn) generateImageBtn.style.display = 'none';
    
    // Clear stored image
    delete gameState.tempPostImage;
    
    // Setup mention autocomplete
    if (captionInput) {
      setupMentionAutocomplete(captionInput);
    }
    
    // Show modal with flex display
    modal.style.display = 'flex';
  }
  
  /**
   * Close player post composer modal
   */
  function closePlayerPostModal() {
    const modal = $('playerPostModal');
    if (modal) modal.style.display = 'none';
    
    // Clear temp data
    delete gameState.tempPostImage;
  }
  
  /**
   * Generate image for player post
   */
  /**
   * Generate image for player post
   * ENHANCED WITH DETAILED LOGGING FOR IMAGE GENERATION PIPELINE
   */
  async function generatePlayerPostImage_handler() {
    console.log('═══════════════════════════════════════════════════════');
    console.log('🎨 [IMAGE GENERATION PIPELINE] Starting...');
    console.log('═══════════════════════════════════════════════════════');
    
    const promptInput = $('playerPostImagePrompt');
    const altInput = $('playerPostAltText');
    const generateBtn = $('generatePlayerPostImage');
    const previewContainer = $('playerPostImagePreview');
    const previewImg = $('playerPostPreviewImg');
    
    if (!promptInput || !generateBtn) {
      console.error('[IMAGE GEN] ❌ Required DOM elements not found');
      return;
    }
    
    const prompt = promptInput.value.trim();
    
    console.log('[IMAGE GEN] STEP 1: Validate Input');
    console.log('[IMAGE GEN] User Prompt:', prompt || '(empty)');
    
    if (!prompt) {
      console.warn('[IMAGE GEN] ❌ Validation failed: Empty prompt');
      alert('Please enter an image description first!');
      return;
    }
    
    console.log('[IMAGE GEN] ✅ Validation passed');
    console.log('[IMAGE GEN] Prompt length:', prompt.length, 'characters');
    
    console.log('───────────────────────────────────────────────────────');
    console.log('[IMAGE GEN] STEP 2: Analyze Prompt Context');
    console.log('───────────────────────────────────────────────────────');
    
    // Analyze prompt for content flags
    const promptLower = prompt.toLowerCase();
    const contentAnalysis = {
      mentions: {
        person: /\b(person|people|man|woman|guy|girl|employee|worker)\b/i.test(prompt),
        location: /\b(office|desk|room|outside|park|beach|home|building)\b/i.test(prompt),
        object: /\b(desk|chair|computer|phone|coffee|car|food)\b/i.test(prompt),
        clothing: /\b(dress|suit|shirt|pants|outfit|uniform|casual|formal)\b/i.test(prompt),
        action: /\b(sitting|standing|walking|working|smiling|looking|holding)\b/i.test(prompt)
      },
      style: {
        selfie: /\b(selfie|self portrait)\b/i.test(prompt),
        professional: /\b(professional|business|work|formal|corporate)\b/i.test(prompt),
        casual: /\b(casual|relaxed|informal|candid)\b/i.test(prompt),
        artistic: /\b(artistic|creative|stylized|aesthetic)\b/i.test(prompt)
      },
      suggestiveKeywords: ['sexy', 'hot', 'revealing', 'attractive', 'seductive', 'provocative', 'intimate', 'sensual'].filter(word => promptLower.includes(word))
    };
    
    console.log('[IMAGE GEN] Content Analysis:', {
      hasPerson: contentAnalysis.mentions.person,
      hasLocation: contentAnalysis.mentions.location,
      hasAction: contentAnalysis.mentions.action,
      style: Object.keys(contentAnalysis.style).filter(k => contentAnalysis.style[k]),
      suggestiveWords: contentAnalysis.suggestiveKeywords.length > 0 ? contentAnalysis.suggestiveKeywords : 'none'
    });
    
    console.log('───────────────────────────────────────────────────────');
    console.log('[IMAGE GEN] STEP 3: Prepare Generation');
    console.log('───────────────────────────────────────────────────────');
    
    // Show loading state
    generateBtn.textContent = '⏳ Generating...';
    generateBtn.disabled = true;
    generateBtn.style.opacity = '0.6';
    
    console.log('[IMAGE GEN] UI State: Loading');
    console.log('[IMAGE GEN] Calling generateImage API...');
    
    const startTime = Date.now();
    
    try {
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 4: Generate Image (AI Processing)');
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] Prompt sent to AI:', prompt);
      
      // Generate image using Perchance AI
      const imageUrl = await generateImage(applyImageStyle(prompt));
      
      const generationTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(`[IMAGE GEN] ✅ Image generated successfully in ${generationTime}s`);
      console.log('[IMAGE GEN] Image URL:', imageUrl.substring(0, 100) + '...');
      
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 5: Store & Display Image');
      console.log('───────────────────────────────────────────────────────');
      
      // Store in temp state
      gameState.tempPostImage = imageUrl;
      console.log('[IMAGE GEN] ✅ Image stored in gameState.tempPostImage');
      
      // Show preview
      if (previewContainer && previewImg) {
        previewImg.src = imageUrl;
        previewContainer.style.display = 'block';
        console.log('[IMAGE GEN] ✅ Preview displayed');
      } else {
        console.warn('[IMAGE GEN] ⚠️ Preview container not found');
      }
      
      // Auto-fill alt text if empty
      if (altInput && !altInput.value.trim()) {
        altInput.value = prompt;
        console.log('[IMAGE GEN] ✅ Alt text auto-filled with prompt');
      } else {
        console.log('[IMAGE GEN] Alt text already present, not overwriting');
      }
      
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 6: Update UI State');
      console.log('───────────────────────────────────────────────────────');
      
      // Success feedback
      generateBtn.textContent = '✓ Image Generated!';
      generateBtn.style.background = '#00d4ff';
      console.log('[IMAGE GEN] UI State: Success');
      
      setTimeout(() => {
        generateBtn.textContent = '🎨 Generate Image';
        generateBtn.style.background = '#533483';
        generateBtn.disabled = false;
        generateBtn.style.opacity = '1';
        console.log('[IMAGE GEN] UI State: Reset to ready');
      }, 2000);
      
      console.log('═══════════════════════════════════════════════════════');
      console.log('✅ [IMAGE GENERATION PIPELINE] COMPLETE');
      console.log(`   Total time: ${generationTime}s`);
      console.log('═══════════════════════════════════════════════════════\n');
      
    } catch (error) {
      const failTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log('═══════════════════════════════════════════════════════');
      console.error('❌ [IMAGE GENERATION PIPELINE] FAILED');
      console.error(`   Time to failure: ${failTime}s`);
      console.error('   Error:', error);
      console.log('═══════════════════════════════════════════════════════\n');
      
      alert('Failed to generate image. Please try again.');
      
      generateBtn.textContent = '🎨 Generate Image';
      generateBtn.disabled = false;
      generateBtn.style.opacity = '1';
    }
  }
  
  /**
   * Regenerate player post image
   */
  async function regeneratePlayerPostImage() {
    await generatePlayerPostImage_handler();
  }
  
  /**
   * Submit player post to feed
   * ENHANCED WITH DETAILED LOGGING FOR EACH STEP
   */
  function submitPlayerPostToFeed() {
    console.log('═══════════════════════════════════════════════════════');
    console.log('🚀 [POST CREATION PIPELINE] STEP 1: Initialize Post');
    console.log('═══════════════════════════════════════════════════════');
    
    const captionInput = $('playerPostCaption');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    
    const caption = captionInput?.value.trim() || '';
    const imageUrl = gameState.tempPostImage || null;
    const imageAlt = imageAltInput?.value.trim() || '';
    const isExplicit = explicitCheckbox?.checked || false;
    
    console.log('[POST CREATION] Input Data:', {
      caption: caption || '(none)',
      imageUrl: imageUrl ? 'Present' : 'None',
      imageAlt: imageAlt || '(none)',
      isExplicitMarked: isExplicit
    });
    
    // Validate
    if (!caption && !imageUrl) {
      console.warn('[POST CREATION] ❌ Validation failed: No caption or image');
      alert('Please add either a caption or an image!');
      return;
    }
    
    if (imageUrl && !imageAlt) {
      console.warn('[POST CREATION] ❌ Validation failed: Image without alt text');
      alert('Please add alt text for your image (helps NPCs understand it)!');
      return;
    }
    
    if (caption.length > 500) {
      console.warn('[POST CREATION] ❌ Validation failed: Caption too long');
      alert('Caption is too long! Maximum 500 characters.');
      return;
    }
    
    console.log('[POST CREATION] ✅ Validation passed');
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📋 [POST CREATION PIPELINE] STEP 2: Determine Content/Type');
    console.log('───────────────────────────────────────────────────────');
    
    // Determine post type
    let postType = 'text';
    const activeTypeBtn = document.querySelector('.post-type-btn.active');
    if (activeTypeBtn) {
      postType = activeTypeBtn.dataset.type;
    }
    
    console.log('[POST CREATION] Post Type:', postType);
    
    // Determine explicit level
    let explicitLevel = 0;
    if (isExplicit) {
      explicitLevel = 3; // Player marked as explicit
      console.log('[POST CREATION] Explicit Level: 3 (player marked as explicit)');
    } else if (imageUrl) {
      // Check for suggestive keywords in alt text
      const suggestiveWords = ['sexy', 'hot', 'revealing', 'underwear', 'lingerie', 'bikini'];
      const hasSuggestive = suggestiveWords.some(word => 
        imageAlt.toLowerCase().includes(word) || caption.toLowerCase().includes(word)
      );
      if (hasSuggestive) {
        explicitLevel = 1;
        console.log('[POST CREATION] Explicit Level: 1 (suggestive keywords detected)');
      } else {
        console.log('[POST CREATION] Explicit Level: 0 (safe content)');
      }
    } else {
      console.log('[POST CREATION] Explicit Level: 0 (text-only post)');
    }
    
    console.log('───────────────────────────────────────────────────────');
    console.log('🔍 [POST CREATION PIPELINE] STEP 3: Extract Context');
    console.log('───────────────────────────────────────────────────────');
    
    // Extract @mentions from caption
    const mentions = extractMentions(caption) || []; // Safety: default to empty array
    const mentionedEmployeeIds = mentions.map(m => m.employeeId);
    
    console.log('[POST CREATION] Mention Analysis:');
    console.log(`  - Found ${mentions.length} @mentions`);
    if (mentions.length > 0) {
      mentions.forEach(m => {
        const emp = gameState.employees.find(e => e.id === m.employeeId);
        console.log(`  - @${m.username} → ${emp?.name} (ID: ${m.employeeId})`);
      });
    }
    
    // Analyze caption for context
    const captionLower = caption.toLowerCase();
    const contextFlags = {
      hasQuestion: captionLower.includes('?'),
      hasEmoji: /[\u{1F600}-\u{1F64F}|\u{1F300}-\u{1F5FF}|\u{1F680}-\u{1F6FF}|\u{2600}-\u{26FF}|\u{2700}-\u{27BF}]/u.test(caption),
      wordCount: caption.split(/\s+/).length,
      hasHashtag: caption.includes('#'),
      hasMention: caption.includes('@'),
      hasExclamation: caption.includes('!')
    };
    
    console.log('[POST CREATION] Caption Context:', contextFlags);
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📝 [POST CREATION PIPELINE] STEP 4: Create Post Object');
    console.log('───────────────────────────────────────────────────────');
    
    // Create post
    const post = createPost({
      authorId: 'player',
      authorName: 'You',
      type: postType,
      content: caption,
      imageUrl: imageUrl,
      imageAlt: imageAlt,
      explicitLevel: explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost: true,
      referencedEmployees: mentionedEmployeeIds // Store mentioned employee IDs (correct param name)
    });
    
    console.log('[POST CREATION] Post Object Created:', {
      id: post.id,
      type: post.type,
      explicitLevel: post.explicitLevel,
      hasImage: !!post.imageUrl,
      mentions: (post.referencedEmployees || []).length,
      location: post.location,
      timestamp: new Date(post.timestamp).toLocaleTimeString()
    });
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📤 [POST CREATION PIPELINE] STEP 5: Publish to Feed');
    console.log('───────────────────────────────────────────────────────');
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    console.log('[POST CREATION] ✅ Post added to feed (position: 0)');
    console.log(`[POST CREATION] Total posts in feed: ${gameState.socialNetwork.posts.length}`);
    
    // Analyze post for public knowledge
    setTimeout(() => {
      analyzePostForPublicKnowledge(post);
    }, 2000); // Slight delay to let engagement start
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
      console.log('[POST CREATION] Dashboard refreshed');
    }
    
    console.log('───────────────────────────────────────────────────────');
    console.log('🧠 [POST CREATION PIPELINE] STEP 6: Update NPC Awareness');
    console.log('───────────────────────────────────────────────────────');
    
    // Store in all employees' awareness - they can see the player's posts
    const imageNote = imageUrl ? ' with image' : '';
    const postSummary = `The boss posted${imageNote}: "${caption}"`;
    let awareEmployees = 0;
    for (const emp of gameState.employees) {
      if (emp.employmentStatus === 'active') {
        remember(emp, postSummary, 'event', 1.5);
        awareEmployees++;
      }
    }
    console.log(`[POST CREATION] Updated memory for ${awareEmployees} active employees`);
    
    console.log('───────────────────────────────────────────────────────');
    console.log('💬 [POST CREATION PIPELINE] STEP 7: Trigger NPC Reactions');
    console.log('───────────────────────────────────────────────────────');
    
    const reactionDelay = 3000 + Math.random() * 5000;
    console.log(`[POST CREATION] NPC reactions will trigger in ${(reactionDelay/1000).toFixed(1)}s`);
    
    // Trigger automatic NPC reactions (delayed slightly for realism)
    setTimeout(() => {
      console.log('[POST CREATION] 🎬 Triggering NPC reactions now...');
      triggerAutomaticNPCReactions(post);
    }, reactionDelay); // 3-8 seconds
    
    console.log('═══════════════════════════════════════════════════════');
    console.log('✅ [POST CREATION PIPELINE] COMPLETE');
    console.log('═══════════════════════════════════════════════════════\n');
    
    // Close modal
    closePlayerPostModal();
    
    // Switch to social tab if not already there
    if (gameState.activeTab !== 'social') {
      switchTab('social');
    } else {
      // Just refresh feed
      renderSocialFeed();
    }
    
    // Show success message
    const feedHeader = document.querySelector('#socialTab h2');
    if (feedHeader) {
      const successMsg = document.createElement('div');
      successMsg.style.cssText = 'position:fixed; top:80px; right:20px; background:#00d4ff; color:#0f1419; padding:12px 20px; border-radius:8px; font-weight:600; box-shadow:0 4px 12px rgba(0,212,255,0.4); z-index:9999;';
      successMsg.textContent = '✓ Post published!';
      document.body.appendChild(successMsg);
      
      setTimeout(() => successMsg.remove(), 3000);
    }
  }
  
  /**
   * Generate a test post
   */
  function generateTestPost() {
    // Pick random employee or player
    const isPlayerPost = Math.random() < 0.3;
    
    let authorId, authorName;
    if (isPlayerPost) {
      authorId = 'player';
      authorName = 'You';
    } else {
      const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
      if (activeEmployees.length === 0) {
        alert('No employees to post! Hire someone first.');
        return;
      }
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      authorId = emp.id;
      authorName = emp.name;
    }
    
    // Random post types
    const types = ['text', 'work', 'selfie', 'meme', 'life_update'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random content
    const textContents = [
      "Just finished a great meeting! 💼",
      "Coffee break vibes ☕✨",
      "Feeling productive today! 🚀",
      "Anyone else excited for the weekend? 🎉",
      "New project, who dis? 👀",
      "Office life got me like... 😅",
      "Team lunch was amazing! 🍕",
      "Crushing these deadlines! 💪",
      "Best coworkers ever! ❤️",
      "Friday feeling! 🎊"
    ];
    
    const content = textContents[Math.floor(Math.random() * textContents.length)];
    
    // Random explicit level (mostly safe)
    const explicitLevel = Math.random() < 0.8 ? 0 : (Math.random() < 0.7 ? 1 : 2);
    
    // Create post
    const post = createPost({
      authorId,
      authorName,
      type,
      content,
      imageUrl: null,
      imageAlt: '',
      explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost
    });
    
    // Add some random likes (20-70% chance per employee)
    const allEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    allEmployees.forEach(emp => {
      if (Math.random() < 0.4 && emp.id !== authorId) {
        post.likes.push(emp.id);
      }
    });
    
    // Add some random comments (10% chance per employee)
    const commentTexts = [
      "Love this! 😍",
      "So true!",
      "Haha same here!",
      "Amazing! 🔥",
      "Can't wait!",
      "You're the best!",
      "This made my day!",
      "Absolutely!",
      "👍👍👍",
      "Facts! 💯"
    ];
    
    allEmployees.forEach(emp => {
      if (Math.random() < 0.15 && emp.id !== authorId) {
        const commentText = commentTexts[Math.floor(Math.random() * commentTexts.length)];
        const comment = createComment({
          postId: post.id,
          authorId: emp.id,
          authorName: emp.name,
          content: commentText
        });
        post.comments.push(comment);
      }
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Refresh feed
    renderSocialFeed();
  }
  
  // ========== AUTONOMOUS POST GENERATION SYSTEM ==========
  
  /**
   * Main autonomous post generation loop
   * Called from gameTick to continuously generate posts
   */
  async function autonomousPostGeneration() {
    // Early return if social features not initialized
    if (!gameState.socialNetwork || !gameState.employees) return;
    
    // Check if enough time has passed since last generation
    const now = Date.now();
    const timeSinceLastPost = now - (gameState.socialNetwork.lastPostGeneration || 0);
    
    // MASSIVELY INCREASED FREQUENCY: 1-3 minutes between posts (was 4-6 min)
    // With 28 employees, this means 20-60 posts per hour instead of 10-15
    const baseInterval = 90000 + Math.random() * 150000; // 1.5-4 min

    if (timeSinceLastPost < baseInterval) return;
    
    // Must have at least 1 employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Update last generation time
    gameState.socialNetwork.lastPostGeneration = now;
    
    // More posts per batch with larger teams (was 1-2, now 1-3)
    const postCount = Math.min(3, Math.floor(1 + activeEmployees.length / 6));
    
    // Generate posts
    for (let i = 0; i < postCount; i++) {
      try {
        await generateEmployeePost();
      } catch (err) {
        console.error('Error generating employee post:', err);
      }
      
      // Small delay between posts for realism
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Also generate autonomous comments and likes on recent posts
    try {
      await generateAutonomousComments();
      await generateAutonomousLikes();
    } catch (err) {
      console.error('Error generating autonomous interactions:', err);
    }
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
  }
  
  /**
   * Check if content is too similar to recent posts by the same author
   * Uses simple keyword overlap and phrase matching
   * IMPROVED: Less aggressive to allow natural topic variations
   */
  function isContentTooSimilar(content, authorId, maxRecentPosts = 5) {
    if (!content) return false;
    
    // Get recent posts by this author
    const authorPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === authorId)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, maxRecentPosts);
    
    if (authorPosts.length === 0) return false;
    
    // Normalize content for comparison
    const normalizeText = (text) => {
      if (!text || typeof text !== 'string') return [];
      return text.toLowerCase()
        .replace(/[^\w\s]/g, '') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 3); // Only words longer than 3 chars
    };
    
    const newWords = normalizeText(content);
    
    // Check each recent post
    for (const post of authorPosts) {
      // Skip if post has no content
      if (!post.content || typeof post.content !== 'string') continue;
      
      const existingWords = normalizeText(post.content);
      
      // Calculate word overlap (INCREASED THRESHOLD: 70% instead of 50%)
      const commonWords = newWords.filter(word => existingWords.includes(word));
      const overlapRatio = commonWords.length / Math.min(newWords.length, existingWords.length);
      
      // If more than 70% overlap, consider it too similar (was 50%)
      if (overlapRatio > 0.7) {
        console.log(`Content similarity detected: ${Math.round(overlapRatio * 100)}% overlap with recent post`);
        return true;
      }
      
      // Check for exact phrase repetition (IMPROVED: 5+ word sequences instead of 3+)
      // This allows common phrases like "weirdest chat with" to pass through
      const newText = content.toLowerCase();
      const existingText = post.content.toLowerCase();
      for (let i = 0; i < newWords.length - 4; i++) { // Changed from -2 to -4 (5 words instead of 3)
        const phrase = newWords.slice(i, i + 5).join(' '); // Changed from 3 to 5
        // Also increased minimum phrase length from 15 to 25 characters
        if (phrase.length > 25 && existingText.includes(phrase)) {
          console.log(`Duplicate phrase detected: "${phrase}"`);
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Generate a single post from a random employee
   */
  async function generateEmployeePost() {
    // Select random active employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    const author = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
    
    // Get employee context (pass ID, not object)
    const context = getEmployeeAwarenessForPost(author.id);
    
    // Safety check - if context is null, skip this post
    if (!context) {
      console.error('Failed to get context for employee:', author.name);
      return;
    }
    
    // Determine post type based on personality and recent activity
    const postType = selectPostType(author, context);
    
    // Check if this is an event-triggered post
    const recentEvents = getRelevantEvents(author.id, 3);
    const shouldReactToEvent = recentEvents.length > 0 && Math.random() < 0.4;
    
    let postContent, imagePrompt, imageUrl, explicitLevel, tags;
    
    if (shouldReactToEvent) {
      // Event-triggered post
      const event = recentEvents[0];
      const reaction = await generateEventReaction(author, event, context);
      
      // Safety check - if reaction generation failed, fall back to organic post
      if (!reaction) {
        console.warn('Event reaction generation failed, falling back to organic post');
        const generated = await generateOrganicPost(author, postType, context);
        postContent = generated.content;
        imagePrompt = generated.imagePrompt;
        explicitLevel = generated.explicitLevel;
        tags = generated.tags || [];
      } else {
        postContent = reaction.content;
        imagePrompt = reaction.imagePrompt;
        explicitLevel = reaction.explicitLevel;
        tags = reaction.tags || [];
      }
    } else {
      // Organic post based on personality
      const generated = await generateOrganicPost(author, postType, context);
      postContent = generated.content;
      imagePrompt = generated.imagePrompt;
      explicitLevel = generated.explicitLevel;
      tags = generated.tags || [];
    }
    
    // Safety check: Ensure postContent is valid
    if (!postContent || typeof postContent !== 'string') {
      console.warn(`Invalid post content generated for ${author.name}, skipping post`);
      return null;
    }
    
    // Check for content similarity with recent posts
    if (isContentTooSimilar(postContent, author.id)) {
      console.log(`Skipping similar post from ${author.name}, will try again later`);
      return null; // Skip this post, will generate a different one next time
    }
    
    // Generate image if needed
    if (imagePrompt && ['selfie', 'meme', 'thirst_trap', 'explicit', 'food', 'travel', 'life_update'].includes(postType)) {
      try {
        imageUrl = await generateImage(applyImageStyle(imagePrompt));
      } catch (error) {
        console.error('Image generation failed:', error);
        imageUrl = null;
      }
    }
    
    // Create post
    const post = createPost({
      authorId: author.id,
      authorName: author.name,
      type: postType,
      content: postContent,
      imageUrl: imageUrl || null,
      imageAlt: imagePrompt || '',
      explicitLevel: explicitLevel,
      tags: tags,
      location: author.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Track topic to avoid duplicates (AI Optimization)
    trackPostTopic(postContent);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Store post in employee memory - ONLY interesting/impactful posts
    const isInterestingPost = 
      explicitLevel >= 2 || // Explicit/revealing content
      ['hookup', 'masturbation', 'nudes', 'sexting', 'moneyshot', 'morning_after', 
       'explicit', 'thirst_trap', 'tea_spilling', 'gossip'].includes(postType) ||
      postContent.includes('@TheBoss') || // Mentions boss
      postContent.includes('@'); // Mentions another employee
    
    if (isInterestingPost) {
      const imageNote = imageUrl ? ' with image' : '';
      remember(author, `I posted${imageNote}: "${postContent}"`, 'event', 2.0);
    }
    
    // Track post type for variety
    gameState.socialNetwork.recentPostTypes.push(postType);
    if (gameState.socialNetwork.recentPostTypes.length > 20) {
      gameState.socialNetwork.recentPostTypes.shift();
    }
    
    // Trigger targeted comments for tea_spilling posts
    if (postType === 'tea_spilling') {
      setTimeout(() => {
        triggerTeaSpillingComments(post, author);
      }, 3000 + Math.random() * 5000); // 3-8 seconds delay
    }
    
    // Log event
    logCompanyEvent('post_created', {
      authorId: author.id,
      authorName: author.name,
      postType: postType,
      explicitLevel: explicitLevel
    });
    
    return post;
  }
  
  /**
   * Select post type based on employee personality
   */
  function selectPostType(employee, context) {
    const social = employee.social;
    if (!social) return 'text';
    
    // Get recent post types to ensure variety
    const recentTypes = gameState.socialNetwork.recentPostTypes || [];
    
    // EXPANDED post type weights - MASSIVELY BOOSTED FOR EXPLICIT/SEXY CONTENT
    // Target: 60%+ Visual/Sexy (especially with high relationships), 20% Mood/Personal, 12% Social, 5% Work, 3% Mundane
    const prefs = social.contentPreferences || {};
    const weights = {
      // ===== VISUAL/SEXY CONTENT (60%+ of posts) - MASSIVELY BOOSTED =====
      selfie: prefs.selfies ? Math.round(prefs.selfies * 60) : 50,          // Was 35
      thirst_trap: prefs.thirstTraps ? Math.round(prefs.thirstTraps * 60) : 60,  // Was 40
      explicit: prefs.explicitContent ? Math.round(prefs.explicitContent * 60) : 55,  // Was 35
      fashion: 35,  // Was 20 - sexy outfit posts
      
      // NEW PORNOGRAPHIC EXPLICIT TYPES (part of 60% Visual/Sexy) - ALL BOOSTED
      hookup: 50,        // Was 30 - Posts about having sex with someone
      masturbation: 45,  // Was 25 - Posts about solo play
      nudes: 48,         // Was 28 - Sending/receiving/posting nude photos
      sexting: 40,       // Was 22 - Flirty/explicit text exchanges
      moneyshot: 35,     // Was 18 - Ejaculation/finish content (most explicit)
      morning_after: 38, // Was 20 - Post-sex glow, pillow talk vibes
      
      // ===== MOOD/PERSONAL (20% total) - SLIGHTLY REDUCED =====
      mood: 18,          // Was 20
      life_update: 12,   // Was 15
      random: 10,        // Was 12
      inspiration: 6,    // Was 8
      
      // ===== SOCIAL/INTERACTIVE (12% total) - REDUCED =====
      text: 10,          // Was 14
      question: 8,       // Was 12
      gossip: 10,        // Was 12
      tea_spilling: 10,  // Was 12
      entertainment: 8,  // Was 10
      
      // ===== WORK/ACHIEVEMENT (5% total) - HEAVILY REDUCED =====
      work: prefs.workPosts ? Math.round(prefs.workPosts * 30) : 4,  // Was 6
      achievement: 4,    // Was 6
      fitness: 5,        // Was 7
      hobby: 5,          // Was 7
      
      // ===== MUNDANE (3% total) - MINIMAL =====
      food: 2,           // Was 4
      travel: 3,         // Was 5
      pet: 2,            // Was 4
      throwback: 2,      // Was 3
      complaint: 3,      // Was 4
      weather: 1,        // Was 2
      meme: 3            // Was 5
    };
    
    // Boost certain post types if there's recent chat context
    if (context.chatContext?.hasRecentChat) {
      const themes = context.chatContext.themes || [];
      
      // If conversation was flirty, boost suggestive AND PORNOGRAPHIC post types
      // REDUCED bonuses to make explicit content more autonomous (not boss-dependent)
      if (themes.includes('flirty/romantic')) {
        weights.text += 8;        // Reduced from 15
        weights.selfie += 10;     // Reduced from 20
        weights.thirst_trap += 12; // Reduced from 25
        weights.mood += 5;        // Reduced from 10
        weights.sexting += 10;    // Reduced from 20
        weights.nudes += 8;       // Reduced from 15
        if (employee.intimacy > 40) { // Lowered from 60 - more autonomous
          weights.explicit += 10;      // Reduced from 20
          weights.hookup += 12;        // Reduced from 25
          weights.masturbation += 9;   // Reduced from 18
          weights.morning_after += 8;  // Reduced from 15
        }
        if (employee.intimacy > 70) { // Lowered from 80
          weights.moneyshot += 10;  // Reduced from 20
        }
      }
      
      // If conversation was work-related, slightly boost work posts
      if (themes.includes('work-related')) {
        weights.work += 10;
        weights.text += 5;
        weights.achievement += 8;
      }
      
      // If conversation was emotional/personal, boost personal content
      if (themes.includes('emotional/personal')) {
        weights.text += 15;
        weights.life_update += 10;
        weights.mood += 12;
        weights.inspiration += 8;
        weights.morning_after += 5;  // Reduced from 10 - less boss-dependent
      }
      
      // If conversation was about food/social, boost related content
      if (themes.includes('food/social')) {
        weights.food += 15;
        weights.life_update += 10;
      }
    }
    
    // Reduce weights for recently used types (variety) - LESS AGGRESSIVE for sexy content
    Object.keys(weights).forEach(type => {
      const recentUseCount = recentTypes.filter(t => t === type).length;
      
      // Sexy content gets SMALLER penalty to maintain high frequency
      const isSexyContent = ['selfie', 'thirst_trap', 'explicit', 'hookup', 'masturbation', 
                            'nudes', 'sexting', 'moneyshot', 'morning_after', 'fashion'].includes(type);
      
      const penalty = isSexyContent ? 3 : 8; // Sexy: -3 per use, Others: -8 per use
      weights[type] = Math.max(1, weights[type] - (recentUseCount * penalty));
    });
    
    // Apply personality modifiers
    const personality = employee.personality || {};
    if (personality.outgoing > 70) {
      weights.selfie += 15;
      weights.life_update += 10;
      weights.question += 10;
      weights.hookup += 12;        // NEW - Outgoing = more social sex
      weights.morning_after += 10; // NEW
    }
    if (personality.professional > 70) {
      weights.work += 20;
      weights.achievement += 10;
      weights.inspiration += 8;
      // Reduce ALL explicit types for professional employees
      weights.explicit -= 10;
      weights.hookup -= 15;
      weights.masturbation -= 12;
      weights.nudes -= 10;
      weights.sexting -= 8;
      weights.moneyshot -= 20;
    }
    if (personality.flirty > 70) {
      weights.thirst_trap += 20;
      weights.selfie += 10;
      weights.mood += 5;
      weights.fashion += 8;
      weights.sexting += 15;       // NEW - Flirty = more sexting
      weights.nudes += 12;         // NEW
      weights.explicit += 10;
      // AUTONOMOUS BOOST: Flirty personalities post sexy content on their own
      weights.hookup += 10;        // Not boss-dependent
      weights.masturbation += 8;   // Self-initiated
    }
    
    // NEW: Confidence affects boldness of posts
    if (personality.confidence > 70) {
      weights.selfie += 10;
      weights.achievement += 12;
      weights.question += 5;
      weights.nudes += 15;         // NEW - Confident = not shy about nudes
      weights.thirst_trap += 12;
      weights.explicit += 10;
      // AUTONOMOUS BOOST: Confident people express sexuality freely
      weights.masturbation += 10;  // Self-expression
      weights.hookup += 8;         // Confident about sharing
    } else if (personality.confidence < 40) {
      weights.mood += 10;
      weights.random += 8;
      weights.complaint += 5;
      // Reduce explicit types for shy employees
      weights.nudes -= 10;
      weights.hookup -= 8;
      weights.moneyshot -= 15;
    }
    
    // NEW: Boost gossip if employee knows juicy gossip!
    initializeGossipSystem(employee);
    const knownGossip = getKnownGossip(employee.id, 1);
    if (knownGossip.length > 0) {
      const gossipJuiciness = knownGossip[0].juiciness || 50;
      const gossipBoost = Math.floor(gossipJuiciness / 5); // Up to +20 for very juicy gossip
      
      weights.gossip += gossipBoost;
      weights.tea_spilling += gossipBoost;
      
      // Super juicy gossip (80+) makes tea_spilling more likely
      if (gossipJuiciness >= 80) {
        weights.tea_spilling += 20;
      }
      
      // Gossipy people post gossip more
      if (employee.gossip.gossipTendency > 60) {
        weights.gossip += 15;
        weights.tea_spilling += 10;
      }
      
      // Bold/confident people more likely to spill tea directly
      if (personality.confidence > 65) {
        weights.tea_spilling += 15;
      }
    } else {
      // No gossip to share, reduce weight
      weights.gossip = 1;
      weights.tea_spilling = 1;
    }
    
    // NEW: Stats-based modifiers for explicit content - MASSIVELY BOOSTED
    const stats = employee.stats || {};
    const desire = stats.desire ?? 50;
    const obedience = stats.obedience ?? 50;
    const comfort = stats.comfort ?? 50;
    const affectionStat = stats.affection ?? 50;
    
    // MAXED RELATIONSHIPS = CONSTANT SEXY CONTENT
    // If ALL stats are high (80+), this employee should post explicit content VERY frequently
    const isMaxedRelationship = desire >= 80 && comfort >= 80 && affectionStat >= 80;
    
    if (isMaxedRelationship) {
      // NUCLEAR BOOST for maxed relationships - 43%+ of their posts should be sexy
      weights.explicit += 80;         // MASSIVE boost
      weights.thirst_trap += 70;      // MASSIVE boost
      weights.hookup += 85;           // MASSIVE boost
      weights.sexting += 65;          // MASSIVE boost
      weights.masturbation += 75;     // MASSIVE boost
      weights.nudes += 80;            // MASSIVE boost
      weights.morning_after += 60;    // MASSIVE boost
      weights.moneyshot += 70;        // MASSIVE boost
      weights.selfie += 50;           // Also boost sexy selfies
      weights.fashion += 40;          // Sexy outfits
      
      // REDUCE mundane content for maxed relationships
      weights.work = Math.max(2, weights.work - 30);
      weights.complaint = Math.max(1, weights.complaint - 20);
      weights.weather = Math.max(1, weights.weather - 15);
      weights.food = Math.max(3, weights.food - 15);
      weights.pet = Math.max(1, weights.pet - 10);
    } else if (desire > 70 || affectionStat > 70 || comfort > 70) {
      // High stats but not maxed - still significant boost
      weights.explicit += 30;
      weights.thirst_trap += 25;
      weights.hookup += 35;
      weights.sexting += 25;
      weights.masturbation += 30;
      weights.nudes += 28;
      weights.morning_after += 20;
      if (desire > 75) weights.moneyshot += 25;
    } else if (desire > 50 || affectionStat > 50) {
      // Moderate stats - smaller boost
      weights.explicit += 12;
      weights.thirst_trap += 10;
      weights.hookup += 15;
      weights.sexting += 10;
      weights.masturbation += 12;
    }
    
    // High obedience + high desire = very explicit content
    if (obedience > 70 && desire > 70) {
      weights.moneyshot += 25;  // Most explicit tier
      weights.nudes += 18;
      weights.hookup += 15;
    }
    
    // High comfort = more open about sex life
    if (comfort > 70) {
      weights.hookup += 12;
      weights.morning_after += 15;
      weights.explicit += 10;
    }
    
    // NEW: Add time-of-day bonuses for realism
    const hour = new Date().getHours();
    if (hour >= 6 && hour < 9) {
      // Morning posts
      weights.mood += 8;
      weights.fitness += 10;
      weights.food += 5; // Coffee/breakfast
      weights.morning_after += 12; // Post-sex morning posts
    } else if (hour >= 9 && hour < 17) {
      // Work hours
      weights.work += 12;
      weights.complaint += 5;
      weights.food += 5; // Lunch
      weights.sexting += 8; // Bored at work = sexting
    } else if (hour >= 17 && hour < 22) {
      // Evening
      weights.life_update += 10;
      weights.entertainment += 10;
      weights.food += 8; // Dinner/drinks
      weights.hookup += 15; // Evening hookups
      weights.thirst_trap += 10; // Getting ready to go out
    } else {
      // Late night (11pm-6am)
      weights.mood += 10;
      weights.random += 8;
      weights.throwback += 8;
      weights.explicit += 15;      // Late night horniness
      weights.masturbation += 20;  // Solo late night fun
      weights.sexting += 12;       // Late night texting
      weights.nudes += 15;         // Late night photo sharing
    }
    
    // Apply company policy modifiers
    const policy = gameState.settings.consentModel || 'casual';
    if (policy === 'professional') {
      // Reduce all explicit content for professional policy
      weights.explicit = Math.max(1, weights.explicit - 15);
      weights.thirst_trap = Math.max(5, weights.thirst_trap - 8);
      weights.hookup = Math.max(1, weights.hookup - 20);
      weights.masturbation = Math.max(1, weights.masturbation - 18);
      weights.nudes = Math.max(1, weights.nudes - 15);
      weights.sexting = Math.max(1, weights.sexting - 12);
      weights.moneyshot = Math.max(1, weights.moneyshot - 25);
      weights.morning_after = Math.max(1, weights.morning_after - 10);
    } else if (policy === 'open') {
      // Boost all explicit content for open policy
      weights.thirst_trap += 15;
      weights.explicit += 15;
      weights.hookup += 20;
      weights.masturbation += 15;
      weights.nudes += 18;
      weights.sexting += 12;
      weights.moneyshot += 10;
      weights.morning_after += 12;
    }
    
    // Weighted random selection
    const totalWeight = Object.values(weights).reduce((sum, w) => sum + Math.max(0, w), 0);
    let random = Math.random() * totalWeight;
    
    for (const [type, weight] of Object.entries(weights)) {
      random -= Math.max(0, weight);
      if (random <= 0) return type;
    }
    
    return 'text'; // Fallback
  }
  
  /**
   * Generate event reaction post using AI
   */
  async function generateEventReaction(employee, event, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Safety check for event structure
    if (!event || !event.type) {
      console.warn('Invalid event structure in generateEventReaction:', event);
      return null;
    }
    
    // Build context for AI
    // Events have properties directly on them (description, involvedEmployees, etc.)
    const eventDescription = (() => {
      switch (event.type) {
        case 'hire': 
          // Extract name from description
          const hireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${hireName} just joined the company`;
        case 'fire': 
          const fireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${fireName} left the company`;
        case 'promotion': 
          const promoName = event.description ? event.description.split(' ')[0] : 'someone';
          const newRole = event.description ? event.description.match(/as (.+)/)?.[1] || 'a new role' : 'a new role';
          return `${promoName} got promoted to ${newRole}`;
        case 'chat': 
          return `Had a ${event.sentiment || 'interesting'} chat with a coworker`;
        case 'gift': 
          return `Received a gift`;
        case 'achievement': 
          return `Reached a milestone: ${event.description || 'an achievement'}`;
        default: 
          return event.description || 'Something happened at work';
      }
    })();
    
    // NATURAL LANGUAGE personality description
    const personalityDescParts = [
      personalityToText(personality.outgoing || 50, 'outgoing'),
      personalityToText(personality.professional || 50, 'professional'),
      personalityToText(personality.flirty || 50, 'flirty')
    ];
    const personalityDesc = `${employee.name} is ${personalityDescParts.join(', ')}`;
    
    const relationshipContext = (context.coworkers || []).slice(0, 3).map(c => 
      `${c.coworkerName} (${c.relationship})`
    ).join(', ');
    
    // Get player/boss description for relevant events
    const playerDesc = getPlayerDescription('post');
    const bossContextNote = (event.type === 'chat' || event.type === 'gift' || event.type === 'promotion') && playerDesc !== 'the boss'
      ? `\nYour boss: ${playerDesc}`
      : '';
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, an employee posting on an uncensored social media about a recent event.

Event: ${eventDescription}
Your personality: ${personalityDesc}
Your coworkers: ${relationshipContext}
Location: ${employee.location || 'office'}${bossContextNote}

Write a SHORT (1-3 sentences) social media post reacting to this event. Be authentic to the personality. Use emojis sparingly (0-2). Be conversational and natural.

${social.contentStyle === 'casual' ? 'Style: Casual and relaxed' : social.contentStyle === 'professional' ? 'Style: Professional but friendly' : 'Style: Balanced between casual and professional'}

Post only:`;

    try {
      const content = await generateText(prompt, {
        temperature: 0.9,
        max_tokens: 50,
        stopSequences: ['\n\n', 'Rating:', '**Rating', '---', 'Why:', 'The stapler', 'The ', '{SEEDS', '{BAN', '{BOOST']
      });
      
      // Clean Perchance tokens and meta-commentary
      let cleanContent = content;
      cleanContent = cleanContent.replace(/\{SEEDS:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{BAN:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{BOOST:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');
      cleanContent = cleanContent.trim();
      
      // Determine explicit level
      let explicitLevel = 0;
      if (event.type === 'chat' && event.sentiment === 'flirty') {
        explicitLevel = Math.min(2, Math.floor(personality.flirty / 40));
      }
      
      // Determine if image should be generated
      let imagePrompt = null;
      if (event.type === 'promotion' && Math.random() < 0.6) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Professional celebration selfie: ${physDesc} smiling, office setting, happy expression, high quality`;
      } else if (event.type === 'achievement' && Math.random() < 0.5) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Excited celebration photo: ${physDesc} celebrating achievement, office environment, triumphant pose, high quality`;
      }
      
      return {
        content: cleanContent,
        imagePrompt,
        explicitLevel,
        tags: [event.type]
      };
    } catch (error) {
      console.error('AI generation failed:', error);
      // Fallback to template
      return {
        content: `${eventDescription}! 🎉`,
        imagePrompt: null,
        explicitLevel: 0,
        tags: [event.type]
      };
    }
  }
  
  /**
   * Convert numeric personality value to natural language descriptor
   */
  function personalityToText(value, traitName) {
    if (value >= 85) return `extremely ${traitName}`;
    if (value >= 70) return `very ${traitName}`;
    if (value >= 55) return `quite ${traitName}`;
    if (value >= 40) return `moderately ${traitName}`;
    if (value >= 25) return `somewhat ${traitName}`;
    return `not very ${traitName}`;
  }

  /**
   * Generate organic post using AI
   */
  async function generateOrganicPost(employee, postType, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Build rich context with NATURAL LANGUAGE personality description
    const personalityDesc = [
      personalityToText(personality.outgoing || 50, 'outgoing'),
      personalityToText(personality.professional || 50, 'professional'),
      personalityToText(personality.flirty || 50, 'flirty'),
      personalityToText(personality.confidence || 50, 'confident'),
      personalityToText(personality.humor || 50, 'humorous')
    ].join(', ');
    
    // Get people you know with their usernames for potential mentions
    const peopleWithUsernames = (context.coworkers || []).slice(0, 5).map(c => {
      const person = gameState.employees.find(e => e.id === c.coworkerId);
      const username = person?.social?.username || null;
      return {
        name: c.coworkerName,
        username: username,
        relationship: c.relationship,
        knownFor: c.knownFor || 'friend'
      };
    });
    
    const relationshipContext = peopleWithUsernames.map(c => 
      c.username 
        ? `${c.name} (@${c.username}) - ${c.relationship}, ${c.knownFor}` 
        : `${c.name} - ${c.relationship}, ${c.knownFor}`
    ).join(', ') || 'new to the network';
    
    const locationContext = (context.knownLocations || []).join(', ') || 'around town';
    
    // Get boss relationship
    const bossRelationship = employee.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    
    // Randomly decide if this post should mention someone (30% chance for relevant post types)
    const shouldMention = Math.random() < 0.3 && 
                          ['text', 'work', 'life_update', 'food'].includes(postType) &&
                          (peopleWithUsernames.length > 0 && peopleWithUsernames.some(c => c.username));
    
    // Boss mention (lower chance, but increases with relationship)
    const shouldMentionBoss = Math.random() < (0.05 + (affection / 100) * 0.15) && // 5-20% chance based on affection
                              ['text', 'work', 'food', 'life_update'].includes(postType);
    
    const mentionablePeople = peopleWithUsernames.filter(c => c.username);
    let mentionInstruction = '';
    
    if (shouldMentionBoss) {
      const bossTone = intimacy > 60 ? 'warmly and casually' : affection > 50 ? 'appreciatively' : 'casually';
      mentionInstruction = `\n💡 Consider naturally mentioning @TheBoss if relevant. Be ${bossTone}. Examples: "Hanging with @TheBoss was fun!", "Thanks @TheBoss", "@TheBoss really came through". Only mention if it feels natural!`;
    } else if (shouldMention && mentionablePeople.length > 0) {
      const randomPerson = mentionablePeople[Math.floor(Math.random() * mentionablePeople.length)];
      mentionInstruction = `\n💡 Consider naturally mentioning @${randomPerson.username} (${randomPerson.name}) if relevant to your post. Examples: "Coffee with @${randomPerson.username} hit different today", "Thanks @${randomPerson.username}!", "Hanging with @${randomPerson.username}". Only mention if it feels natural - don't force it!`;
    }
    
    // Post type specific instructions - MASSIVELY EXPANDED
    const typeInstructions = {
      // Original types (enhanced)
      text: 'Write a casual status update about your day, thoughts, or feelings. Be authentic and varied. Topics: how you\'re feeling, observations, random thoughts, what you\'re doing. 1-2 sentences. Examples: "Why does Monday exist 😩", "Feeling like a main character today ✨", "That moment when you realize it\'s only Tuesday", "Honestly just vibing", "Send coffee or leave me alone ☕"',
      
      work: 'Write about your job/projects BUT make it relatable and interesting. NOT just "meetings". Topics: cool project wins, funny moments, learning something new, frustrations, accomplishments. 1-2 sentences. Examples: "Actually proud of what I made today 🚀", "When everything works on the first try 🎉", "Been at this since 9am send help 💀", "That feeling when you solve a tough problem", "Living my best productive life"',
      
      selfie: 'Write a SHORT caption for a selfie. Show personality - NOT generic "feeling cute". Topics: your mood, confidence, what you\'re doing, where you are, or just pure vibe. Max 15 words. Examples: "Main character energy 💫", "No thoughts, just vibes", "Serving looks and chaos", "That post-workout glow though", "Unapologetically me", "Caught in the act of existing"',
      
      meme: 'Write a humorous, relatable caption. Reference real life, pop culture, common experiences. Be funny and current. 1 sentence. Examples: "Me: *buys coffee* / My bank account: 👁️👄👁️", "POV: You said you\'d be productive today 💀", "Everyone else: weekend plans / Me:", "Not me stress eating again 😅", "When they ask if I\'m okay: *insert image of everything on fire*"',
      
      life_update: 'Share a genuine personal life update - hobbies, weekend, personal news, life moments. Be specific and interesting. 1-2 sentences. Examples: "Finally finished that book I\'ve been reading for 6 months 📚", "Learned a new recipe and didn\'t burn the kitchen down 🎉", "Adopting a plant parent lifestyle, wish me luck 🌱", "Started binging a new show and can\'t stop 📺"',
      
      thirst_trap: `Write a CONFIDENT, FLIRTY caption for a revealing/attractive photo. Be bold, suggestive, playful. ${personality.flirty > 60 ? 'Be explicitly flirtatious' : 'Be subtly seductive'}. Reference confidence, your look, or energy. Max 10 words. Examples: "Confidence looks good on me 😏", "You\'re welcome 💋", "Just thinking out loud 🤔🔥", "Felt cute, felt powerful", "No caption needed 👀", "Making Monday better", "Dangerous mood today"`,
      
      explicit: `Write a SEXUALLY BOLD caption for explicit content. Be provocative and unapologetic. ${personality.flirty > 70 ? 'Be very direct' : 'Use suggestive language'}. Max 12 words. Examples: "After hours 🔥", "Private show 💦", "What you don't usually see 😈", "Special delivery", "No rules tonight", "Taking requests 👀", "Feeling dangerous", "Handle with care"`,
      
      travel: 'Post about travel, places, or wanting to travel. Show excitement or wanderlust. 1 sentence. Examples: "Daydreaming about beaches and zero responsibilities 🏖️", "Next vacation can\'t come soon enough", "That travel bug hitting different lately ✈️", "Exploring local spots hits different 🗺️"',
      
      food: 'Post about food, drinks, or cravings with enthusiasm. Be specific or playful. 1 sentence. Examples: "This coffee is single-handedly keeping me alive ☕", "Taco Tuesday is the only thing I believe in 🌮", "Why does food taste better when someone else makes it 🍕", "Currently accepting dinner recommendations", "That post-meal satisfaction 😌"',
      
      // NEW expanded types for variety
      fitness: 'Post about workout, gym, health, or physical activity. Show effort, results, or motivation. 1-2 sentences. Examples: "That post-workout high hits different 💪", "Gym session: crushed / My legs: destroyed", "Actually showed up today, proud of myself 🏋️", "Running on endorphins and stubbornness", "Started my fitness journey, we\'ll see how this goes 🏃"',
      
      hobby: `Post about a specific hobby or interest. Be passionate and specific - reference what you DO. Include details. 1-2 sentences. ${employee.hobbies && employee.hobbies.length > 0 ? `Your hobbies: ${employee.hobbies.join(', ')}. Reference one of these!` : ''} Examples: "Finally beat that level I\'ve been stuck on 🎮", "New vinyl just dropped and it\'s 🔥", "Spent the afternoon painting and lost track of time 🎨", "Photography walk was exactly what I needed 📸"`,
      
      entertainment: 'Post about movies, shows, music, books, or pop culture. Share opinions, recommendations, or what you\'re into. 1-2 sentences. Examples: "Just finished that show everyone\'s talking about and WOW 🎬", "This song is living rent-free in my head 🎵", "Reading a book that\'s actually making me think 📖", "Can we talk about that plot twist though 😱", "New album on repeat, absolute fire 🔥"',
      
      mood: 'Pure vibe/feeling post. Express current mood, energy, or emotional state. Be authentic and relatable. 1 sentence. Examples: "Big chaotic energy today 🌪️", "Soft girl hours 🌸", "Feeling myself a little too much today ✨", "Main character syndrome activated", "That unexplainable good mood", "Tired but make it aesthetic 😴", "Existing and thriving", "No thoughts, head empty, vibes immaculate"',
      
      question: 'Ask followers something - opinion, recommendation, this-or-that. Be engaging. 1 sentence with question mark. Examples: "Coffee or tea, and why is coffee the only right answer? ☕", "What\'s a show I NEED to watch right now? 📺", "Hot take: pineapple on pizza is valid. Fight me or agree? 🍕", "Weekend plans or just winging it? 🎉", "What\'s your go-to comfort food when life gets weird? 🍜"',
      
      achievement: 'Share a personal win - small or big. NOT always work (can be life, personal growth, random wins). Show pride. 1-2 sentences. Examples: "Didn\'t hit snooze once this week, I\'m basically unstoppable", "Finally organized my closet and found clothes I forgot existed 🎉", "Made it through the week without a breakdown, new personal record 💪", "Hit a goal I didn\'t think I could reach 🎯", "Small win but it feels big ✨"',
      
      throwback: 'Nostalgic post about a memory, past experience, or "remember when". Be specific and reflective. 1-2 sentences. Examples: "Remember when we all thought 2020 would be our year 💀", "Thinking about that summer where everything just hit different ☀️", "Found old photos and the nostalgia is hitting hard 📸", "Miss the days when my biggest worry was what to eat 🥺", "Throwback to when life was simpler"',
      
      pet: 'Post about pets, animals, or wanting a pet. Show affection or humor. 1 sentence. Examples: "My cat judges every life decision I make and she\'s not wrong 🐱", "Dogs really are too pure for this world 🐕", "That moment when your pet becomes your therapist 💕", "Saw the cutest dog today and it made my whole week", "Considering adopting a pet just for the emotional support"',
      
      fashion: 'Post about outfit, style, clothing, or fashion choices. Show confidence in your look. 1 sentence. Examples: "Serving looks and confidence today 💃", "This outfit said main character and I listened ✨", "When your outfit matches your energy >>", "Feeling this style lately 👗", "Comfortable AND cute, we love to see it"',
      
      complaint: 'Vent about something annoying, frustrating, or relatable. Keep it real and funny. 1-2 sentences. Examples: "Why does everything decide to break at the same time 😩", "Being an adult is just constantly asking wait do I have plans 💀", "My back hurts and I didn\'t even do anything this is 25", "Can life give me a break or is that too much to ask", "Monday can take several seats 💺"',
      
      inspiration: 'Share something motivational, philosophical, or reflective. Be genuine not corporate-cheesy. 1-2 sentences. Examples: "Growth is uncomfortable but staying the same is worse 🌱", "Normalize doing what\'s best for you even if others don\'t get it ✨", "You don\'t have to be perfect just keep showing up 💪", "Small steps still count as progress 🚶", "Be the energy you want to attract"',
      
      weather: 'Comment on weather and how it affects mood or plans. Be relatable. 1 sentence. Examples: "This weather is giving main character energy ☀️", "Rain + cozy vibes = perfect day for doing nothing 🌧️", "Why is it so hot I\'m literally melting 🥵", "Cold weather = excuse to stay in bed all day ❄️", "Perfect weather for absolutely nothing productive"',
      
      random: 'Completely random thought observation or chaotic energy. Be spontaneous and unexpected. 1 sentence. Examples: "Thinking about how penguins have knees and now I can\'t unthink it 🐧", "What if plants are actually farming us 🌱🤔", "The word bed looks like a bed", "Why do we say heads up when we actually mean duck 💀", "Random urge to completely change my life at 2am", "Not all thoughts need to be said but here we are"',
      
      gossip: `Post about gossip/drama you know about. Be VAGUE and MYSTERIOUS but juicy. Use cryptic language or emojis. DON'T name names. 1-2 sentences. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know but DON\'T name names directly - keep it mysterious!' : ''} Examples: "Someone is MESSY and I'm here for it 👀☕", "The tea is piping hot today and I'm observing from a safe distance 🍿", "Not me knowing things I probably shouldn't know 🤐", "Drama >>> any reality TV show 📺", "Just heard something WILD but my lips are sealed... for now 🤫", "Y'all I can't even—things are SPICY lately 🌶️"`,
      
      tea_spilling: `SPILL THE TEA! Post about gossip/drama you know with SPECIFIC NAMES using @mentions. Be DIRECT and call people out, but keep it playful/dramatic not mean. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know and USE NAMES with @ mentions!' : ''} 1-2 sentences max. Examples: "Sooo @sarah and @mike definitely hooked up last night, I'm just saying 👀", "Wait @jessica has been wearing @kevin's hoodie all week? TEA 🍵", "Not @emma posting thirst traps right after her breakup with @alex... we see you queen 💅", "@chris really thought nobody would notice him sneaking out with @amber 😏", "The way @madison looked at @tyler... PLEASE 💕"`
    };
    
    const contentStyleNote = social.contentStyle === 'casual' ? 'Use casual language, contractions, slang' :
                            social.contentStyle === 'professional' ? 'Use professional but friendly tone' :
                            'Use balanced conversational tone';
    
    // Get recent posts by this employee to encourage variety
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === employee.id)
      .slice(0, 3)
      .map(p => p.content)
      .join(' | ');
    
    // Check recent community posts for overused themes
    const recentCommunityPosts = gameState.socialNetwork.posts
      .slice(0, 20)
      .map(p => p.content.toLowerCase());
    
    // EXPANDED theme detection to catch more repetitive patterns
    const overusedThemes = [];
    const themeChecks = [
      // Original checks
      { keywords: ['garage', 'park', 'parking'], theme: 'garage/parking' },
      { keywords: ['keys', 'lost', 'looking for', 'hunting for', 'found'], theme: 'lost items' },
      { keywords: ['reorganiz', 'organiz', 'clean', 'tidy'], theme: 'organization' },
      { keywords: ['server', 'rack', 'cable', 'wifi'], theme: 'IT equipment' },
      
      // NEW expanded checks for common repetitive themes
      { keywords: ['coffee', 'caffeine', 'espresso', 'latte'], theme: 'coffee' },
      { keywords: ['monday', 'mondays'], theme: 'Monday complaints' },
      { keywords: ['weekend', 'friday', 'tgif'], theme: 'weekend vibes' },
      { keywords: ['meeting', 'meetings', 'zoom', 'conference'], theme: 'meetings' },
      { keywords: ['deadline', 'due date', 'crunch'], theme: 'deadlines' },
      { keywords: ['tired', 'exhausted', 'sleep', 'nap'], theme: 'being tired' },
      { keywords: ['vibe', 'vibing', 'vibes'], theme: 'vibe posts' },
      { keywords: ['main character', 'mc energy'], theme: 'main character' },
      { keywords: ['chaos', 'chaotic'], theme: 'chaos energy' },
      { keywords: ['broke', 'money', 'paycheck', 'bank account'], theme: 'money struggles' }
    ];
    
    themeChecks.forEach(check => {
      const matchCount = recentCommunityPosts.filter(post => 
        check.keywords.some(kw => post.includes(kw))
      ).length;
      // More strict: 2+ posts (was 3+) about same theme triggers avoidance
      if (matchCount >= 2) {
        overusedThemes.push(check.theme);
      }
    });
    
    const themeAvoidanceNote = overusedThemes.length > 0 
      ? `\n⚠️ AVOID these overused themes: ${overusedThemes.join(', ')} - pick something completely different!`
      : '';
    
    const varietyNote = recentPosts 
      ? `\nYour recent posts: "${recentPosts}"\n⚠️ Write something DIFFERENT - new topic, different angle, fresh perspective!${themeAvoidanceNote}` 
      : themeAvoidanceNote;
    
    // Build chat context instruction
    let chatContextNote = '';
    if (context.chatContext?.hasRecentChat) {
      const chat = context.chatContext;
      const timeAgoText = chat.timeAgo < 60 ? `${chat.timeAgo} minutes ago` : `${Math.round(chat.timeAgo / 60)} hours ago`;
      const themesText = chat.themes.length > 0 ? chat.themes.join(', ') : 'casual conversation';
      
      // Get last few message previews
      // NOTE: "[truncated]" instead of "..." to avoid AI thinking person trailed off mid-sentence
      const messagePreview = chat.lastMessages
        .map(msg => `${msg.sender}: "${msg.preview}${msg.preview.length >= 100 ? ' [truncated]' : ''}"`)
        .join('\n');
      
      // Check relationship level to determine tone - NATURAL LANGUAGE
      const relationshipTone = intimacy > 60 
        ? '🔥 IMPORTANT: You have a very intimate, consensual relationship with your boss. You genuinely enjoy this dynamic! If posting about intimate conversations or requests, be positive, excited, teasing, or playful.'
        : intimacy > 30
        ? '💕 You have a developing close relationship with your boss. Frame flirty or intimate content positively and teasingly.'
        : affection > 60
        ? '😊 You have good rapport with your boss. Keep posts about interactions positive or playful.'
        : '';
      
      chatContextNote = `\n\n💬 RECENT CHAT WITH BOSS (${timeAgoText}):
Conversation themes: ${themesText}
Last messages:
${messagePreview}

⚠️ NOTE: If you see "..." (ellipses) in messages above, that's just typing style for dramatic effect - NOT the person trailing off incomplete. Don't make posts about "mysterious unfinished sentences" or "what were they going to say?"

${relationshipTone}

💡 OPTIONAL: You could make a post inspired by this conversation! Examples:
- If it was flirty: "Still thinking about that conversation... 😏" or "Feeling some type of way today 🔥"
- If it was about projects: "Excited about this new thing I'm working on!" or "Time to crush it 💪"
- If it was personal: "Good talks hit different" or "Grateful for good listeners"
- Or post about something COMPLETELY DIFFERENT - you don't have to reference the chat!

${chat.themes.includes('flirty/romantic') && ['text', 'selfie', 'thirst_trap'].includes(postType) 
  ? '🔥 Since you had a flirty chat recently, feel free to make a suggestive/spicy post if it feels natural!' 
  : ''}`;
    }
    
    // Build boss request context
    let bossRequestNote = '';
    if (context.requestedByBoss) {
      bossRequestNote = `\n\n🎯 BOSS REQUESTED THIS POST:
The boss specifically asked you to make this post${context.requestContext ? `: "${context.requestContext}"` : ''}.
You've already agreed to do it, so make the post they requested!
Be confident and match the tone they were asking for.
${postType === 'explicit' || postType === 'thirst_trap' ? 'They want something bold and provocative - don\'t hold back!' : ''}`;
    }
    
    // Get player/boss description for context when mentioning
    const playerDesc = getPlayerDescription('post'); // Use 'post' context for social media
    const bossContextNote = playerDesc !== 'the boss' ? `\n\n👤 ABOUT YOUR BOSS:\n${playerDesc}` : '';
    
    // Add gossip context for gossip posts
    let gossipContextNote = '';
    if (postType === 'gossip' || postType === 'tea_spilling') {
      const knownGossip = getKnownGossip(employee.id, 3);
      if (knownGossip.length > 0) {
        const gossipDetails = knownGossip.map(g => {
          const subject = g.subjectId === 'player' ? 'the boss' : 
                        gameState.employees.find(e => e.id === g.subjectId)?.name || 'someone';
          const subjectUsername = g.subjectId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.subjectId)?.social?.username || null;
          const target = g.targetId ? 
                        (g.targetId === 'player' ? 'the boss' : 
                         gameState.employees.find(e => e.id === g.targetId)?.name || 'someone') : '';
          const targetUsername = g.targetId ? 
                                (g.targetId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.targetId)?.social?.username || null) : '';
          const accuracy = g.accuracy < 50 ? ' (might be a rumor)' : 
                          g.accuracy < 80 ? ' (heard through grapevine)' : '';
          
          if (postType === 'tea_spilling' && subjectUsername) {
            // For tea spilling, provide names with usernames
            return `- ${subject} (${subjectUsername})${target ? ` and ${target} (${targetUsername})` : ''}: ${g.content}${accuracy}`;
          } else {
            return `- ${g.content}${accuracy}`;
          }
        }).join('\n');
        
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\n🍵 TEA TO SPILL:
${gossipDetails}

🎯 SPILL IT! Use @usernames to call people out directly! Be dramatic and juicy but playful. Examples:
- "Not @sarah hooking up with @mike in the supply closet 👀"
- "@kevin has been acting SUS around @jessica lately... just saying 🫖"
- "Everyone pretending they don't see @alex and @emma sneaking around 😏"`;
        } else {
          gossipContextNote = `\n\n🫖 GOSSIP YOU KNOW:
${gossipDetails}

⚠️ DON'T name names directly! Keep it mysterious and vague. Hint at the drama without being too specific. Use "someone", "people", "coworkers", etc.`;
        }
      } else {
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\n⚠️ You don't have specific tea right now, so make a teasing post about ALMOST spilling tea or hinting that you know something without details.`;
        } else {
          gossipContextNote = `\n\n⚠️ You don't actually know any specific gossip right now, so make a generic "something's happening" type post or pretend you heard something vague.`;
        }
      }
    }
    
    // Gender and physical description for full self-awareness
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'Male' ? 'man' : employee.gender === 'Trans Man' ? 'trans man' : employee.gender === 'Trans Woman' ? 'trans woman' : employee.gender === 'Female Futa' ? 'woman with unique anatomy' : 'woman'}` : '';
    const physicalDesc = context.employee?.physicalDescription || getPhysicalDescriptionForPrompt(employee);
    
    // === AI QUALITY LEARNING: Add good examples to prompt ===
    let learningExamples = '';
    const goodPosts = gameState.aiQuality?.goodExamples?.posts || [];
    if (goodPosts.length > 0) {
      // Get up to 3 recent good examples
      const examples = goodPosts.slice(0, 3).map(ex => `"${ex.content}"`).join(', ');
      learningExamples = `\n\n✅ QUALITY EXAMPLES (player-approved posts that work well):\n${examples}\n\nUse these as inspiration for quality and style. Match this level of authenticity and readability.`;
    }
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored PERSONAL social media platform (like Instagram/Twitter).

🌐 PLATFORM CONTEXT: This is a PERSONAL social network separate from work - NOT a work chat or Slack channel. While you work together, this is for PERSONAL sharing, fun, and connecting outside of professional boundaries. Think Instagram vibes - casual, personal, sometimes spicy!

YOUR PHYSICAL APPEARANCE: ${physicalDesc}
(You are fully aware of your body, gender, and physical characteristics. Reference them naturally if relevant to your post, especially in selfies or intimate content.)

Your personality: You are ${personalityDesc}.
${buildAIContextFromSkills(employee)}
Post type: ${postType}
People you know: ${relationshipContext}
Style: ${contentStyleNote}${varietyNote}${mentionInstruction}${chatContextNote}${bossRequestNote}${bossContextNote}${gossipContextNote}${learningExamples}

${typeInstructions[postType] || typeInstructions.text}

CRITICAL RULES: 
- Write ONLY the post itself - NO explanations, notes, or meta-commentary
- NO parenthetical notes like "(Note: ...)" or style explanations
- Be SHORT and authentic (1-2 sentences MAX, but NOT single-word posts)
- This is a PERSONAL social network - NOT professional, NOT work chat
- Feel free to be casual, flirty, fun, and expressive
- Hashtags: Use 0-1 hashtags, make them natural and varied (avoid #Garage unless truly relevant)
- Emojis: 0-2 max, use sparingly
- Don't always mention location - posts can be about ANYTHING
- Vary your topics - avoid repetitive scenarios (keys, parking, garage organization)
- Sound like a real person, not AI
- When mentioning people, use their @username format naturally
- NEVER use "caught in mid-[action]" phrases or similar incomplete action descriptions
- Avoid one-word or extremely short posts like "Made it to work" or "Self-care morning"
- Add personality and context - give readers something interesting

Write ONLY the social media post text:`;

    try {
      // Check if AI is available
      if (typeof generateText !== 'function') {
        throw new Error('AI text plugin not available');
      }
      
      let content = await generateText(prompt, {
        temperature: 0.9,
        max_tokens: 80,
        stopSequences: ['\n\n', '{SEEDS', '{BAN', '{BOOST', '---', 'Rating:', '**Rating', 'Rationale:', 'Analysis:', '(Note:', '**(Note', 'Physical description:', 'Selfie Caption:', '**Why']
      });
      
      // CRITICAL FIX: Extract actual string from response
      content = extractText(content);
      
      // AGGRESSIVE meta-commentary removal for posts
      
      // CRITICAL: Remove Perchance formatting tokens that shouldn't appear in output
      // Remove {SEEDS:...} patterns (e.g., "{SEEDS:apiculate|synbio}")
      content = content.replace(/\{SEEDS:[^}]*\}\s*/gi, '');
      // Remove {BAN:...} patterns
      content = content.replace(/\{BAN:[^}]*\}\s*/gi, '');
      // Remove {BOOST:...} patterns
      content = content.replace(/\{BOOST:[^}]*\}\s*/gi, '');
      // Remove any remaining {WHATEVER:...} patterns
      content = content.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');
      
      // Remove bold name headers (e.g., "**Beverly Elliott**" or "**Sophia Harrell**")
      content = content.replace(/^\*\*[^*]+\*\*\s*/g, '');
      
      // Remove "Posted:" prefixes (e.g., "Posted: 3 hours ago")
      content = content.replace(/^Posted:\s*[^\n]+\n\s*/i, '');
      
      // Remove everything after common meta-commentary markers
      content = content.split(/\n\s*\(/)[0]; // Remove "(Note: ...)" style comments
      content = content.split(/\n\s*\*/)[0];  // Remove "*(...)" style comments
      content = content.split(/\(Note:/)[0];  // Remove inline notes
      content = content.split(/\(Character count:/)[0]; // Remove character count analysis
      content = content.split(/\(Emojis used:/)[0]; // Remove emoji analysis
      content = content.split(/\(Approach:/)[0]; // Remove approach analysis
      content = content.split(/\(Style note:/)[0]; // Remove style notes
      content = content.split(/\*\(Balanced/)[0]; // Remove specific patterns
      content = content.split(/\*\(Casual/)[0];
      content = content.split(/\*\(Keeps/)[0];
      content = content.split(/\*\(Style/)[0];
      // Remove trailing analysis markers
      content = content.replace(/\s*\(Tagged coworkers.*?\)$/i, ''); // Remove tagging thoughts
      content = content.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
      content = content.trim();
      
      // AUTO-CONVERT boss mentions to @TheBoss for consistent detection
      // Replace variations: "boss", "the boss", "my boss", "our boss", "Boss"
      content = content.replace(/\b(the\s+)?([Mm]y\s+)?([Oo]ur\s+)?[Bb]oss\b/g, '@TheBoss');
      // Clean up duplicate @ symbols that might result from "the @boss" → "@TheBoss"
      content = content.replace(/@@TheBoss/g, '@TheBoss');
      // Clean up if there was already an @ before: "@boss" → "@TheBoss"
      content = content.replace(/@[Bb]oss\b/g, '@TheBoss');
      
      // === AI QUALITY LEARNING: Apply aggressive cleanup with learned patterns ===
      content = cleanWithLearning(content);
      
      // === POST QUALITY VALIDATION: Reject posts that are too short or generic ===
      const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
      const hasOnlyEmojis = /^[\s\p{Emoji}]+$/u.test(content);
      
      // List of overly generic single-line posts to reject
      const genericPhrases = [
        /^made it to work\.?$/i,
        /^self-care morning\.?$/i,
        /^vibing\.?$/i,
        /^mood\.?$/i,
        /^feeling good\.?$/i,
        /^just chilling\.?$/i,
        /^another day\.?$/i,
        /^here we go\.?$/i,
        /^ready for this\.?$/i
      ];
      
      const isGenericPost = genericPhrases.some(pattern => pattern.test(content.replace(/[✨💭🤔💫⚡☕📅✓😌]/g, '').trim()));
      
      if (wordCount < 3 || hasOnlyEmojis || isGenericPost) {
        console.warn('[AI Quality] Post rejected: too short or generic:', content);
        throw new Error('Generated content too short or generic, using fallback');
      }
      
      // Track mentions for stats
      const mentionedUsernames = [];
      const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
      let match;
      while ((match = mentionRegex.exec(content)) !== null) {
        mentionedUsernames.push(match[1]);
      }
      
      // Update mention counts for mentioned employees (use same smart matching as extractMentions)
      mentionedUsernames.forEach(mentionedUsername => {
        const mentionedEmployee = gameState.employees.find(e => {
          if (!e.social?.username) return false;
          const storedUsername = e.social.username.toLowerCase();
          const mentioned = mentionedUsername.toLowerCase();
          
          // Try multiple matching strategies
          if (storedUsername === mentioned) return true;
          const normalize = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
          if (normalize(storedUsername) === normalize(mentioned)) return true;
          return false;
        });
        if (mentionedEmployee && mentionedEmployee.social) {
          mentionedEmployee.social.totalMentions = (mentionedEmployee.social.totalMentions || 0) + 1;
        }
      });
      
      // Determine explicit level based on post type and personality
      let explicitLevel = 0;
      if (postType === 'thirst_trap') {
        // Thirst traps are always at least level 2 (lewd/revealing)
        explicitLevel = personality.flirty > 70 ? 3 : 2;
      } else if (postType === 'explicit') {
        // Explicit posts are always level 4 (very explicit/NSFW)
        explicitLevel = 4;
      } else if (postType === 'selfie' && personality.flirty > 65) {
        explicitLevel = Math.random() < 0.3 ? 1 : 0;
      }
      
      // Generate image prompt for visual post types
      let imagePrompt = null;
      if (['selfie', 'thirst_trap', 'explicit', 'meme', 'food', 'travel', 'life_update'].includes(postType)) {
        imagePrompt = await generateImagePrompt(employee, postType, content, context);
      }
      
      return {
        content: content.trim(),
        imagePrompt,
        explicitLevel,
        tags: [postType]
      };
    } catch (error) {
      console.error('[AI] Generation failed for employee post:', error);
      console.error('[AI] Post type:', postType);
      console.error('[AI] Employee:', employee.name);
      
      // Enhanced fallback templates with more variety and personality
      const personality = employee.personality || {};
      const templates = {
        text: [
          'Just vibing ✨', 
          'Mood today 💭', 
          'Thoughts? 🤔',
          'Random thought of the day 🌟',
          'Currently feeling this energy ⚡',
          'Just reflecting on things 💫',
          'That Monday feeling 📅',
          'Vibes check ✓'
        ],
        work: [
          'Productive day at the office! 💼', 
          'Meeting wrapped up ✓', 
          'Project milestone reached 📊',
          'Team collaboration going strong 🤝',
          'Another successful presentation 📈',
          'Coffee break well deserved ☕',
          'Focused work mode activated �',
          'Making progress on this quarter\'s goals 🎯'
        ],
        selfie: [
          'Feeling good today ✨', 
          'Current mood captured 📸', 
          'Quick snap before heading out 🚀',
          'Today\'s look 👗',
          'Catching the right lighting 🌞',
          'Fresh haircut energy 💇',
          'Outfit of the day 👔',
          'Post-gym glow 💪'
        ],
        meme: [
          'Office life be like 😅', 
          'Relatable content incoming 👀', 
          'Story of my life right here 📖',
          'When Monday hits different 🫠',
          'Accurate representation of my workday 💯',
          'Too real not to share 🤣',
          'This speaks to me on a spiritual level ✨',
          'Found this gem and had to share 💎'
        ],
        life_update: [
          'Weekend plans are shaping up nicely 🎉', 
          'New hobby unlocked 🎮', 
          'Life update: Things are looking good ✨',
          'Trying something new this week 🌟',
          'Personal growth journey continues 📚',
          'Making positive changes 🌱',
          'Exploring new interests lately 🗺️',
          'Leveling up in life 🚀'
        ],
        food: [
          'Lunch break hitting different today 🍽️',
          'Discovered a new favorite spot 🍜',
          'Treating myself right 🥗',
          'Food coma incoming... worth it 😋',
          'Chef\'s kiss on this meal 👨‍🍳',
          'Brunch goals achieved ☕',
          'Dinner plans: sorted ✓'
        ],
        thirst_trap: [
          'Confidence level: Maximum 💯', 
          'Feeling myself today ✨', 
          'Good vibes only 😌',
          'Energy is unmatched right now 🔥',
          'Living my best life 🌟',
          'Main character energy 👑',
          'No filter needed 📸'
        ],
        explicit: [
          'After hours mood activated 🌙', 
          'No caption needed here 💋', 
          'You already know the vibe 😏',
          'Late night thoughts 🌃',
          'Feeling bold tonight ✨',
          'That kind of evening 🥂',
          'Private mode: ON 🔒'
        ]
      };
      
      // Select from appropriate template array
      const fallbackArray = templates[postType] || templates.text;
      
      // Add personality-based variation if available
      let content;
      if (personality.flirty > 70 && Math.random() > 0.5) {
        const flirtyAddons = [' 😘', ' 💕', ' 😉', ' 💫'];
        content = fallbackArray[Math.floor(Math.random() * fallbackArray.length)] + flirtyAddons[Math.floor(Math.random() * flirtyAddons.length)];
      } else if (personality.professional > 70 && Math.random() > 0.5) {
        const professionalAddons = [' #WorkLife', ' #Productive', ' #Goals'];
        content = fallbackArray[Math.floor(Math.random() * fallbackArray.length)] + professionalAddons[Math.floor(Math.random() * professionalAddons.length)];
      } else {
        content = fallbackArray[Math.floor(Math.random() * fallbackArray.length)];
      }
      
      console.warn('[AI] Using fallback caption:', content);
      
      return {
        content,
        imagePrompt: null,
        explicitLevel: postType === 'explicit' ? 3 : postType === 'thirst_trap' ? 1 : 0,
        tags: [postType]
      };
    }
  }
  
  /**
   * Analyze post caption to extract key subjects, themes, and context
   * MASSIVELY EXPANDED for comprehensive coverage!
   */
  function analyzeCaption(caption) {
    const lower = caption.toLowerCase();
    
    // ===== FOOD ITEMS (50+ categories) =====
    const foodMatches = {
      'coffee': ['coffee', 'latte', 'espresso', 'cappuccino', 'mocha', 'americano', 'cold brew', 'iced coffee', 'frappe', 'macchiato'],
      'burger': ['burger', 'hamburger', 'cheeseburger', 'whopper', 'big mac'],
      'pizza': ['pizza', 'slice', 'pie', 'pepperoni', 'margherita', 'deep dish'],
      'sushi': ['sushi', 'sashimi', 'roll', 'maki', 'nigiri', 'california roll', 'spicy tuna'],
      'ramen': ['ramen', 'noodle soup', 'tonkotsu', 'miso ramen', 'shoyu'],
      'taco': ['taco', 'tacos', 'burrito', 'quesadilla', 'enchilada', 'nachos'],
      'sandwich': ['sandwich', 'sub', 'hoagie', 'panini', 'grilled cheese', 'blt', 'club sandwich'],
      'salad': ['salad', 'greens', 'lettuce', 'caesar', 'cobb salad', 'greek salad'],
      'pasta': ['pasta', 'spaghetti', 'fettuccine', 'ravioli', 'linguine', 'penne', 'carbonara', 'alfredo', 'bolognese'],
      'cake': ['cake', 'birthday cake', 'cheesecake', 'chocolate cake', 'vanilla cake', 'red velvet'],
      'cookie': ['cookie', 'cookies', 'chocolate chip', 'oatmeal cookie', 'sugar cookie'],
      'ice cream': ['ice cream', 'gelato', 'sundae', 'cone', 'scoop'],
      'donut': ['donut', 'doughnut', 'glazed', 'jelly donut', 'cruller'],
      'brownie': ['brownie', 'brownies', 'fudge brownie'],
      'lemon bars': ['lemon bar', 'lemon bars', 'lemon square', 'lemon dessert'],
      'boba': ['boba', 'bubble tea', 'milk tea', 'pearl tea', 'tapioca'],
      'smoothie': ['smoothie', 'smoothie bowl', 'acai bowl', 'protein shake'],
      'breakfast': ['breakfast', 'brunch'],
      'pancakes': ['pancake', 'pancakes', 'flapjack', 'stack'],
      'waffles': ['waffle', 'waffles', 'belgian waffle'],
      'eggs': ['eggs', 'scrambled', 'fried egg', 'omelet', 'omelette', 'poached egg'],
      'bacon': ['bacon', 'strips', 'crispy bacon'],
      'toast': ['toast', 'buttered toast'],
      'avocado toast': ['avocado toast', 'avo toast', 'smashed avo'],
      'cereal': ['cereal', 'cheerios', 'corn flakes', 'granola'],
      'cocktail': ['cocktail', 'martini', 'mojito', 'margarita', 'whiskey', 'vodka', 'gin', 'tequila', 'rum'],
      'beer': ['beer', 'brew', 'ale', 'lager', 'ipa', 'pint'],
      'wine': ['wine', 'red wine', 'white wine', 'rosé', 'champagne', 'prosecco'],
      'tea': ['tea', 'green tea', 'black tea', 'chai', 'herbal tea', 'iced tea'],
      'wings': ['wing', 'wings', 'buffalo wings', 'chicken wings', 'hot wings'],
      'fries': ['fries', 'french fries', 'chips', 'waffle fries', 'curly fries'],
      'soup': ['soup', 'stew', 'chowder', 'bisque', 'pho', 'gumbo'],
      'steak': ['steak', 'ribeye', 'sirloin', 'filet', 'beef', 't-bone'],
      'chicken': ['chicken', 'poultry', 'fried chicken', 'grilled chicken', 'chicken breast'],
      'seafood': ['seafood', 'fish', 'salmon', 'tuna', 'shrimp', 'lobster', 'crab', 'oyster'],
      'bbq': ['bbq', 'barbecue', 'ribs', 'brisket', 'pulled pork', 'smoked'],
      'hotdog': ['hot dog', 'hotdog', 'frank', 'corn dog'],
      'popcorn': ['popcorn', 'kettle corn'],
      'chips': ['chips', 'potato chips', 'tortilla chips', 'pretzels', 'crisps'],
      'cheese': ['cheese', 'cheddar', 'mozzarella', 'brie', 'gouda', 'parmesan', 'cheese board', 'charcuterie'],
      'poke bowl': ['poke', 'poke bowl', 'ahi'],
      'curry': ['curry', 'indian food', 'tikka masala', 'vindaloo'],
      'dim sum': ['dim sum', 'dumpling', 'dumplings', 'bao', 'steamed bun'],
      'bagel': ['bagel', 'bagels', 'cream cheese'],
      'muffin': ['muffin', 'muffins', 'blueberry muffin'],
      'croissant': ['croissant', 'pastry', 'danish'],
      'fruit': ['fruit', 'apple', 'banana', 'orange', 'berry', 'berries', 'strawberry', 'mango', 'watermelon'],
      'vegetables': ['veggie', 'vegetables', 'carrot', 'broccoli', 'spinach'],
      'snack': ['snack', 'snacking', 'munchies']
    };
    
    let detectedFood = null;
    for (const [category, keywords] of Object.entries(foodMatches)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedFood = category;
        break;
      }
    }
    
    // ===== MOODS & EMOTIONS (30+ states) =====
    const moods = {
      tired: ['tired', 'exhausted', 'sleepy', 'dead', 'drained', 'worn out', 'beat', 'fatigue', 'zombie', 'need sleep', 'can\'t even'],
      happy: ['happy', 'excited', 'great', 'amazing', 'wonderful', 'fantastic', 'vibing', 'blessed', 'grateful', 'joyful', 'thrilled', 'elated', 'stoked'],
      confident: ['confident', 'feeling myself', 'good vibes', 'powerful', 'unstoppable', 'boss', 'killing it', 'on top', 'got this', 'crushing'],
      flirty: ['flirt', 'mood', 'you know', 'wink', 'after hours', 'naughty', 'cheeky', 'tease', 'playful', 'spicy', 'wild', 'devil'],
      stressed: ['stress', 'busy', 'hectic', 'overwhelm', 'deadline', 'crazy', 'panic', 'anxiety', 'nervous', 'worried', 'pressure'],
      relaxed: ['chill', 'relax', 'calm', 'peaceful', 'zen', 'cozy', 'serene', 'tranquil', 'ease', 'unwind', 'mellow'],
      sad: ['sad', 'down', 'depressed', 'blue', 'melancholy', 'heartbroken', 'crying', 'tears', 'upset', 'hurt'],
      angry: ['angry', 'mad', 'furious', 'pissed', 'annoyed', 'irritated', 'rage', 'frustrated', 'livid'],
      silly: ['silly', 'goofy', 'funny', 'derp', 'weird', 'quirky', 'random', 'chaos', 'unhinged'],
      proud: ['proud', 'accomplished', 'achievement', 'success', 'win', 'nailed it', 'crushed it'],
      bored: ['bored', 'boring', 'meh', 'whatever', 'yawn', 'nothing to do'],
      hungover: ['hungover', 'hangover', 'regret', 'last night', 'never again', 'why did i'],
      motivated: ['motivated', 'motivated', 'inspired', 'determined', 'focused', 'driven', 'hustle', 'grind'],
      romantic: ['romantic', 'love', 'date night', 'valentine', 'crush', 'heart', 'swooning'],
      mysterious: ['mysterious', 'secret', 'cryptic', 'enigma', 'wonder', 'curious'],
      sassy: ['sassy', 'attitude', 'unbothered', 'petty', 'shade', 'savage']
    };
    
    let detectedMood = 'neutral';
    for (const [mood, keywords] of Object.entries(moods)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedMood = mood;
        break;
      }
    }
    
    // ===== ACTIVITIES (40+ types) =====
    const activities = {
      workout: ['workout', 'gym', 'exercise', 'fitness', 'lift', 'lifting', 'cardio', 'run', 'running', 'jog', 'jogging', 'weights', 'training', 'sweat', 'gains', 'leg day', 'arm day'],
      yoga: ['yoga', 'meditation', 'meditate', 'stretch', 'stretching', 'pilates'],
      travel: ['travel', 'trip', 'vacation', 'holiday', 'getaway', 'adventure', 'explore', 'wanderlust'],
      work: ['work', 'working', 'meeting', 'project', 'deadline', 'presentation', 'client', 'boss', 'coworker'],
      cooking: ['cook', 'cooking', 'baking', 'bake', 'recipe', 'homemade', 'chef', 'kitchen', 'meal prep'],
      reading: ['read', 'reading', 'book', 'novel', 'page', 'chapter', 'library', 'literature'],
      gaming: ['game', 'gaming', 'play', 'playing', 'controller', 'stream', 'streaming', 'twitch', 'console', 'pc gaming', 'esports'],
      art: ['paint', 'painting', 'draw', 'drawing', 'art', 'sketch', 'sketching', 'canvas', 'illustration', 'digital art'],
      music: ['music', 'song', 'singing', 'guitar', 'piano', 'drums', 'concert', 'band', 'playlist', 'jam', 'practice'],
      dancing: ['dance', 'dancing', 'moves', 'choreography', 'ballet', 'salsa', 'club', 'party'],
      shopping: ['shopping', 'shop', 'store', 'mall', 'bought', 'purchase', 'retail therapy', 'haul'],
      cleaning: ['clean', 'cleaning', 'organize', 'organizing', 'tidy', 'laundry', 'dishes', 'vacuum'],
      studying: ['study', 'studying', 'homework', 'exam', 'test', 'cramming', 'research', 'learning'],
      driving: ['drive', 'driving', 'commute', 'traffic', 'road trip', 'cruise'],
      walking: ['walk', 'walking', 'stroll', 'strolling', 'hike', 'hiking'],
      swimming: ['swim', 'swimming', 'pool', 'lap', 'dive', 'diving'],
      biking: ['bike', 'biking', 'cycle', 'cycling', 'bicycle', 'ride', 'riding'],
      photography: ['photo', 'photography', 'camera', 'shoot', 'shooting', 'pictures', 'snap', 'capture'],
      movie: ['movie', 'film', 'cinema', 'theater', 'watching', 'binge', 'netflix', 'tv show', 'series'],
      socializing: ['friends', 'hanging out', 'hangout', 'party', 'gathering', 'social', 'meet up', 'catch up'],
      sleeping: ['sleep', 'sleeping', 'nap', 'napping', 'bed', 'rest', 'snooze'],
      drinking: ['drinking', 'drinks', 'bar', 'pub', 'tipsy', 'drunk', 'shots', 'cheers'],
      selfcare: ['self care', 'spa', 'facial', 'massage', 'manicure', 'pedicure', 'pamper', 'treat myself'],
      grooming: ['shower', 'bath', 'shave', 'hair', 'makeup', 'skincare', 'getting ready'],
      diy: ['diy', 'build', 'building', 'craft', 'crafting', 'project', 'handmade', 'woodwork'],
      gardening: ['garden', 'gardening', 'plant', 'plants', 'flower', 'flowers', 'grow', 'growing'],
      pets: ['pet', 'dog', 'cat', 'puppy', 'kitten', 'fur baby', 'doggo', 'pupper', 'kitty'],
      celebration: ['celebrate', 'celebrating', 'birthday', 'anniversary', 'promotion', 'milestone', 'achievement']
    };
    
    let detectedActivity = null;
    for (const [activity, keywords] of Object.entries(activities)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedActivity = activity;
        break;
      }
    }
    
    // ===== LOCATIONS (30+ places) =====
    const locations = {
      home: ['home', 'house', 'apartment', 'room', 'living room', 'couch', 'sofa', 'staying in'],
      bedroom: ['bedroom', 'bed', 'bedroom vibes'],
      bathroom: ['bathroom', 'mirror', 'restroom'],
      kitchen: ['kitchen', 'counter', 'stove', 'oven'],
      office: ['office', 'desk', 'cubicle', 'workspace', 'conference room', 'meeting room', 'work'],
      gym: ['gym', 'fitness center', 'weight room', 'locker room'],
      outdoor: ['outside', 'outdoor', 'outdoors', 'fresh air'],
      park: ['park', 'playground', 'green space'],
      beach: ['beach', 'shore', 'sand', 'ocean', 'sea', 'waves', 'coastline'],
      mountains: ['mountain', 'mountains', 'peak', 'summit', 'trail', 'hike'],
      car: ['car', 'vehicle', 'driving', 'front seat', 'back seat'],
      restaurant: ['restaurant', 'diner', 'eatery', 'bistro'],
      cafe: ['cafe', 'coffee shop', 'café', 'coffeehouse', 'starbucks'],
      bar: ['bar', 'pub', 'tavern', 'lounge', 'club', 'nightclub'],
      airport: ['airport', 'terminal', 'gate', 'flight', 'plane', 'airplane'],
      hotel: ['hotel', 'resort', 'motel', 'inn', 'room service'],
      mall: ['mall', 'shopping center', 'store', 'retail'],
      library: ['library', 'bookstore', 'book shop'],
      hospital: ['hospital', 'clinic', 'doctor', 'medical'],
      school: ['school', 'university', 'college', 'campus', 'class', 'classroom'],
      pool: ['pool', 'swimming pool', 'poolside'],
      elevator: ['elevator', 'lift'],
      parking: ['parking lot', 'parking garage', 'garage'],
      subway: ['subway', 'train', 'metro', 'station'],
      rooftop: ['rooftop', 'roof', 'terrace'],
      balcony: ['balcony', 'patio', 'deck'],
      garden: ['garden', 'backyard', 'yard'],
      forest: ['forest', 'woods', 'trees', 'nature'],
      city: ['city', 'downtown', 'urban', 'skyline', 'street'],
      countryside: ['countryside', 'rural', 'farm', 'field']
    };
    
    let detectedLocation = null;
    for (const [location, keywords] of Object.entries(locations)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLocation = location;
        break;
      }
    }
    
    // ===== TIME OF DAY =====
    const timeOfDay = {
      morning: ['morning', 'breakfast', 'sunrise', 'dawn', 'am', 'woke up', 'wake up'],
      afternoon: ['afternoon', 'lunch', 'midday', 'noon'],
      evening: ['evening', 'dinner', 'sunset', 'dusk', 'pm'],
      night: ['night', 'nighttime', 'late night', 'midnight', 'dark'],
      latenight: ['late', '2am', '3am', '4am', 'can\'t sleep', 'insomnia']
    };
    
    let detectedTimeOfDay = null;
    for (const [time, keywords] of Object.entries(timeOfDay)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedTimeOfDay = time;
        break;
      }
    }
    
    // ===== WEATHER =====
    const weather = {
      sunny: ['sunny', 'sun', 'sunshine', 'bright', 'clear', 'beautiful day'],
      rainy: ['rain', 'raining', 'rainy', 'wet', 'umbrella', 'drizzle', 'storm', 'stormy'],
      snowy: ['snow', 'snowing', 'snowy', 'winter', 'cold', 'freezing', 'ice'],
      cloudy: ['cloudy', 'overcast', 'gray', 'grey', 'gloomy'],
      hot: ['hot', 'heat', 'sweat', 'humid', 'melting'],
      windy: ['windy', 'wind', 'breezy', 'breeze']
    };
    
    let detectedWeather = null;
    for (const [condition, keywords] of Object.entries(weather)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedWeather = condition;
        break;
      }
    }
    
    // ===== CLOTHING & STYLE =====
    const clothing = {
      casual: ['casual', 'comfy', 'comfortable', 'sweats', 'hoodie', 'jeans', 't-shirt', 'tshirt'],
      formal: ['formal', 'dress', 'suit', 'tie', 'heels', 'blazer', 'professional'],
      athletic: ['athletic', 'workout clothes', 'gym clothes', 'activewear', 'leggings', 'sports bra', 'tank'],
      pajamas: ['pajamas', 'pjs', 'pj', 'sleepwear', 'nightgown'],
      swimwear: ['swimsuit', 'bikini', 'swimwear', 'bathing suit', 'trunks'],
      cozy: ['cozy', 'cosy', 'fuzzy', 'blanket', 'warm']
    };
    
    let detectedClothing = null;
    for (const [style, keywords] of Object.entries(clothing)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedClothing = style;
        break;
      }
    }
    
    // ===== LIGHTING & AESTHETIC =====
    const lighting = {
      golden_hour: ['golden hour', 'sunset', 'sunrise', 'magic hour'],
      natural: ['natural light', 'daylight', 'sunlight'],
      dark: ['dark', 'darkness', 'dim', 'shadow', 'shadows'],
      bright: ['bright', 'well lit', 'flash'],
      moody: ['moody', 'dramatic', 'noir', 'cinematic'],
      soft: ['soft', 'gentle', 'warm', 'ambient']
    };
    
    let detectedLighting = null;
    for (const [light, keywords] of Object.entries(lighting)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLighting = light;
        break;
      }
    }
    
    // ===== SOCIAL CONTEXT =====
    const socialContext = {
      alone: ['alone', 'solo', 'by myself', 'me time', 'solo'],
      with_friends: ['friends', 'squad', 'crew', 'gang', 'besties', 'bff'],
      with_partner: ['boyfriend', 'girlfriend', 'partner', 'bae', 'boo', 'date'],
      with_coworkers: ['coworker', 'colleague', 'team', 'work friend'],
      with_family: ['family', 'mom', 'dad', 'sister', 'brother', 'parents']
    };
    
    let detectedSocialContext = null;
    for (const [context, keywords] of Object.entries(socialContext)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSocialContext = context;
        break;
      }
    }
    
    // ===== OBJECTS & ITEMS =====
    const objects = {
      phone: ['phone', 'iphone', 'android', 'mobile', 'cell'],
      laptop: ['laptop', 'computer', 'macbook', 'pc'],
      book: ['book', 'novel', 'reading'],
      headphones: ['headphones', 'earbuds', 'airpods', 'music'],
      sunglasses: ['sunglasses', 'shades'],
      hat: ['hat', 'cap', 'beanie'],
      bag: ['bag', 'purse', 'backpack', 'tote']
    };
    
    let detectedObject = null;
    for (const [obj, keywords] of Object.entries(objects)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedObject = obj;
        break;
      }
    }
    
    // ===== SEASON =====
    const season = {
      spring: ['spring', 'springtime', 'bloom', 'flowers'],
      summer: ['summer', 'summertime', 'hot', 'beach season'],
      fall: ['fall', 'autumn', 'leaves', 'pumpkin', 'halloween'],
      winter: ['winter', 'wintertime', 'snow', 'cold', 'holiday', 'christmas']
    };
    
    let detectedSeason = null;
    for (const [s, keywords] of Object.entries(season)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSeason = s;
        break;
      }
    }
    
    // ===== BODY LANGUAGE & POSES =====
    const pose = {
      sitting: ['sitting', 'sit', 'seated', 'chair'],
      standing: ['standing', 'stand'],
      lying: ['lying', 'laying', 'lay down', 'horizontal'],
      leaning: ['lean', 'leaning'],
      walking: ['walking', 'walk'],
      looking_back: ['looking back', 'over shoulder', 'glance back']
    };
    
    let detectedPose = null;
    for (const [p, keywords] of Object.entries(pose)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedPose = p;
        break;
      }
    }
    
    // ===== EXTRACT SPECIFIC DETAILS (cities, landmarks, unique features) =====
    // This captures custom details that aren't in our predefined categories
    const specificDetails = [];
    
    // Famous cities/places
    const cities = ['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'prague', 'vienna', 'venice', 'florence', 'milan', 'athens', 'santorini', 'mykonos', 'bali', 'phuket', 'bangkok', 'singapore', 'hong kong', 'seoul', 'beijing', 'shanghai', 'dubai', 'istanbul', 'cairo', 'marrakech', 'cape town', 'sydney', 'melbourne', 'auckland', 'fiji', 'hawaii', 'maui', 'oahu', 'tahiti', 'bora bora', 'maldives', 'seychelles', 'mauritius', 'bali', 'cancun', 'cabo', 'tulum', 'playa del carmen', 'costa rica', 'jamaica', 'bahamas', 'aruba', 'new york', 'nyc', 'manhattan', 'brooklyn', 'los angeles', 'la', 'hollywood', 'malibu', 'san francisco', 'miami', 'vegas', 'las vegas', 'chicago', 'boston', 'seattle', 'portland', 'austin', 'nashville', 'new orleans', 'montreal', 'toronto', 'vancouver', 'whistler', 'mexico city', 'buenos aires', 'rio', 'sao paulo', 'lima', 'santiago', 'bogota', 'cartagena', 'havana', 'lisboa', 'lisbon', 'porto', 'madrid', 'seville', 'ibiza', 'mallorca', 'valencia', 'geneva', 'zurich', 'lucerne', 'copenhagen', 'stockholm', 'oslo', 'helsinki', 'reykjavik', 'iceland', 'dublin', 'edinburgh', 'glasgow', 'belfast', 'budapest', 'krakow', 'warsaw', 'dubrovnik', 'split', 'zagreb', 'bucharest', 'sofia', 'belgrade', 'tel aviv', 'jerusalem', 'petra', 'dubai', 'abu dhabi', 'doha', 'muscat', 'mumbai', 'delhi', 'jaipur', 'agra', 'goa', 'kathmandu', 'pokhara', 'colombo', 'manila', 'hanoi', 'ho chi minh', 'siem reap', 'angkor', 'luang prabang', 'yangon', 'bagan', 'kuala lumpur', 'penang', 'langkawi', 'jakarta', 'ubud', 'queenstown', 'rotorua', 'perth', 'brisbane', 'gold coast', 'cairns', 'great barrier reef'];
    cities.forEach(city => {
      if (lower.includes(city)) specificDetails.push(city);
    });
    
    // Unique features (bamboo, cherry blossoms, etc.)
    const features = ['bamboo', 'cherry blossom', 'cherry blossoms', 'sakura', 'palm tree', 'palm trees', 'coconut tree', 'pine tree', 'redwood', 'sequoia', 'cactus', 'desert', 'dunes', 'sand dunes', 'waterfall', 'volcano', 'geyser', 'hot springs', 'aurora', 'northern lights', 'southern lights', 'milky way', 'stars', 'starry sky', 'full moon', 'sunset', 'sunrise', 'rainbow', 'double rainbow', 'lighthouse', 'windmill', 'windmills', 'castle', 'temple', 'shrine', 'pagoda', 'mosque', 'cathedral', 'church', 'monastery', 'ruins', 'ancient', 'colosseum', 'eiffel tower', 'big ben', 'statue of liberty', 'golden gate', 'brooklyn bridge', 'times square', 'central park', 'taj mahal', 'great wall', 'pyramids', 'sphinx', 'acropolis', 'parthenon', 'stonehenge', 'machu picchu', 'christ the redeemer', 'sugarloaf mountain', 'mount fuji', 'mount everest', 'kilimanjaro', 'matterhorn', 'swiss alps', 'rocky mountains', 'andes', 'himalayas', 'grand canyon', 'yosemite', 'yellowstone', 'zion', 'bryce canyon', 'glacier', 'fjord', 'fjords', 'iceberg', 'ice cave', 'blue lagoon', 'cenote', 'cave', 'cavern', 'grotto', 'canyon', 'valley', 'meadow', 'prairie', 'savanna', 'jungle', 'rainforest', 'mangrove', 'coral reef', 'kelp forest', 'vineyard', 'winery', 'lavender field', 'tulip field', 'sunflower field', 'rice paddy', 'terraces', 'rice terraces', 'tea plantation', 'coffee farm', 'olive grove', 'orchard', 'botanical garden', 'japanese garden', 'zen garden', 'rooftop', 'skyline', 'skyscraper', 'penthouse', 'balcony', 'terrace', 'patio', 'deck', 'pier', 'dock', 'marina', 'harbor', 'port', 'boardwalk', 'promenade', 'cobblestone', 'alley', 'alleyway', 'street art', 'mural', 'graffiti', 'neon lights', 'neon signs', 'lanterns', 'fairy lights', 'string lights', 'christmas lights', 'fireworks', 'bonfire', 'campfire', 'fire pit'];
    features.forEach(feature => {
      if (lower.includes(feature)) specificDetails.push(feature);
    });
    
    // Activities with specific details
    const specificActivities = ['dance party', 'dancing party', 'coding session', 'coding marathon', 'coding', 'hackathon', 'photoshoot', 'photo shoot', 'wine tasting', 'beer tasting', 'brunch', 'dinner party', 'house party', 'rooftop party', 'pool party', 'beach party', 'bbq party', 'birthday party', 'karaoke', 'trivia night', 'game night', 'movie night', 'girls night', 'boys night', 'date night', 'spa day', 'beach day', 'snow day', 'road trip', 'camping trip', 'backpacking', 'glamping', 'safari', 'cruise', 'boat trip', 'yacht', 'sailing', 'snorkeling', 'scuba diving', 'surfing', 'paddleboarding', 'kayaking', 'rafting', 'zip lining', 'rock climbing', 'bouldering', 'skiing', 'snowboarding', 'ice skating', 'sledding', 'tubing', 'parasailing', 'skydiving', 'bungee jumping', 'hot air balloon', 'helicopter ride', 'scenic flight'];
    specificActivities.forEach(activity => {
      if (lower.includes(activity)) specificDetails.push(activity);
    });
    
    return {
      food: detectedFood,
      mood: detectedMood,
      activity: detectedActivity,
      location: detectedLocation,
      timeOfDay: detectedTimeOfDay,
      weather: detectedWeather,
      clothing: detectedClothing,
      lighting: detectedLighting,
      socialContext: detectedSocialContext,
      object: detectedObject,
      season: detectedSeason,
      pose: detectedPose,
      specificDetails: specificDetails.length > 0 ? specificDetails : null,
      rawCaption: caption // Pass full caption for AI context
    };
  }

  /**
   * Generate image prompt for visual posts
   * NOW WITH CAPTION ANALYSIS FOR PERFECT CONTINUITY!
   */
  async function generateImagePrompt(employee, postType, postCaption, context = null) {
    const personality = employee.personality || {};
    
    // Get consistent physical description for THIS employee
    const physicalDesc = getPhysicalDescriptionForPrompt(employee);
    
    // ===== NEW: AI-POWERED IMAGE PROMPT GENERATION =====
    // Use AI to intelligently generate image prompt based on full context
    
    // Only include chat context for explicit/thirst_trap posts or boss-requested posts
    let chatContextForImage = '';
    let bossRequestContext = '';
    
    const shouldIncludeContext = postType === 'explicit' || postType === 'thirst_trap' || context?.requestedByBoss;
    
    if (shouldIncludeContext) {
      // Get recent chat context if available
      const chatHistory = gameState.chatHistory[employee.id] || [];
      const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
      const recentChats = chatHistory
        .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
        .slice(-5); // Last 5 messages within 2 hours
      
      if (recentChats.length >= 2) {
        const recentMessages = recentChats.slice(-3).map(msg => `${msg.sender}: "${msg.content}"`).join('\n');
        chatContextForImage = `\n\nRECENT CONVERSATION WITH BOSS:\n${recentMessages}\n(Consider if the post is responding to or related to this conversation)`;
      }
      
      // Check if this was a boss-requested post
      if (context?.requestedByBoss) {
        bossRequestContext = `\n\nBOSS REQUESTED THIS POST: The boss specifically asked for this type of post${context.requestContext ? `: "${context.requestContext}"` : ''}. The image should fulfill their request.`;
      }
    }
    
    // Build AI prompt for image generation
    const imagePromptGenerationPrompt = `You are creating an image prompt for a social media post.

EMPLOYEE PHYSICAL DESCRIPTION:
${physicalDesc}

POST TYPE: ${postType}
POST CAPTION: "${postCaption}"
${chatContextForImage}${bossRequestContext}

CRITICAL INSTRUCTIONS:
1. Generate a DETAILED image prompt that EXACTLY matches what the caption describes or implies
2. Use the employee's EXACT physical description (copy it verbatim - don't summarize)
3. If caption mentions specific clothing, pose, location, mood - include ALL of it
4. If caption implies nudity/explicit content, describe it explicitly (this is for adult content)
5. If caption references a conversation (like "your request"), consider recent chat context
6. Be HIGHLY SPECIFIC about pose, clothing, expression, setting, camera angle
7. For explicit posts: describe anatomy visibility in detail (use anatomical terms from physical description)
8. For Female Futa: explicitly mention BOTH penis and vagina if nude/explicit
9. For Trans characters: use their appropriate anatomy from physical description
10. Make the image and caption tell ONE COHESIVE STORY

EXAMPLES OF GOOD IMAGE PROMPTS:

Caption: "Locked door, unlocked desires... your special request delivered fresh 😈"
Type: explicit
Context: Boss requested nude photo
Image Prompt: "(Physical description) stands in front of a locked wooden door in bedroom. She is completely nude, full frontal nudity. Her (specific breast description from profile) are fully exposed, nipples visible. Her (specific genital description - both penis and vagina for futa) are on full display in an erotic showcase. Face shows passionate, teasing expression looking directly at camera. Hands on hips, confident pose. Soft bedroom lighting. NSFW explicit content for boss's private request."

Caption: "That post-workout glow though 💪"
Type: selfie
Image Prompt: "(Physical description) taking gym mirror selfie. Wearing sports bra and leggings, slightly sweaty from workout. Face shows accomplished smile with flushed cheeks from exercise. Gym equipment visible in background. Phone in hand. Natural gym lighting. Athletic, healthy vibe."

Caption: "Coffee and chaos, the Monday mood ☕😩"
Type: text/food
Image Prompt: "Close-up of artisan coffee cup on messy office desk. Laptop visible, papers scattered. Morning natural lighting through window. Cozy but slightly overwhelmed atmosphere. No person visible, focus on coffee and workspace chaos."

NOW GENERATE THE IMAGE PROMPT:
Write ONLY the detailed image prompt - no explanations, no meta-commentary:`;

    try {
      // Generate AI-powered image prompt
      let aiImagePrompt = await generateText(imagePromptGenerationPrompt, {
        temperature: 0.8,
        max_tokens: 150,
        stopSequences: ['\n\n\n', 'Caption:', 'Example:', 'Note:', 'Remember:', '**Note', 'Type:', 'Context:', '---']
      });
      
      // Clean up any meta-commentary
      aiImagePrompt = aiImagePrompt.replace(/^\*\*[^*]+\*\*\s*/g, '');
      aiImagePrompt = aiImagePrompt.split(/\n\s*\(/)[0];
      aiImagePrompt = aiImagePrompt.split(/\(Note:/)[0];
      aiImagePrompt = aiImagePrompt.trim();
      
      // Validate it's not empty
      if (aiImagePrompt && aiImagePrompt.length > 20) {
        console.log(`AI-generated image prompt for ${employee.name}:`, aiImagePrompt.substring(0, 100) + '...');
        return aiImagePrompt;
      } else {
        console.warn('AI image prompt too short, falling back to template');
      }
    } catch (error) {
      console.error('AI image prompt generation failed:', error);
    }
    
    // ===== FALLBACK: Template-based system (if AI fails) =====
    const analysis = analyzeCaption(postCaption);
    
    const basePrompts = {
      selfie: [
        `${physicalDesc} taking a casual selfie, natural lighting, friendly smile, office setting`,
        `Close-up selfie of ${physicalDesc}, relaxed expression, neutral background, good lighting`,
        `${physicalDesc} taking selfie with soft smile, professional casual look, modern aesthetic`,
        `Mirror selfie of ${physicalDesc}, casual outfit, phone in hand, clean background`,
        `${physicalDesc} bathroom mirror selfie, good lighting, casual pose, modern style`,
        `Car selfie of ${physicalDesc}, golden hour lighting, windshield reflection, relaxed vibe`,
        `${physicalDesc} desk selfie, workspace visible, laptop in background, professional casual`,
        `Outdoor selfie of ${physicalDesc}, natural daylight, blurred background, genuine smile`,
        `${physicalDesc} elevator selfie, mirror reflection, going to work vibes, morning energy`,
        `Coffee shop selfie of ${physicalDesc}, drink in frame, cozy atmosphere, casual Monday mood`,
        `${physicalDesc} post-workout selfie, gym mirror, athletic wear, accomplishment glow`,
        `${physicalDesc} bedroom selfie, soft morning light, messy hair, authentic moment`,
        `${physicalDesc} lunch break selfie, restaurant background, food nearby, happy expression`,
        `Late night work selfie of ${physicalDesc}, desk lamp lighting, tired but determined look`,
        `Weekend selfie of ${physicalDesc}, casual home setting, relaxed vibe, natural smile`
      ],
      thirst_trap: [
        `Provocative photo of ${physicalDesc} in form-fitting gym attire, sports bra and leggings, toned body visible, gym mirror selfie, showing off physique, confident sexy pose`,
        `${physicalDesc} in tight dress, curves emphasized, low neckline, showing cleavage, mirror selfie, bedroom setting, seductive expression, body on display`,
        `${physicalDesc} in lingerie, lace bra and panties, bedroom mirror selfie, sensual pose, showing off body, intimate setting, confident and sexy`,
        `${physicalDesc} in bikini, beach or poolside, wet from water, body glistening, revealing swimwear, showing skin, attractive pose, summer vibes`,
        `${physicalDesc} wearing unbuttoned shirt, cleavage visible, messy hair, bedroom eyes, seductive morning look, showing skin suggestively`,
        `${physicalDesc} in tight yoga pants and crop top, cameltoe visible, toned stomach showing, gym setting, athletic but sexy, mirror selfie`,
        `${physicalDesc} in short skirt and crop top, midriff exposed, legs on display, confident pose, urban setting, showing off body`,
        `${physicalDesc} in silk robe barely covering body, cleavage visible, bare legs showing, bedroom setting, morning after vibe, sultry expression`,
        `${physicalDesc} in wet white shirt, see-through fabric, outline visible, water droplets, provocative accidental reveal aesthetic`,
        `${physicalDesc} from behind, tight pants emphasizing butt, looking over shoulder, flirty expression, showing off curves, confident pose`,
        `${physicalDesc} in sports bra only, bare midriff, athletic shorts low on hips, post-workout selfie, toned body on display, sweaty and sexy`,
        `${physicalDesc} in backless dress, bare back visible, side curves showing, elegant but provocative, looking over shoulder seductively`,
        `${physicalDesc} in low-cut top, deep cleavage visible, leaning forward, close-up angle, showing assets, bedroom eyes, flirty vibe`,
        `${physicalDesc} lying on bed in underwear, body stretched out, intimate angle, showing curves, messy bedroom hair, come-hither expression`,
        `${physicalDesc} sitting with legs spread in short skirt, inner thighs visible, provocative pose, confident expression, daring photo`
      ],
      explicit: [
        `NSFW photo of ${physicalDesc} topless, breasts exposed, hands covering nipples, bedroom setting, nude from waist up, sensual lighting, explicit content`,
        `${physicalDesc} completely nude, full frontal nudity, strategic hand placement, bedroom or bathroom, soft lighting, artistic nude photography, explicit NSFW`,
        `${physicalDesc} in transparent lingerie, nipples visible through fabric, see-through panties, body fully on display, bedroom, explicit intimate wear`,
        `${physicalDesc} topless from behind, bare back and butt visible, looking over shoulder, nude photography, sensual pose, NSFW explicit content`,
        `${physicalDesc} nude in shower, water running over naked body, wet skin glistening, intimate bathroom setting, full nudity, explicit content`,
        `${physicalDesc} on bed completely naked, lying seductively, intimate bedroom angle, full body nudity visible, explicit NSFW photography`,
        `${physicalDesc} wearing only unbuttoned shirt open exposing breasts, bare pussy visible, sitting pose, bedroom, explicit nude content`,
        `${physicalDesc} topless mirror selfie, breasts fully exposed, nipples visible, confident pose, bathroom or bedroom, explicit NSFW content`,
        `${physicalDesc} in spread eagle pose wearing nothing, full frontal nudity, lying on bed, intimate explicit angle, NSFW adult content`,
        `${physicalDesc} nude from side angle, breast and butt visible, artistic nude pose, bedroom setting, sensual lighting, explicit photography`,
        `${physicalDesc} wearing collar and nothing else, submissive kneeling pose, bedroom floor, fetish content, explicit NSFW`,
        `${physicalDesc} in bed sheets barely covering, breast peeking out, implied full nudity underneath, intimate morning scene, explicit suggestion`,
        `${physicalDesc} bent over showing bare ass, topless, looking back at camera, bedroom, explicit provocative pose, NSFW adult content`,
        `${physicalDesc} with legs spread wide in lingerie, crotch area visible, extremely revealing, bedroom, explicit sexual pose, NSFW`,
        `${physicalDesc} masturbating, hand between legs, topless, bedroom, explicit sexual content, NSFW adult photography, orgasmic expression`
      ],
      meme: [
        `Funny relatable meme image, office humor, modern internet meme style, text overlay space`,
        `Humorous workplace situation image, meme format, relatable content, funny expression`,
        `Comic-style meme about office life, funny scenario, internet humor aesthetic`,
        `Distracted boyfriend meme style, office edition, three people, dramatic pointing`,
        `Drake yes/no meme template, office scenarios, contrasting situations, clear panels`,
        `Expanding brain meme style, office productivity levels, ascending intelligence joke`,
        `This is fine dog meme, office on fire metaphor, coffee drinking, everything burning`,
        `Woman yelling at cat meme, office meeting drama, pointing and confused expressions`,
        `Two buttons sweating choice meme, work-life balance dilemma, person struggling to decide`,
        `Surprised Pikachu face, office edition, shocked reaction, yellow character, meme format`,
        `Galaxy brain meme style, office hacks, ascending ideas, space background evolution`,
        `Batman slapping Robin meme, office suggestion rejected, dramatic slap action`,
        `Change my mind meme, controversial office opinion, person at table, debate setup`,
        `Always has been meme, astronauts in space, office realization, gun pointing revelation`,
        `Is this a butterfly meme, confused person, office task misidentification, pointing gesture`,
        `Vince McMahon reaction meme, increasing excitement, office scenarios, four panel progression`,
        `Bernie Sanders sitting meme, office edition, folded arms, chair sitting, waiting mood`,
        `Roll Safe thinking meme, office life hack, pointing at head, can't fail logic`
      ],
      food: [
        `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        `Gourmet lunch plate, colorful ingredients, restaurant presentation, overhead shot, Instagram-worthy`,
        `Mouth-watering burger and fries, golden crispy, food truck setting, casual dining vibe`,
        `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks`,
        `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        `Decadent dessert plate, chocolate cake, drizzle, fork ready, cafe setting, indulgent`,
        `Healthy breakfast bowl, acai berries, granola, fruits, colorful presentation, morning energy`,
        `Pizza slice with cheese pull, wood-fired crust, melty goodness, casual dining, shareable`,
        `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        `Street taco plate, three tacos, authentic Mexican, lime wedge, casual food truck aesthetic`,
        `Starbucks cup on desk, laptop nearby, work setup, coffee shop vibes, productivity mood`,
        `Homemade pasta dish, fork twirling, fresh basil, rustic Italian, warm lighting`,
        `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        `Takeout containers on desk, late night work, Chinese food, chopsticks, office grind`,
        `Avocado toast, poached egg, artisan bread, brunch aesthetic, millennial food culture`,
        `Boba tea with straw, colorful drink, pearls visible, trendy cafe, aesthetic background`,
        `Charcuterie board, cheese, meats, grapes, crackers, sharing platter, sophisticated snacking`
      ],
      travel: [
        `Beautiful beach sunset, palm trees silhouette, orange sky, vacation vibes, peaceful scene`,
        `${physicalDesc} at mountain summit, arms raised, scenic overlook, adventure achievement`,
        `Stunning city skyline at night, lights reflecting, urban exploration, travel photography`,
        `Tropical beach scene, turquoise water, white sand, paradise destination, vacation mode`,
        `${physicalDesc} at famous landmark, tourist pose, iconic background, travel memories`,
        `Airport terminal view, planes visible, travel excitement, departure board, wanderlust`,
        `Hotel room view, city skyline through window, morning coffee, business travel aesthetic`,
        `Hiking trail panorama, mountains in distance, nature path, outdoor adventure, scenic beauty`,
        `Beach footprints in sand, ocean waves, sunset lighting, peaceful moment, coastal vibes`,
        `${physicalDesc} on airplane, window seat, clouds outside, travel mood, flying high`,
        `European cobblestone street, historic buildings, charming alley, cultural exploration`,
        `Desert landscape, vast horizon, golden hour, road trip adventure, American Southwest`,
        `Ski resort view, snowy mountains, winter sports, cold weather travel, alpine scenery`,
        `Tropical poolside, resort view, palm trees, lounging, luxury vacation aesthetic`,
        `${physicalDesc} backpack on, train station, solo travel, adventure beginning, wanderlust mood`,
        `National park vista, natural wonder, dramatic landscape, outdoor exploration, bucket list`,
        `Cruise ship deck view, ocean horizon, maritime travel, luxurious journey, sea adventure`
      ],
      life_update: [
        `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`,
        `${physicalDesc} with new pet, happy cuddle, home environment, life milestone moment`,
        `Yoga mat and water bottle, fitness journey, home workout setup, healthy lifestyle`,
        `${physicalDesc} painting on canvas, art supplies, creative hobby, focused expression`,
        `New apartment empty room, moving boxes, fresh start, life transition, excited energy`,
        `${physicalDesc} playing guitar, music hobby, casual home setting, creative pursuit`,
        `Garden with growing plants, dirt hands, outdoor hobby, nature connection, satisfying growth`,
        `${physicalDesc} at graduation, cap and gown, achievement moment, proud expression`,
        `Cozy reading nook, books stacked, coffee nearby, personal space, intellectual hobby`,
        `${physicalDesc} running on trail, athletic gear, fitness goal, outdoor exercise`,
        `Home office setup, organized desk, plants, productivity space, work-from-home life`,
        `${physicalDesc} cooking in kitchen, ingredients visible, culinary hobby, domestic scene`,
        `Meditation space, cushions, candles, zen atmosphere, wellness practice, self-care`,
        `${physicalDesc} with baked goods, oven mitt, proud baker, kitchen accomplishment`,
        `Bicycle leaned against wall, outdoor adventure gear, active lifestyle, weekend plans`,
        `${physicalDesc} at pottery wheel, clay hands, craft hobby, artistic concentration`,
        `Home gym equipment, weights visible, fitness dedication, personal space, health journey`
      ]
    };
    
    // ===== CAPTION-AWARE IMAGE GENERATION =====
    let prompt = '';
    
    // FOOD POSTS - Match specific food item from caption
    if (postType === 'food' && analysis.food) {
      const foodPrompts = {
        'coffee': `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        'burger': `Mouth-watering burger and fries, golden crispy, sesame bun, melted cheese, casual dining vibe`,
        'pizza': `Pizza slice with cheese pull, wood-fired crust, melty goodness, toppings visible, shareable`,
        'sushi': `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks, soy sauce`,
        'ramen': `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        'taco': `Street taco plate, three tacos, authentic Mexican, lime wedge, cilantro, casual food truck aesthetic`,
        'sandwich': `Delicious sandwich, layers visible, fresh ingredients, deli presentation, toasted bread`,
        'salad': `Fresh colorful salad bowl, mixed greens, vegetables, healthy presentation, fork ready`,
        'pasta': `Homemade pasta dish, fork twirling, fresh basil, parmesan cheese, rustic Italian, warm lighting`,
        'cake': `Decadent layered cake, frosting, slice cut, celebratory dessert, bakery quality`,
        'cookie': `Fresh baked cookies on plate, chocolate chips, homemade, warm and delicious`,
        'ice cream': `Ice cream scoops in bowl or cone, colorful, melting slightly, sweet treat, dessert vibes`,
        'donut': `Glazed donuts on plate, sprinkles or icing, bakery fresh, sweet breakfast treat`,
        'brownie': `Fudgy brownie squares, chocolate richness, dessert plate, indulgent treat`,
        'lemon bars': `Fresh lemon bars on a plate, powdered sugar dusted, bright yellow filling, dessert presentation`,
        'boba': `Boba tea with thick straw, colorful drink, tapioca pearls visible, trendy cafe, aesthetic background`,
        'smoothie': `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        'breakfast': `Healthy breakfast plate, eggs, toast, bacon, morning meal, colorful presentation`,
        'pancakes': `Stack of fluffy pancakes, syrup drizzle, butter pat, breakfast perfection, morning vibes`,
        'waffles': `Belgian waffles with toppings, syrup, whipped cream, breakfast indulgence`,
        'eggs': `Perfectly cooked eggs, breakfast plate, toast, morning meal, protein-rich`,
        'bacon': `Crispy bacon strips, breakfast side, sizzling, delicious protein`,
        'toast': `Toasted bread, butter spreading, golden brown, breakfast staple`,
        'avocado toast': `Avocado toast, poached egg, artisan bread, microgreens, brunch aesthetic, millennial food culture`,
        'cereal': `Cereal bowl with milk, spoon, breakfast table, morning meal, nostalgic`,
        'cocktail': `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        'beer': `Cold beer in glass or bottle, foam head, bar setting, relaxation drink, social vibes`,
        'wine': `Wine glass with red or white wine, elegant presentation, sophisticated drink, evening mood`,
        'tea': `Hot tea in cup, tea bag or loose leaf, steam rising, cozy drink, calming`,
        'wings': `Chicken wings plate, buffalo sauce, celery sticks, ranch dip, sports bar vibe`,
        'fries': `Golden crispy french fries, sea salt, ketchup, casual dining, shareable basket`,
        'soup': `Steaming bowl of soup, spoon ready, bread on side, comfort food, cozy presentation`,
        'steak': `Perfectly cooked steak, grill marks, sides visible, upscale dinner, meat lover's dream`,
        'chicken': `Delicious chicken dish, cooked to perfection, protein main course, satisfying meal`,
        'seafood': `Fresh seafood platter, ocean-to-table, elegant presentation, coastal cuisine`,
        'bbq': `BBQ plate with ribs or brisket, smoky char, barbecue sauce, Southern comfort food`,
        'hotdog': `Hot dog with toppings, classic American, stadium food, casual dining`,
        'popcorn': `Bowl of popcorn, movie snack, butter or seasoning, entertainment food`,
        'chips': `Bag or bowl of chips, snack food, crunchy, casual munchies`,
        'cheese': `Cheese board or charcuterie, variety of cheeses, crackers, grapes, sophisticated snacking`,
        'poke bowl': `Colorful poke bowl, fresh fish, rice, vegetables, Hawaiian cuisine, healthy bowl`,
        'curry': `Aromatic curry dish, rice, Indian spices, warm comfort food, flavorful`,
        'dim sum': `Dim sum basket, steamed dumplings, Asian cuisine, variety platter, chopsticks`,
        'bagel': `Fresh bagel with cream cheese, toasted, breakfast favorite, New York style`,
        'muffin': `Freshly baked muffins, bakery quality, breakfast pastry, warm and fluffy`,
        'croissant': `Flaky croissant, buttery pastry, French bakery, coffee companion`,
        'fruit': `Fresh fruit plate or bowl, colorful, healthy, natural sweetness, vibrant`,
        'vegetables': `Fresh vegetable plate, healthy eating, colorful produce, nutritious meal`,
        'snack': `Snack plate with variety, munchies, casual eating, satisfying treats`
      };
      
      prompt = foodPrompts[analysis.food] || `Appetizing ${analysis.food}, restaurant presentation, overhead shot, Instagram-worthy, delicious`;
      
      // Add location context to food
      if (analysis.location === 'home' || analysis.location === 'kitchen') {
        prompt += ', homemade, cozy kitchen setting';
      } else if (analysis.location === 'office') {
        prompt += ', on office desk, work lunch vibes';
      } else if (analysis.location === 'restaurant' || analysis.location === 'cafe') {
        prompt += ', restaurant setting, dining out atmosphere';
      } else if (analysis.location === 'outdoor' || analysis.location === 'park') {
        prompt += ', outdoor eating, picnic vibes, al fresco';
      }
      
      // Add time of day context
      if (analysis.timeOfDay === 'morning') {
        prompt += ', morning breakfast vibes, fresh start';
      } else if (analysis.timeOfDay === 'afternoon') {
        prompt += ', lunch time, midday meal';
      } else if (analysis.timeOfDay === 'evening' || analysis.timeOfDay === 'night') {
        prompt += ', dinner setting, evening meal';
      } else if (analysis.timeOfDay === 'latenight') {
        prompt += ', late night snack, midnight munchies';
      }
      
      // Add mood context
      if (analysis.mood === 'happy' || analysis.mood === 'excited') {
        prompt += ', joyful eating moment, satisfying';
      } else if (analysis.mood === 'stressed') {
        prompt += ', comfort food, stress eating, needed this';
      } else if (analysis.mood === 'hungover') {
        prompt += ', hangover cure, recovery food';
      }
      
      // Add social context
      if (analysis.socialContext === 'with_friends') {
        prompt += ', shared meal, group dining, social eating';
      } else if (analysis.socialContext === 'alone') {
        prompt += ', solo meal, treating myself';
      }
    }
    
    // SELFIE POSTS - Match mood from caption
    else if (postType === 'selfie') {
      const moodModifiers = {
        tired: 'tired expression, dark circles, exhausted but authentic',
        happy: 'genuine big smile, happy eyes, joyful energy',
        confident: 'confident expression, direct eye contact, powerful presence',
        flirty: 'playful smile, flirtatious gaze, knowing look',
        stressed: 'stressed expression, messy hair, overwhelmed but coping',
        relaxed: 'relaxed expression, peaceful vibe, calm energy',
        sad: 'sad expression, vulnerable moment, emotional',
        angry: 'frustrated expression, intense gaze, strong emotion',
        silly: 'goofy expression, funny face, playful energy',
        proud: 'proud smile, accomplished look, confident stance',
        bored: 'bored expression, unamused face, whatever mood',
        hungover: 'hungover look, messy hair, regretful expression, sunglasses indoors',
        motivated: 'determined expression, focused energy, driven look',
        romantic: 'soft romantic expression, dreamy eyes, gentle smile',
        mysterious: 'mysterious gaze, enigmatic expression, subtle smile',
        sassy: 'sassy expression, attitude, side-eye, confident smirk'
      };
      
      const locationModifiers = {
        home: 'casual home setting, relaxed vibe',
        bedroom: 'bedroom setting, soft morning light, authentic moment',
        bathroom: 'bathroom mirror selfie, good lighting, casual pose',
        kitchen: 'kitchen background, casual home vibe',
        office: 'office setting, professional casual, desk visible',
        gym: 'gym mirror, athletic wear, post-workout glow',
        car: 'car selfie, windshield reflection, driving vibes',
        outdoor: 'outdoor setting, natural daylight, fresh air',
        park: 'park background, nature setting, green scenery',
        beach: 'beach setting, ocean background, vacation vibes',
        cafe: 'coffee shop background, cozy atmosphere, casual vibe',
        bar: 'bar or club setting, nightlife energy, dim lighting',
        airport: 'airport terminal, travel mode, wanderlust energy',
        hotel: 'hotel room, travel vibes, away from home',
        mall: 'shopping mall background, retail therapy mood',
        elevator: 'elevator mirror selfie, going to work vibes',
        parking: 'parking lot background, casual outdoor setting',
        rooftop: 'rooftop view, city background, elevated perspective',
        balcony: 'balcony background, outdoor home space'
      };
      
      const activityModifiers = {
        workout: 'post-workout selfie, gym mirror, athletic wear, accomplishment glow, sweaty',
        yoga: 'post-yoga selfie, zen energy, workout mat visible, peaceful',
        work: 'desk selfie, workspace visible, laptop in background, professional casual',
        dancing: 'mid-dance energy, movement blur, party vibes',
        shopping: 'shopping bags visible, retail therapy energy, store background',
        grooming: 'fresh after shower, clean look, getting ready vibes',
        selfcare: 'spa day vibes, face mask, pampered look, relaxation mode',
        pets: 'selfie with pet, cuddles, animal in frame, wholesome',
        celebration: 'celebration energy, party mode, festive atmosphere'
      };
      
      const timeModifiers = {
        morning: 'morning light, sunrise glow, fresh day energy',
        afternoon: 'midday lighting, bright natural light',
        evening: 'golden hour lighting, warm sunset tones',
        night: 'evening lighting, night vibes, darker atmosphere',
        latenight: 'late night lighting, desk lamp or dim light, tired but awake'
      };
      
      const weatherModifiers = {
        sunny: 'bright sunny day, clear skies, natural sunlight',
        rainy: 'rainy day vibes, window droplets visible, cozy indoors',
        snowy: 'snowy weather, winter vibes, cold weather gear',
        hot: 'hot weather, summer vibes, dealing with heat'
      };
      
      const clothingModifiers = {
        casual: 'casual comfy outfit, relaxed style',
        formal: 'formal dressed up outfit, professional look',
        athletic: 'athletic wear, gym clothes, sporty style',
        pajamas: 'pajamas or sleepwear, cozy home mode',
        swimwear: 'swimsuit or beach wear, vacation mode',
        cozy: 'cozy outfit, blanket visible, warm and comfortable'
      };
      
      const socialModifiers = {
        alone: 'solo selfie, personal moment',
        with_friends: 'with friends in background, group vibes',
        with_partner: 'couple selfie, romantic moment',
        with_coworkers: 'with coworkers, team moment',
        with_family: 'family in frame, wholesome moment'
      };
      
      // Start with base
      prompt = `${physicalDesc} taking a selfie`;
      
      // Add activity-specific context (highest priority)
      if (analysis.activity && activityModifiers[analysis.activity]) {
        prompt = `${physicalDesc} ${activityModifiers[analysis.activity]}`;
      }
      // Or location
      else if (analysis.location && locationModifiers[analysis.location]) {
        prompt += `, ${locationModifiers[analysis.location]}`;
      } else {
        prompt += ', natural lighting';
      }
      
      // Add time of day
      if (analysis.timeOfDay && timeModifiers[analysis.timeOfDay]) {
        prompt += `, ${timeModifiers[analysis.timeOfDay]}`;
      }
      
      // Add weather context
      if (analysis.weather && weatherModifiers[analysis.weather]) {
        prompt += `, ${weatherModifiers[analysis.weather]}`;
      }
      
      // Add clothing style
      if (analysis.clothing && clothingModifiers[analysis.clothing]) {
        prompt += `, ${clothingModifiers[analysis.clothing]}`;
      }
      
      // Add social context
      if (analysis.socialContext && socialModifiers[analysis.socialContext]) {
        prompt += `, ${socialModifiers[analysis.socialContext]}`;
      }
      
      // Add mood (very important!)
      if (analysis.mood !== 'neutral' && moodModifiers[analysis.mood]) {
        prompt += `, ${moodModifiers[analysis.mood]}`;
      } else {
        prompt += `, friendly smile, genuine expression`;
      }
      
      // Add lighting aesthetic if specified
      if (analysis.lighting) {
        const lightMap = {
          'golden_hour': 'golden hour lighting, warm sunset glow',
          'natural': 'natural lighting, soft daylight',
          'dark': 'dark moody lighting, dramatic shadows',
          'bright': 'bright well-lit, clear visibility',
          'moody': 'moody dramatic lighting, cinematic feel',
          'soft': 'soft ambient lighting, gentle glow'
        };
        if (lightMap[analysis.lighting]) {
          prompt += `, ${lightMap[analysis.lighting]}`;
        }
      }
      
      // Add pose if mentioned
      if (analysis.pose) {
        const poseMap = {
          'sitting': 'sitting pose, seated position',
          'standing': 'standing pose',
          'lying': 'lying down, horizontal position',
          'leaning': 'leaning pose, casual lean',
          'looking_back': 'looking over shoulder, glance back'
        };
        if (poseMap[analysis.pose]) {
          prompt += `, ${poseMap[analysis.pose]}`;
        }
      }
    }
    
    // THIRST TRAP - Match mood, location, clothing, and confidence level
    else if (postType === 'thirst_trap') {
      const flirtyLevel = personality.flirty || 50;
      let baseDesc = flirtyLevel > 70 
        ? `${physicalDesc} in stylish form-fitting outfit, seductive pose, confident allure`
        : `${physicalDesc} in fashionable outfit, attractive pose, subtle confidence`;
      
      // Location-specific thirst traps
      if (analysis.location === 'gym') {
        baseDesc = `${physicalDesc} in gym clothes, athletic build, form-fitting activewear, mirror selfie, confident pose`;
      } else if (analysis.location === 'office') {
        baseDesc = `${physicalDesc} in fitted business attire, powerful stance, office setting, professional sexy`;
      } else if (analysis.location === 'bedroom') {
        baseDesc = `${physicalDesc} in bedroom setting, intimate casual outfit, soft lighting, confident allure`;
      } else if (analysis.location === 'bathroom') {
        baseDesc = `${physicalDesc} bathroom mirror shot, form-fitting outfit, confident expression, modern aesthetic`;
      } else if (analysis.location === 'car') {
        baseDesc = `${physicalDesc} in car, hand on steering wheel or door, confident cool pose, attractive lighting`;
      } else if (analysis.location === 'outdoor' || analysis.location === 'beach') {
        baseDesc = `${physicalDesc} outdoor setting, natural background, attractive casual pose, golden hour vibes`;
      }
      
      // Clothing-specific adjustments
      if (analysis.clothing === 'athletic') {
        baseDesc = `${physicalDesc} in athletic wear, fit body showcase, gym aesthetic, sporty confidence`;
      } else if (analysis.clothing === 'formal') {
        baseDesc = `${physicalDesc} in elegant formal outfit, sophisticated sexy, dressed to impress, stylish`;
      } else if (analysis.clothing === 'swimwear') {
        baseDesc = `${physicalDesc} in swimwear, beach body confidence, summer vibes, attractive pose`;
      }
      
      // Mood modifications
      const moodAdd = analysis.mood === 'confident' 
        ? ', powerful stance, direct gaze, commanding presence'
        : analysis.mood === 'flirty' 
        ? ', playful seductive expression, knowing smile'
        : analysis.mood === 'sassy'
        ? ', attitude, side glance, confident smirk'
        : ', flattering lighting, stylish aesthetic';
      
      prompt = baseDesc + moodAdd;
      
      // Time of day lighting
      if (analysis.timeOfDay === 'evening' || analysis.lighting === 'golden_hour') {
        prompt += ', golden hour lighting, warm sunset tones';
      } else if (analysis.timeOfDay === 'night') {
        prompt += ', evening lighting, sultry night vibes';
      }
    }
    
    // EXPLICIT - Match caption's suggestiveness, location, and mood
    else if (postType === 'explicit') {
      let explicitPrompts = [
        `Suggestive photo of ${physicalDesc}, intimate lighting, alluring expression, tasteful composition`,
        `${physicalDesc} in revealing outfit, seductive pose, dim romantic lighting, artistic sensuality`,
        `Sultry portrait of ${physicalDesc}, provocative pose, sensual atmosphere, artistic`,
        `${physicalDesc} in silk robe, intimate moment, soft lighting, artistic boudoir style`,
        `Artistic intimate shot of ${physicalDesc}, dramatic shadows, alluring gaze, sensual mood`,
        `${physicalDesc} in lace outfit, romantic lighting, seductive expression, classy provocation`
      ];
      
      // Location-specific explicit content
      if (analysis.location === 'bedroom' || analysis.location === 'home') {
        prompt = `${physicalDesc} bedroom setting, intimate outfit, soft lighting, seductive pose, private moment`;
      } else if (analysis.location === 'bathroom') {
        prompt = `${physicalDesc} bathroom setting, steam or soft lighting, intimate moment, artistic sensuality`;
      } else if (analysis.location === 'office') {
        prompt = `${physicalDesc} in after-hours office, loosened professional clothing, suggestive pose, dramatic lighting`;
      } else {
        prompt = explicitPrompts[Math.floor(Math.random() * explicitPrompts.length)];
      }
      
      // Add flirty/mood emphasis
      if (analysis.mood === 'flirty') {
        prompt += ', extra seductive energy, provocative gaze';
      } else if (analysis.mood === 'confident') {
        prompt += ', bold confident sexuality, powerful allure';
      }
      
      // Time/lighting adjustments
      if (analysis.timeOfDay === 'night' || analysis.timeOfDay === 'latenight') {
        prompt += ', night time intimacy, dim ambient lighting';
      } else if (analysis.lighting === 'moody') {
        prompt += ', moody dramatic lighting, artistic shadows';
      }
    }
    
    // MEME POSTS - Use generic meme templates (captions are the content)
    else if (postType === 'meme') {
      const memePrompts = basePrompts.meme;
      prompt = memePrompts[Math.floor(Math.random() * memePrompts.length)];
    }
    
    // TRAVEL POSTS - Match activity/location/weather from caption + SPECIFIC DETAILS!
    else if (postType === 'travel') {
      // PRIORITY 1: Use specific details from caption (cities, landmarks, features)
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0]; // Use first specific detail
        
        // Famous cities
        if (['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'dubai', 'bali', 'santorini', 'venice', 'new york', 'nyc', 'manhattan', 'los angeles', 'miami', 'vegas', 'hawaii', 'iceland', 'maldives'].includes(detail)) {
          prompt = `Beautiful scenic view of ${detail}, iconic travel destination, stunning photography`;
          // Add specific features if mentioned
          if (analysis.specificDetails.includes('bamboo')) prompt = `Bamboo forest in ${detail}, tall bamboo trees, serene green path, asian travel aesthetic`;
          else if (analysis.specificDetails.includes('cherry blossom')) prompt = `Cherry blossoms in ${detail}, pink sakura trees, springtime beauty, japanese aesthetic`;
          else if (analysis.specificDetails.includes('temple')) prompt = `Ancient temple in ${detail}, cultural landmark, travel photography, architectural beauty`;
          else if (analysis.specificDetails.includes('beach')) prompt = `Beach paradise in ${detail}, turquoise water, tropical vacation, stunning coastal view`;
          else if (analysis.specificDetails.includes('mountains')) prompt = `Mountain view in ${detail}, scenic peaks, alpine landscape, adventure travel`;
          else if (analysis.specificDetails.includes('skyline')) prompt = `City skyline of ${detail}, urban landscape, metropolitan beauty, travel photography`;
          else if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated beauty';
          else if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
        }
        // Unique features (bamboo, cherry blossoms, waterfalls, etc.)
        else if (['bamboo', 'cherry blossom', 'waterfall', 'volcano', 'aurora', 'northern lights', 'castle', 'temple', 'shrine', 'pagoda', 'lighthouse', 'windmill', 'ruins', 'pyramids', 'taj mahal', 'eiffel tower', 'colosseum', 'mount fuji', 'grand canyon'].includes(detail)) {
          prompt = `Stunning ${detail} view, travel destination, breathtaking scenery, wanderlust photography`;
          if (detail === 'bamboo') prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
          else if (detail === 'cherry blossom') prompt = `Cherry blossom trees in full bloom, pink sakura petals, springtime beauty, japanese aesthetic, magical scene`;
          else if (detail === 'waterfall') prompt = `Majestic waterfall, cascading water, lush greenery, nature paradise, adventure travel`;
          else if (detail === 'aurora' || detail === 'northern lights') prompt = `Aurora borealis dancing in night sky, northern lights, colorful sky phenomenon, arctic beauty`;
          else if (detail === 'castle') prompt = `Ancient castle, medieval architecture, historical landmark, european travel, fairytale aesthetic`;
          else if (detail === 'temple' || detail === 'shrine') prompt = `Sacred temple, ornate architecture, cultural heritage, spiritual destination, travel photography`;
          else if (detail === 'lighthouse') prompt = `Coastal lighthouse, ocean view, maritime charm, seaside travel, scenic beauty`;
          else if (detail === 'volcano') prompt = `Active volcano, dramatic landscape, adventure travel, powerful nature, unique destination`;
          else if (detail === 'ruins') prompt = `Ancient ruins, historical site, archaeological wonder, travel exploration, timeless beauty`;
        }
        // Specific activities
        else if (['safari', 'cruise', 'yacht', 'snorkeling', 'scuba diving', 'skiing', 'snowboarding', 'hot air balloon', 'helicopter ride'].includes(detail)) {
          if (detail === 'safari') prompt = `Safari adventure, wildlife viewing, african landscape, jeep tour, nature exploration`;
          else if (detail === 'cruise' || detail === 'yacht') prompt = `Luxury cruise/yacht, ocean view, deck relaxation, maritime travel, vacation vibes`;
          else if (detail === 'snorkeling' || detail === 'scuba diving') prompt = `Underwater adventure, tropical reef, marine life, diving/snorkeling, aquatic beauty`;
          else if (detail === 'skiing' || detail === 'snowboarding') prompt = `Ski resort, snowy slopes, winter sports, mountain adventure, alpine scenery`;
          else if (detail === 'hot air balloon') prompt = `Hot air balloon ride, aerial view, floating above landscape, sunrise/sunset adventure`;
          else if (detail === 'helicopter ride') prompt = `Helicopter tour, aerial photography, bird's eye view, scenic flight, adventure travel`;
        }
      }
      // PRIORITY 2: Activity-based travel
      else if (analysis.activity === 'workout' || analysis.activity === 'hiking') {
        prompt = `${physicalDesc} on hiking trail, athletic gear, nature adventure, scenic mountain vista`;
      } else if (analysis.activity === 'swimming') {
        prompt = `${physicalDesc} at pool or beach, swimming, tropical water, vacation mode`;
      }
      // PRIORITY 3: Location-based travel
      else if (analysis.location === 'beach') {
        prompt = `Beautiful beach scene, turquoise water, white sand, palm trees, paradise destination, vacation vibes`;
        if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
      } else if (analysis.location === 'mountains') {
        prompt = `${physicalDesc} at mountain summit, scenic overlook, dramatic peaks, adventure achievement`;
        if (analysis.weather === 'snowy') prompt += ', snow-covered peaks, winter wonderland';
      } else if (analysis.location === 'airport') {
        prompt = `Airport terminal view, planes visible, departure board, travel excitement, wanderlust`;
      } else if (analysis.location === 'hotel') {
        prompt = `Hotel room view, city skyline through window, travel vibes, vacation accommodation`;
      } else if (analysis.location === 'city') {
        prompt = `Stunning city skyline, urban exploration, city lights, travel photography, metropolitan vibes`;
        if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated buildings';
      } else if (analysis.location === 'forest') {
        // Check for bamboo specifically in raw caption
        if (analysis.rawCaption && analysis.rawCaption.toLowerCase().includes('bamboo')) {
          prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
        } else {
          prompt = `Forest trail scene, nature path, trees, outdoor adventure, peaceful wilderness`;
        }
      } else if (analysis.location === 'countryside') {
        prompt = `Countryside landscape, rural scenery, fields, peaceful nature, escape from city`;
      }
      // Weather-based travel
      else if (analysis.weather === 'snowy') {
        prompt = `Snowy mountain scene, winter sports, ski resort view, alpine scenery, cold weather travel`;
      } else if (analysis.weather === 'sunny' && analysis.season === 'summer') {
        prompt = `Tropical beach paradise, bright sunshine, summer vacation, turquoise water, relaxation`;
      }
      // Season-based travel
      else if (analysis.season === 'fall') {
        prompt = `Autumn landscape, fall foliage, colorful leaves, scenic beauty, seasonal travel`;
      } else if (analysis.season === 'spring') {
        prompt = `Spring scenery, blooming flowers, fresh greenery, beautiful season, nature awakening`;
      }
      // Mood-based travel
      else if (analysis.mood === 'relaxed') {
        prompt = `Peaceful vacation scene, relaxation vibes, tranquil destination, stress-free moment`;
      } else if (analysis.mood === 'excited') {
        prompt = `${physicalDesc} excited at destination, arms raised, adventure energy, travel joy`;
      }
      // Default travel prompts
      else {
        const travelPrompts = basePrompts.travel;
        prompt = travelPrompts[Math.floor(Math.random() * travelPrompts.length)];
      }
    }
    
    // LIFE UPDATE - Match activity, mood, objects from caption + SPECIFIC DETAILS!
    else if (postType === 'life_update') {
      // PRIORITY 1: Use specific activities from caption
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0];
        
        if (detail === 'dance party' || detail === 'dancing party') {
          prompt = `${physicalDesc} at dance party, dancing with friends, party lights, music vibes, energetic celebration, fun social gathering`;
          if (analysis.timeOfDay === 'night') prompt += ', nighttime party energy, colorful lights';
        } else if (detail === 'coding session' || detail === 'coding marathon' || detail === 'coding') {
          prompt = `${physicalDesc} at desk coding, laptop screen glow, programmer aesthetic, focused developer, code on screen visible, tech workspace`;
          if (analysis.timeOfDay === 'night' || detail.includes('midnight')) prompt += ', late night coding, dark room with screen glow, night owl developer energy';
        } else if (detail === 'hackathon') {
          prompt = `${physicalDesc} at hackathon event, intense coding, tech competition, developer energy, multiple screens, programming marathon`;
        } else if (detail === 'photoshoot' || detail === 'photo shoot') {
          prompt = `${physicalDesc} during photoshoot, camera equipment visible, professional lighting, model pose, photography session`;
        } else if (detail === 'wine tasting' || detail === 'beer tasting') {
          prompt = `${physicalDesc} at tasting event, wine/beer glasses, elegant setting, sophisticated social gathering, sampling drinks`;
        } else if (detail === 'brunch') {
          prompt = `${physicalDesc} at brunch, restaurant table with food and mimosas, social dining, weekend vibes, friends gathering`;
        } else if (detail === 'karaoke') {
          prompt = `${physicalDesc} singing karaoke, microphone in hand, stage lights, music performance, fun social activity`;
        } else if (detail === 'game night') {
          prompt = `Game night setup, board games or video games visible, friends gathered, snacks and drinks, fun social evening`;
        } else if (detail === 'movie night') {
          prompt = `${physicalDesc} watching movie, cozy couch setting, popcorn and drinks, screen glow, relaxation entertainment`;
        } else if (detail === 'spa day') {
          prompt = `${physicalDesc} at spa, relaxation vibes, face mask or robe, pampering session, self-care luxury, wellness treatment`;
        } else if (detail === 'road trip') {
          prompt = `${physicalDesc} on road trip, car interior view, scenic highway, adventure travel, open road vibes`;
        } else if (detail === 'camping trip' || detail === 'glamping') {
          prompt = `Camping scene, tent or glamping setup, nature outdoor, campfire visible, wilderness adventure, outdoor lifestyle`;
        } else if (detail === 'yacht' || detail === 'sailing') {
          prompt = `${physicalDesc} on yacht/sailboat, ocean water, luxury boating, nautical lifestyle, maritime adventure`;
        }
      }
      
      // PRIORITY 2: Activity-based prompts
      const activityPrompts = {
        workout: `${physicalDesc} in athletic gear, fitness journey, exercise setting, healthy lifestyle`,
        yoga: `${physicalDesc} on yoga mat, meditation space, zen energy, wellness practice`,
        cooking: `${physicalDesc} in kitchen, cooking ingredients visible, culinary hobby, proud chef moment`,
        reading: `${physicalDesc} with book in cozy chair, reading nook, warm lighting, intellectual moment`,
        gaming: `Gaming setup, controller or keyboard, screen glow, colorful RGB lights, gamer lifestyle, focused play`,
        art: `${physicalDesc} with art supplies, creative project, painting or drawing, artistic focus, canvas visible`,
        music: `${physicalDesc} with instrument, music practice, creative hobby, passionate musician`,
        dancing: `${physicalDesc} dancing, movement energy, music vibes, expressive moment`,
        shopping: `${physicalDesc} with shopping bags, retail therapy, new purchases, happy consumer`,
        cleaning: `${physicalDesc} organizing space, cleaning supplies, tidy home, productive vibes`,
        studying: `${physicalDesc} with books and laptop, studying hard, focused learning, academic dedication`,
        diy: `${physicalDesc} with tools, DIY project, building something, hands-on creativity`,
        gardening: `${physicalDesc} in garden, plants and flowers, dirt hands, outdoor hobby, nature connection`,
        pets: `${physicalDesc} with pet, cuddles and love, animal companion, wholesome moment`,
        selfcare: `${physicalDesc} spa day vibes, face mask or pampering, relaxation mode, treating self`,
        celebration: `${physicalDesc} celebrating, party decorations, achievement moment, festive energy`
      };
      
      if (analysis.activity && activityPrompts[analysis.activity]) {
        prompt = activityPrompts[analysis.activity];
      }
      // Location-based life updates
      else if (analysis.location === 'home' || analysis.location === 'bedroom') {
        prompt = `${physicalDesc} cozy at home, relaxed setting, personal space, comfortable vibes`;
        if (analysis.mood === 'relaxed') prompt += ', peaceful calm energy';
      } else if (analysis.location === 'kitchen') {
        prompt = `${physicalDesc} in kitchen, cooking or baking, domestic scene, home chef energy`;
      } else if (analysis.location === 'gym') {
        prompt = `${physicalDesc} at gym, workout equipment visible, fitness dedication, health journey`;
      }
      // Object-based life updates
      else if (analysis.object === 'book') {
        prompt = `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`;
      } else if (analysis.object === 'laptop') {
        prompt = `Home office setup, organized desk, laptop, productivity space, work-from-home life`;
      } else if (analysis.object === 'headphones') {
        prompt = `${physicalDesc} with headphones, music listening, relaxed vibes, audio enjoyment`;
      }
      // Mood-based life updates
      else if (analysis.mood === 'proud') {
        prompt = `${physicalDesc} showing off accomplishment, proud moment, achievement display, satisfied expression`;
      } else if (analysis.mood === 'motivated') {
        prompt = `${physicalDesc} motivated energy, goal-focused, determined look, hustle mode`;
      } else if (analysis.mood === 'relaxed') {
        prompt = `${physicalDesc} in relaxation mode, cozy space, calm energy, self-care moment`;
      }
      // Default life update prompts
      else {
        const lifePrompts = basePrompts.life_update;
        prompt = lifePrompts[Math.floor(Math.random() * lifePrompts.length)];
      }
    }
    
    // Fallback to original templates
    else {
      const prompts = basePrompts[postType] || basePrompts.selfie;
      prompt = prompts[Math.floor(Math.random() * prompts.length)];
    }
    
    // Add personality modifiers
    if (personality.confidence > 70 && ['selfie', 'thirst_trap'].includes(postType)) {
      prompt += ', bold confident expression';
    }
    if (personality.flirty > 70 && ['thirst_trap', 'explicit', 'selfie'].includes(postType)) {
      prompt += ', flirtatious energy';
    }
    
    return prompt;
  }
  
  /**
   * Generate autonomous comments on recent posts
   */
  async function generateAutonomousComments() {
    // Get recent posts (last 10)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 10);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    // Each employee has a chance to comment on posts
    for (const employee of activeEmployees) {
      // 10% chance to comment (REDUCED FROM 20% FOR PERFORMANCE)
      if (Math.random() > 0.1) continue;
      
      // Select random post (not their own)
      const eligiblePosts = recentPosts.filter(p => 
        p.authorId !== employee.id && 
        !p.comments.some(c => c.authorId === employee.id) // Haven't commented yet
      );
      
      if (eligiblePosts.length === 0) continue;
      
      const post = eligiblePosts[Math.floor(Math.random() * eligiblePosts.length)];
      
      // Get relationship with post author
      const relationship = employee.relationships?.[post.authorId];
      const relationType = relationship?.type || 'neutral';
      
      // Generate comment based on relationship
      const commentText = await generateComment(employee, post, relationType);
      
      const comment = createComment({
        postId: post.id,
        authorId: employee.id,
        authorName: employee.name,
        content: commentText
      });
      
      post.comments.push(comment);
      
      // Small chance (15%) for viral engagement - NPC comment triggers reinvigoration
      if (post.comments.length >= 3 && Math.random() < 0.15) {
        console.log(`[Autonomous] 🔥 ${employee.name}'s comment sparked viral engagement!`);
        setTimeout(async () => {
          await triggerAdditionalNPCComments(post);
        }, 6000 + Math.random() * 8000); // 6-14 seconds delay
      }
      
      // 🌐 Evaluate relationship between commenter and post author
      const postAuthor = gameState.employees.find(e => e.id === post.authorId);
      
      console.log(`[Autonomous] ${employee.name} commented on ${post.isPlayerPost ? 'player' : postAuthor?.name}'s post`);
      
      if (postAuthor && postAuthor.id !== employee.id) {
        await evaluateNPCReactionToPost(employee, postAuthor, post, commentText);
      }
      
      // AGGRESSIVE FIX: Always update immediately, no visibility checks
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Autonomous] FORCE updating comments for post ${post.id}`);
        updateCommentsSection(postEl, post);
      }
      
      // Request smart feed update as backup
      requestSmartFeedUpdate(post.id);
    }
  }
  
  /**
   * Trigger targeted comments from NPCs mentioned in tea-spilling posts
   * NPCs who are called out feel compelled to respond
   */
  async function triggerTeaSpillingComments(post, author) {
    // Extract @mentions from post content using smart extraction
    const extractedMentions = extractMentions(post.content);
    
    if (extractedMentions.length === 0) return;
    
    console.log(`[Social] Tea-spilling post has ${extractedMentions.length} mentions, triggering targeted comments`);
    
    // Get mentioned employee objects
    const mentionedEmployees = extractedMentions
      .map(m => gameState.employees.find(e => e.id === m.employeeId))
      .filter(e => e && e.id !== author.id);
    
    // 70-90% chance each mentioned NPC comments (they feel called out!)
    for (let i = 0; i < mentionedEmployees.length; i++) {
      const npc = mentionedEmployees[i];
      const shouldComment = Math.random() < 0.7 + Math.random() * 0.2;
      
      if (!shouldComment) continue;
      
      const delay = (i + 1) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateTeaSpillingResponse(npc, post, author);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        // Store in memory - they were called out!
        remember(npc, `${author.name} called me out in a post about: "${post.content}"`, 'event', 2.5);
        remember(author, `${npc.name} responded to my tea-spilling post`, 'interaction', 1.5);
        
        // Relationship might change depending on response
        const relationship = npc.relationships?.[author.id];
        if (relationship) {
          // Drama can strain or strengthen relationships
          const isDramatic = Math.random() < 0.3;
          relationship.strength += isDramatic ? -3 : 1;
        }
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
    
    // Others might also comment for the drama (20% of non-mentioned people)
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== author.id &&
      !mentionedEmployees.find(m => m.id === e.id)
    );
    
    const bystanders = Math.min(2, Math.floor(activeEmployees.length * 0.2));
    for (let i = 0; i < bystanders; i++) {
      const npc = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      const delay = (mentionedEmployees.length + i + 1) * (2000 + Math.random() * 4000);
      
      setTimeout(async () => {
        const reactions = [
          '👀🍿', 'The TEA is hot today', 'I\'m just here for the comments 🍿',
          'This is MESSY 💀', 'Drama!! 🫖', 'Oh wow 😳', 'Spicy 🌶️',
          'Not this on my feed 😂', 'The audacity lol', '💀💀💀'
        ];
        
        const commentText = reactions[Math.floor(Math.random() * reactions.length)];
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Generate a response from someone called out in a tea-spilling post
   */
  async function generateTeaSpillingResponse(npc, post, author) {
    const affection = npc.stats?.affection || 0;
    const personality = npc.personality || {};
    const relationship = npc.relationships?.[author.id];
    
    // Determine response tone
    const isEmbarrassed = personality.confidence < 50;
    const isDefiant = personality.confidence > 70;
    const isFriendly = relationship?.type === 'friend' || relationship?.type === 'best_friend';
    const intimacy = npc.intimacy || 0;
    
    const prompt = `You are ${npc.name}. ${author.name} just called you out in a social media post that says: "${post.content}"

YOUR PERSONALITY: confidence: ${personality.confidence}/100, outgoing: ${personality.outgoing}/100, flirty: ${personality.flirty}/100
YOUR RELATIONSHIP WITH ${author.name}: ${relationship?.type || 'coworker'}

Write a SHORT comment response (5-15 words) that reacts to being called out. Options:
${isEmbarrassed ? '- Play it off embarrassed/shy' : ''}
${isDefiant ? '- Own it confidently' : ''}
${isFriendly ? '- Playfully banter back' : ''}
${intimacy > 40 ? '- Flirt back' : ''}
- Deny it playfully
- Make a joke about it
- Call them out back

Examples:
- "WHO TOLD YOU 😭"
- "And what about it? 💅"
- "Says the one who... 👀"
- "EXCUSE ME this is slander"
- "You're one to talk 😏"
- "Mind your business lol"
- "Okay but you're not wrong 💀"

Write ONLY the comment:`;

    try {
      const response = await generateText(prompt, { temperature: 1.0, max_tokens: 40 });
      let comment = response.trim().replace(/^["']|["']$/g, '');
      
      return comment;
      
    } catch (error) {
      console.error('Tea response generation failed:', error);
      
      // Fallback templates
      if (isDefiant) {
        return ['And what about it? 💅', 'You\'re one to talk 😏', 'Mind your business lol'][Math.floor(Math.random() * 3)];
      } else if (isEmbarrassed) {
        return ['WHO TOLD YOU 😭', 'This is NOT true 💀', 'EXCUSE ME'][Math.floor(Math.random() * 3)];
      } else {
        return ['Okay but you\'re not wrong', 'Says you 👀', 'The audacity lol'][Math.floor(Math.random() * 3)];
      }
    }
  }
  
  /**
   * Generate a comment using AI or templates
   * NOW WITH FULL CONTEXT AWARENESS FOR NPC-TO-NPC INTERACTIONS
   */
  async function generateComment(employee, post, relationType) {
    const postAuthor = gameState.employees.find(e => e.id === post.authorId);
    
    // Get FULL context for this interaction
    const relationship = employee.relationships?.[post.authorId];
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    // Get their relationship with the post author (if NPC)
    const hasRelationship = postAuthor && !post.isPlayerPost;
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Determine if this should be a meaningful comment based on context
    const shouldUseMeaningfulComment = 
      post.isPlayerPost || // ALWAYS use AI for player posts!
      post.explicitLevel >= 2 || // Explicit content
      post.type === 'tea_spilling' || // Drama
      post.type === 'life_update' || // Important updates
      post.type === 'achievement' || // Milestones
      post.type === 'thirst_trap' || // Suggestive posts
      post.type === 'gossip' || // Mysterious posts
      relationshipStrength > 60 || // Close relationship
      affection > 50 || // Employee likes the player
      desire > 50 || // Employee desires the player
      intimacy > 40 || // Intimate relationship with player
      hasRelationship && (relationType === 'best_friend' || relationType === 'romantic' || relationType === 'rival' || relationType === 'enemy');
    
    // Use AI for meaningful comments, quick templates for casual interactions
    if (shouldUseMeaningfulComment) {
      console.log(`[Social] ${employee.name} using AI comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post (type: ${post.type}, explicit: ${post.explicitLevel})`);
      try {
        return await generateAIComment(employee, post, postAuthor, relationship, relationType);
      } catch (error) {
        console.error('AI comment failed, using enhanced templates:', error);
        return generateEnhancedTemplateComment(employee, post, postAuthor, relationType);
      }
    }
    
    // Quick casual comments for basic interactions
    console.log(`[Social] ${employee.name} using casual comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post`);
    return generateCasualComment(employee, post, relationType);
  }
  
  /**
   * Generate AI-powered comment with full context awareness
   * THIS IS WHERE THE JUICE HAPPENS
   */
  async function generateAIComment(commenter, post, postAuthor, relationship, relationType) {
    const commenterPersonality = commenter.personality || {};
    const postAuthorPersonality = postAuthor?.personality || {};
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Get recent interactions between these two NPCs
    const recentInteractions = relationshipHistory.slice(-3).map(h => h.description).join('; ') || 'No recent history';
    
    // Build comprehensive context
    const isPlayerPost = post.isPlayerPost;
    const targetName = isPlayerPost ? 'the boss' : postAuthor.name;
    
    // GET CONVERSATION CONTEXT - This is the juicy stuff!
    let conversationContext = '';
    
    // If commenting on player's post, check DM history with player
    if (isPlayerPost) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-10); // Last 10 messages
      
      if (recentDMs.length > 0) {
        // Extract juicy details from recent DMs
        const juicyDetails = recentDMs
          .filter(msg => msg.content && msg.content.length > 10)
          .slice(-5) // Last 5 meaningful messages
          .map(msg => {
            const speaker = msg.sender === 'player' ? 'Boss' : commenter.name;
            return `${speaker}: "${msg.content.substring(0, 100)}"`;
          })
          .join('\n');
        
        if (juicyDetails) {
          conversationContext = `\n\nRECENT DM CONVERSATION WITH BOSS:
${juicyDetails}

You can reference things from your DMs if relevant! Examples:
- "Well you told me you were working late tonight 👀"
- "That's funny because you said something totally different to me earlier"
- "Didn't you just say you hated this? 😂"
- "Interesting... remember what we talked about?"
- "This contradicts what you told me but ok"`;
        }
      }
    }
    
    // If commenting on another NPC's post, check if we have DM history with the BOSS about this person
    if (!isPlayerPost && postAuthor) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-20); // Look further back
      
      // Check if we've talked about this person with the boss
      const mentionsOfTarget = recentDMs.filter(msg => 
        msg.content && (
          msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
          msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
        )
      );
      
      if (mentionsOfTarget.length > 0) {
        const gossipDetails = mentionsOfTarget.slice(-3).map(msg => {
          const speaker = msg.sender === 'player' ? 'Boss' : 'You';
          return `${speaker}: "${msg.content.substring(0, 100)}"`;
        }).join('\n');
        
        conversationContext = `\n\nYOU'VE DISCUSSED ${postAuthor.name.toUpperCase()} WITH THE BOSS:
${gossipDetails}

You can call them out based on what you know! Examples:
- "That's not what I heard 👀"
- "Interesting... the boss told me something different about you"
- "Funny timing after what happened"
- "Everyone's talking about you btw"
- "The boss was just telling me about this actually"`;
      }
    }
    
    // CROSS-REFERENCE: Check if other NPCs have talked about the post author with the player
    if (!isPlayerPost && postAuthor) {
      // Check ALL employee DM histories for mentions of this person
      let heardGossip = '';
      for (const employee of gameState.employees) {
        if (employee.id === commenter.id || employee.id === postAuthor.id) continue;
        
        const theirDMs = gameState.chatHistory[employee.id] || [];
        const theirGossip = theirDMs.filter(msg =>
          msg.content && (
            msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
            msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
          )
        ).slice(-2); // Just the most recent gossip
        
        if (theirGossip.length > 0 && Math.random() < 0.3) { // 30% chance to reference others' gossip
          heardGossip = `\n\nGOSSIP YOU'VE HEARD:
${employee.name} was talking about ${postAuthor.name}: "${theirGossip[0].content.substring(0, 80)}"

You heard through the grapevine! Examples:
- "Is it true what everyone's saying?"
- "I heard some interesting things about you"
- "People are talking 👀"
- "The whole office has been discussing this"`;
          break; // Just use the first gossip found
        }
      }
      
      if (heardGossip) {
        conversationContext += heardGossip;
      }
    }
    
    // Determine emotional context
    let emotionalContext = '';
    if (relationType === 'romantic') {
      emotionalContext = `You're romantically involved with ${targetName}. Your comments should show affection and intimacy.`;
    } else if (relationType === 'crush') {
      emotionalContext = `You have a crush on ${targetName}. You're trying to flirt subtly but also play it cool.`;
    } else if (relationType === 'best_friend') {
      emotionalContext = `${targetName} is your best friend. You can be playful, supportive, or tease them.`;
    } else if (relationType === 'friend') {
      emotionalContext = `You're friends with ${targetName}. Keep it friendly and supportive.`;
    } else if (relationType === 'rival') {
      emotionalContext = `You and ${targetName} are rivals. There's competitive tension. Be subtly shady or backhanded.`;
    } else if (relationType === 'enemy') {
      emotionalContext = `You don't like ${targetName}. Your comment can be dismissive, sarcastic, or pointedly critical.`;
    } else {
      emotionalContext = `You're coworkers with ${targetName}. This is a PERSONAL social network (like Instagram), not work chat - be casual, real, and fun.`;
    }
    
    // Special context for different post types
    let postTypeContext = '';
    if (post.type === 'tea_spilling') {
      postTypeContext = 'This is DRAMA. They\'re spilling tea about someone. React with appropriate shock, support, or defense of the person being called out.';
    } else if (post.type === 'thirst_trap' || post.explicitLevel >= 2) {
      postTypeContext = 'This is suggestive/explicit content. React appropriately based on your relationship and personality. Could be supportive, flirty, shocked, or disapproving.';
    } else if (post.type === 'life_update') {
      postTypeContext = 'This is an important life update. Show genuine interest or concern.';
    } else if (post.type === 'achievement') {
      postTypeContext = 'They\'re celebrating an achievement. React with congratulations (genuine or backhanded based on relationship).';
    } else if (post.type === 'complaint') {
      postTypeContext = 'They\'re venting or complaining. Commiserate, offer advice, or dismiss them based on your relationship.';
    } else if (post.type === 'gossip') {
      postTypeContext = 'They\'re being cryptic/mysterious about drama. Either ask for details, play along with the mystery, or act concerned.';
    }
    
    // 🔞 CONTENT POLICY: This is an adult workplace with open, sex-positive culture
    const contentPolicy = gameState.settings?.policy || 'open';
    let toneGuidance = '';
    
    if (contentPolicy === 'open') {
      // Enthusiastic consent model - everyone is comfortable with adult content
      toneGuidance = `🔞 WORKPLACE CULTURE: This is an open, sex-positive workplace. Explicit content, sexual references, and adult humor are NORMAL and accepted by everyone. DO NOT act shocked, prudish, or suggest keeping things "PG" or "family-friendly" - that's NOT how this workplace operates. Be natural, comfortable, and match the energy of explicit content without moralizing.`;
    } else if (contentPolicy === 'professional') {
      toneGuidance = `WORKPLACE CULTURE: Maintain professional boundaries. Sexual content should be addressed tactfully with appropriate workplace discretion.`;
    } else {
      // Casual
      toneGuidance = `WORKPLACE CULTURE: Relaxed office culture. Adult content is acceptable but address it naturally based on your comfort level and relationship.`;
    }
    
    // OPTIMIZED: Short, direct prompt that forces clean output
    const prompt = `${toneGuidance}

${commenter.name} sees ${targetName}'s post: "${post.content.substring(0, 100)}"
Rel: ${relationType} (${relationshipStrength}/100)
Personality: Conf${commenterPersonality.confidence||50} Out${commenterPersonality.outgoing||50} Flirt${commenterPersonality.flirty||50} Pro${commenterPersonality.professional||50}
${post.explicitLevel >= 2 ? 'EXPLICIT POST - respond naturally without moralizing' : ''}${conversationContext ? '\nHAS INSIDER INFO FROM DMS' : ''}

Comment (5-25 words, reference post specifics, show personality):`;


    const response = await generateText(prompt, { 
      temperature: 0.9,  // Reduced from 1.0 for more consistency
      top_p: 0.95,       // Limit token sampling
      max_tokens: 40,    // Slightly increased for 25-word limit
      stopSequences: ['\n', '\n\n', '.)', '".', 'Rating', 'Rationale', 'Why', 'Because', '{SEEDS', '{BAN', '{BOOST', '---', '(Relationship', 'Physical', 'Brainstorm', 'Good approach', 'Bad approach', 'Final', 'Boss', 'personality traits']  // EXPANDED
    });
    
    let comment = response.trim();
    
    // NUCLEAR OPTION: Aggressive cleanup to remove ALL meta-commentary
    
    // CRITICAL: Take ONLY first line/sentence to cut meta-text
    comment = comment.split('\n')[0].trim();
    
    // CRITICAL: If we see ANY meta-patterns, stop at them
    const metaMarkers = ['Boss', 'personality traits:', 'Brainstorm', 'Good approach', 'Bad approach', 'Final', 'Word count', 'matches', 'References', 'Playful', 'Emoji use'];
    for (const marker of metaMarkers) {
      const idx = comment.indexOf(marker);
      if (idx > 10) { // If marker appears after 10 chars, cut everything after
        comment = comment.substring(0, idx).trim();
        break;
      }
    }
    
    // Remove Perchance formatting tokens (can appear anywhere)
    comment = comment.replace(/\{SEEDS:[^}]*\}/gi, '');
    comment = comment.replace(/\{BAN:[^}]*\}/gi, '');
    comment = comment.replace(/\{BOOST:[^}]*\}/gi, '');
    comment = comment.replace(/\{[A-Z_]+:[^}]*\}/g, '');
    comment = comment.replace(/\s*---\s*/g, ' '); // Remove separators
    
    // Remove quotes
    comment = comment.replace(/^["']|["']$/g, '');
    
    // Remove "Name:" or "Name's Comment:" prefix
    comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*'?s?\s*(?:Comment)?:\s*/g, '');
    
    // Remove **Name** prefix
    comment = comment.replace(/^\*\*\([^)]+\)\*\*\s*/g, '');
    comment = comment.replace(/^\*\*[^*]+\*\*:\s*/g, '');
    
    // Remove parenthetical meta-notes at end
    comment = comment.replace(/\s*\([^)]{15,}\)\s*$/i, ''); // Long parentheticals
    comment = comment.replace(/\s*\(Relationship[^)]*\)\s*$/i, '');
    comment = comment.replace(/\s*\(Word count[^)]*\)\s*$/i, '');
    comment = comment.replace(/\s*\(\d+\s*(?:words?|characters?)[^)]*\)\s*$/i, '');
    
    // If comment starts with meta-text, it's broken - return fallback
    if (/^(Boss|Personality|Brainstorm|Good|Bad|Final|Physical|The comment)/i.test(comment)) {
      console.warn(`[Comment] Meta-text detected, using fallback: "${comment.substring(0, 50)}"`);
      return generateEnhancedTemplateComment(commenter, post, postAuthor, relationType);
    }
    
    comment = comment.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
    comment = comment.trim();
    
    // Ensure reasonable length
    if (comment.length > 150) {
      comment = comment.substring(0, 147) + '...';
    }
    
    // Detect if this comment reveals DM knowledge (spicy!)
    const revealsPrivateInfo = conversationContext && (
      comment.toLowerCase().includes('told me') ||
      comment.toLowerCase().includes('said') ||
      comment.toLowerCase().includes('dm') ||
      comment.toLowerCase().includes('conversation') ||
      comment.toLowerCase().includes('earlier') ||
      comment.toLowerCase().includes('different') ||
      comment.toLowerCase().includes('heard') ||
      comment.toLowerCase().includes('everyone knows')
    );
    
    // Store this interaction in relationship history
    if (relationship && !isPlayerPost) {
      const historyEntry = {
        timestamp: Date.now(),
        description: `Commented on their post: "${comment}"${revealsPrivateInfo ? ' [EXPOSED PRIVATE INFO!]' : ''}`,
        impact: relationType === 'enemy' ? -2 : relationType === 'rival' ? -1 : 1,
        causedDrama: revealsPrivateInfo
      };
      
      if (!relationship.history) relationship.history = [];
      relationship.history.push(historyEntry);
      if (relationship.history.length > 10) relationship.history.shift();
      
      // Adjust relationship strength based on comment tone
      if (relationType === 'enemy' || relationType === 'rival') {
        relationship.strength = Math.max(0, relationship.strength - 1);
      } else {
        relationship.strength = Math.min(100, relationship.strength + 1);
      }
      
      // If revealing private info, damage trust even among friends!
      if (revealsPrivateInfo && relationType !== 'enemy') {
        relationship.strength = Math.max(0, relationship.strength - 3);
        console.log(`[Drama] ${commenter.name} exposed private info about ${postAuthor.name}! Trust -3`);
      }
    }
    
    // If player's post and commenter revealed DM knowledge, they might get confronted later
    if (isPlayerPost && revealsPrivateInfo) {
      // Flag for potential future confrontation/gossip
      if (!commenter.recentBehavior) commenter.recentBehavior = [];
      commenter.recentBehavior.push({
        type: 'revealed_dm_info',
        timestamp: Date.now(),
        comment: comment
      });
      if (commenter.recentBehavior.length > 5) commenter.recentBehavior.shift();
      
      console.log(`[Drama] ${commenter.name} publicly referenced private DMs with boss!`);
    }
    
    console.log(`[Social${revealsPrivateInfo ? ' 🫖' : ''}] ${commenter.name} → ${targetName}: "${comment}"`);
    
    return comment;
  }
  
  /**
   * Enhanced template-based comments (fallback for AI failure)
   * Much better than the old generic ones
   */
  function generateEnhancedTemplateComment(commenter, post, postAuthor, relationType) {
    const personality = commenter.personality || {};
    const isConfident = personality.confidence > 60;
    const isFlirty = personality.flirty > 60;
    const isOutgoing = personality.outgoing > 60;
    
    // Post-type specific templates
    if (post.type === 'tea_spilling') {
      const dramaTemplates = [
        'WAIT what?! I need the full story rn �',
        'The TEA is piping hot today ☕',
        'This is MESSY and I\'m here for it 🍿',
        'SAY IT LOUDER FOR THE PEOPLE IN THE BACK',
        'Not this on my feed ��',
        'The way I gasped at this',
        'Oop- somebody said it finally',
        'This is the content I signed up for 🫖'
      ];
      return dramaTemplates[Math.floor(Math.random() * dramaTemplates.length)];
    }
    
    if (post.explicitLevel >= 2 || post.type === 'thirst_trap') {
      if (relationType === 'romantic' || relationType === 'crush') {
        return ['🥵🥵🥵', 'Stop it you\'re killing me', 'How are you even REAL', 'Not fair 😭🔥'][Math.floor(Math.random() * 4)];
      } else if (isFlirty) {
        return ['Okay WOW 👀', 'The AUDACITY �', 'You really did that huh', 'Damn �'][Math.floor(Math.random() * 4)];
      } else {
        return ['Looking good! 🔥', 'Confidence! ✨', 'Serving looks!', 'Get it! 💯'][Math.floor(Math.random() * 4)];
      }
    }
    
    if (post.type === 'complaint') {
      const sympathyTemplates = [
        'Ugh I felt that in my SOUL',
        'No literally why is it like this',
        'This is so valid honestly',
        'The way this is my daily struggle',
        'Someone needed to say it'
      ];
      const dismissiveTemplates = [
        'It\'s really not that deep',
        'Sure Jan 🙄',
        'Okay but like... why tho',
        'Interesting take'
      ];
      
      if (relationType === 'enemy' || relationType === 'rival') {
        return dismissiveTemplates[Math.floor(Math.random() * dismissiveTemplates.length)];
      }
      return sympathyTemplates[Math.floor(Math.random() * sympathyTemplates.length)];
    }
    
    // Relationship-based templates
    if (relationType === 'best_friend') {
      return [
        'BESTIE!! This is everything 💕',
        'Why are you like this I love you 😂',
        'The way you always serve content',
        'This is why you\'re my favorite person',
        'Not you coming for my whole existence',
        'Okay this made my entire day'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'romantic') {
      return [
        'You\'re stunning I can\'t 😍',
        'Miss you already ❤️',
        'How did I get this lucky',
        'Beautiful inside and out 💕',
        'Come over? 👀'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'crush') {
      return [
        'Wow 😳',
        'This look though 👀',
        'Okay I see you 🔥',
        'Um hello?? 😍',
        'Not me blushing at this'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'rival') {
      return [
        'Interesting choice',
        'Sure that\'s one way to do it',
        'Bold of you 🙄',
        'Okay and?',
        'If you say so',
        'Meh I\'ve seen better'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'enemy') {
      return [
        '🙄',
        'Whatever',
        'Seriously?',
        'Okay cool story',
        'Not interested',
        'Pass'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Friend templates
    if (relationType === 'friend') {
      return [
        'Haha love this energy!',
        'You always have the best posts ✨',
        'This is so YOU I love it',
        'Main character moment!',
        'Living for this vibe',
        'The way you just understood the assignment'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Default neutral but more interesting
    const neutralTemplates = [
      'This hits different',
      'Okay this is actually great',
      'Valid honestly',
      'Needed to see this today',
      'The vibe is immaculate',
      'This energy >>>',
      'No notes this is perfect'
    ];
    
    return neutralTemplates[Math.floor(Math.random() * neutralTemplates.length)];
  }
  
  /**
   * Quick casual comments for low-stakes interactions
   */
  function generateCasualComment(employee, post, relationType) {
    // Special handling for player posts
    if (post.isPlayerPost) {
      const affection = employee.stats?.affection || 0;
      const desire = employee.stats?.desire || 0;
      const intimacy = employee.intimacy || 0;
      
      if (intimacy > 60 || (affection > 60 && desire > 50)) {
        return ['Love this boss! �', 'You look amazing! �', 'Boss energy ✨', 'Stunning! 💕'][Math.floor(Math.random() * 4)];
      } else if (affection > 40) {
        return ['Nice post boss!', 'Love it! 😊', 'Great stuff! �', 'Looking good boss! ✨'][Math.floor(Math.random() * 4)];
      }
    }
    
    // Quick relationship-based responses
    const templates = {
      best_friend: ['Yessss! 🔥', 'Love this!', 'You always slay', 'This! 💯', 'Iconic behavior'],
      friend: ['Haha love it!', 'So good!', 'Amazing! ✨', 'This made my day', 'Yesss 🙌', 'The vibe!'],
      crush: ['😍', 'Wow 🔥', 'Um hello', '👀💕', 'Okay then'],
      romantic: ['Beautiful ❤️', 'Miss you', '😘', 'Love this babe', 'Gorgeous'],
      rival: ['Interesting...', 'Sure', 'Ok 🙄', 'Meh', 'If you say so'],
      enemy: ['🙄', 'Whatever', 'Seriously?', 'Pass', '😒'],
      neutral: ['Nice!', 'Cool vibes', 'This hits', 'Love the energy', 'Valid', '✨']
    };
    
    const options = templates[relationType] || templates.neutral;
    return options[Math.floor(Math.random() * options.length)];
  }
  
  /**
   * Generate "first post" for newly hired employee
   * Called immediately after hiring to create their introduction post
   */
  async function generateFirstEmployeePost(employee) {
    // Ensure social data exists first
    if (!employee.social) {
      initializeEmployeeSocialData(employee);
    }
    
    // Check if employee already has a first post (prevent duplicates)
    if (employee.social.hasFirstPost) return;
    
    // Mark that they've made their first post
    employee.social.hasFirstPost = true;
    
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Generate AI-powered first post
    const personalityDesc = `outgoing: ${personality.outgoing || 50}/100, professional: ${personality.professional || 50}/100, confidence: ${personality.confidence || 50}/100`;
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored social media for the FIRST TIME after just getting hired.

Your personality: ${personalityDesc}
Your role: ${employee.position || 'Employee'}
Location: ${employee.location || 'headquarters'}

Write a SHORT (1-2 sentences) first post announcing you just joined the company. Be authentic to your personality. Express excitement about starting. Use 0-2 emojis.

${social.contentStyle === 'casual' ? 'Style: Casual and friendly' : social.contentStyle === 'professional' ? 'Style: Professional but warm' : 'Style: Balanced and personable'}

Examples:
- High outgoing: "Just joined the team and already loving the energy! Can't wait to meet everyone! 🎉✨"
- High professional: "Excited to start my new role at the company. Looking forward to contributing to the team's success. 💼"
- Balanced: "First day at the new job! Feeling great about this opportunity. 😊"

Post:`;

    let content;
    try {
      content = await generateText(prompt);
      content = content.trim();
    } catch (error) {
      console.error('AI generation failed for first post:', error);
      // Fallback templates based on personality
      const fallbacks = {
        high_outgoing: [
          "Just joined the team! So excited to be here! 🎉",
          "New job, new adventures! Let's do this! ✨",
          "First day vibes! Already loving the energy here! 🚀",
          "Officially part of the team! Can't wait to meet everyone! 😊"
        ],
        high_professional: [
          "Excited to join the team and contribute to our success. 💼",
          "Looking forward to starting this new chapter. Happy to be here.",
          "Grateful for this opportunity. Ready to make an impact. 🎯",
          "Pleased to announce I've joined the company. Let's build something great."
        ],
        balanced: [
          "Just started today! Excited for what's ahead. 😊",
          "New team member here! Looking forward to working with everyone. 👋",
          "Day one complete! Great first impression. ✨",
          "Happy to be part of the team! Excited to get started. 🎉"
        ]
      };
      
      // Select template category based on personality
      let category = 'balanced';
      if (personality.outgoing > 70) category = 'high_outgoing';
      else if (personality.professional > 70) category = 'high_professional';
      
      const templates = fallbacks[category];
      content = templates[Math.floor(Math.random() * templates.length)];
    }
    
    // Determine if they want to post a selfie (30% chance if outgoing > 60)
    let imagePrompt = null;
    let imageUrl = null;
    
    if (personality.outgoing > 60 && Math.random() < 0.3) {
      // Use consistent physical description for first post selfie
      const physicalDesc = getPhysicalDescriptionForPrompt(employee);
      imagePrompt = `Professional first-day selfie: ${physicalDesc}, smiling confidently, office setting, welcoming expression, good lighting, business casual attire, friendly and approachable`;
      
      try {
        imageUrl = await generateImage(applyImageStyle(imagePrompt));
      } catch (error) {
        console.error('Image generation failed for first post:', error);
        imageUrl = null;
      }
    }
    
    // Create the first post
    const post = createPost({
      authorId: employee.id,
      authorName: employee.name,
      type: imageUrl ? 'selfie' : 'text',
      content: content,
      imageUrl: imageUrl,
      imageAlt: imagePrompt || 'First day at work',
      explicitLevel: 0, // Always safe for first post
      tags: ['first_post', 'new_hire'],
      location: employee.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Log event
    logCompanyEvent('first_post', {
      authorId: employee.id,
      authorName: employee.name,
      postType: post.type
    });
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
    
    console.log(`✅ ${employee.name} made their first post!`);
    
    return post;
  }
  
  /**
   * Generate autonomous likes on recent posts
   */
  async function generateAutonomousLikes() {
    // Get recent posts (last 15)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 15);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    for (const employee of activeEmployees) {
      for (const post of recentPosts) {
        // Skip own posts
        if (post.authorId === employee.id) continue;
        
        // Ensure likes array exists
        if (!Array.isArray(post.likes)) {
          post.likes = [];
        }
        
        // Skip if already liked
        if (post.likes.includes(employee.id)) continue;
        
        // Determine like probability based on relationship
        const relationship = employee.relationships?.[post.authorId];
        const relationType = relationship?.type || 'neutral';
        
        let likeProbability = 0.3; // Base 30%
        
        switch (relationType) {
          case 'best_friend': likeProbability = 0.9; break;
          case 'friend': likeProbability = 0.7; break;
          case 'crush': likeProbability = 0.85; break;
          case 'romantic': likeProbability = 0.95; break;
          case 'rival': likeProbability = 0.1; break;
          case 'enemy': likeProbability = 0.05; break;
        }
        
        // Boost probability for explicit content if employee is flirty
        if (post.explicitLevel >= 2 && employee.personality?.flirty > 60) {
          likeProbability += 0.2;
        }
        
        // Random like based on probability
        if (Math.random() < likeProbability) {
          post.likes.push(employee.id);
          
          // 🌐 Evaluate relationship impact from liking (smaller than comments)
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== employee.id) {
            // Viewing and liking without commenting = smaller relationship impact
            await evaluateNPCReactionToPost(employee, postAuthor, post, null);
          }
        }
      }
    }
  }

  
  // Show notification
  /**
   * Load and display patch notes
   * Version format: YYMMDDHHMMSS
   */
  function loadPatchNotes() {
    const patchNotesContent = $('patchNotesContent');
    if (!patchNotesContent) return;
    
    // Define patch notes (newest first)
    const patchNotes = [
      {
        version: '2510240835',
        date: 'October 24, 2025',
        title: '🔧 Critical Bug Fixes: Scene Visualization & Social Posts',
        changes: [
          {
            category: '🎬 Scene Visualization - CRITICAL FIXES',
            items: [
              '<strong>FIXED: Random Unrelated Images Bug:</strong> Scene visualization was generating completely random images (mountain streams instead of erotica, lizards instead of characters, etc.) due to Perchance returning String objects instead of primitive strings.',
              '<strong>String Object Extraction:</strong> Created <code>extractText()</code> helper function to properly convert Perchance\'s String objects to usable text. Prevents prompt from being treated as character array (0, 1, 2, ...) instead of actual string.',
              '<strong>Markdown Pollution Fix:</strong> AI was adding <code>**Image Prompt:**</code>, <code>**Visual Details:**</code>, bullet points, and <code>*(Word count: X)*</code> to prompts - confusing image generator. Now strips all markdown formatting.',
              '<strong>Enhanced Prompts:</strong> Increased max_tokens from 100→200, added detailed instructions for exact current activity, poses, expressions, location details, mood/atmosphere, and clothing/props.',
              '<strong>Better Context:</strong> Now extracts last 3 player and NPC messages for deeper understanding of scene. Temperature increased from 0.7→0.8 for more creative but focused output.',
              '<strong>Stop Sequences:</strong> Added stops for "Visual Details:", "**Visual", "Word count:" to prevent AI from continuing into metadata.',
              '<strong>XML Tag Removal:</strong> Strips <code>&lt;image prompt&gt;</code> tags that AI sometimes adds.'
            ]
          },
          {
            category: '✏️ Custom Image Prompts',
            items: [
              '<strong>Custom Prompt Option:</strong> Added "Custom Prompt" to image style dropdown per user request.',
              '<strong>Personal Style Directives:</strong> Users can now write their own custom style instructions (e.g., "watercolor painting, soft colors, dreamy atmosphere") instead of being limited to presets.',
              '<strong>Expandable Textarea:</strong> UI shows/hides custom prompt field based on selection. Includes helpful placeholder text.',
              '<strong>Persistent Storage:</strong> Custom prompts save to gameState and persist across sessions.',
              '<strong>Fallback Handling:</strong> If custom prompt is empty, falls back to "high quality, detailed".'
            ]
          },
          {
            category: '📱 Social Post Quality Improvements',
            items: [
              '<strong>FIXED: Short Generic Posts:</strong> AI was spamming feed with one-word posts like "Self-care morning", "Made it to work", "Vibing". Increased max_tokens from 60→80 and added quality validation.',
              '<strong>FIXED: "Caught in Mid-" Repetition:</strong> AI was obsessed with phrases like "caught in mid-laugh", "caught in mid-sip", "caught in mid-bite". Added regex filters to <code>cleanWithLearning()</code> to remove all "mid-action" patterns.',
              '<strong>Post Quality Validation:</strong> Now rejects posts with <3 words, emoji-only posts, and generic phrases before they hit the feed.',
              '<strong>Enhanced Fallback Templates:</strong> Expanded from 3 options per type to 7-10 varied options. Added personality-based variations (flirty emojis, professional hashtags).',
              '<strong>Better AI Instructions:</strong> Explicit rules: "NOT single-word posts", "Avoid one-word or extremely short posts", "NEVER use caught in mid-[action] phrases", "Add personality and context".',
              '<strong>Expanded Post Types:</strong> Added fallbacks for: fitness, hobby, entertainment, mood, question, achievement, throwback, pet, fashion, complaint, inspiration, weather, random, gossip.'
            ]
          },
          {
            category: '🕐 PostId Timestamp Validation',
            items: [
              '<strong>FIXED: Invalid PostIds Bug:</strong> Fallback system was generating posts with invalid postIds lacking timestamps, causing posts to get stuck at top of feed and become undeletable.',
              '<strong>Robust Timestamp Generation:</strong> Added validation in <code>createPost()</code> with multiple fallbacks: 1) Date.now(), 2) gameState.time.currentTime, 3) new Date().getTime(), 4) Epoch timestamp.',
              '<strong>Error Logging:</strong> Console warnings if timestamp is NaN or invalid.',
              '<strong>Guaranteed Valid IDs:</strong> Ensures all posts have format <code>post_{counter}_{timestamp}</code> with valid timestamp for proper sorting and deletion.'
            ]
          },
          {
            category: '🛠️ Technical Implementation',
            items: [
              '<strong>New Helper Function:</strong> <code>extractText(response)</code> - Universal text extraction from generateText responses. Handles String objects, response objects with .text/.generatedText properties, and primitive strings.',
              '<strong>Applied Everywhere:</strong> Scene visualization, social post generation, and image style application now use extractText() for consistent handling.',
              '<strong>Markdown Stripping:</strong> Comprehensive regex patterns remove: bold headers, bullet points, labels, word counts, and formatting artifacts.',
              '<strong>AI Prompt Improvements:</strong> Added explicit instructions: "Write ONLY the description itself. NO markdown formatting, NO bold headers, NO labels."',
              '<strong>Debug Logging:</strong> Enhanced console logs show prompt length, style application, and final prompt endings for troubleshooting.'
            ]
          },
          {
            category: '📊 Expected Improvements',
            items: [
              'Scene visualizations accurately reflect conversation context instead of random images',
              'Users can define custom art styles with personal preferences',
              'Social posts are more substantive and varied (3+ words minimum)',
              'No more "caught in mid-X" repetitive AI phrases',
              'All posts have valid IDs with timestamps for proper sorting/deletion',
              'Overall better AI content quality across all generation points'
            ]
          }
        ]
      },
      {
        version: '2010232145',
        date: 'October 23, 2025',
        title: '🎨 Global Image Style System & Prestige Bug Fixes',
        changes: [
          {
            category: '✨ New Features',
            items: [
              '<strong>Global Image Style Setting:</strong> Choose a consistent art style for ALL image generation (profiles, chats, social posts, scenes)',
              '<strong>6 Style Options:</strong> Photorealistic, Anime/Manga, Artistic/Painterly, Cartoon/Comic, Cinematic, Professional Studio',
              '<strong>Automatic Style Application:</strong> Selected style is applied to all 14+ image generation points automatically',
              '<strong>Style Persistence:</strong> Image style preference saves across sessions',
              '<strong>Smart Style Directives:</strong> Each style includes comprehensive prompt modifiers for consistent results'
            ]
          },
          {
            category: '🐛 Critical Bug Fixes',
            items: [
              '<strong>Fixed Prestige Unlock Cost Bug:</strong> Product unlock costs were locked to pre-prestige values (e.g., garage products requiring billions after prestige). Now properly resets to base values.',
              '<strong>Base Unlock Cost System:</strong> Added comprehensive lookup table with default costs for all 40+ products',
              '<strong>Prestige Reset Logic:</strong> Product unlock costs now correctly reset to original values regardless of dynamic changes'
            ]
          },
          {
            category: '🎨 Image Generation Improvements',
            items: [
              'Updated 14+ image generation locations to use consistent styling',
              'Employee profile pictures (onboarding)',
              'Chat image requests (player to NPC)',
              'Chat image requests (NPC to player)',
              'Image regeneration in chats',
              'Visualize current scene',
              'Social feed posts with images',
              'Social feed custom player posts',
              'Boss fight character images',
              'Gift preview images',
              'First post selfies (new hires)',
              'All images now respect global style setting'
            ]
          },
          {
            category: '⚙️ Technical Implementation',
            items: [
              'Added <code>applyImageStyle()</code> helper function for consistent style application',
              'Style directives automatically append to all image prompts',
              'Duplicate detection prevents style tags from being added multiple times',
              'Debug logging shows style application for troubleshooting',
              'Settings UI integration with real-time style switching',
              'Base unlock costs for garage, home_office, office_suite, factory, and corporate_tower products'
            ]
          },
          {
            category: '💾 Prestige System Improvements',
            items: [
              '<strong>Complete Cost Reset:</strong> All product unlock costs reset to base defaults',
              'Prevents progression blocks after prestige',
              'Maintains game balance across prestige cycles',
              'Preserves intended early-game flow after reset',
              'Fixed unlock costs for 8 garage products, 10 home office products, 10 office suite products, 10 factory products, 10 corporate tower products'
            ]
          }
        ]
      },
      {
        version: '2510221000',
        date: 'October 22, 2025',
        title: '🚀 Nuclear Context Intelligence + Anti-Repetition System',
        changes: [
          {
            category: '🧠 Revolutionary AI Context Selection',
            items: [
              '<strong>Nuclear Context Intelligence System:</strong> Completely rewrote how AI selects context for NPC conversations. Instead of "context dumping" (sending ALL employee data in every prompt), now intelligently selects 5-15 most relevant pieces using multi-dimensional scoring.',
              '<strong>Multi-Dimensional Scoring:</strong> Each context piece scored on 5 dimensions: Base Priority (inherent importance), Semantic Relevance (matches conversation topic), Temporal Relevance (time-sensitive data gets freshness bonus), Novelty (anti-repetition penalty), Coherence (works well with other selected pieces).',
              '<strong>Adaptive Selection Algorithm:</strong> Greedily selects best-scoring context with category balancing (prevents all personality, no current state). Respects token budgets: 400 tokens for casual chat, 300 for social posts, 250 for comments.',
              '<strong>Usage Tracking:</strong> System tracks which context pieces are used in each interaction. Pieces used recently get heavy novelty penalties (70% reduction) to prevent repetition. Pieces used in last hour completely excluded.',
              '<strong>Context Categories:</strong> 9 categories with different priorities: core_identity (always included), personality (high), current_state (high, time-sensitive), relationships (low), skills (work-context), stats (medium), flags (variable), personal_life (low), appearance (very low).'
            ]
          },
          {
            category: '🎯 Anti-Repetition Enforcement',
            items: [
              '<strong>FIXED: Physical Appearance Obsession:</strong> NPCs were constantly describing "bright blue eyes", "chestnut waves", and "barefoot" in EVERY response. Drastically reduced appearance priority (0.2→0.05, 0.1→0.02), added avoidRepetition flags, and explicit AI instruction to STOP obsessing over looks.',
              '<strong>FIXED: Coworker Name-Dropping Plague:</strong> NPCs mentioned coworkers in EVERY SINGLE MESSAGE, even during intimate moments ("Judith\'s budget reports wouldn\'t know what to make of this"). Reduced relationship priority by 75-85%, removed automatic office dynamics/social context injection.',
              '<strong>FIXED: Betting Obsession:</strong> NPCs constantly saying "[Coworker] bet me $20 that..." as excuse to mention people. Added explicit ban on using bets/wagers as crutch to name-drop coworkers.',
              '<strong>Explicit AI Instructions:</strong> Added critical directives telling AI to: NOT constantly describe appearance (only when it changes or asked), NOT randomly bring up coworkers (only when player asks or directly relevant), NOT use betting patterns to shoehorn names, NEVER mention coworkers during intimate moments.',
              '<strong>Context Selectivity:</strong> Removed automatic inclusion of office dynamics, recent social posts, and gossip. These now only appear when semantically relevant or player asks about them.'
            ]
          },
          {
            category: '🏢 Corporate Hierarchy Overhaul',
            items: [
              '<strong>FIXED: Hierarchy Levels Completely Redesigned:</strong> Levels now correctly match the corporate structure: Level 1 = Staff (product workers), Level 2 = Local Manager, Level 3 = Regional Manager, Level 4 = Branch Manager, Level 5 = CFO/COO, Level 6 = Senior Executive, Level 7 = CEO.',
              '<strong>Proper Level Progression:</strong> New employees start at Level 1 (Staff) - the bottom tier managing products. Removed confusing "Entry Level" terminology. Everyone starts as Staff and can work their way up.',
              '<strong>Corporate Pyramid Population:</strong> Migration system now syncs employees to corporate pyramid positions after auto-assignment. Your staff will properly appear in the Corporate Ladder screen at Level 1 positions.',
              '<strong>Updated Promotion Requirements:</strong> Adjusted requirements to match new hierarchy: Staff→Local Manager (60% prod, Lv1 mgmt), Local→Regional (70%, Lv2), Regional→Branch (75%, Lv4), Branch→CFO/COO (80%, Lv6), CFO/COO→Senior Exec (85%, Lv8), Senior Exec→CEO (90%, Lv10).',
              '<strong>Position Icons & Colors:</strong> Each level has appropriate icon and color: 👔 Staff (green), 👨‍💼 Local Manager (blue), 🎯 Regional Manager (gold), 📊 Branch Manager (pink), 💼 CFO/COO (purple), ⭐ Senior Executive (deep purple), 👑 CEO (red).'
            ]
          },
          {
            category: '🔧 Staff Position Management & Save Migration',
            items: [
              '<strong>SMART Auto-Assignment from Old Saves:</strong> Migration system intelligently extracts product assignments from old "Manager – [Product Name]" position fields, auto-assigns employees to correct products, syncs them to corporate pyramid, then cleans up outdated display fields.',
              '<strong>FIXED: Promotion Vacancy Bug:</strong> When promoting employee from Staff position to higher role, the old product position is now properly vacated and automation disabled. Shows warning notification: "⚠️ [Position] is now vacant! Hire new staff to restore automation."',
              '<strong>FIXED: "Managed by Unknown" Bug:</strong> Old saves had products with invalid manager references. Migration system now detects and clears broken assignments, showing helpful message: "⚠️ Staff assignment lost - click Hire Staff to reassign"',
              '<strong>Cleaner People Tab Cards:</strong> Removed redundant "Manager – [Product] • [Product]" line from employee cards. The Corporate Hierarchy section already shows their level and role clearly.',
              '<strong>Position Title Clarity:</strong> Business tab now shows which employee staffs each product: "✓ Staffed by [Name] (Lv.X)" or "⚠️ No staff assigned - automation disabled" when vacant.',
              '<strong>Better Terminology:</strong> Changed "Hire Employee" → "Hire Staff", "Upgrade Manager" → "Upgrade Position", "Managed by" → "Staffed by" to clarify you\'re improving the position (equipment/processes) not the person.',
              '<strong>Upgrade Notifications:</strong> Position upgrade messages now say "[Product] position upgraded to Lv.X - Better equipment & efficiency!" making it clear what\'s improving.',
              '<strong>Save Migration:</strong> Loading old saves automatically validates all product-employee assignments and fixes any orphaned manager references from fired/promoted employees.',
              '<strong>Secretary Title Fix:</strong> Executive Secretary position (level 6.5) now correctly sets employee title to "Executive Secretary" instead of incorrectly showing "Regional Director" (level 6).'
            ]
          },
          {
            category: '📊 Debug & Analytics Tools',
            items: [
              '<strong>debugContextSelection():</strong> Console function to see exactly what context is selected for any interaction. Shows scores, breakdown by dimension, and formatted output.',
              '<strong>showContextAnalytics():</strong> View comprehensive analytics on context usage for any employee - most/least used pieces, category distribution, average pieces per interaction, recent history.',
              '<strong>Token Budget System:</strong> Different interaction types have appropriate budgets to prevent bloat while maintaining quality context.'
            ]
          }
        ]
      },
      {
        version: '2510220820',
        date: 'October 22, 2025',
        title: '⬆️ Promotion UX Overhaul + Bug Fixes',
        changes: [
          {
            category: '✨ Improved Promotion System',
            items: [
              '<strong>Promote Button in Employee Profiles:</strong> New "⬆️ Promote" button appears in employee profile modals. Shows as green/active when employee is eligible for promotion, grayed out with "🔒 Not Eligible" when not eligible.',
              '<strong>Seamless Promotion Flow:</strong> Click "Promote" button → profile closes → Corporate Pyramid opens with eligible positions highlighted in gold. Much more intuitive than drag-and-drop.',
              '<strong>Visual Confirmation Modal:</strong> Beautiful side-by-side comparison showing old position → new position with animated arrow. Displays employee photo, position cards with level/title, cost breakdown, and your remaining cash after promotion.',
              '<strong>Smart Eligibility Detection:</strong> System automatically checks all higher-level positions and secretary role to determine if employee has promotion opportunities.',
              '<strong>Mobile-Friendly:</strong> Click-based system works perfectly on mobile devices, replacing janky drag-and-drop.',
              '<strong>Current Position Display:</strong> Employee profiles now show current position title and level badge next to the Promote button.'
            ]
          },
          {
            category: '🏢 Secretary Position Addition',
            items: [
              '<strong>Executive Secretary Role:</strong> New special position that reports directly to the CEO with no subordinates. Perfect for early-game hiring.',
              '<strong>Visual Placement:</strong> Appears next to the CEO in the Corporate Pyramid (slightly smaller for visual hierarchy) with unique purple/magenta color scheme and 📋 icon.',
              '<strong>Easy Access:</strong> Can be filled by Level 1-3 employees. Low cost ($1,000) encourages early hiring.',
              '<strong>Auto-Migration:</strong> Automatically added to existing saves without requiring new game.',
              '<strong>Fully Integrated:</strong> Works with all position management functions including assignment, removal, and promotion flow.'
            ]
          },
          {
            category: '🐛 Bug Fixes',
            items: [
              '<strong>Fixed createSocialPost Error:</strong> Function was being called but never defined, causing ReferenceError in generateMorningPost, generateEveningPost, and createActivityPost. Now properly creates and adds posts to social feed.',
              '<strong>Fixed Mention Suggestions Crash:</strong> TypeError when accessing employee IDs in getMentionSuggestions. Added comprehensive null checks and validation for employee objects, IDs, and mention statistics.',
              '<strong>Fixed Scarf Obsession:</strong> Removed accessories (including scarves) from the fullDescription string sent to AI. Employees were constantly mentioning scarves because it was in their character description for every AI interaction. Accessories still stored in data but no longer pollute conversations.'
            ]
          },
          {
            category: '🎨 UI Improvements',
            items: [
              '<strong>Discord Icon:</strong> Re-added Discord server link icon to top bar (left of settings gear). Opens in new tab with proper SVG icon in Discord brand color.',
              '<strong>Promotion Confirmation Animations:</strong> Smooth fade-in, slide-up, and pulsing arrow effects in confirmation modal. Green glow on affordable promotions, disabled state for insufficient funds.',
              '<strong>Better Error Messages:</strong> More descriptive error messages for position assignment failures with specific reasons.'
            ]
          }
        ]
      },
      {
        version: '2510211800',
        date: 'October 21, 2025',
        title: '🏢 Corporate Ladder System + NPC Lifelike Systems',
        changes: [
          {
            category: '🎯 Corporate Hierarchy & Pyramid Visualization',
            items: [
              '<strong>7-Level Organizational Chart:</strong> Complete restructure from product-based positions to true hierarchical reporting structure (Level 1 Staff → Level 7 CEO). Positions automatically created based on products/locations unlocked.',
              '<strong>Interactive Pyramid Modal:</strong> Beautiful visual org chart showing your entire company structure at a glance. Click any position to view details, drag employees between positions, pan/zoom controls, mobile-friendly touch support.',
              '<strong>Auto-Assignment:</strong> Newly hired employees automatically assigned to Level 1 Staff positions for their product, appearing immediately in the pyramid.',
              '<strong>Dynamic Position Creation:</strong> Positions scale with your business - Level 1 (1 per product), Level 2 (2-3 per location), Level 3 (1 per location), Level 4 (manages 2-3 locations), Level 5 (CFO/COO), Level 6 (Senior Executive), Level 7 (CEO - You!).',
              '<strong>Reporting Relationships:</strong> Each position tracks who reports to whom, subordinate counts, span of control. Validates chain of command when assigning employees.',
              '<strong>Position Details Modal:</strong> Click any position to see employee info, skills, salary, reporting structure. Remove employees or view vacant positions.',
              '<strong>Migration System:</strong> Seamlessly converts old product-based save data to new hierarchical structure automatically on load.'
            ]
          },
          {
            category: '📈 Promotion System Overhaul',
            items: [
              '<strong>Clear Requirements:</strong> Each level has specific productivity and management skill requirements (Level 2: 60% productivity → Level 7: 90% productivity + Level 8 management).',
              '<strong>Visual Promotion Badges:</strong> Employees eligible for promotion display a pulsing golden "⬆️ READY" badge on their pyramid tile.',
              '<strong>Eligibility Display:</strong> Click any employee in the pyramid to see detailed promotion requirements with current vs. needed values. Shows what they\'re missing in red, what they\'ve achieved in green.',
              '<strong>Three Status States:</strong> Ready (green banner), Not Ready (shows gaps), Max Level (gold crown).',
              '<strong>Promotion Costs:</strong> Scaling costs from $500 (Level 1→2) to $500,000 (Level 6→7). Lateral moves get 50% discount.',
              '<strong>Smart Assignment:</strong> System validates if employee meets level requirements and has necessary management skills before allowing position assignment.'
            ]
          },
          {
            category: '🎓 Employee Development Programs',
            items: [
              '<strong>Training Workshops:</strong> Company-wide training affecting all employees at once. Cost: $500 per employee. Benefits: +5-10 productivity, +20 management XP. No cooldown - run as often as budget allows.',
              '<strong>Performance Reviews:</strong> Individual one-on-one reviews with tiered benefits. Cost: $200. Cooldown: 7 days per employee. Low performers get +15-20 productivity, average +10-15, high performers +5-10. Also boosts affection by +5.',
              '<strong>Team Building Activities:</strong> Fun company events boosting both productivity and morale. Cost: $800 per employee. Cooldown: 14 days. Benefits: +3-7 productivity, +8 affection, +8 comfort, +30 social XP.',
              '<strong>Review History Tracking:</strong> All performance reviews tracked in employee career data with before/after productivity values.',
              '<strong>Development Programs UI:</strong> New section at top of People tab with three cards showing each program, costs, cooldowns, and benefits. One-click activation buttons.'
            ]
          },
          {
            category: '🏷️ Universal Flag System',
            items: [
              '<strong>Dynamic State Tracking:</strong> NPCs can now have unlimited custom "flags" that track ANY state, condition, or trait - physical conditions (pregnant, sick, tired), relationship agreements (free use, exclusive dating), personality traits (dominant, submissive, shy), life events (birthday soon, recent breakup), preferences & kinks (exhibitionist, breeding kink), and literally anything imaginable.',
              '<strong>Two Flag Types:</strong> System flags (auto-created by game mechanics like pregnancy) and custom flags (player-created for any purpose).',
              '<strong>Smart AI Integration:</strong> Flags automatically inject into AI conversation context, so NPCs naturally remember and reference their states. No more forgetting major developments!',
              '<strong>Automatic Detection:</strong> Game watches conversations and suggests flags based on patterns (e.g., detecting free-use agreements, relationship changes). Zero extra AI calls - pure regex pattern matching.',
              '<strong>Flag Management UI:</strong> Beautiful modal accessible from People tab and unified profiles. View all active flags with their priority, AI guidance text, and expiration dates. One-click add/remove.',
              '<strong>Quick-Add Buttons:</strong> 9 pre-configured common flags (Pregnant, In Relationship, Free Use Agreement, Secret Affair, Breeding Kink, Submissive, Dominant, Exhibitionist, Polyamorous) with appropriate emoji, priority, and AI context.',
              '<strong>Flag Display:</strong> Active flags show as colored badges on employee cards with emoji icons (🤰 Pregnant, 💋 Free Use, etc.).',
              '<strong>Custom Flag Creation:</strong> Full custom flag form with name, emoji, description, priority (low/medium/high), AI guidance, optional expiration dates.',
              '<strong>Priority System:</strong> High-priority flags appear first in AI context to ensure important traits/states are emphasized.'
            ]
          },
          {
            category: '🗂️ Unified NPC Profile System',
            items: [
              '<strong>10-Tab Interface:</strong> Comprehensive profile modal consolidating all NPC information: Overview (bio + quick stats), Stats (relationship meters), Skills (work skills with levels), Possessions (gifts received), Flags (state management), Schedule (work hours), Social (feed activity), Relationship (detailed dynamics), Appearance (physical traits), Gallery (images).',
              '<strong>Overview Tab Redesign:</strong> Merged Bio and Overview into single tab with profile picture, basic info, quick stat previews, active flags display, and action buttons.',
              '<strong>Stats Tab:</strong> Visual progress bars for all relationship stats (affection, trust, comfort, desire, productivity) with hover tooltips and exact values.',
              '<strong>Skills Tab:</strong> Work skills displayed with level, XP progress bars, next level requirements. Shows technical, creative, social, management, and life skills (fitness, cooking) with emoji icons.',
              '<strong>Flags Tab:</strong> Full flag management interface within profile - view all flags, add custom flags, quick-add common flags, remove flags. Real-time updates.',
              '<strong>Possessions Tab:</strong> Gallery of all gifts given to NPC with images, names, dates, and categories. Shows appreciation and relationship building over time.',
              '<strong>Schedule Tab:</strong> Work schedule, PTO balance, sick days, hours worked, late days tracking. Future: will show daily routine and current activity.',
              '<strong>Live Edit Mode:</strong> Toggle edit mode to modify NPC data directly in profile. Unsaved changes highlighted. Save/cancel with confirmation.',
              '<strong>Clickable Everywhere:</strong> Access unified profiles by clicking NPC names/avatars anywhere - People tab cards, social media posts, comments, chat.'
            ]
          },
          {
            category: '📋 Skills & Progression System',
            items: [
              '<strong>Work Skills:</strong> Technical, Creative, Social, Management skills that level up through gameplay. Each skill has level (1-10), XP, and max XP with exponential scaling.',
              '<strong>Life Skills:</strong> Fitness and Cooking skills for personal development and lifestyle activities.',
              '<strong>XP Sources:</strong> Employees gain skill XP from work hours (automatic), evening activities, weekend activities, chat conversations (social), deep conversations (+5 social), flirting (intimate skill), work discussions (highest work skill +3).',
              '<strong>Level-Up Notifications:</strong> Visual notifications when employees level up skills with celebration emoji 🎉.',
              '<strong>Specialization Unlocks:</strong> Certain skill levels unlock specializations (e.g., Technical 3 = "Code Wizard").',
              '<strong>Productivity Bonuses:</strong> Skills provide effective productivity bonuses - technical skills boost tech products, creative skills boost creative products, management gives universal 0.5x boost.',
              '<strong>Skill Display:</strong> Skills shown in unified profiles, employee cards, position details with levels and progress bars.'
            ]
          },
          {
            category: '📅 Schedule & Time System',
            items: [
              '<strong>Work Schedule:</strong> Each employee has work days (Mon-Fri default), start/end hours (9 AM - 5 PM), currently-working status, clock in/out timestamps.',
              '<strong>Hours Tracking:</strong> Daily hours worked, total days worked, late days counted for analytics and performance.',
              '<strong>Leave System:</strong> PTO balance (10 days default), sick days (5 days), currently on leave status, leave type tracking (PTO/sick/maternity), leave end dates.',
              '<strong>Future-Ready:</strong> Data structure prepared for time-aware NPC behaviors, location tracking, and daily routine generation.'
            ]
          },
          {
            category: '🏠 Life Outside Work',
            items: [
              '<strong>Current Activity Tracking:</strong> NPCs track what they\'re currently doing outside work (prepared for future real-time activity generation).',
              '<strong>Hobbies System:</strong> Active hobbies with frequency (30-100% engagement), skill levels (1-5), and last-done timestamps.',
              '<strong>Evening Preferences:</strong> Randomized preferences for gym (0-40%), cooking (0-60%), socializing (0-50%), relaxing (30-70%), hobbies (0-60%), dating (0-30%).',
              '<strong>Living Situation:</strong> Apartment/house/condo type, roommate status, pet ownership with details (35% have pets - dogs, cats, birds, fish with randomly generated names like "Max", "Luna").',
              '<strong>Social Circle:</strong> Outside contacts including best friend (70% have one), family (80%), relationship status (30% in relationships), detailed status tracking (single/dating/serious/married).',
              '<strong>Weekend Plans:</strong> System ready to generate upcoming weekend activities and track last weekend activity.',
              '<strong>Pet System:</strong> Pets tracked with name, type, who gifted them, and timestamps. Displayable in profiles and referenced in conversations.'
            ]
          },
          {
            category: '🎨 UI/UX Improvements',
            items: [
              '<strong>People Tab Enhancements:</strong> New "Employee Development Programs" section with three cards for Training, Team Building, and Performance Reviews. Cost displays, cooldown indicators, hover effects.',
              '<strong>Employee Card Badges:</strong> Active flags display as colored emoji badges on employee cards. Promotion-ready employees get golden pulsing "⬆️ READY" badge.',
              '<strong>New Action Buttons:</strong> Added "📊 Review" button to employee cards for quick performance review access. "🏷️ Flags" button for flag management.',
              '<strong>Pyramid Controls:</strong> Pan/zoom controls, pinch-to-zoom on mobile, smooth animations, position tile hover effects.',
              '<strong>Modal Improvements:</strong> All new modals use consistent styling with gradients, hover effects, responsive design. Better z-index management prevents stacking issues.',
              '<strong>Visual Feedback:</strong> Success/error notifications for all development program actions. Cost displays update dynamically. Cooldown timers shown in UI.'
            ]
          },
          {
            category: '⚙️ Technical Improvements',
            items: [
              '<strong>Data Structure Expansion:</strong> Added gameState.corporatePyramid with CEO object, positions arrays by level, promotion costs. gameState.productivitySystems for tracking workshops/reviews. Flag arrays in employee objects.',
              '<strong>Automatic Initialization:</strong> New data structures auto-initialize on first access with sensible defaults. Migration code converts old saves seamlessly.',
              '<strong>Event Logging:</strong> Training workshops, team building, and promotions now create company event log entries for AI context.',
              '<strong>Save Compatibility:</strong> All new systems designed with backward compatibility. Old saves load and automatically upgrade to new structure.',
              '<strong>Performance:</strong> Flag detection uses regex patterns (no AI calls). Pyramid rendering optimized for large companies. Efficient subordinate counting.',
              '<strong>Code Organization:</strong> New dedicated sections for corporate hierarchy functions, productivity systems, flag management. Clear function documentation.'
            ]
          },
          {
            category: '🔮 Foundation for Future Features',
            items: [
              '<strong>Advanced Social Dynamics:</strong> Flag system enables complex NPC-to-NPC relationships. Schedule system ready for time-aware interactions.',
              '<strong>Family System:</strong> Data structures prepared for pregnancy tracking (7-14 day cycles), children with genetic inheritance, family relationships.',
              '<strong>Dynamic Schedules:</strong> Time system ready to generate daily routines, track NPC locations throughout the day, implement time-aware behaviors.',
              '<strong>Life Simulation:</strong> Weekend activities, evening routines, hobby progression, social events outside work - all data structures in place.',
              '<strong>Relationship Depth:</strong> Flags enable tracking of complex relationship agreements (polyamory, exclusivity, kinks, preferences) that persist across save/load.',
              '<strong>Expandable Systems:</strong> Universal flag system means ANY new state/trait can be added without code changes - just create a new flag!'
            ]
          }
        ]
      },
      {
        version: '2510191600',
        date: 'October 19, 2025',
        title: '💾 Comprehensive Save/Load System Overhaul',
        changes: [
          {
            category: '🔒 Save/Load Coverage (50+ Properties)',
            items: [
              '<strong>Complete System Audit:</strong> Conducted comprehensive audit of all game systems to ensure 100% save/load coverage. Created detailed documentation tracking all 50+ gameState properties.',
              '<strong>Social Network Data:</strong> Added explicit saving/loading for all social network properties including feedFilter, feedSort, recentPostTypes, playerDraft (caption, imagePrompt, altText, imageUrl).',
              '<strong>Player Profile:</strong> Ensured complete player character data is saved (firstName, lastName, age, gender, ethnicity, physical details, intimate details, personality).',
              '<strong>Company Context:</strong> Added full save/load for companyWideContext (currentBuzz, lastUpdate, maxItems, decayTime) and all company awareness data.',
              '<strong>Prestige System:</strong> Verified prestige data saving (prestigeLevel, influencePoints, lifetimeEarnings, prestigeMultiplier, globalUpgrades, bossFights).',
              '<strong>Employee Systems:</strong> Ensured typingStates, onboarding array, and currentCandidates are properly saved.',
              '<strong>Missing Properties Fixed:</strong> Added initialization for playerMentionStats, activeGossip, lastProactiveMessageCheck, lifestyleAdjustmentCounter, and currentCandidates.'
            ]
          },
          {
            category: '📊 Backward Compatibility',
            items: [
              '<strong>Default Values:</strong> All new properties have sensible defaults, ensuring old saves load without errors.',
              '<strong>Migration Path:</strong> Old saves automatically upgraded to new structure without manual intervention.',
              '<strong>No Breaking Changes:</strong> Existing players can load saves from any previous version.',
              '<strong>Future-Proof Template:</strong> Created comprehensive guide for adding new save properties (see SAVE_LOAD_AUDIT.md).'
            ]
          },
          {
            category: '📝 Documentation',
            items: [
              '<strong>SAVE_LOAD_AUDIT.md Created:</strong> Complete documentation of all saved properties, validation checklist, and migration strategies.',
              '<strong>Coverage Statistics:</strong> 50+ properties tracked across Core (12), Business (8), Employees (10), Social (12), Company (6), Gifts (7), AI (5).',
              '<strong>Developer Guide:</strong> Step-by-step instructions for adding new save properties and handling Sets/Maps.'
            ]
          }
        ]
      },
      {
        version: '2510191523',
        date: 'October 19, 2025',
        title: '🚨 Critical Save/Load Bug Fixes',
        changes: [
          {
            category: '🔥 Game-Breaking Fixes',
            items: [
              '<strong>CRITICAL: Fixed Hiring Crash After Loading:</strong> Fixed "TypeError: gameState.usedEmployeeNames.has is not a function" that prevented hiring employees after loading saved games. The Set object was being converted to an Array during JSON serialization, breaking the name uniqueness check.',
              '<strong>Set Object Restoration:</strong> Added automatic conversion of usedEmployeeNames from Array back to Set when loading games. This preserves the .has() and .add() methods required by the hiring system.',
              '<strong>Gender Settings Migration:</strong> Fixed "Cannot read properties of undefined (reading \'female\')" error for old saves without genderSettings. Now automatically initializes with default values (100% female) for backwards compatibility.',
              '<strong>Additional Set/Map Fixes:</strong> Also fixed blockedProactiveMessages (Set) and recentTopics (Map) which had the same serialization issue. All non-serializable objects now properly restored on load.',
              '<strong>Debug Logging:</strong> Added console logs to track Set/Map restoration and settings initialization for easier troubleshooting.'
            ]
          },
          {
            category: '📝 Technical Details',
            items: [
              '<strong>Root Cause:</strong> JavaScript Sets and Maps are not JSON-serializable. When saving to localStorage/KV storage, Sets are converted to Arrays and Maps to plain objects. The loadGame function now detects this and converts them back.',
              '<strong>Affected Systems:</strong> Name generation (usedEmployeeNames Set), gender selection (genderSettings object), topic tracking (recentTopics Map), proactive messages (blockedProactiveMessages Set).',
              '<strong>Migration Safety:</strong> Fixes apply automatically to all existing saves without requiring manual intervention. Missing objects are initialized with proper defaults.',
              '<strong>Future Prevention:</strong> This fix provides a comprehensive template for handling all non-serializable objects (Maps, Sets, etc.) in future features.'
            ]
          }
        ]
      },
      {
        version: '2510191346',
        date: 'October 19, 2025',
        title: '🎁 Gift System Fixes & AI Improvements',
        changes: [
          {
            category: '🔧 Critical Gift System Fixes',
            items: [
              '<strong>Gift Price Scaling Overhaul:</strong> Fixed absurd gift expectations at high wealth levels. Previously at $27B lifetime income, game expected $8.7M-$8.7B gifts, treating a $15k Barcelona trip as "too cheap" (0.3× penalty). Now capped at reasonable human scale: $5k-$500k range regardless of wealth.',
              '<strong>Price Philosophy Change:</strong> Gifts now judged on thoughtfulness, not price relative to net worth. Any gift $1k+ receives no penalty. Even billionaires appreciate a nice vacation!',
              '<strong>New Price Ranges:</strong> Perfect range (1.5× bonus): $15k-$150k | Good range (1.2× bonus): $2.5k-$1M | Modest (1.0×): Any $1k+ gift | Only gifts under $100 receive penalties.',
              '<strong>First Gift Detection:</strong> Fixed NPCs reacting to first-ever gifts as if they\'d received them before. Added explicit "THIS IS YOUR FIRST GIFT" flag in AI prompts with appropriate surprise/delight instructions.',
              '<strong>Reduced "Overwhelmed" Penalty:</strong> Now only triggers for $500k+ gifts with very weak relationships (under 30), reduced from 0.5× to 0.7× penalty.',
              '<strong>Debug Logging:</strong> Added comprehensive gift evaluation logs showing category match, price score, modifiers, and final reception calculations.'
            ]
          },
          {
            category: '⚡ AI Generation Optimization',
            items: [
              '<strong>Stat Evaluation Overhaul:</strong> Implemented optimizations for Player→NPC stat analysis. Reduced prompt from ~600 tokens to ~150 tokens (75% reduction).',
              '<strong>Format-First Prompts:</strong> Moved output format instructions to beginning of prompts, forcing AI cooperation before seeing context.',
              '<strong>Deterministic Output:</strong> Changed temperature from 0.3 → 0 and added top_p:0 for 100% consistent stat evaluations.',
              '<strong>Aggressive Stop Sequences:</strong> Expanded from 8 to 15 stop sequences including "The", "This", "I", "Because" to prevent meta-commentary.',
              '<strong>Context Compression:</strong> Reduced chat context from last 60 messages to last 4 messages (93% reduction) for faster processing.',
              '<strong>Robust Parsing:</strong> Added value clamping to [-10, +10] range and better handling of malformed responses.'
            ]
          },
          {
            category: '💬 Comment Generation Fixes',
            items: [
              '<strong>Meta-Commentary Removal:</strong> Fixed AI outputting internal reasoning in comments like "Boss\'s post is explicit... personality traits: flirty at 36/100... Brainstorming authentic responses..."',
              '<strong>Prompt Compression:</strong> Reduced comment generation prompts from ~50 lines to ~6 lines (88% reduction).',
              '<strong>Short Direct Prompts:</strong> New format forces clean output: "Name sees post: \'content\' | Rel: type (strength/100) | Comment (5-25 words):"',
              '<strong>Nuclear Cleanup:</strong> Added aggressive sanitization that strips Perchance tokens ({SEEDS}, {BAN}, {BOOST}), name prefixes, and meta-text markers.',
              '<strong>First-Line-Only:</strong> Comments now extract only first line/sentence, cutting any multi-line meta-analysis.',
              '<strong>Fallback Detection:</strong> If comment starts with "Boss", "Personality", or other meta-text, automatically uses template comment instead.'
            ]
          },
          {
            category: '🔧 Other Fixes',
            items: [
              '<strong>Advanced Stats Editing:</strong> Fixed Sandbox Mode stats not persisting when reopening bio modal. Modal now closes and reopens automatically after save to display fresh values.',
              '<strong>Gift History Tracking:</strong> Added logging of gift history before each gift to help debug duplicate detection.',
              '<strong>Price Scale Display:</strong> All price calculations now log capped vs uncapped values for transparency.'
            ]
          }
        ]
      },
      {
        version: '2510172020',
        date: 'October 17, 2025',
        title: '🐛 Bug Fixes & AI Optimization',
        changes: [
          {
            category: '🔧 Bug Fixes',
            items: [
              '<strong>Memory Initialization:</strong> Fixed crash when editing bio stats then sending chat messages (ensureEmployeeMemory now called after bio save)',
              '<strong>Memory Validation:</strong> Added defensive checks to remember() function to prevent undefined memory.items errors',
              '<strong>Product Unlock Discount:</strong> Fixed "Bulk Buying" prestige reward not applying to product unlock costs. Now shows discounted price with strikethrough original price and discount percentage.',
              '<strong>Perchance Token Removal:</strong> Fixed {SEEDS:...}, {BAN:...}, {BOOST:...} and other Perchance formatting tokens appearing in posts, comments, and chat messages. Added aggressive sanitization to all AI-generated content.'
            ]
          },
          {
            category: '✅ Prestige System Audit (All Confirmed Working)',
            items: [
              '<strong>💰 Income Multiplier:</strong> ✓ Applied to all product earnings (visible in product values)',
              '<strong>💵 Starting Capital:</strong> ✓ Bonus cash added when prestiging',
              '<strong>👆 Quick Hands (Click Power):</strong> ✓ Reduces product cycle time when clicking (-0.05s per level)',
              '<strong>👔 HR Efficiency:</strong> ✓ Reduces manager hire/upgrade costs (5% per level, max 50%)',
              '<strong>📦 Bulk Buying:</strong> ✓ NOW FIXED - Reduces product unlock AND upgrade costs (3% per level, max 45%). Visual discount shown on unlock buttons.',
              '<strong>⚡ Automation Boost:</strong> ✓ Managers work faster (5% per level, affects auto-run cycle time)'
            ]
          },
          {
            category: '⚡ AI Prompt Optimization (In Progress)',
            items: [
              '<strong>Chat Stat Evaluation:</strong> Simplified prompt 80%, reduced from 60 lines to 15 lines. Added explicit "Numbers only" instruction with aggressive stop sequences',
              '<strong>NPC Reaction Evaluation:</strong> Changed "Rate -5 to +5:" to "Output single number -5 to +5 only:" to prevent narrative flashback stories',
              '<strong>Image Prompt Generation:</strong> Reduced custom prompt analysis by 60%, added stop sequences to prevent verbose "Camera angle:", "Mood:" descriptions',
              '<strong>Scene Visualization:</strong> Simplified prompt from 20 lines to 8 lines, removed numbered instructions',
              '<strong>Post Generation:</strong> Added "The stapler" stop sequence to block narrative storytelling, reduced max_tokens to 50',
              '<strong>Comment Generation:</strong> Added stop sequences to 6 additional functions (reply comments, mentions, autonomous comments)',
              '<strong>Token Limits:</strong> Tightened across board - evaluations: 3-10 tokens, comments: 35-50 tokens, images: 100-150 tokens',
              '<strong>Temperature Tuning:</strong> Lowered to 0.3 for evaluations (deterministic), 0.7-0.9 for creative content',
              '<strong>Note:</strong> These fixes require page reload to clear prompt cache. Testing in progress to confirm effectiveness.'
            ]
          }
        ]
      },
      {
        version: '2510170912',
        date: 'October 17, 2025',
        title: '🎁 Complete Gift System - AI-Powered Gift Giving',
        changes: [
          {
            category: '🎉 Major New Feature',
            items: [
              '<strong>🎁 Complete Gift System:</strong> Give meaningful gifts to employees with AI-powered reactions, dynamic pricing, and deep integration!'
            ]
          },
          {
            category: '🧞‍♂️ Gift Genie (AI Gift Generator)',
            items: [
              '<strong>Custom Gift Creation:</strong> Describe any gift in text and AI generates it with name, description, category, and price',
              '<strong>100 Cycling Suggestions:</strong> Rotating placeholder text for inspiration (updates every 1.5 seconds)',
              '<strong>Budget Limits:</strong> Set max price from $100 to $1 billion',
              '<strong>Smart Category Mapping:</strong> Prevents AI drift with 11 fixed categories',
              '<strong>Optional Image Generation:</strong> Create visual representations of your gifts',
              '<strong>UNIQUE Gift Warnings:</strong> Special indicators for one-time-only items (private islands, landmarks, etc.)'
            ]
          },
          {
            category: '💝 11 Gift Categories',
            items: [
              '💕 <strong>ROMANTIC:</strong> Flowers, jewelry, love letters',
              '💎 <strong>LUXURY:</strong> Designer items, champagne, spa days',
              '✈️ <strong>EXPERIENCES:</strong> Concert tickets, vacations, skydiving',
              '💻 <strong>TECH:</strong> Gadgets, smart devices, gaming gear',
              '📚 <strong>INTELLECTUAL:</strong> Books, courses, museum memberships',
              '🍰 <strong>FOOD:</strong> Gourmet treats, wine, restaurant vouchers',
              '🛠️ <strong>PRACTICAL:</strong> Office supplies, tools, home goods',
              '🎪 <strong>QUIRKY:</strong> Novelty items, weird collectibles',
              '🧘 <strong>WELLNESS:</strong> Fitness equipment, meditation apps',
              '👗 <strong>FASHION:</strong> Clothing, accessories, cosmetics',
              '🌍 <strong>UNIQUE:</strong> One-time only items (private islands, landmarks, planets)'
            ]
          },
          {
            category: '📈 Dynamic Price Scaling',
            items: [
              '<strong>Scales with Company Growth:</strong> Recommended gift prices adapt to your lifetime income THIS prestige',
              '<strong>Startup ($0-$10K):</strong> $10-$500 gifts',
              '<strong>Small Business ($10K-$1M):</strong> $500-$10K gifts',
              '<strong>Growing Company ($1M-$100M):</strong> $10K-$500K gifts',
              '<strong>Corporation ($100M-$10B):</strong> $500K-$50M gifts',
              '<strong>Mega Corp ($10B+):</strong> $50M-$1B+ gifts',
              'Real-time recommendations displayed in Store UI'
            ]
          },
          {
            category: '🎭 NPC Gift Preferences',
            items: [
              '<strong>Personalized Tastes:</strong> Each employee has 2-3 loved categories, 2-3 hated categories',
              '<strong>Loved Gifts:</strong> 1.5x to 2.5x stat bonus!',
              '<strong>Hated Gifts:</strong> Negative stat changes (can harm relationship)',
              '<strong>Visual Indicators:</strong> "They\'ll LOVE this! 💕" / "They might hate this... 💔" hints in gift selection',
              'Generated at employee creation, persistent across saves',
              'Visible in employee bio under "🎁 Gift Preferences"'
            ]
          },
          {
            category: '🎯 Intelligent Gift Reception',
            items: [
              '<strong>Multi-Factor Calculation:</strong> Category match, price, relationship, timing all affect reaction',
              '<strong>Gift Fatigue:</strong> 3+ gifts in 7 days = -50% effectiveness (prevents stat grinding)',
              '<strong>Duplicate Detection:</strong> Same gift within 30 days = -70% penalty',
              '<strong>Price Appropriateness:</strong> Too cheap OR too expensive = penalties',
              '<strong>Relationship-Based:</strong> Low relationship + expensive gift = "Suspicious" reaction',
              '<strong>6 Reaction Tones:</strong> Delighted, Grateful, Overwhelmed, Underwhelmed, Suspicious, Confused',
              'AI-generated contextual reactions based on employee personality, gift type, and reception quality'
            ]
          },
          {
            category: '💬 Conversation Integration',
            items: [
              '<strong>Give Gift Button:</strong> Added to conversation attachment menu (+ button)',
              '<strong>Gift Selection Modal:</strong> Browse inventory with live preference hints',
              '<strong>Visual Hints:</strong> Green borders for loved categories, red for hated, neutral for others',
              '<strong>One-Click Giving:</strong> Select gift → instant AI reaction in chat',
              '<strong>Stat Changes Visible:</strong> See exact affection, comfort, trust, desire changes',
              'Gifts appear in chat history with reactions',
              'Empty state when no gifts in inventory (directs to Gifts tab)'
            ]
          },
          {
            category: '📊 Gift History & Statistics',
            items: [
              '<strong>Bio Integration:</strong> View gift preferences in employee bio modal',
              '<strong>Total Gifts:</strong> Count of all gifts received',
              '<strong>Total Value:</strong> Sum of all gift prices',
              '<strong>Recent Gifts:</strong> Gifts received in last 7 days',
              '<strong>Favorite Gifts:</strong> Top 5 most-loved gifts displayed',
              'Color-coded category badges (green for loves, red for hates)',
              'Stat bonus explanations next to each preference'
            ]
          },
          {
            category: '📱 Social Media Integration',
            items: [
              '<strong>Expensive Gifts = Posts:</strong> Gifts over $100K trigger automatic social media posts',
              'NPCs share their reactions publicly',
              'Includes gift details (name, value, category)',
              'Increases NPC fame and engagement',
              'Visible on social feed with reactions'
            ]
          },
          {
            category: '🛡️ Anti-Exploit Features',
            items: [
              '<strong>UNIQUE Gift Tracking:</strong> One-time items can only be given once per save file',
              '<strong>Gift Fatigue System:</strong> Prevents stat grinding with rapid gifting',
              '<strong>Duplicate Detection:</strong> Encourages variety in gift selection',
              '<strong>Price-Relationship Checks:</strong> Suspicious reactions to inappropriate gifts',
              'Lifetime income tracking (THIS prestige only, resets on prestige)',
              'Inventory unlimited but UNIQUE gifts tracked globally'
            ]
          },
          {
            category: '🎨 UI/UX Improvements',
            items: [
              '<strong>New Gifts Tab:</strong> Complete store interface with gradient styling',
              '<strong>Gift Preview Modal:</strong> See all details before purchasing',
              '<strong>Inventory Grid:</strong> Visual cards with hover effects',
              '<strong>Delete Gifts:</strong> Remove unwanted items from inventory',
              '<strong>Cycling Suggestions:</strong> Smooth 1.5-second transitions between ideas',
              '<strong>Responsive Design:</strong> Works on all screen sizes',
              'Color-coded visual language (pink for gifts, green for loves, red for hates)'
            ]
          },
          {
            category: '💾 Technical Implementation',
            items: [
              '<strong>~1500 Lines of Code:</strong> Complete feature with 15+ functions',
              '<strong>Save/Load Support:</strong> All gift data persists correctly',
              '<strong>Migration System:</strong> Old saves automatically get gift preferences',
              '<strong>Performance Optimized:</strong> Efficient category lookups and calculations',
              'Comprehensive error handling',
              'Full documentation in GIFT_SYSTEM_COMPLETE.md'
            ]
          }
        ]
      },
      {
        version: '2510170000',
        date: 'October 17, 2025',
        title: '🤜 NPC Conversation Improvements',
        changes: [
          {
            category: '✨ Improvements',
            items: [
              '<strong>Fixed repetitive "knuckles" descriptions:</strong> NPCs were constantly mentioning knuckles (whitening, clenching, tightening) in conversations. Added explicit ban on this overused trope with alternative body language suggestions (fidgeting, shifting weight, playing with hair/clothing, eye movements, breathing changes, facial expressions, etc.)'
            ]
          }
        ]
      },
      {
        version: '2510162000',
        date: 'October 16, 2025',
        title: '💰 Payment System Overhaul & Complete Save System',
        changes: [
          {
            category: '✨ Major New Features',
            items: [
              '<strong>Company-Scaled NPC Spending:</strong> NPCs now develop spending habits that scale with company success (1.0x to 6.0x multiplier)',
              '<strong>Gradual Lifestyle Adjustment:</strong> NPCs smoothly adapt their spending as your business grows (5% per tick)',
              '<strong>Dynamic Money Requests:</strong> NPCs ask for amounts proportional to company size and their financial situation',
              '<strong>Counter-Offer System:</strong> Send custom amounts with personal justifications when NPCs request money',
              '<strong>Bank Balance Tracking:</strong> Each NPC tracks their cumulative money received and spending patterns',
              '<strong>Lifestyle Inflation:</strong> NPCs develop more expensive habits when receiving money (+$1/day per $10K sent)',
              '<strong>AI-Enhanced Requests:</strong> Smart, context-aware money requests based on financial need, personality, and relationship',
              '<strong>Complete Save/Load System:</strong> Import/Export saves as JSON files with metadata and validation',
              '<strong>Patch Notes System:</strong> View update history with timestamp-based versioning (YYMMDDHHMMSS format)'
            ]
          },
          {
            category: '💾 Save System Improvements',
            items: [
              'Export saves to JSON files with metadata (version, timestamp, player stats)',
              'Import saves from files with validation and preview before loading',
              'Save files include confirmation dialog showing money, employees, prestige level',
              'Automatic filename generation with timestamps',
              'Legacy save format detection and migration support',
              'Pretty-printed JSON for easy editing and debugging',
              'Full state restoration with UI refresh after import'
            ]
          },
          {
            category: '🐛 Critical Bug Fixes',
            items: [
              '<strong>Fixed black screen after prestiging</strong> - Now properly loads dashboard with full UI refresh',
              '<strong>Fixed sandbox settings not saving</strong> - Personality attributes, conversation phase, and memory cap now persist correctly',
              'Fixed personality attributes (confidence, outgoing, flirty, professional, humor) not being saved',
              'Fixed conversation phase dropdown not persisting between edits',
              'Fixed memory cap adjustments being lost after save',
              'Prestige now forces complete UI refresh for all tabs (dashboard, business, people)',
              'Added object initialization checks to prevent undefined property errors'
            ]
          },
          {
            category: '📈 Financial System Balance',
            items: [
              '<strong>Early game ($1K-$100K):</strong> NPCs spend $60-180/day, request $500-$3,000',
              '<strong>Mid game ($1M):</strong> NPCs spend $125-375/day, request $2,000-$20,000',
              '<strong>Late game ($100M):</strong> NPCs spend $225-675/day, request $10,000-$150,000',
              '<strong>End game ($1B+):</strong> NPCs spend $300-900/day, request $50,000-$500,000+',
              'Request probability scales with financial desperation (broke NPCs more likely to ask)',
              'Spending rate caps at $50,000/day to prevent absurdity',
              'Request probability caps at 35% maximum to prevent spam'
            ]
          },
          {
            category: '🎨 UI Enhancements',
            items: [
              'Redesigned Data Management section with color-coded buttons',
              'Added emojis and better labels for all save/load actions',
              'New Patch Notes modal with organized categories and version history',
              'Improved notification messages with context and status',
              'Better visual hierarchy in settings panel',
              'Confirmation dialogs show detailed info before destructive actions'
            ]
          },
          {
            category: '⚙️ Technical Improvements',
            items: [
              'Added <code>calculateScaledSpendingRate()</code> function for company-scaled spending',
              'Added <code>adjustEmployeeLifestyles()</code> for gradual lifestyle creep',
              'Enhanced <code>considerMoneyRequest()</code> with financial intelligence',
              'Improved <code>sendMoneyToNPC()</code> with better framing and reactions',
              'New <code>loadSaveData()</code> function for complete state restoration',
              'Added <code>handleImportedFile()</code> for file validation and parsing',
              'Enhanced <code>exportSave()</code> with metadata and pretty printing',
              'Better error handling and user feedback throughout save/load system'
            ]
          }
        ]
      }
      // Add future patch notes above this line
    ];
    
    // Generate HTML
    let html = '';
    patchNotes.forEach((patch, index) => {
      html += `
        <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:${index < patchNotes.length - 1 ? '20px' : '0'}; border:1px solid #667eea;">
          <div style="margin-bottom:15px;">
            <div style="display:flex; justify-content:space-between; align-items:start; flex-wrap:wrap; gap:10px;">
              <div>
                <h3 style="margin:0 0 5px 0; color:#667eea; font-size:1.5rem;">${patch.title}</h3>
                <div style="color:#aaa; font-size:0.9rem;">${patch.date}</div>
              </div>
              <div style="background:rgba(102,126,234,0.2); padding:6px 12px; border-radius:6px; border:1px solid #667eea;">
                <span style="color:#667eea; font-family:monospace; font-size:0.85rem;">v${patch.version}</span>
              </div>
            </div>
          </div>
          
          ${patch.changes.map(category => `
            <div style="margin-bottom:20px;">
              <h4 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">${category.category}</h4>
              <ul style="margin:0; padding-left:20px; color:#e0e0e0;">
                ${category.items.map(item => `<li style="margin-bottom:8px; line-height:1.5;">${item}</li>`).join('')}
              </ul>
            </div>
          `).join('')}
        </div>
      `;
    });
    
    patchNotesContent.innerHTML = html;
  }

  function showNotification(message, type = 'success') {
    // Create notification element
    const colors = {
      success: '#4caf50',
      error: '#e94560',
      warning: '#ffa726',
      info: '#2196f3'
    };
    
    const notification = document.createElement('div');
    notification.style.cssText = `position:fixed; bottom:20px; right:20px; background:${colors[type] || colors.success}; color:white; padding:15px 20px; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3); z-index:3000; max-width:300px; animation: slideIn 0.3s;`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.animation = 'fadeOut 0.3s';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
  
  // Save game
  // Flag to prevent saving during reset
  let isResetting = false;
  
  // Save game using kv-plugin (avoids localStorage quota limits)
  async function saveGame(showToast = true) {
    // Don't save if we're in the middle of resetting
    if (isResetting) return;
    
    try {
      // Don't update lastPlayTime here - it should only update when page becomes hidden
      // or when user is actually leaving
      await kv.gameSave.set("gameState", gameState);
      if (showToast) showNotification('Game saved!');
    } catch (error) {
      console.error('Error saving game:', error);
      showNotification('Failed to save game!');
    }
  }

  // Load game using kv-plugin
  async function loadGame() {
    try {
      const savedState = await kv.gameSave.get("gameState");
      if (savedState) {
        const parsed = savedState;
        
        // CRITICAL FIX: Convert Sets/Maps that were serialized to Arrays/Objects BEFORE merging
        // This prevents them from being spread as arrays/objects into the new gameState
        if (parsed.usedEmployeeNames && Array.isArray(parsed.usedEmployeeNames)) {
          console.log(`[LoadGame] Pre-converting usedEmployeeNames Array (${parsed.usedEmployeeNames.length} items) to Set`);
          parsed.usedEmployeeNames = new Set(parsed.usedEmployeeNames);
        }
        if (parsed.blockedProactiveMessages && Array.isArray(parsed.blockedProactiveMessages)) {
          console.log(`[LoadGame] Pre-converting blockedProactiveMessages Array (${parsed.blockedProactiveMessages.length} items) to Set`);
          parsed.blockedProactiveMessages = new Set(parsed.blockedProactiveMessages);
        }
        if (parsed.recentTopics && !parsed.recentTopics.has) {
          const entries = Object.entries(parsed.recentTopics);
          console.log(`[LoadGame] Pre-converting recentTopics object (${entries.length} items) to Map`);
          parsed.recentTopics = new Map(entries);
        }
        
        // Merge saved state with default state to ensure all properties exist
        gameState = {
          ...gameState,
          ...parsed,
          // Ensure activeLocationId defaults to first unlocked location
          activeLocationId: parsed.activeLocationId || 'garage',
          upgradeMultiplier: parsed.upgradeMultiplier || 1,
          // Ensure locations have proper unlock states
          locations: (parsed.locations || gameState.locations).map(loc => ({
            unlocked: loc.unlocked ?? (loc.owned ?? (loc.id === 'garage')), // First location or previously owned
            owned: loc.owned ?? loc.unlocked ?? (loc.id === 'garage'),
            ...loc
          })),
          // Ensure critical objects are properly initialized
          products: (parsed.products || gameState.products).map(p => {
            // Define unlock costs based on product id (for backwards compatibility)
            const defaultUnlockCosts = {
              'website': 0,      // first product is free
              'app': 100,
              'consulting': 400,
              'cloud': 1800,
              'seo': 3000,
              'branding': 5000,
              'ecommerce': 8000,
              'automation': 12000,
              'copywriting': 0, // first in home_office
              'video_editing': 20000,
              'marketing': 35000,
              'consulting_premium': 55000,
              'saas': 85000
            };
            
            return {
              // backfill new balance fields for old saves
              baseUpgradeCost: p.baseUpgradeCost ?? p.upgradeCost ?? 50,
              costGrowth: p.costGrowth ?? 1.35,
              valueExponent: p.valueExponent ?? 0.85,
              managerSpeedCapPct: p.managerSpeedCapPct ?? 0.40,
              // backfill unlock properties
              unlocked: p.unlocked ?? (p.id === 'website' ? true : false), // first product unlocked by default
              unlockCost: p.unlockCost ?? (defaultUnlockCosts[p.id] || 0),
              ...p
            };
          }),
          employees: parsed.employees || gameState.employees,
          settings: {...gameState.settings, ...(parsed.settings || {})},
          chatHistory: parsed.chatHistory || {},
          typingStates: parsed.typingStates || {},
          onboarding: parsed.onboarding || [],
          
          // Player profile data
          playerProfile: {
            ...gameState.playerProfile,
            ...(parsed.playerProfile || {})
          },
          
          // Ensure social network data exists (backward compatibility)
          socialNetwork: {
            ...gameState.socialNetwork,
            ...(parsed.socialNetwork || {}),
            posts: parsed.socialNetwork?.posts || [],
            globalEvents: parsed.socialNetwork?.globalEvents || [],
            postIdCounter: parsed.socialNetwork?.postIdCounter || 0,
            feedFilter: parsed.socialNetwork?.feedFilter || 'all',
            feedSort: parsed.socialNetwork?.feedSort || 'recent',
            recentPostTypes: parsed.socialNetwork?.recentPostTypes || [],
            playerDraft: parsed.socialNetwork?.playerDraft || {
              caption: '',
              imagePrompt: '',
              altText: '',
              imageUrl: null
            }
          },
          
          // Company context and awareness
          companyContext: {
            ...gameState.companyContext,
            ...(parsed.companyContext || {})
          },
          companyWideContext: {
            ...gameState.companyWideContext,
            ...(parsed.companyWideContext || {}),
            currentBuzz: parsed.companyWideContext?.currentBuzz || [],
            lastUpdate: parsed.companyWideContext?.lastUpdate || Date.now(),
            maxItems: parsed.companyWideContext?.maxItems || 40,
            decayTime: parsed.companyWideContext?.decayTime || 604800000
          },
          
          // Prestige system
          prestigeLevel: parsed.prestigeLevel ?? 0,
          influencePoints: parsed.influencePoints ?? 0,
          lifetimeEarnings: parsed.lifetimeEarnings ?? 0,
          lifetimeEarningsConverted: parsed.lifetimeEarningsConverted ?? 0,
          prestigeMultiplier: parsed.prestigeMultiplier ?? 1.0,
          
          // Global upgrades
          globalUpgrades: {
            clickPower: parsed.globalUpgrades?.clickPower ?? 0,
            incomeBoost: parsed.globalUpgrades?.incomeBoost ?? {},
            costReduction: parsed.globalUpgrades?.costReduction ?? {}
          },
          
          // Boss fights
          bossFights: {
            active: parsed.bossFights?.active || null,
            defeated: parsed.bossFights?.defeated || [],
            history: parsed.bossFights?.history || []
          }
        };
        
        // Initialize social data for all employees (migration for old saves)
        gameState.employees.forEach(emp => {
          initializeEmployeeSocialData(emp);
          ensureEmployeeMemory(emp);
          
          // Migrate gift preferences for old saves
          if (!emp.giftPreferences) {
            emp.giftPreferences = generateGiftPreferences();
          }
          
          // Initialize hireDate for old saves (use a past date so sorting works)
          if (!emp.hireDate) {
            emp.hireDate = Date.now() - (Math.random() * 30 * 24 * 60 * 60 * 1000); // Random date within last 30 days
          }
          
          // Initialize career data for old saves (Corporate Ladder System)
          if (!emp.career) {
            emp.career = {
              level: 1,
              title: gameState.hierarchyLevels[1].title,
              salary: gameState.hierarchyLevels[1].baseSalary,
              startDate: emp.hireDate || Date.now(),
              promotionHistory: [],
              directReports: [],
              managerId: null
            };
            console.log(`[LoadGame] Initialized career data for ${emp.name} at Level 1`);
          }
          
          // MIGRATION FIX: Update old "Entry Level" titles to "Staff"
          if (emp.career.title === "Entry Level") {
            emp.career.title = "Staff";
            emp.career.level = 1; // Ensure level is correct
            const levelInfo = gameState.hierarchyLevels?.[1];
            if (levelInfo) {
              emp.career.salary = levelInfo.baseSalary;
            }
            console.log(`[LoadGame Migration] Updated ${emp.name}'s title from "Entry Level" to "Staff" (Level 1)`);
          }
          
          // MIGRATION FIX: Ensure career level matches career title
          if (emp.career && emp.career.title) {
            const expectedLevel = Object.keys(gameState.hierarchyLevels || {}).find(lvl => {
              const levelInfo = gameState.hierarchyLevels[lvl];
              return levelInfo && levelInfo.title === emp.career.title;
            });
            
            if (expectedLevel && emp.career.level != expectedLevel) {
              emp.career.level = parseInt(expectedLevel);
              console.log(`[LoadGame Migration] Synced ${emp.name}'s level to ${expectedLevel} to match title "${emp.career.title}"`);
            }
          }
        });
        
        // MIGRATION FIX: Auto-assign employees to products based on old "position" field
        // Old system stored position as "Manager – [Product Name]"
        // Extract product name and auto-assign ONCE, then clean up old fields
        let autoAssignedCount = 0;
        
        gameState.employees.forEach(emp => {
          // Check if employee has old-style position field with "Manager –" or "Manager -"
          if (emp.position && /Manager\s*[–-]\s*(.+)/.test(emp.position)) {
            const match = emp.position.match(/Manager\s*[–-]\s*(.+?)(?:\s*•|$)/);
            if (match) {
              const productNameFromPosition = match[1].trim();
              console.log(`[LoadGame Migration] Found old position for ${emp.name}: "${emp.position}" -> extracting product: "${productNameFromPosition}"`);
              
              // Find matching product by name
              const matchingProduct = gameState.products.find(p => 
                p.name.toLowerCase() === productNameFromPosition.toLowerCase()
              );
              
              if (matchingProduct && matchingProduct.unlocked && !matchingProduct.managerHired) {
                // Auto-assign this employee to the product
                matchingProduct.managerHired = true;
                matchingProduct.managerId = emp.id;
                matchingProduct.managerLevel = matchingProduct.managerLevel || 1;
                matchingProduct.onboardStartTime = null; // Skip onboarding for migrated employees
                
                console.log(`[LoadGame Migration] ✓ Auto-assigned ${emp.name} to "${matchingProduct.name}"`);
                autoAssignedCount++;
              } else if (matchingProduct) {
                console.log(`[LoadGame Migration] ⚠ Product "${productNameFromPosition}" found but already has staff or is locked`);
              } else {
                console.log(`[LoadGame Migration] ⚠ Product "${productNameFromPosition}" not found`);
              }
            }
          }
          
          // Clean up old fields that are no longer used
          if (emp.position) {
            console.log(`[LoadGame Migration] Cleaning up old position field for ${emp.name}: "${emp.position}"`);
            delete emp.position;
          }
          if (emp.productManaged) {
            console.log(`[LoadGame Migration] Cleaning up old productManaged field for ${emp.name}: "${emp.productManaged}"`);
            delete emp.productManaged;
          }
        });
        
        if (autoAssignedCount > 0) {
          console.log(`[LoadGame Migration] Auto-assigned ${autoAssignedCount} employee(s) to their products from old save data`);
          showNotification(`Migration: Auto-assigned ${autoAssignedCount} employee(s) to their positions!`);
        }
        
        // MIGRATION FIX: Clean up product managerId references that point to non-existent employees
        // This fixes "Managed by Unknown" issue in old saves (run AFTER auto-assignment)
        const validEmployeeIds = new Set(gameState.employees.map(e => e.id));
        let fixedProducts = 0;
        
        gameState.products.forEach(product => {
          if (product.managerHired && product.managerId) {
            // Check if managerId points to an existing employee
            if (!validEmployeeIds.has(product.managerId)) {
              console.log(`[LoadGame Migration] Product "${product.name}" has invalid managerId: ${product.managerId} - clearing`);
              product.managerHired = false;
              product.managerId = null;
              product.managerLevel = 0;
              fixedProducts++;
            }
          } else if (product.managerHired && !product.managerId) {
            // Manager hired but no ID set - this is invalid
            console.log(`[LoadGame Migration] Product "${product.name}" has managerHired=true but no managerId - clearing`);
            product.managerHired = false;
            product.managerLevel = 0;
            fixedProducts++;
          }
        });
        
        if (fixedProducts > 0) {
          console.log(`[LoadGame Migration] Fixed ${fixedProducts} product(s) with invalid manager references`);
          showNotification(`Migration: Fixed ${fixedProducts} orphaned product assignment(s).`);
        }
        
        // MIGRATION FIX: Sync employees to corporate pyramid positions after product assignment
        // This ensures employees show up in the Corporate Ladder screen at their correct positions
        gameState.products.forEach(product => {
          if (product.managerHired && product.managerId) {
            // Find the staff position for this product in the corporate pyramid
            const staffPosition = gameState.corporatePyramid?.positions?.[1]?.find(
              pos => pos.productId === product.id
            );
            
            if (staffPosition && !staffPosition.employeeId) {
              // Assign employee to pyramid position
              staffPosition.employeeId = product.managerId;
              staffPosition.isVacant = false;
              
              const employee = gameState.employees.find(e => e.id === product.managerId);
              if (employee) {
                console.log(`[LoadGame Migration] ✓ Synced ${employee.name} to corporate pyramid position: ${staffPosition.title}`);
              }
            }
          }
        });
        
        // Ensure gift inventory exists
        if (!gameState.giftInventory) {
          gameState.giftInventory = {
            items: [],
            capacity: Infinity
          };
        }
        
        // Ensure gift store exists (new system)
        if (!gameState.giftStore) {
          gameState.giftStore = {
            items: []
          };
        }
        
        // Ensure currentLifetimeIncome exists
        if (gameState.currentLifetimeIncome === undefined) {
          gameState.currentLifetimeIncome = gameState.totalEarnings || 0;
        }
        
        // Ensure givenUniqueGifts exists
        if (!gameState.givenUniqueGifts) {
          gameState.givenUniqueGifts = [];
        }
        
        // Ensure createdUniqueGifts exists (new system)
        if (!gameState.createdUniqueGifts) {
          gameState.createdUniqueGifts = [];
        }
        
        // FIX: Update old timeScale value (60) to new value (20)
        if (gameState.time && gameState.time.timeScale === 60) {
          console.log('[LoadGame] Updating timeScale from 60 to 20 (1 game min = 3 real seconds)');
          gameState.time.timeScale = 20;
        }
        
        // SAFETY CHECK: Ensure Sets/Maps are properly initialized (fallback for edge cases)
        if (!gameState.usedEmployeeNames || !gameState.usedEmployeeNames.has) {
          console.warn('[LoadGame] usedEmployeeNames not a Set, initializing empty Set');
          gameState.usedEmployeeNames = new Set();
        }
        
        if (!gameState.blockedProactiveMessages || !gameState.blockedProactiveMessages.has) {
          console.warn('[LoadGame] blockedProactiveMessages not a Set, initializing empty Set');
          gameState.blockedProactiveMessages = new Set();
        }
        
        if (!gameState.recentTopics || !gameState.recentTopics.has) {
          console.warn('[LoadGame] recentTopics not a Map, initializing empty Map');
          gameState.recentTopics = new Map();
        }
        
        // FIX: Ensure genderSettings exists (backwards compatibility with old saves)
        if (!gameState.genderSettings) {
          console.log('[LoadGame] Initializing missing genderSettings with defaults');
          gameState.genderSettings = {
            female: 100,
            male: 0,
            femaleFuta: 0,
            transMan: 0,
            transWoman: 0
          };
        }
        
        // FIX: Ensure aiQuality exists (backwards compatibility with old saves)
        if (!gameState.aiQuality) {
          console.log('[LoadGame] Initializing missing aiQuality (RLHF system) with defaults');
          gameState.aiQuality = {
            goodExamples: { posts: [], comments: [], chats: [] },
            badExamples: { posts: [], comments: [], chats: [] },
            bannedPatterns: [],
            stats: { totalVotes: 0, upvotes: 0, downvotes: 0, postsVoted: 0, commentsVoted: 0, chatsVoted: 0 },
            maxExamplesPerType: 20,
            tutorialShown: false
          };
        }
        
        // Ensure playerMentionStats exists (for social feed analytics)
        if (!gameState.playerMentionStats) {
          gameState.playerMentionStats = {
            totalMentions: 0,
            positiveReactions: 0,
            negativeReactions: 0,
            lastMentionTime: null
          };
        }
        
        // Ensure activeGossip exists (for NPC chatter system)
        if (!gameState.activeGossip) {
          gameState.activeGossip = [];
        }
        
        // Ensure lastProactiveMessageCheck exists (for proactive NPC messages)
        if (!gameState.lastProactiveMessageCheck) {
          gameState.lastProactiveMessageCheck = 0;
        }
        
        // Ensure lifestyleAdjustmentCounter exists (for employee lifestyle updates)
        if (!gameState.lifestyleAdjustmentCounter) {
          gameState.lifestyleAdjustmentCounter = 0;
        }
        
        // Ensure currentCandidates exists (for hiring system)
        if (!gameState.currentCandidates) {
          gameState.currentCandidates = null;
        }
        
        // Ensure usedEmployeeNames is initialized (if it doesn't exist at all)
        if (!gameState.usedEmployeeNames) {
          gameState.usedEmployeeNames = new Set();
        }
        
        // Update company awareness on load
        updateCompanyAwareness();
        
        // Generate initial relationships if none exist
        const hasRelationships = gameState.employees.some(emp => 
          emp.relationships && Object.keys(emp.relationships).length > 0
        );
        if (!hasRelationships && gameState.employees.length > 1) {
          generateRandomRelationships();
        }
        
        // Initialize used names from loaded employees
        initializeUsedNames();
        
        showNotification('Game loaded!');
        
        // Check for AFK income
        checkAfkIncome();
      } else {
        // Try to migrate from old localStorage if available
        await migrateFromLocalStorage();
      }
    } catch (error) {
      console.error('Error loading game:', error);
      showNotification('Failed to load saved game. Starting fresh!');
    }
  }
  
  // Check for AFK income when player returns
  function checkAfkIncome() {
    // Ensure offline earnings settings exist
    if (!gameState.offlineEarnings) {
      gameState.offlineEarnings = {
        enabled: true,
        maxDuration: 24 * 60 * 60 * 1000, // 24 hours
        rate: 0.5, // 50%
        lastPlayedRealTime: Date.now()
      };
    }
    
    const now = Date.now();
    
    // Use offlineEarnings.lastPlayedRealTime for accurate offline tracking
    const lastActiveTime = gameState.offlineEarnings.lastPlayedRealTime || gameState.lastInteractionTime || gameState.lastPlayTime || now;
    const timeAway = now - lastActiveTime; // milliseconds (REAL TIME)
    
    // Only show if away for more than 5 minutes
    const MIN_TIME_AWAY = 5 * 60 * 1000; // 5 minutes
    if (timeAway < MIN_TIME_AWAY) {
      // Update times for next session
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Skip if offline earnings disabled
    if (!gameState.offlineEarnings.enabled) {
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate income per second (based on current game state)
    const incomePerSecond = parseFloat(calculateCashPerSecond());
    
    // If no income, skip
    if (incomePerSecond <= 0) {
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate time away in seconds (REAL TIME)
    const secondsAway = Math.floor(timeAway / 1000);
    
    // Cap at max duration from settings (default 24 hours)
    const maxAfkSeconds = Math.floor(gameState.offlineEarnings.maxDuration / 1000);
    const cappedSecondsAway = Math.min(secondsAway, maxAfkSeconds);
    
    // Calculate earnings at configured rate (default 50% of full rate)
    const afkRate = gameState.offlineEarnings.rate; // 0.5 = 50%
    const fullEarnings = incomePerSecond * cappedSecondsAway;
    const afkEarnings = Math.floor(fullEarnings * afkRate);
    
    // Log for debugging
    console.log(`[AFK] Time away: ${(cappedSecondsAway / 60).toFixed(1)} minutes`);
    console.log(`[AFK] Income rate: $${formatNumber(incomePerSecond)}/sec`);
    console.log(`[AFK] Full earnings (100%): $${formatNumber(fullEarnings)}`);
    console.log(`[AFK] AFK earnings (${afkRate * 100}%): $${formatNumber(afkEarnings)}`);
    
    // Format time away
    const hours = Math.floor(cappedSecondsAway / 3600);
    const minutes = Math.floor((cappedSecondsAway % 3600) / 60);
    const timeAwayText = hours > 0 
      ? `${hours}h ${minutes}m` 
      : `${minutes}m`;
    
    // Update modal with earnings info
    const afkModal = document.getElementById('afkIncomeModal');
    const timeAwayEl = document.getElementById('afkTimeAway');
    const incomeRateEl = document.getElementById('afkIncomeRate');
    const fullEarningsEl = document.getElementById('afkFullEarnings');
    const afkEarningsEl = document.getElementById('afkEarnings');
    const afkRateEl = document.getElementById('afkRate');
    const claimBtn = document.getElementById('claimAfkIncome');
    const closeBtn = document.getElementById('closeAfkIncome');
    
    if (timeAwayEl) timeAwayEl.textContent = timeAwayText;
    if (incomeRateEl) incomeRateEl.textContent = `$${formatNumber(incomePerSecond)}/sec`;
    if (fullEarningsEl) fullEarningsEl.textContent = `$${formatNumber(fullEarnings)}`;
    if (afkEarningsEl) afkEarningsEl.textContent = `$${formatNumber(afkEarnings)}`;
    if (afkRateEl) afkRateEl.textContent = `${afkRate * 100}%`;
    
    // Show modal
    if (afkModal) {
      afkModal.style.display = 'flex';
    }
    
    // Claim button handler
    if (claimBtn) {
      claimBtn.onclick = () => {
        gameState.cash += afkEarnings;
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + afkEarnings; // Track THIS prestige only
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        gameState.offlineEarnings.lastPlayedRealTime = now; // Update real time tracker
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
        showNotification(`Claimed $${formatNumber(afkEarnings)} AFK earnings!`);
      };
    }
    
    // Close button handler
    if (closeBtn) {
      closeBtn.onclick = () => {
        gameState.cash += afkEarnings; // Still give them the money
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + afkEarnings; // Track THIS prestige only
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        gameState.offlineEarnings.lastPlayedRealTime = now; // Update real time tracker
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
      };
    }
  }
  
  // Migrate old localStorage data to kv-plugin (one-time migration)
  async function migrateFromLocalStorage() {
    try {
      const oldSave = localStorage.gameState;
      if (oldSave) {
        console.log('Migrating old localStorage save to kv-plugin...');
        const parsed = JSON.parse(oldSave);
        await kv.gameSave.set("gameState", parsed);
        // Clear old localStorage to free up space
        delete localStorage.gameState;
        console.log('Migration complete! Old localStorage data cleared.');
        showNotification('Save data migrated to new storage system!');
        // Reload the game with the migrated data
        await loadGame();
      }
    } catch (error) {
      console.error('Error migrating from localStorage:', error);
    }
  }

  // ===== PRESTIGE SYSTEM FUNCTIONS =====
  
  // Define permanent upgrades purchasable with Influence Points
  const influenceUpgrades = {
    incomeMultiplier: {
      id: 'incomeMultiplier',
      name: 'Income Multiplier',
      description: 'Increase all income by 10% per level',
      icon: '💰',
      baseCost: 5,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.incomeMultiplier || 0,
      effect: (level) => 1 + (level * 0.1) // 10% per level
    },
    startingCash: {
      id: 'startingCash',
      name: 'Starting Capital',
      description: 'Start each prestige with more cash',
      icon: '💵',
      baseCost: 3,
      costIncrease: 1.4,
      maxLevel: 100,
      getCurrentLevel: () => gameState.influenceUpgrades?.startingCash || 0,
      effect: (level) => 50 * level // $50 per level
    },
    clickPower: {
      id: 'clickPower',
      name: 'Quick Hands',
      description: 'Click products to reduce time by +0.05s per level',
      icon: '👆',
      baseCost: 3,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.clickPower || 0,
      effect: (level) => level * 0.05 // +0.05s time reduction per click per level
    },
    employeeDiscount: {
      id: 'employeeDiscount',
      name: 'HR Efficiency',
      description: 'Reduce employee costs by 5% per level',
      icon: '👔',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 10,
      getCurrentLevel: () => gameState.influenceUpgrades?.employeeDiscount || 0,
      effect: (level) => Math.max(0.5, 1 - (level * 0.05)) // Max 50% discount at level 10
    },
    productDiscount: {
      id: 'productDiscount',
      name: 'Bulk Buying',
      description: 'Reduce product costs by 3% per level',
      icon: '📦',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 15,
      getCurrentLevel: () => gameState.influenceUpgrades?.productDiscount || 0,
      effect: (level) => Math.max(0.55, 1 - (level * 0.03)) // Max 45% discount at level 15
    },
    autoProgress: {
      id: 'autoProgress',
      name: 'Automation Boost',
      description: 'Managers work 5% faster per level',
      icon: '⚡',
      baseCost: 6,
      costIncrease: 1.4,
      maxLevel: 20,
      getCurrentLevel: () => gameState.influenceUpgrades?.autoProgress || 0,
      effect: (level) => 1 + (level * 0.05) // 5% faster per level
    }
  };
  
  // Initialize influence upgrades in gameState if not present
  if (!gameState.influenceUpgrades) {
    gameState.influenceUpgrades = {};
    Object.keys(influenceUpgrades).forEach(key => {
      gameState.influenceUpgrades[key] = 0;
    });
  }
  
  // Calculate how many influence points player will gain from current lifetime earnings
  function calculateInfluenceGain() {
    // Only count earnings that haven't been converted to influence yet
    const unconvertedEarnings = gameState.lifetimeEarnings - (gameState.lifetimeEarningsConverted || 0);
    // Formula: sqrt(earnings / 10000) rounded down
    // This means: $10k = 1 IP, $40k = 2 IP, $90k = 3 IP, $160k = 4 IP, etc.
    return Math.floor(Math.sqrt(unconvertedEarnings / 10000));
  }
  
  // Calculate cost of next level for an influence upgrade
  function getInfluenceUpgradeCost(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return 0;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) return Infinity;
    
    return Math.ceil(upgrade.baseCost * Math.pow(upgrade.costIncrease, currentLevel));
  }
  
  // Purchase an influence upgrade
  function purchaseInfluenceUpgrade(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return false;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) {
      showNotification('Upgrade is at max level!');
      return false;
    }
    
    const cost = getInfluenceUpgradeCost(upgradeId);
    if (gameState.influencePoints < cost) {
      showNotification('Not enough Influence Points!');
      return false;
    }
    
    // Purchase upgrade
    gameState.influencePoints -= cost;
    gameState.influenceUpgrades[upgradeId] = currentLevel + 1;
    
    showNotification(`Upgraded ${upgrade.name} to level ${currentLevel + 1}!`);
    updatePrestigeUI();
    renderInfluenceUpgrades();
    return true;
  }
  
  // Render the influence upgrades shop
  function renderInfluenceUpgrades() {
    const container = document.getElementById('influenceUpgradesContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    Object.values(influenceUpgrades).forEach(upgrade => {
      const currentLevel = upgrade.getCurrentLevel();
      const cost = getInfluenceUpgradeCost(upgrade.id);
      const isMaxed = currentLevel >= upgrade.maxLevel;
      const canAfford = gameState.influencePoints >= cost && !isMaxed;
      
      const upgradeDiv = document.createElement('div');
      upgradeDiv.style.cssText = `
        background: #16213e;
        border-radius: 12px;
        padding: 20px;
        border: 2px solid ${canAfford ? '#ffd700' : '#2a3f5f'};
        transition: all 0.3s;
        opacity: ${isMaxed ? '0.6' : '1'};
      `;
      
      if (canAfford) {
        upgradeDiv.style.cursor = 'pointer';
        upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        upgradeDiv.onmouseenter = () => {
          upgradeDiv.style.transform = 'translateY(-3px)';
          upgradeDiv.style.boxShadow = '0 6px 20px rgba(255,215,0,0.3)';
        };
        upgradeDiv.onmouseleave = () => {
          upgradeDiv.style.transform = 'translateY(0)';
          upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        };
        upgradeDiv.onclick = () => purchaseInfluenceUpgrade(upgrade.id);
      }
      
      upgradeDiv.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
          <div>
            <div style="font-size:2rem; margin-bottom:8px;">${upgrade.icon}</div>
            <div style="font-weight:700; font-size:1.1rem; color:white; margin-bottom:5px;">${upgrade.name}</div>
            <div style="color:#aaa; font-size:0.85rem; line-height:1.4;">${upgrade.description}</div>
          </div>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px; padding-top:15px; border-top:1px solid #2a3f5f;">
          <div style="color:#00d4ff; font-size:0.9rem;">Level ${currentLevel}/${upgrade.maxLevel}</div>
          <div style="color:${canAfford ? '#ffd700' : isMaxed ? '#2ecc71' : '#666'}; font-weight:700; font-size:1.1rem;">
            ${isMaxed ? '✓ MAXED' : `${cost} IP`}
          </div>
        </div>
      `;
      
      container.appendChild(upgradeDiv);
    });
  }
  
  // Update the prestige UI with current stats
  function updatePrestigeUI() {
    // Update current stats
    const currentPrestigeLevelEl = document.getElementById('currentPrestigeLevel');
    const lifetimeEarningsEl = document.getElementById('lifetimeEarningsDisplay');
    const currentInfluencePointsEl = document.getElementById('currentInfluencePoints');
    const currentMultiplierEl = document.getElementById('currentMultiplier');
    const nextPrestigeInfluenceEl = document.getElementById('nextPrestigeInfluence');
    const prestigeReqEl = document.getElementById('prestigeRequirement');
    
    if (currentPrestigeLevelEl) currentPrestigeLevelEl.textContent = gameState.prestigeLevel;
    if (lifetimeEarningsEl) lifetimeEarningsEl.textContent = `$${formatNumber(gameState.lifetimeEarnings)}`;
    if (currentInfluencePointsEl) currentInfluencePointsEl.textContent = gameState.influencePoints;
    
    // Calculate total multiplier from all sources
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const totalMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (currentMultiplierEl) currentMultiplierEl.textContent = `${totalMultiplier.toFixed(1)}x`;
    
    // Calculate influence gain for next prestige
    const influenceGain = calculateInfluenceGain();
    if (nextPrestigeInfluenceEl) nextPrestigeInfluenceEl.textContent = influenceGain;
    
    // Check if player meets requirement to prestige (at least $100k lifetime earnings)
    const canPrestige = gameState.lifetimeEarnings >= 100000 && influenceGain > 0;
    const prestigeBtn = document.getElementById('prestigeBtn');
    
    if (prestigeBtn) {
      if (canPrestige) {
        prestigeBtn.disabled = false;
        prestigeBtn.style.opacity = '1';
        prestigeBtn.style.cursor = 'pointer';
        if (prestigeReqEl) prestigeReqEl.textContent = '';
      } else {
        prestigeBtn.disabled = true;
        prestigeBtn.style.opacity = '0.5';
        prestigeBtn.style.cursor = 'not-allowed';
        if (prestigeReqEl) {
          const needed = 100000 - gameState.lifetimeEarnings;
          prestigeReqEl.textContent = `Requires $100k total earnings (need $${formatNumber(needed)} more)`;
        }
      }
    }
  }
  
  // Show the prestige confirmation modal
  function showPrestigeModal() {
    const influenceGain = calculateInfluenceGain();
    if (influenceGain <= 0 || gameState.lifetimeEarnings < 100000) {
      showNotification('You need at least $100k lifetime earnings to prestige!');
      return;
    }
    
    const modal = document.getElementById('prestigeModal');
    const gainAmount = document.getElementById('prestigeGainAmount');
    
    if (gainAmount) gainAmount.textContent = `+${influenceGain}`;
    if (modal) modal.style.display = 'flex';
  }
  
  // Execute the prestige (reset game with benefits)
  function executePrestige() {
    const influenceGain = calculateInfluenceGain();
    
    // Award influence points
    gameState.influencePoints += influenceGain;
    gameState.prestigeLevel += 1;
    
    // Mark current lifetime earnings as converted to prevent re-claiming
    gameState.lifetimeEarningsConverted = gameState.lifetimeEarnings;
    
    // Reset current lifetime income (this prestige only)
    gameState.currentLifetimeIncome = 0;
    
    // Preserve these values
    const preservedInfluencePoints = gameState.influencePoints;
    const preservedPrestigeLevel = gameState.prestigeLevel;
    const preservedLifetimeEarnings = gameState.lifetimeEarnings;
    const preservedLifetimeEarningsConverted = gameState.lifetimeEarningsConverted;
    const preservedInfluenceUpgrades = {...gameState.influenceUpgrades};
    const preservedSettings = {...gameState.settings};
    const preservedPlayerBio = gameState.settings?.playerBio || '';
    const preservedGenderSettings = {...gameState.genderSettings};
    
    // NEW: Preserve former employees for rehiring
    const preservedFormerEmployees = gameState.formerEmployees || [];
    
    // ========== CORPORATE HIERARCHY: PRESERVE EMPLOYEES TO REHIRE POOL ==========
    const preservedRehirePool = [];
    
    // Save current employees to rehire pool
    gameState.employees.forEach(employee => {
      if (!employee || !employee.name) return;
      if (employee.employmentStatus !== 'active') return;
      
      // Calculate relationship strength
      const relationshipStrength = calculateRelationshipStrength(employee);
      
      // Calculate productivity bonus for rehire
      const rehireBonus = calculateRehireBonus(employee);
      
      // Create rehire data snapshot
      const rehireData = {
        // Identity
        id: employee.id,
        name: employee.name,
        age: employee.age,
        gender: employee.gender,
        
        // Career snapshot
        previousLevel: employee.career?.level || 1,
        previousTitle: employee.career?.title || "Staff",
        previousSalary: employee.career?.salary || 40000,
        promotionHistory: employee.career?.promotionHistory ? [...employee.career.promotionHistory] : [],
        
        // Full stat preservation
        stats: {...employee.stats},
        skills: employee.skills ? JSON.parse(JSON.stringify(employee.skills)) : {},
        personality: {...employee.personality},
        
        // Relationship data
        relationshipStrength: relationshipStrength,
        rehireBonus: rehireBonus,
        
        // Memory preservation
        memory: employee.memory ? {...employee.memory} : {},
        chatHistory: gameState.chatHistory[employee.id] ? [...gameState.chatHistory[employee.id]] : [],
        
        // Physical & bio data
        physical: employee.physical ? {...employee.physical} : {},
        profileImage: employee.profileImage,
        bio: employee.bio,
        
        // Traits
        keyTrait: employee.keyTrait,
        personalityTraits: employee.personalityTraits ? [...employee.personalityTraits] : [],
        hobbies: employee.hobbies ? [...employee.hobbies] : [],
        kinks: employee.kinks ? [...employee.kinks] : [],
        
        // Product association
        productId: employee.productId,
        productManaged: employee.productManaged,
        
        // Gift preferences
        giftPreferences: employee.giftPreferences,
        
        // Meta
        timesRehired: (employee.timesRehired || 0),
        originalHireDate: employee.hireDate || Date.now(),
        lastPrestigeLevel: preservedPrestigeLevel
      };
      
      preservedRehirePool.push(rehireData);
    });
    
    console.log(`💼 Preserved ${preservedRehirePool.length} employees to rehire pool`);
    
    // Save current employees as former employees (with their product associations) - LEGACY SYSTEM
    gameState.employees.forEach(emp => {
      if (emp.productManaged) {
        // Check if this employee was already a former employee
        const existingFormerIndex = preservedFormerEmployees.findIndex(
          fe => fe.originalId === (emp.originalId || emp.id)
        );
        
        const employeeData = {
          // Preserve original ID for tracking across prestiges
          originalId: emp.originalId || emp.id,
          name: emp.name,
          age: emp.age,
          gender: emp.gender,
          position: emp.position,
          productManaged: emp.productManaged,
          profileImage: emp.profileImage,
          bio: emp.bio,
          personality: emp.personality,
          personalityTraits: emp.personalityTraits,
          hobbies: emp.hobbies,
          kinks: emp.kinks,
          traits: emp.traits,
          keyTrait: emp.keyTrait,
          physical: emp.physical,
          chatHistory: gameState.chatHistory[emp.id] || [],
          photos: emp.photos || [],
          memory: emp.memory,
          stats: emp.stats,
          relationships: emp.relationships,
          intimacy: emp.intimacy,
          // Track loyalty (times rehired)
          timesRehired: existingFormerIndex >= 0 ? (preservedFormerEmployees[existingFormerIndex].timesRehired || 0) + 1 : 1,
          lastPrestigeLevel: preservedPrestigeLevel
        };
        
        if (existingFormerIndex >= 0) {
          // Update existing former employee data
          preservedFormerEmployees[existingFormerIndex] = employeeData;
        } else {
          // Add new former employee
          preservedFormerEmployees.push(employeeData);
        }
      }
    });
    
    // ========== BASE UNLOCK COST LOOKUP ==========
    // Define base unlock costs for ALL products (used to reset after prestige)
    const baseUnlockCosts = {
      // Garage
      'website': 0,
      'app': 80,
      'consulting': 300,
      'cloud': 1200,
      'seo': 3000,
      'branding': 5000,
      'ecommerce': 8000,
      'automation': 12000,
      // Home Office
      'copywriting': 0,
      'video_editing': 20000,
      'marketing': 35000,
      'consulting_premium': 55000,
      'saas': 85000,
      'virtual_assistant': 120000,
      'social_media_mgmt': 180000,
      'online_courses': 250000,
      'business_coaching': 350000,
      'digital_marketing': 480000,
      // Office Suite
      'enterprise_saas': 0,
      'enterprise_software': 700000,
      'api_marketplace': 1200000,
      'white_label': 2000000,
      'cybersecurity': 3500000,
      'data_analytics': 5500000,
      'crm_system': 8500000,
      'ai_integration': 13000000,
      'blockchain': 20000000,
      'acquisitions': 30000000,
      // Factory
      'custom_keychains': 0,
      'branded_tshirts': 35000000,
      'phone_cases': 60000000,
      'custom_mugs': 100000000,
      'tech_gadgets': 150000000,
      'luxury_merch': 230000000,
      'smart_devices': 350000000,
      'wearables': 520000000,
      'vr_headsets': 780000000,
      'drones': 1170000000,
      // Corporate Tower
      'patent_licensing': 0,
      'venture_capital': 1500000000,
      'hedge_fund': 2500000000,
      'market_manipulation': 4000000000,
      'insider_trading': 6500000000,
      'tax_havens': 10000000000,
      'lobbying': 15000000000,
      'government_contracts': 23000000000,
      'space_tourism': 35000000000,
      'quantum_computing': 50000000000
    };
    
    // Calculate starting cash from influence upgrades
    const startingCashBonus = influenceUpgrades.startingCash.effect(
      gameState.influenceUpgrades?.startingCash || 0
    );
    
    // Reset game state (this resets everything to defaults)
    const freshState = {
      cash: gameBalance.startingCash + startingCashBonus,
      playerUpgrades: { clickPower: 0 },
      totalEarnings: 0,
      onboarding: [],
      lastPlayTime: Date.now(),
      
      // PRESTIGE SYSTEM (preserved)
      prestigeLevel: preservedPrestigeLevel,
      influencePoints: preservedInfluencePoints,
      lifetimeEarnings: preservedLifetimeEarnings,
      lifetimeEarningsConverted: preservedLifetimeEarningsConverted,
      prestigeMultiplier: 1.0,
      influenceUpgrades: preservedInfluenceUpgrades,
      
      // GLOBAL UPGRADES (reset on prestige)
      globalUpgrades: {
        clickPower: 0,
        incomeBoost: {},
        costReduction: {}
      },
      
      // BOSS FIGHTS (reset)
      bossFights: {
        active: null,
        defeated: [],
        history: []
      },
      
      // Locations (reset to just garage)
      locations: gameState.locations.map(loc => ({
        ...loc,
        owned: loc.id === 'garage',
        unlocked: loc.id === 'garage',
        products: []
      })),
      
      activeLocationId: 'garage',
      
      // Products (reset all progress, keep only base definition properties)
      products: gameState.products.map(p => ({
        // Keep base definition properties
        id: p.id,
        name: p.name,
        locationId: p.locationId,
        nsfwLevel: p.nsfwLevel,
        
        // Economic properties (keep base values)
        valuePerUnit: p.valuePerUnit,
        baseUpgradeCost: p.baseUpgradeCost,
        costGrowth: p.costGrowth,
        valuePerUpgrade: p.valuePerUpgrade,
        valueExponent: p.valueExponent,
        
        // Timing properties (keep base values)
        baseTimeMs: p.baseTimeMs,
        clickSecondsBase: p.clickSecondsBase,
        
        // Manager properties (keep base costs)
        managerHireCost: p.managerHireCost,
        managerUpgradeCost: p.managerUpgradeCost,
        managerSpeedCapPct: p.managerSpeedCapPct,
        
        // Unlock properties - RESET to base unlock cost (fixes prestige lock bug)
        unlockCost: baseUnlockCosts[p.id] !== undefined ? baseUnlockCosts[p.id] : p.unlockCost,
        
        // RESET all progress properties
        quantity: 0,
        level: 0,
        upgradeCost: p.baseUpgradeCost, // Reset to base cost
        unlocked: false,
        running: false,
        timeRemainingMs: 0,
        managerHired: false,
        managerLevel: 0
      })),
      
      // Employees (reset)
      employees: [],
      
      // ========== CORPORATE HIERARCHY SYSTEM ==========
      hierarchyLevels: gameState.hierarchyLevels, // Preserve structure
      corporateHierarchy: {
        levels: { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [] },
        executiveRoles: { COO: null, CFO: null }
      },
      rehirePool: preservedRehirePool, // Preserved rehire candidates
      currentHiringCandidates: {
        newHires: [],
        rehires: [],
        productId: null,
        activeTab: 'newHires'
      },
      globalIncomeMultiplier: 1.0,
      
      // Former employees (preserved for rehiring) - LEGACY SYSTEM
      formerEmployees: preservedFormerEmployees,
      
      // Social Network (reset)
      socialNetwork: {
        posts: [],
        globalEvents: [],
        postIdCounter: 0,
        lastPostGeneration: 0,
        postGenerationInterval: 300000,
        feedFilter: 'all',
        feedSort: 'recent',
        recentPostTypes: [],
        playerDraft: {
          caption: '',
          imagePrompt: '',
          altText: '',
          imageUrl: null
        }
      },
      
      // Company Context (reset)
      companyContext: {
        totalEmployees: 0,
        locationEmployeeCounts: {},
        recentHires: [],
        recentFires: [],
        recentPromotions: [],
        interdepartmentalEvents: []
      },
      
      // Social Feed (deprecated but keep for compatibility)
      socialFeed: [],
      socialStats: {
        totalPosts: 0,
        totalLikes: 0,
        totalComments: 0
      },
      chatHistory: {},
      activeChat: null,
      
      // News (reset to defaults)
      news: [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ],
      
      // Settings (preserved)
      settings: {
        ...preservedSettings,
        playerBio: preservedPlayerBio
      },
      
      // Gender Settings (preserved)
      genderSettings: preservedGenderSettings,
      
      // AI Quality (preserved - don't lose training progress)
      aiQuality: gameState.aiQuality || {
        goodExamples: { posts: [], comments: [], chats: [] },
        badExamples: { posts: [], comments: [], chats: [] },
        bannedPatterns: [],
        stats: { totalVotes: 0, upvotes: 0, downvotes: 0, postsVoted: 0, commentsVoted: 0, chatsVoted: 0 },
        maxExamplesPerType: 20,
        tutorialShown: false
      },
      
      activeTab: 'dashboard',
      upgradeMultiplier: 1
    };
    
    // Replace gameState with fresh state
    Object.keys(gameState).forEach(key => delete gameState[key]);
    Object.assign(gameState, freshState);
    
    // Close modal
    const modal = document.getElementById('prestigeModal');
    if (modal) modal.style.display = 'none';
    
    // Save and refresh UI
    saveGame(false);
    updateUI();
    updatePrestigeUI();
    renderInfluenceUpgrades();
    
    // Show success notification
    showNotification(`✨ Prestiged! Gained ${influenceGain} Influence Points!`, 5000);
    
    // Switch to dashboard tab and force full refresh
    switchTab('dashboard');
    
    // Force reload the dashboard content after prestige
    setTimeout(() => {
      updateDashboard();
      refreshDashboardSections();
      updateBusinessTab();
      updatePeopleTab();
    }, 100);
  }

  // Autosave setup
  // Store autosave interval ID so we can clear it
  let autosaveIntervalId = null;
  
  function setupAutosave() {
    // Clear any existing autosave interval first
    if (autosaveIntervalId) {
      clearInterval(autosaveIntervalId);
      autosaveIntervalId = null;
    }
    
    if (gameState.settings.autosave) {
      autosaveIntervalId = setInterval(() => saveGame(false), 5000); // every 5s, no toast
    }
  }
  
  // Export save
  /**
   * Export save to downloadable JSON file
   */
  function exportSave() {
    try {
      // Create a save object with metadata
      const saveData = {
        version: '250116200000', // Current game version
        timestamp: Date.now(),
        date: new Date().toISOString(),
        gameState: gameState
      };
      
      const jsonString = JSON.stringify(saveData, null, 2); // Pretty print for readability
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      // Generate filename with timestamp
      const dateStr = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `FreeUseOffice-Save-${dateStr}.json`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
      showNotification(`💾 Save exported: ${filename}`, 'success');
    } catch (error) {
      console.error('Error exporting save:', error);
      showNotification('❌ Failed to export save!', 'error');
    }
  }
  
  /**
   * Import save from JSON file
   */
  function importSave() {
    const fileInput = document.getElementById('importFileInput');
    if (!fileInput) {
      showNotification('❌ Import system not available!', 'error');
      return;
    }
    
    // Trigger file picker
    fileInput.click();
  }
  
  /**
   * Handle imported file
   */
  function handleImportedFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    
    reader.onload = async function(e) {
      try {
        const contents = e.target.result;
        const saveData = JSON.parse(contents);
        
        // Validate save data structure
        if (!saveData.gameState) {
          // Try legacy format (direct gameState)
          if (saveData.cash !== undefined && saveData.products !== undefined) {
            // This looks like a direct gameState export
            if (confirm('⚠️ This appears to be an old save format. Import anyway? (May cause issues)')) {
              await loadSaveData(saveData);
            }
          } else {
            showNotification('❌ Invalid save file format!', 'error');
          }
          return;
        }
        
        // Show confirmation with save info
        const saveDate = saveData.date ? new Date(saveData.date).toLocaleString() : 'Unknown';
        const saveMoney = saveData.gameState.cash ? formatCash(saveData.gameState.cash) : 'Unknown';
        const saveEmployees = saveData.gameState.employees ? saveData.gameState.employees.length : 0;
        const savePrestige = saveData.gameState.prestigeLevel || 0;
        
        const confirmMsg = `📥 Import Save File?\n\n` +
          `💰 Money: ${saveMoney}\n` +
          `👥 Employees: ${saveEmployees}\n` +
          `✨ Prestige Level: ${savePrestige}\n` +
          `📅 Save Date: ${saveDate}\n\n` +
          `⚠️ This will overwrite your current progress!`;
        
        if (confirm(confirmMsg)) {
          await loadSaveData(saveData.gameState);
          showNotification('✅ Save imported successfully!', 'success');
        }
      } catch (error) {
        console.error('Error importing save:', error);
        showNotification('❌ Failed to import save! File may be corrupted.', 'error');
      }
      
      // Reset file input
      event.target.value = '';
    };
    
    reader.onerror = function() {
      showNotification('❌ Failed to read file!', 'error');
    };
    
    reader.readAsText(file);
  }
  
  /**
   * Load save data into game
   */
  async function loadSaveData(data) {
    try {
      // Clear current game state
      Object.keys(gameState).forEach(key => delete gameState[key]);
      
      // Load new state
      Object.assign(gameState, data);
      
      // Save to storage
      await kv.gameSave.set("gameState", gameState);
      
      // Refresh entire UI
      updateUI();
      updatePrestigeUI();
      renderInfluenceUpgrades();
      
      // Switch to dashboard and force refresh
      switchTab('dashboard');
      setTimeout(() => {
        updateDashboard();
        refreshDashboardSections();
        updateBusinessTab();
        updatePeopleTab();
        updateSocialTab();
      }, 100);
      
      // Restart autosave if enabled
      setupAutosave();
      
      return true;
    } catch (error) {
      console.error('Error loading save data:', error);
      showNotification('❌ Failed to load save data!', 'error');
      return false;
    }
  }
  
  // Reset game
  async function resetGame() {
    if (confirm('Are you sure you want to reset the game? All progress will be lost!')) {
      try {
        // Set reset flag to prevent any saves during reset
        isResetting = true;
        
        // Stop autosave immediately to prevent saving during reset
        if (autosaveIntervalId) {
          clearInterval(autosaveIntervalId);
          autosaveIntervalId = null;
        }
        
        // Wait a moment for any pending saves to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Clear kv storage
        await kv.gameSave.delete("gameState");
        
        // Clear old localStorage
        localStorage.removeItem('gameState');
        
        // Wait another moment to ensure delete operations complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Show notification before reload
        showNotification('Game reset! Reloading...');
        
        // Wait a bit for notification to show
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Now reload (isResetting flag will be cleared by reload)
        location.reload();
      } catch (error) {
        console.error('Error resetting game:', error);
        showNotification('Error resetting game. Please try again.');
        isResetting = false; // Reset flag on error
      }
    }
  }
  
  // Unlock location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(l => l.id === locationId);
    if (!location) return showNotification('Location not found!');
    
    if (location.unlocked) return showNotification('Location already unlocked!');
    
    // Check prerequisites
    if (!checkLocationUnlockable(locationId)) {
      return showNotification('Complete all products in previous locations first!');
    }
    
    // Check cost
    if (gameState.cash < location.cost) {
      return showNotification(`Need $${formatNumber(location.cost)} to unlock ${location.name}!`);
    }
    
    // Unlock location
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true; // backward compatibility
    
    // Initialize corporate pyramid positions for this location
    initializeHierarchicalPyramid();
    
    // Switch to the newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Unlock the first product in this location
    const firstProduct = gameState.products.find(p => p.locationId === locationId);
    if (firstProduct && firstProduct.unlockCost === 0) {
      firstProduct.unlocked = true;
    }
    
    showNotification(`${location.name} unlocked!`);
    updateBusinessTab();
    updateUI();
  }
  
  // Purchase location (backward compatibility alias)
  function purchaseLocation(locationId) {
    unlockLocation(locationId);
  }
  
  // Generate initial employees
  function generateInitialEmployees() {
    // Use the massive name pools defined earlier
    const traits = ['Hardworking', 'Creative', 'Analytical', 'Charismatic', 'Detail-oriented', 'Adaptable'];
    const personalities = ['Friendly', 'Reserved', 'Outgoing', 'Thoughtful', 'Energetic', 'Calm'];
    const hobbies = ['Reading', 'Photography', 'Hiking', 'Gaming', 'Cooking', 'Traveling', 'Music', 'Art', 'Yoga', 'Dancing'];
    const kinks = ['Exhibitionism', 'Bondage', 'Roleplay', 'Dominance', 'Submission', 'Voyeurism', 'Teasing', 'Spanking'];
    
    // Generate 2 initial employees
    for (let i = 0; i < 2; i++) {
      // Use gender selection system
      const gender = selectGenderForEmployee();
      const fullName = generateUniqueName(gender); // Use unique name generator with gender
      
      // Generate random traits and personality
      const trait = traits[Math.floor(Math.random() * traits.length)];
      const personality = personalities[Math.floor(Math.random() * personalities.length)];
      
      // Generate 1-3 random hobbies
      const numHobbies = Math.floor(Math.random() * 3) + 1;
      const employeeHobbies = [];
      while (employeeHobbies.length < numHobbies) {
        const hobby = hobbies[Math.floor(Math.random() * hobbies.length)];
        if (!employeeHobbies.includes(hobby)) {
          employeeHobbies.push(hobby);
        }
      }
      
      // Generate 2-4 random kinks
      const numKinks = Math.floor(Math.random() * 3) + 2;
      const employeeKinks = [];
      while (employeeKinks.length < numKinks) {
        const kink = kinks[Math.floor(Math.random() * kinks.length)];
        if (!employeeKinks.includes(kink)) {
          employeeKinks.push(kink);
        }
      }
      
      // Generate initial stats (0-100 scale)
      const stats = {
        affection: 20 + Math.floor(Math.random() * 20),   // How much they like you personally
        comfort: 40 + Math.floor(Math.random() * 30),      // How comfortable they feel around you
        trust: 30 + Math.floor(Math.random() * 30),        // How much they trust you
        desire: 5 + Math.floor(Math.random() * 15),        // Romantic/sexual attraction
        obedience: 40 + Math.floor(Math.random() * 30),    // Willingness to follow instructions
        productivity: 50 + Math.floor(Math.random() * 30)  // Work performance (affects game mechanics)
      };
      
      // Generate detailed physical appearance (NEW SYSTEM!) - Gender-aware
      const detailedPhysical = generateDetailedPhysicalAppearance(gender);
      
      // Generate AI personality attributes (C.O.F.P.H.)
      const aiPersonality = {
        confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
        outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
        flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
        professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
        humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
      };
      
      gameState.employees.push({
        id: `emp_${Date.now()}_${i}`,
        name: fullName, // Use the unique name generated above
        position: 'Employee',
        gender: gender,
        trait: trait,
        personality: aiPersonality,  // AI-readable personality object
        personalityTraits: [personality], // Human-readable personality traits
        hobbies: employeeHobbies,
        kinks: employeeKinks,
        stats: stats,
        level: 1,
        hired: true,
        bio: `A ${personality.toLowerCase()} and ${trait.toLowerCase()} team member who enjoys ${employeeHobbies.join(', ')}.`,
        physical: detailedPhysical, // Use new detailed system
        profileImage: null,
        memory: [] // long-term memory: facts, events, relationship history
      });
    }
  }

  // Expose functions to global scope for external access
  window.selectManagerCandidate = selectManagerCandidate;
  window.closeHiringModal = closeHiringModal;
  window.showNotification = showNotification;
  window.updateUI = updateUI;
  window.updateDashboard = updateDashboard;
  window.updateBusinessTab = updateBusinessTab;
  window.updatePeopleTab = updatePeopleTab;
  window.updateGiftsTab = updateGiftsTab;
  window.updateHRTab = updateHRTab;
  window.updateNewsFeed = updateNewsFeed;
  window.gameTick = gameTick;
  window.updateNews = updateNews;
  window.saveGame = saveGame;
  window.loadGame = loadGame;
  window.migrateFromLocalStorage = migrateFromLocalStorage;
  window.resetGame = resetGame;
  window.exportSave = exportSave;
  window.resetGame = resetGame;
  window.unlockLocation = unlockLocation;
  window.purchaseLocation = purchaseLocation;
  window.checkLocationUnlockable = checkLocationUnlockable;
  window.handleEmployeeAction = handleEmployeeAction;
  window.openChat = openChat;
  window.loadChatHistory = loadChatHistory;
  window.addChatMessage = addChatMessage;
  window.sendChatMessage = sendChatMessage;
  window.updateEmployeeStatsFromChat = updateEmployeeStatsFromChat;
  window.setupEventListeners = setupEventListeners;
  window.switchTab = switchTab;
  window.updateTabContent = updateTabContent;
  window.updateProductsList = updateProductsList;
  window.updateProductProgressBars = updateProductProgressBars;
  window.startOrClickProduct = startOrClickProduct;
  window.upgradeProduct = upgradeProduct;
  window.hireOrUpgradeManager = hireOrUpgradeManager;
  window.createOrLinkManagerNPC = createOrLinkManagerNPC;
  window.buyClickPower = buyClickPower;
  window.buyIncomeBoost = buyIncomeBoost;
  window.buyCostReduction = buyCostReduction;
  window.updateUpgradesTab = updateUpgradesTab;
  
  // Boss fight functions
  window.startBossFight = startBossFight;
  window.bossFightAttack = bossFightAttack;
  window.bossFightRetreat = bossFightRetreat;
  window.closeBossFight = closeBossFight;
  window.checkBossFightRequirements = checkBossFightRequirements;
  window.generateInitialEmployees = generateInitialEmployees;
  window.setupAutosave = setupAutosave;
  window.calculateCashPerSecond = calculateCashPerSecond;
  window.getManagerSpeedMultiplier = getManagerSpeedMultiplier;
  window.currentCycleTimeMs = currentCycleTimeMs;
  window.currentValue = currentValue;
  window.clickReductionMs = clickReductionMs;
  
  // Social Network System Functions (for testing and debugging)
  window.initializeEmployeeSocialData = initializeEmployeeSocialData;
  window.updateRelationship = updateRelationship;
  window.generateRandomRelationships = generateRandomRelationships;
  window.updateCompanyAwareness = updateCompanyAwareness;
  window.logCompanyEvent = logCompanyEvent;
  window.getRelevantEvents = getRelevantEvents;
  window.getCoworkerContext = getCoworkerContext;
  window.getEmployeeAwarenessForPost = getEmployeeAwarenessForPost;
  window.getRandomCoworkerByRelation = getRandomCoworkerByRelation;
  window.getLocationCoworkers = getLocationCoworkers;
  window.getKnownLocations = getKnownLocations;
  window.knowsEmployee = knowsEmployee;
  window.createPost = createPost;
  window.createComment = createComment;
  window.createEvent = createEvent;
  window.createRelationship = createRelationship;
  
  // Social Feed UI Functions
  window.updateSocialTab = updateSocialTab;
  window.renderSocialFeed = renderSocialFeed;
  window.generateTestPost = generateTestPost;
  window.openPlayerPostComposer = openPlayerPostComposer;
  window.closePlayerPostModal = closePlayerPostModal;
  window.submitPlayerPostToFeed = submitPlayerPostToFeed;
  window.regeneratePlayerPostImage = regeneratePlayerPostImage;
  window.handleLikePost = handleLikePost;
  // toggleComments removed - now using modal system (openPostModal)
  window.openPostModal = openPostModal;
  window.closePostModal = closePostModal;
  window.submitModalComment = submitModalComment;
  window.addCommentToPost = addCommentToPost;
  window.openImageViewer = openImageViewer;
  window.showEmployeeProfile = showEmployeeProfile;
  window.loadProfileTab = loadProfileTab;
  window.openBioModal = openBioModal;
  window.openUnifiedProfile = openUnifiedProfile;
  window.setProfilePicture = setProfilePicture;
  window.linkifyMentions = linkifyMentions;
  
  // Autonomous Post Generation Functions
  window.autonomousPostGeneration = autonomousPostGeneration;
  window.generateEmployeePost = generateEmployeePost;
  window.generateFirstEmployeePost = generateFirstEmployeePost;
  window.generateAutonomousComments = generateAutonomousComments;
  window.generateAutonomousLikes = generateAutonomousLikes;
  
  // Initialize game when DOM is loaded
  document.addEventListener('DOMContentLoaded', initGame);
</script>

<style>
  /* General styles */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #0f1419;
    color: white;
    overflow-x: hidden;
    transition: background 1s ease-in-out;
  }
  
  /* Card styling */
  .card {
    transition: transform 0.2s;
  }
  
  .card:hover {
    transform: translateY(-5px);
  }
  
  .dashboard-card:hover {
    transform: translateY(-5px) scale(1.02);
    box-shadow: 0 6px 30px rgba(102,126,234,0.5) !important;
  }
  
  /* Custom scrollbar for dashboard sections */
  #dashRecentMessages::-webkit-scrollbar,
  #dashSocialMentions::-webkit-scrollbar,
  #dashTopPerformers::-webkit-scrollbar,
  #newsFeed::-webkit-scrollbar,
  #contextList::-webkit-scrollbar,
  #gossipList::-webkit-scrollbar {
    width: 6px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-track,
  #dashSocialMentions::-webkit-scrollbar-track,
  #dashTopPerformers::-webkit-scrollbar-track,
  #newsFeed::-webkit-scrollbar-track,
  #contextList::-webkit-scrollbar-track,
  #gossipList::-webkit-scrollbar-track {
    background: #0f3460;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb,
  #dashSocialMentions::-webkit-scrollbar-thumb,
  #dashTopPerformers::-webkit-scrollbar-thumb,
  #newsFeed::-webkit-scrollbar-thumb,
  #contextList::-webkit-scrollbar-thumb,
  #gossipList::-webkit-scrollbar-thumb {
    background: #00d4ff;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb:hover,
  #dashSocialMentions::-webkit-scrollbar-thumb:hover,
  #dashTopPerformers::-webkit-scrollbar-thumb:hover,
  #newsFeed::-webkit-scrollbar-thumb:hover,
  #contextList::-webkit-scrollbar-thumb:hover,
  #gossipList::-webkit-scrollbar-thumb:hover {
    background: #00a8cc;
  }
  
  /* Button styling */
  button {
    transition: background-color 0.2s;
  }
  
  button:hover {
    opacity: 0.9;
  }
  
  /* Tab active styling */
  .tab-btn.active {
    border-bottom: 3px solid #e94560;
  }
  
  /* Modal styling */
  .modal {
    animation: fadeIn 0.3s;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  /* Pulse animation for unlockable locations */
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.8;
      transform: scale(1.05);
    }
  }

  /* Chat message styling */
  #chatMessages {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><rect width="20" height="20" fill="%2316213e"/><circle cx="10" cy="10" r="1" fill="%230f3460"/></svg>');
    background-size: 20px 20px;
  }

  /* Notification animation */
  @keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
  }
  
  @keyframes slideDown {
    from { 
      transform: translateX(-50%) translateY(-20px);
      opacity: 0;
    }
    to { 
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
  
  #newPostsNotification:hover {
    transform: translateX(-50%) scale(1.05) !important;
    box-shadow: 0 6px 30px rgba(0, 212, 255, 0.6) !important;
  }

  /* News ticker animation */
  @keyframes ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
  }

  #newsContent {
    display: inline-block;
    animation: ticker 20s linear infinite;
  }

  /* Bulletproof hiring modal overlay */
  #hiringModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important; /* above chat/toasts/etc */
    pointer-events: auto !important;
  }
  #hiringModal * { pointer-events: auto !important; }
  #hiringModal[hidden] { display: none !important; }
  
  /* PHASE 7B: Enhanced candidate cards */
  .candidate-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
  }
  .candidate-card:hover {
    transform: translateY(-4px) !important;
    box-shadow: 0 8px 20px rgba(255, 215, 0, 0.2) !important;
  }
  .select-candidate-btn:hover {
    transform: scale(1.02) !important;
    filter: brightness(1.1) !important;
  }
  .select-candidate-btn:active {
    transform: scale(0.98) !important;
  }

  /* Bulletproof chat modal overlay */
  #chatModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important;
    pointer-events: auto !important;
  }
  #chatModal * { pointer-events: auto !important; }
  #chatModal[hidden], #chatModal[style*="display:none"] { display: none !important; pointer-events: none !important; }
  
  /* Boss fight modal */
  #bossFightModal[hidden], #bossFightModal[style*="display:none"] { display: none !important; }

  /* Cash display glow animations */
  @keyframes cash-glow {
    0%, 100% { 
      text-shadow: 0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 25px rgba(255, 165, 0, 0.9), 0 0 50px rgba(255, 165, 0, 0.6);
      transform: scale(1.02);
    }
  }

  @keyframes cash-glow-intense {
    0%, 100% { 
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 35px rgba(255, 215, 0, 1), 0 0 70px rgba(255, 215, 0, 0.8), 0 0 100px rgba(255, 215, 0, 0.5);
      transform: scale(1.05);
    }
  }

  /* Constant stream animation for sub-1-second product cycles */
  @keyframes constantStream {
    0% { 
      background-position: 0% 50%;
    }
    100% { 
      background-position: 200% 50%;
    }
  }

  /* ========== MOBILE RESPONSIVE STYLES ========== */
  
  /* Mobile breakpoint */
  @media screen and (max-width: 768px) {
    
    /* ===== MODAL IMPROVEMENTS ===== */
    
    /* Make modals scrollable and properly sized on mobile */
    .modal {
      padding: 10px !important;
      align-items: flex-start !important; /* Align to top instead of center */
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS */
    }
    
    /* Modal content containers */
    .modal > div {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 95vh !important;
      margin: 10px auto !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Chat modal specific */
    #chatModal > div {
      height: 90vh !important;
      max-height: 90vh !important;
    }
    
    /* Player profile modal - make scrollable */
    #playerProfileModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Boss fight modal */
    #bossFightModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Prestige modal */
    #prestigeModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* ===== SOCIAL FEED MOBILE LAYOUT ===== */
    
    /* Social tab container - make it stack vertically */
    #socialTab > div {
      flex-direction: column !important;
      height: auto !important;
      gap: 15px !important;
    }
    
    /* Left sidebar - expand to full width */
    #socialTab > div > div:first-child {
      flex: 1 !important;
      width: 100% !important;
    }
    
    /* Feed container - expand to full width */
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
      width: 100% !important;
      max-height: none !important;
    }
    
    /* Social feed posts - better mobile layout */
    .social-post {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* Social post content - ensure proper text wrapping */
    .social-post p,
    .social-post div {
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
      word-break: normal !important;
      white-space: normal !important;
      max-width: 100% !important;
    }
    
    /* Social post images */
    .social-post img {
      max-width: 100% !important;
      height: auto !important;
    }
    
    /* ===== DASHBOARD IMPROVEMENTS ===== */
    
    /* Dashboard stats grid - single column on mobile */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* Dashboard cards - adjust sizing */
    .dashboard-card {
      padding: 15px !important;
    }
    
    /* Main content grid - stack vertically */
    #dashboardTab > div[style*="grid-template-columns: 1fr 1fr"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== TOP BAR IMPROVEMENTS ===== */
    
    /* Top bar - more compact on mobile */
    #topBar {
      padding: 8px 10px !important;
      font-size: 0.85rem !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div {
      gap: 10px !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div > div {
      font-size: 0.8rem !important;
    }
    
    /* ===== TAB NAVIGATION ===== */
    
    /* Tab buttons - better touch targets */
    .tab-btn {
      padding: 12px 15px !important;
      font-size: 0.9rem !important;
      min-width: fit-content !important;
    }
    
    #tabNav {
      overflow-x: auto !important;
      -webkit-overflow-scrolling: touch !important;
      white-space: nowrap !important;
    }
    
    /* ===== PEOPLE TAB IMPROVEMENTS ===== */
    
    /* Employee grid - single or double column on mobile */
    #peopleTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)) !important;
    }
    
    /* ===== BUSINESS TAB IMPROVEMENTS ===== */
    
    /* Products grid - single column on small screens */
    #productsList {
      grid-template-columns: 1fr !important;
      gap: 12px !important;
    }
    
    /* Product cards */
    .product-card {
      padding: 12px !important;
    }
    
    /* ===== TOUCH TARGET IMPROVEMENTS ===== */
    
    /* All buttons - minimum touch size */
    button {
      min-height: 44px !important;
      min-width: 44px !important;
      touch-action: manipulation !important;
    }
    
    /* Small icon buttons can be slightly smaller but still touch-friendly */
    button[style*="font-size:1.5rem"],
    button[style*="font-size:1.2rem"] {
      min-height: 40px !important;
      min-width: 40px !important;
    }
    
    /* Input fields - better touch targets */
    input, textarea, select {
      min-height: 44px !important;
      font-size: 16px !important; /* Prevent iOS zoom on focus */
      padding: 10px !important;
    }
    
    /* ===== HIRE MANAGER MODAL FIX ===== */
    
    /* Make hire manager modal scrollable and properly sized */
    #hiringModal {
      padding: 10px !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    #hiringModal .hiring-modal-panel {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 85vh !important;
      overflow-y: auto !important;
      padding: 15px !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Candidate cards container - stack vertically on mobile */
    #hiringModal .hiring-modal-panel > div[style*="display:flex"] {
      flex-direction: column !important;
      align-items: center !important;
    }
    
    /* Individual candidate cards */
    #hiringModal .candidate-card {
      width: 100% !important;
      max-width: 350px !important;
      margin: 8px 0 !important;
    }
    
    /* Stats grid in candidate cards */
    #hiringModal .candidate-card > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 6px !important;
    }
    
    /* ===== LOCATION SUBTABS FIX ===== */
    
    /* Location buttons - ensure horizontal scrolling */
    #locationSubtabs {
      display: flex !important;
      gap: 8px !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      -webkit-overflow-scrolling: touch !important;
      padding-bottom: 8px !important;
      scrollbar-width: thin !important;
    }
    
    /* Location buttons - prevent shrinking */
    #locationSubtabs button {
      flex-shrink: 0 !important;
      min-width: fit-content !important;
      padding: 10px 16px !important;
      white-space: nowrap !important;
      display: inline-flex !important;
      align-items: center !important;
      gap: 6px !important;
    }
    
    /* Ensure icons and text don't wrap */
    #locationSubtabs button span,
    #locationSubtabs button {
      white-space: nowrap !important;
    }
    
    /* ===== CHAT IMPROVEMENTS ===== */
    
    /* Chat modal container */
    #chatModal > div {
      width: 95% !important;
      max-width: 500px !important;
      height: 85vh !important;
      max-height: 85vh !important;
    }
    
    /* Chat messages area */
    #chatMessages {
      padding: 10px !important;
      gap: 8px !important;
    }
    
    /* Chat input container - proper flex layout */
    #chatModal > div > div:nth-last-child(2) {
      padding: 10px !important;
      display: flex !important;
      gap: 6px !important;
      flex-wrap: nowrap !important;
      align-items: center !important;
    }
    
    /* Chat attach and emoji buttons - fixed width */
    #chatAttachBtn,
    #chatEmojiBtn {
      flex-shrink: 0 !important;
      width: 40px !important;
      padding: 8px !important;
    }
    
    /* Chat input field - takes remaining space */
    #chatInput {
      flex: 1 1 auto !important;
      min-width: 0 !important;
      max-width: 100% !important;
      width: auto !important;
      margin: 0 !important;
    }
    
    /* Chat send button - fixed width */
    #chatSendBtn {
      flex-shrink: 0 !important;
      padding: 8px 12px !important;
      white-space: nowrap !important;
    }
    
    /* ===== MAIN CONTENT PADDING ===== */
    
    #mainContent {
      padding: 12px !important;
    }
    
    /* ===== CARDS AND CONTAINERS ===== */
    
    .card {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* ===== TEXT SIZING ===== */
    
    h1 {
      font-size: 1.5rem !important;
    }
    
    h2 {
      font-size: 1.3rem !important;
    }
    
    h3 {
      font-size: 1.1rem !important;
    }
    
    /* ===== MODAL CLOSE BUTTONS ===== */
    
    /* Make close buttons larger and easier to tap */
    .modal button[style*="position:absolute"][style*="top:"] {
      width: 44px !important;
      height: 44px !important;
      font-size: 1.5rem !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    /* ===== IMAGE GALLERIES IN MODALS ===== */
    
    /* Request/send image modals - better layout */
    #requestImageModal > div,
    #sendImageModal > div,
    #requestPostModal > div {
      max-height: 85vh !important;
      overflow-y: auto !important;
    }
    
    /* Image preset buttons - grid layout */
    .request-preset,
    .send-preset,
    .request-post-preset {
      min-height: 44px !important;
      padding: 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* ===== PLAYER POST COMPOSER ===== */
    
    #playerPostModal textarea {
      min-height: 120px !important;
      font-size: 16px !important;
    }
    
    /* ===== GIFTS TAB ===== */
    
    #giftsTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)) !important;
    }
    
    /* ===== HR TAB ===== */
    
    #hrTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== INVEST TAB ===== */
    
    #investTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== LANDSCAPE ORIENTATION IMPROVEMENTS ===== */
    
    @media (orientation: landscape) and (max-height: 500px) {
      /* Modals take full screen in landscape on short screens */
      .modal > div {
        width: 98% !important;
        max-height: 98vh !important;
        margin: 1vh auto !important;
      }
      
      /* Hire manager modal in landscape */
      #hiringModal .hiring-modal-panel {
        max-height: 96vh !important;
      }
      
      /* Reduce padding to maximize space */
      .modal > div > * {
        padding: 8px !important;
      }
      
      /* Top bar even more compact */
      #topBar {
        padding: 5px 8px !important;
        font-size: 0.75rem !important;
      }
      
      /* Tab navigation */
      .tab-btn {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
      
      /* Location buttons even more compact in landscape */
      #locationSubtabs button {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
    }
  }
  
  /* ===== TABLET BREAKPOINT (768px - 1024px) ===== */
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    
    /* Slightly adjust layouts for tablets */
    #socialTab > div {
      flex-direction: row !important;
    }
    
    #socialTab > div > div:first-child {
      flex: 0 0 250px !important;
    }
    
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
    }
    
    /* Dashboard - 2 columns */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
    }
    
    /* Products - 2 columns */
    #productsList {
      grid-template-columns: repeat(2, 1fr) !important;
    }
  }
  
  /* ===== SMALL MOBILE (< 400px) ===== */
  @media screen and (max-width: 400px) {
    
    /* Even more compact */
    #topBar {
      font-size: 0.75rem !important;
      padding: 6px 8px !important;
    }
    
    .tab-btn {
      padding: 10px 12px !important;
      font-size: 0.85rem !important;
    }
    
    /* Location buttons on very small screens */
    #locationSubtabs button {
      padding: 8px 12px !important;
      font-size: 0.8rem !important;
    }
    
    #mainContent {
      padding: 8px !important;
    }
    
    /* Modal content */
    .modal > div {
      width: 98% !important;
      padding: 15px !important;
    }
    
    /* Hire manager modal on small screens */
    #hiringModal .hiring-modal-panel {
      width: 98% !important;
      padding: 12px !important;
    }
    
    #hiringModal .candidate-card {
      max-width: 100% !important;
      padding: 12px !important;
    }
    
    /* Chat input on very small screens - even more compact */
    #chatAttachBtn,
    #chatEmojiBtn {
      width: 36px !important;
      padding: 6px !important;
      font-size: 1rem !important;
    }
    
    #chatSendBtn {
      padding: 6px 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* Smaller text in tight spaces */
    .dashboard-card {
      font-size: 0.9rem !important;
    }
  }
  
  /* ===== ACCESSIBILITY IMPROVEMENTS ===== */
  
  /* Better focus indicators for keyboard/screen reader users */
  @media (hover: none) and (pointer: coarse) {
    /* Touch devices */
    button:active {
      transform: scale(0.98);
      opacity: 0.9;
    }
  }
  
  /* ========== CHAT MESSAGE EDITING STYLES ========== */
  
  /* Edit and resend buttons */
  .edit-btn, .resend-btn {
    opacity: 0;
    transition: opacity 0.2s ease;
  }
  
  .chat-message:hover .edit-btn,
  .chat-message:hover .resend-btn {
    opacity: 1;
  }
  
  /* Make buttons always visible on touch devices */
  @media (hover: none) and (pointer: coarse) {
    .edit-btn, .resend-btn {
      opacity: 0.7;
    }
    
    .chat-message:active .edit-btn,
    .chat-message:active .resend-btn {
      opacity: 1;
    }
  }
  
  /* Edit mode indicator for send button */
  #chatSendBtn {
    transition: all 0.3s ease;
  }
  
  #chatSendBtn.editing-mode {
    background-color: #ff9800 !important;
    animation: pulse-edit 2s infinite;
  }
  
  @keyframes pulse-edit {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
    }
    50% {
      box-shadow: 0 0 0 10px rgba(255, 152, 0, 0);
    }
  }
  
  /* Regeneration count badge */
  .regenerate-count {
    display: inline-block;
    background: rgba(255, 152, 0, 0.2);
    color: #ff9800;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 4px;
    font-weight: bold;
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    button {
      border: 2px solid currentColor !important;
    }
  }
  
  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    #chatSendBtn.editing-mode {
      animation: none !important;
    }
  }
</style>